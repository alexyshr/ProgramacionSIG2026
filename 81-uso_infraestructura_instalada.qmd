# Uso de la Infraestructura Instalada {#sec-anexo_infraestructura}


## Configuraci√≥n inicial del entorno (Pre-flight) {#sec-preflight}

Para automatizar el soporte de gr√°ficos y capturas sin configurar cada archivo individualmente, ejecute estos comandos en la terminal del contenedor `contenedor_sig_unal` inmediatamente despu√©s de iniciar los servicios con `docker compose up -d`:

| Categor√≠a | Comando de Configuraci√≥n | Prop√≥sito |
|:--- |:--- |:--- |
| **Automatizaci√≥n R** | `echo 'Sys.setenv(CHROMOTE_CHROME = "/opt/google/chrome/chrome")' >> /etc/R/Rprofile.site` | Configura la ruta de Chrome para todo el sistema R de forma persistente. (si falla usa `/usr/lib/R/etc/Rprofile.site`. El `R.home("etc")` en nuestro sistema es `/usr/lib/R/etc`)|
| **Seguridad Root** | `echo 'options(chromote.args = c("--no-sandbox", "--disable-gpu", "--headless", "--remote-debugging-port=9222"))' >> /etc/R/Rprofile.site` | Habilita el modo *headless* y evita bloqueos de *sandbox* al ejecutar como root. (si falla usa `/usr/lib/R/etc/Rprofile.site`. El `R.home("etc")` en nuestro sistema es `/usr/lib/R/etc`)|

: Comandos de configuraci√≥n global del contenedor {#tbl-preflight}

/usr/bin/google-chrome
/usr/lib/R/etc/Rprofile.site /etc/R/Rprofile.site

Google Chrome se necesita para compilar c√≥digo `mermaid` dentro de Quarto. Ejecute uno de lo siguientes comandos para comprobar si Google Chrome web browser est√° instalado correctamente:

```bash
google-chrome --version
```

```bash
which google-chrome
```

```bash
quarto check
```

La imagen cargada del archivo tar ya incluye los programas descritos a continuaci√≥n en @tbl-preflight_old. Esta tabla se deja como referencia para facilitar una futura compilaci√≥n. La tabla descrita l√≠neas abajo servir√° para complementar el archivo Dockerfile.

| Categor√≠a | Comando de Configuraci√≥n | Prop√≥sito |
|:--- |:--- |:--- |
| **Soporte Base** | `apt-get update && apt-get install -y fonts-symbola wget` | Fuentes para emojis y herramienta de descarga de paquetes externos. |
| **Navegador** | `wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb && apt install -y ./google-chrome-stable_current_amd64.deb` | Instala Google Chrome (Bypass de Snap). Obligatorio para capturas de mapas en Docker. |
| **Librer√≠as R** | `Rscript -e "install.packages('webshot2', repos='https://cloud.r-project.org/')"` | Instala el motor de captura de widgets HTML y mapas de Leaflet. |
| **Librer√≠as Python**| `pip3 install selenium` | Habilita la automatizaci√≥n de capturas para visualizaciones din√°micas de Python. |
| **Librer√≠as Julia** | `julia -e 'using Pkg; Pkg.add(["FileIO", "ImageIO"])'` | Soporte esencial para procesar y exportar gr√°ficos en el ecosistema Julia. |

: Comandos de configuraci√≥n global del contenedor ya incluidos en la imagen cargada a partir del archivo .tar {#tbl-preflight_old}




### Ventajas de esta configuraci√≥n {#sec-ventajas}

Al usar el archivo `Rprofile.site`, hemos logrado que:

1.  **Limpieza:** Sus archivos `.qmd` solo contendr√°n c√≥digo de an√°lisis geogr√°fico, eliminando bloques de configuraci√≥n de sistema repetitivos.
2.  **Persistencia:** Cualquier usuario o script que inicie una sesi√≥n de R dentro de este contenedor heredar√° autom√°ticamente la capacidad de tomar capturas de pantalla.
3.  **Compatibilidad:** Quarto detectar√° `webshot2` y el navegador Chrome de forma nativa al renderizar a PDF.

### Notas de implementaci√≥n {#sec-notas-tecnicas}

::: {.callout-note}
#### ¬øPor qu√© Google Chrome y no Chromium?
En distribuciones basadas en Ubuntu 22.04 o superiores, el comando `apt install chromium-browser` instala una versi√≥n ligada a **Snap**, la cual no puede ejecutarse dentro de un contenedor Docker por restricciones de seguridad del kernel. La instalaci√≥n manual del paquete `.deb` de Google Chrome garantiza un binario funcional en `/usr/bin/google-chrome`.
:::

::: {.callout-important}
#### Importancia de ImageIO y FileIO en Julia
En Julia, estas librer√≠as act√∫an como los "drivers" de imagen. Sin ellas, aunque el c√≥digo genere un mapa o gr√°fico, Quarto no podr√° convertirlo a un formato que LaTeX entienda (como PNG), resultando en bloques vac√≠os en el PDF final.
:::


## Funci√≥n j_eval y j_plot en R

El motor de ejecuci√≥n de los archivos Quarto (`.qmd`) dentro del contenedor instalado para el curso es `knitr`, el cual est√° basado en `R`. Esto significa que el c√≥digo de `Python` y `Julia` se ejecuta a trav√©s de `R` para generar los archivos de salida HTML y PDF. 

`Python` se ejecuta mediante el paquete de R `reticulate`, mientras que `Julia` suele hacerlo a trav√©s del paquete `JuliaCall`. Debido a que este √∫ltimo presenta problemas de compatibilidad con librer√≠as geoespaciales en `R`, se desarrollaron con apoyo de inteligencia artificial las funciones `j_eval` y `j_plot`, las cuales utilizan el paquete `JuliaConnectoR` en su lugar.

Las funciones `j_eval` y `j_plot` son usadas para ejecutar c√≥digo **Julia** en **R**. `j_eval` ejecuta comandos que no tengan salidas gr√°ficas, y `j_plot` es necesaria cu√°ndo el c√≥digo Julia produce salidas gr√°ficas.

```{r}
#| label: j_eval_j_plot
#| code-fold: true
#| results: asis
# #| include: false
source("./docs/j_eval_j_plot.r")
```


### Flujo de ejecuci√≥n de texto con j_eval {#sec-flujo-jeval}

Para entender por qu√© los resultados aparecen con colores y c√≥mo se gestionan los bloques de c√≥digo, observe el siguiente flujo de ejecuci√≥n de la funci√≥n `j_eval`:

fig-flujo-jeval

::: {#fig-flujo-jeval}
![](images/fig-flujo-jeval.png){width=100%}
Arquitectura de ejecuci√≥n de la funci√≥n puente j_eval.
:::


::: {.callout-note}
Como se ilustra en la @fig-flujo-jeval, la funci√≥n no solo "pasa" el texto, sino que act√∫a como un supervisor que espera a que los bloques de programaci√≥n est√©n completos antes de despertar al motor de Julia. Esto garantiza la estabilidad del sistema.
:::

### Flujo de generaci√≥n gr√°fica con j_plot {#sec-flujo-jplot}

A diferencia de la ejecuci√≥n de texto, `j_plot` requiere una coordinaci√≥n adicional para gestionar archivos f√≠sicos. Observe el proceso:


::: {#fig-flujo-jplot}
![](images/fig-flujo-jplot.png){width=100%}
Arquitectura de generaci√≥n y renderizado de gr√°ficos Julia-R.
:::

::: {.callout-tip}
#### El rol del disco duro
Como muestra la @fig-flujo-jplot, el secreto de `j_plot` es que utiliza un archivo temporal como "puente" visual. Por eso, si usted tiene el archivo `tmp_plot.png` abierto en otro programa, j_plot podr√≠a fallar al intentar sobrescribirlo.
:::


### Interpretaci√≥n de errores y consola {#sec-errores-consola}

Al trabajar con la interoperabilidad entre lenguajes (usando las funciones `j_eval` y `j_plot` definidas arriba, la consola de **VSCode** nos devolver√° mensajes que debemos aprender a interpretar.

#### El error de conexi√≥n TCP
Si al usar Julia recibe un mensaje de error que menciona `TCP connection`, usualmente significa que el motor de Julia se ha cerrado o ha entrado en conflicto de memoria.
* **Soluci√≥n**: Ejecute `.ensure_julia_ready()` en su consola de R para reiniciar el puente de comunicaci√≥n.

#### Interpretaci√≥n del Stacktrace en Julia
Cuando Julia detecta un error, genera un rastro de llamadas o *Stacktrace*. No intente leer cada l√≠nea; busque siempre la primera (que define el tipo de error) y la √∫ltima l√≠nea de c√≥digo escrita por usted.

```julia
# Ejemplo de error por √≠ndice fuera de rango
ERROR: BoundsError: attempt to access 5-element Vector{Int64} at index [6]
```

#### Resaltado de sintaxis en la salida
Gracias a la configuraci√≥n de `results: asis` en los bloques de c√≥digo, la salida de nuestras funciones aparecer√° con el prompt `julia>` coloreado, facilitando la distinci√≥n entre lo que es un mensaje informativo y un resultado del c√°lculo.


## Introducci√≥n a la infraestructura de datos

Este anexo constituye la gu√≠a t√©cnica para la gesti√≥n del entorno de desarrollo instalado. Es decir, informaci√≥n que describe y detalla los contenedores instalados (instalaci√≥n opci√≥n A), su estructura y funcionamiento, as√≠ mismo como la descripci√≥n y detalles adicionales de las dos instalaciones de QGIS (Instalaci√≥n Opci√≥n B) 

### Contenedores instalados (Instalaci√≥n Opci√≥n A) {#sec-contenedores_instalados}

Siguiendo los pasos detallados en @sec-guia_A para instalar los contenedores Docker, en resumen, ellos contendr√°n:

1. Un contenedor `contenedor_sig_unal` correspondiente a la imagen `image_sig_unal:final` el cual contendr√° las siguientes herramientas:

* **Python** (@sec-anexo_python), **R** (@sec-anexo_r) y **Julia** (@sec-anexo_julia) con los principales paquetes/librer√≠as para geoprocesamiento.
* **Quarto** (Ver @sec-anexo_quarto).
* **TinyTeX** (Ver @sec-tinytex).

2. Una contenedor `contenedor_postgis_unal` correspondiente a la imagen `postgis_unal:final` el cual contendr√° las siguientes herramientas:

* **PostgreSQL** + **PostGIS** (Ver @sec-anexo_postgresql).



#### üß™ Bater√≠a de pruebas de integridad del docker

| ID | Comando de Verificaci√≥n (Docker) | Descripci√≥n |
|:---|:---|:---|
| 01 | `docker exec contenedor_sig_unal gdalinfo --version` | Verifica que el n√∫cleo de GDAL est√° activo. |
| 02 | `docker exec contenedor_sig_unal R -e "library(sf); st_point(c(0,0))"` | Prueba la librer√≠a `sf` y el motor de geometr√≠a en R. |
| 03 | `docker exec contenedor_sig_unal python3 -c "import geopandas; print(geopandas.__version__)"` | Verifica el stack espacial de Python. |
| 04 | `docker exec contenedor_sig_unal R -e "j_eval('sum([1, 2, 3])')"` | **Test Cr√≠tico:** Verifica la funci√≥n personalizada y el puente R -> Julia. |
| 05 | `docker exec contenedor_sig_unal R -e "j_plot('plot(rand(10))')"` | Prueba la generaci√≥n de gr√°ficos Julia capturados por R. |
| 06 | `docker exec contenedor_sig_unal julia -e 'using ArchGDAL; println(ArchGDAL.GDAL.gdalversioninfo("RELEASE_NAME"))'` | **Cirug√≠a Exitosa:** Confirma que Julia accede a GDAL del sistema (v3.12.1). |
| 07 | `docker exec contenedor_sig_unal R -e "library(RPostgres); dbConnect(Postgres(), host='db-postgis', dbname='sig_db_unal', user='profe_unal', password='geomatica2025')"` | Prueba la conexi√≥n R -> PostGIS (Interna). |
| 08 | `docker exec contenedor_sig_unal python3 -c "import psycopg2; conn = psycopg2.connect(host='db-postgis', dbname='sig_db_unal', user='profe_unal', password='geomatica2025'); print('Python PostGIS conectado ‚úÖ'); conn.close()"` | Prueba la conexi√≥n Python -> PostGIS (Interna). |
| 09 | `docker exec contenedor_sig_unal R -e "cat(whitebox::wbt_version())"` | Verifica que los binarios de WhiteboxTools est√°n instalados y accesibles. |
| 10 | `docker exec contenedor_sig_unal R -e "library(httpgd); print('Visor OK')"` | Verifica que el motor gr√°fico para VSCode est√° listo en el puerto `8787`. |

#### Configuraci√≥n de puertos y conectividad {#sec-puertos}

Para que su computadora (Host) pueda comunicarse con los servicios dentro del contenedor, hemos dise√±ado un sistema de "puentes" o mapeo de puertos. Esto evita conflictos si ya tiene instalados otros servidores de bases de datos o Jupyter en su PC.

| Servicio | Puerto en su PC (Host) | Puerto en Contenedor | Prop√≥sito | Acceso / Conexi√≥n |
|:---|:---:|:---:|:---|:---|
| **Jupyter Lab** | `8889` | `8888` | Programaci√≥n y Notebooks | `http://localhost:8889` |
| **Visor R (httpgd)** | `8788` | `8787` | Gr√°ficos de R y VSCode | `http://localhost:8788` |
| **PostGIS (DB)** | `5434` | `5432` | Base de Datos Espacial | `localhost:5434` |


#### üîë Credenciales de la base de datos {#sec-credenciales}

Utilice estos datos para configurar sus conexiones en QGIS, ArcGIS Pro o mediante c√≥digo (R/Python/Julia):

* **Base de Datos:** `sig_db_unal`
* **Usuario:** `profe_unal`
* **Contrase√±a:** `geomatica2025`
* **Host:** `localhost`
* **Puerto:** `5434`
* **Host Interno:** `db-postgis` (Use este nombre √∫nicamente para conexiones **dentro** de sus scripts).



#### L√≥gica de arquitectura (Dockerfile y docker-compose) {#sec-arquitectura-puertos}

La configuraci√≥n del entorno se ha "blindado" t√©cnicamente para garantizar la estabilidad:

1.  **En el Dockerfile**: Se usan las instrucciones `EXPOSE 8888` y `EXPOSE 8787`. Esto le avisa a Docker que el contenedor tiene dos "puertas" abiertas internamente. Al fijar `httpgd.port = 8787`, nos aseguramos de que el visor de gr√°ficos de R no pelee con Jupyter por el mismo canal.
2.  **En el Docker-Compose**: 
    * **`8889:8888`**: Permite que este curso conviva con otras instalaciones de Jupyter (que suelen usar el 8888).
    * **`8788:8787`**: Habilita la conexi√≥n independiente de VSCode al visor de gr√°ficos de R.
    * **`5434:5432`**: Evita el choque con bases de datos locales (Postgres suele usar el 5432 o 5433).


#### Gu√≠a de acceso: El concepto de "lados" {#sec-guia-acceso}

Es fundamental entender desde d√≥nde est√° intentando conectar:

> ##### üåê Desde afuera (Su PC / Host)
> Es lo que usted configura en su navegador o en QGIS. Usted ve los puertos mapeados:
> * **Jupyter/Notebooks**: `http://localhost:8889` (usando el token `geomatica2025`).
> * **Base de Datos (QGIS/DBeaver)**: Host: `localhost`, Puerto: `5434`.

> ##### üê≥ Desde adentro (El Contenedor)
> Sus scripts de Python, R y Julia no saben que existe un mapeo externo. Dentro de su "casa" Docker, nada ha cambiado:
> * **PostGIS**: El c√≥digo debe buscar el puerto est√°ndar `5432` y el host `db-postgis`.
> * **httpgd**: El servidor de gr√°ficos sigue escuchando en el puerto interno `8787`.

::: {.callout-note}
##### Tip de Conexi√≥n
Si intenta conectar QGIS usando el puerto `5432` y falla, recuerde que el "puente" hacia el contenedor se construy√≥ espec√≠ficamente sobre el puerto **`5434`**.
:::

#### Resumen de la infraestructura instalada

| Componente | Versi√≥n / Estado | Detalles T√©cnicos |
|:---|:---|:---|
| **R Engine** | `4.3.3` (Angel Food Cake) | Puente `JuliaConnectoR` y visor `httpgd` configurados. |
| **Julia Stack** | `v1.10.x` | **ArchGDAL 3.12.1** operativo mediante enlaces simb√≥licos. |
| **Python Stack** | `3.12.x` | GeoPandas, PyTorch y drivers `psycopg2` listos. |
| **Base de Datos** | **PostGIS** (Noble) | Host interno `db-postgis` con extensi√≥n espacial activa. |
| **Visualizaci√≥n** | **Dual Mode** | Puertos **8788** (R/Julia Plots) y **8889** (Jupyter Lab). |
| **Persistencia** | **Vol√∫menes Docker** | Mapeo bidireccional en `/home/rstudio/work` confirmado. |
| **Cirug√≠a SSL** | ‚úÖ Aplicada | Compatibilidad OpenSSL 3.0 (Sistema) vs 3.3 (Julia). |

##  Localizaci√≥n de archivos y persistencia

En el contenedor, su carpeta del equipo local se encuentra vinculada a la ruta **/home/rstudio/work**. 
    * Cualquier archivo guardado en esa ruta dentro de Jupyter aparecer√° en su carpeta de Windows.
    * Se recomienda organizar su trabajo en las subcarpetas: `notebooks`, `scripts`, y `data`.
    * La carpeta `imagenes` (sin t√≠lde y provista para las im√°genes usadas en los archivos Quarto) debe residir tambi√©n en esta ruta para un renderizado correcto.

::: {.callout-important}
### Persistencia de Datos
Si su contenedor se apaga o se reinicia, los datos de su base de datos PostGIS y los datos almancenados en `/home/rstudio/work` **no se pierden**. El volumen nombrado act√∫a como un disco duro externo que sobrevive a cualquier ca√≠da del sistema.
:::

## Cargar los contenedores dentro de VSCode {#sec-cargar_contenedores_vscode}

Para una experiencia de desarrollo profesional, conecte VSCode directamente al contenedor:

* Inicie Docker Desktop
* En el "PowerShell" de windows ub√≠quese en la carpeta donde instal√≥ los contenedores (ver @sec-cargar_docker_tar)
* Ejecute el comando: `docker compose up -d`
* Abra VSCode
* Instale (local) la extensi√≥n `Dev Containers`
* Acceda a la paleta de comandos con `Ctrl + Shift + P`, escriba (o seleccione) **Dev Containers: Attach to Running Container...**, y seleccione el contenedor **`contenedor_sig_unal`** (imagen `image_sig_unal`).
* Abra la carpeta `/home/rstudio/work` (esa carpeta corresponde a la carpeta local en d√≥nde instal√≥ los contenedores)
- Una vez conectado "dentro" del contenedor, debe habilitar/instalar las extensiones (*'Install in Container'*). Vea el listado completo en @sec-extensiones-vscode.

## Inicializaci√≥n del visor gr√°fico (solo una vez por sesi√≥n) {#sec-httpgd}

Para que los gr√°ficos de R (y los puentes de Python/Julia) se visualicen correctamente en VSCode, debe inicializar el dispositivo gr√°fico. En su terminal de R, ejecute:

```r
# Lanza el servidor de gr√°ficos httpgd
httpgd::hgd()
```

* **Acceso al Visor**: VSCode deber√≠a abrir autom√°ticamente una pesta√±a con el visor. Si esto no sucede o prefiere usar su navegador externo (Chrome/Edge), acceda a la direcci√≥n: **`http://127.0.0.1:8788`**.
* **Nota sobre Puertos**: Aunque el comando en R pueda imprimir una URL interna con el puerto `8787` o un token aleatorio, **ignore esa direcci√≥n**. Gracias a nuestro archivo `docker-compose.yml`, el puerto **8788** de su Windows est√° "cableado" permanentemente al visor, eliminando la necesidad de buscar tokens o puertos din√°micos. (xxx)


## Ingreso a Jupyter Lab {#sec-acceder_jupyterlab}

Abra su navegador y acceda a: [http://localhost:8889](http://localhost:8889)
* **Contrase√±a/Token:** (Si se solicita) `geomatica2025`
* **Persistencia:** Todo archivo guardado en la carpeta `/home/rstudio/work` aparecer√° autom√°ticamente en su carpeta de Windows. **No guarde nada fuera de esa ruta**, o se perder√° al cerrar el contenedor.


Puede pasar directamente la url completa: 

[http://127.0.0.1:8889/lab?token=geomatica2025](http://127.0.0.1:8889/lab?token=geomatica2025)

Si la url anterior no funciona, puede verificar cu√°l url usa actualmente el contenedor, la cual aparece al final del log despu√©s de ejecutar el siguiente comando:

```bash
docker logs contenedor_sig_unal
```

**Alternativa:** Puede iniciar/reiniciar el servidor de Jupyter Lab en la url [http://127.0.0.1:8889/lab?token=geomatica2025](http://127.0.0.1:8889/lab?token=geomatica2025). Use el siguiente comando ejecutado desde el terminal de VSCode:

```bash
jupyter lab --ip=0.0.0.0 --port=8889 --no-browser --allow-root --ServerApp.token='geomatica2025'
```

## Gu√≠a visual de JupyterLab

Al ingresar, se encontrar√° con el centro de mando de sus kernels, donde podr√° elegir entre R, Python o Julia para sus Notebooks:

![Interfaz de JupyterLab configurada para el laboratorio.](./images/JupyterLab.png){#fig-jupyterlab}

### La Carpeta 'work' y el Espejo de Datos

En el panel izquierdo de la @fig-jupyterlab, la carpeta **`/home/rstudio/work/`** es el espejo de su directorio local en Windows. Gracias a la configuraci√≥n de vol√∫menes en el archivo `docker-compose.yml`, existe un puente directo: todo cambio realizado en Jupyter se refleja en su disco duro y viceversa, garantizando que su trabajo no se pierda al apagar el contenedor.

## Compilaci√≥n de la gu√≠a completa o documentos individuales {#sec-compilacion}

La gu√≠a del curso est√° organizada a partir de un **archivo orquestador** `_quarto.yml`, el cual contiene una referencia expl√≠cita a cada uno de los archivos Quarto (`.qmd`) que definen los cap√≠tulos, las presentaciones, los talleres y los anexos. Este archivo centraliza la organizaci√≥n y el formato de la gu√≠a tanto en **PDF** como en **HTML**.

### Compilaci√≥n del proyecto completo

Si desea compilar la gu√≠a completa del curso y generar todos los formatos, simplemente ejecute el comando `quarto render` en la carpeta ra√≠z (donde se encuentra el archivo `_quarto.yml`):

```bash
# Desde la carpeta ra√≠z donde reside el archivo '_quarto.yml'
quarto render
```

### Compilaci√≥n de archivos individuales

En ocasiones, querr√° trabajar en un solo cap√≠tulo sin procesar el libro entero. Para compilar un archivo espec√≠fico (ej. `archivo.qmd`) de manera independiente y evitar que Quarto aplique las reglas de numeraci√≥n y referencias del proyecto global, siga estos pasos:

1.  **Renombrar temporalmente el orquestador:** Cambie el nombre de `_quarto.yml` a **`_quarto.yml.back`**. Esto hace que Quarto trate al archivo como un documento "solitario".
2.  **Ejecutar el renderizado espec√≠fico:**

* **Generar todos los formatos (HTML y PDF):**
```bash
quarto render archivo.qmd --to all
```
* **Generar solo formato HTML:**
```bash
quarto render archivo.qmd --to html
```
* **Generar solo formato PDF:**
```bash
quarto render archivo.qmd --to pdf
```

### Notas de estudio y personalizaci√≥n

::: {.callout-tip icon="true"}
#### ¬°Personaliza tu aprendizaje!
En Quarto, puedes agregar tus propias **notas de estudio** usando la sintaxis de "callouts". Recuerda que este documento est√° en proceso de **construcci√≥n** y sufrir√° cambios permanentes hasta terminar el curso. 

Puedes buscar **ayuda en Internet** para personalizar la apariencia de tus notas. La sintaxis b√°sica es:

```markdown
::: {.callout-tip icon="true"}
### ¬°Escribe tu nota aqu√≠!
Este es un espacio para tus observaciones personales y recordatorios.
:::
```
:::

## Mapeo de capacidades SIG

Es vital entender que, aunque usemos lenguajes distintos, todos "beben" de las mismas librer√≠as de bajo nivel instaladas en nuestra imagen base de OSGeo:

| Operaci√≥n | R (`sf` / `terra`) | Python (`GeoPandas`) | Julia (`ArchGDAL`) | Motor de Sistema |
| :--- | :--- | :--- | :--- | :--- |
| Lectura de Datos | `st_read()` / `rast()` | `read_file()` / `open()` | `ArchGDAL.read()` | **GDAL** |
| Buffers / Geometr√≠a | `st_buffer()` | `.buffer()` | `LibGEOS.buffer()` | **GEOS** |
| Reproyecci√≥n | `st_transform()` | `.to_crs()` | `ArchGDAL.reproject()` | **PROJ** |


## Verificaci√≥n de conectividad multilenguaje

**Nota t√©cnica**: Dentro de la red de Docker, el host es `db-postgis`.

::: panel-tabset
### Python

::: {.content-visible when-format="html"}
::: {.callout-tip collapse="true" icon="false"}
#### ‚ñ∑ C√ìDIGO PURO (Copiar y Pegar)
```{python}
#| label: python_verificacion_codigo
#| eval: false
import psycopg2
import geopandas as gpd
import fiona
import matplotlib.pyplot as plt
from shapely.geometry import Point

print("--- Inicio de Verificaci√≥n de Python SIG ---")

# 1. Prueba de conexi√≥n a la base de datos PostGIS
try:
    conn = psycopg2.connect(
        host="db-postgis", 
        dbname="sig_db_unal", 
        user="profe_unal", 
        password="geomatica2025"
    )
    print("‚úÖ Conexi√≥n a PostGIS: Exitosa")
    conn.close()
except Exception as e:
    print(f"‚ùå Error de conexi√≥n a PostGIS: {e}")

# 2. Prueba de Fiona y drivers GDAL
try:
    drivers = len(fiona.supported_drivers)
    print(f"‚úÖ Fiona operativo: {drivers} drivers GDAL detectados")
except Exception as e:
    print(f"‚ùå Error en Fiona/GDAL: {e}")

# 3. Prueba de GeoPandas, Motores GEOS y Visualizaci√≥n
try:
    # Creamos un punto y su buffer (GEOS)
    punto = Point(0, 0)
    buffer_geom = punto.buffer(1.0)
    
    # Creamos GeoDataFrames para graficar
    gdf_buffer = gpd.GeoDataFrame({'geometry': [buffer_geom]}, crs="EPSG:4326")
    gdf_punto = gpd.GeoDataFrame({'geometry': [punto]}, crs="EPSG:4326")
    
    print(f"‚úÖ GeoPandas {gpd.__version__}: Operativo")
    print(f"‚úÖ Motores GEOS/Shapely: Verificados")

    # Generaci√≥n del Plot Espacial con Ejes y Cuadr√≠cula
    fig, ax = plt.subplots(figsize=(6, 6))
    
    # Graficamos el buffer
    gdf_buffer.plot(ax=ax, color='lightgreen', edgecolor='green', alpha=0.4, label='Buffer')
    
    # Graficamos el punto original (en rojo)
    gdf_punto.plot(ax=ax, color='red', markersize=50, zorder=5, label='Centro')
    
    # Configuraci√≥n de estilo consistente (Ejes y Grilla)
    ax.set_title("Validaci√≥n Python SIG: Buffer GEOS")
    ax.set_xlabel("Longitud")
    ax.set_ylabel("Latitud")
    ax.grid(True, linestyle='--', alpha=0.7) # Cuadr√≠cula activada
    ax.set_aspect('equal') # Proporci√≥n 1:1 para evitar deformaci√≥n
    
    plt.show()
    print("‚úÖ Visualizaci√≥n GeoPandas: Mapa generado con √©xito")

except Exception as e:
    print(f"‚ùå Error en el stack espacial de Python: {e}")

print("--- Verificaci√≥n Finalizada ---")
```
:::
:::

```{python}
#| label: python_verificacion
import psycopg2
import geopandas as gpd
import fiona
import matplotlib.pyplot as plt
from shapely.geometry import Point

print("--- Inicio de Verificaci√≥n de Python SIG ---")

# 1. Prueba de conexi√≥n a la base de datos PostGIS
try:
    conn = psycopg2.connect(
        host="db-postgis", 
        dbname="sig_db_unal", 
        user="profe_unal", 
        password="geomatica2025"
    )
    print("‚úÖ Conexi√≥n a PostGIS: Exitosa")
    conn.close()
except Exception as e:
    print(f"‚ùå Error de conexi√≥n a PostGIS: {e}")

# 2. Prueba de Fiona y drivers GDAL
try:
    drivers = len(fiona.supported_drivers)
    print(f"‚úÖ Fiona operativo: {drivers} drivers GDAL detectados")
except Exception as e:
    print(f"‚ùå Error en Fiona/GDAL: {e}")

# 3. Prueba de GeoPandas, Motores GEOS y Visualizaci√≥n
try:
    # Creamos un punto y su buffer (GEOS)
    punto = Point(0, 0)
    buffer_geom = punto.buffer(1.0)
    
    # Creamos GeoDataFrames para graficar
    gdf_buffer = gpd.GeoDataFrame({'geometry': [buffer_geom]}, crs="EPSG:4326")
    gdf_punto = gpd.GeoDataFrame({'geometry': [punto]}, crs="EPSG:4326")
    
    print(f"‚úÖ GeoPandas {gpd.__version__}: Operativo")
    print(f"‚úÖ Motores GEOS/Shapely: Verificados")

    # Generaci√≥n del Plot Espacial con Ejes y Cuadr√≠cula
    fig, ax = plt.subplots(figsize=(6, 6))
    
    # Graficamos el buffer
    gdf_buffer.plot(ax=ax, color='lightgreen', edgecolor='green', alpha=0.4, label='Buffer')
    
    # Graficamos el punto original (en rojo)
    gdf_punto.plot(ax=ax, color='red', markersize=50, zorder=5, label='Centro')
    
    # Configuraci√≥n de estilo consistente (Ejes y Grilla)
    ax.set_title("Validaci√≥n Python SIG: Buffer GEOS")
    ax.set_xlabel("Longitud")
    ax.set_ylabel("Latitud")
    ax.grid(True, linestyle='--', alpha=0.7) # Cuadr√≠cula activada
    ax.set_aspect('equal') # Proporci√≥n 1:1 para evitar deformaci√≥n
    
    plt.show()
    print("‚úÖ Visualizaci√≥n GeoPandas: Mapa generado con √©xito")

except Exception as e:
    print(f"‚ùå Error en el stack espacial de Python: {e}")

print("--- Verificaci√≥n Finalizada ---")
```

### R

::: {.content-visible when-format="html"}
::: {.callout-tip collapse="true" icon="false"}
#### ‚ñ∑ C√ìDIGO PURO (Copiar y Pegar)
```{r}
#| label: r_verificacion_codigo
#| eval: false
library(DBI)
library(RPostgres)
library(sf)
library(terra)

cat("--- Inicio de Verificaci√≥n de R-Spatial ---\n")

# 1. Prueba de conexi√≥n a la base de datos PostGIS
tryCatch({
  con <- dbConnect(
    RPostgres::Postgres(), 
    host = "db-postgis", 
    dbname = "sig_db_unal", 
    user = "profe_unal", 
    password = "geomatica2025"
  )
  cat("‚úÖ Conexi√≥n a PostGIS: Exitosa\n")
  dbDisconnect(con)
}, error = function(e) {
  cat("‚ùå Error de conexi√≥n a PostGIS:", conditionMessage(e), "\n")
})

# 2. Prueba de Motores de Sistema y Visualizaci√≥n (sf)
tryCatch({
  conf <- sf_extSoftVersion()
  cat(paste0("‚úÖ sf operativo. Motores detectados:\n",
             "   - GDAL: ", conf["GDAL"], "\n",
             "   - GEOS: ", conf["GEOS"], "\n",
             "   - PROJ: ", conf["PROJ"], "\n"))
  
  # Creamos el punto y el buffer
  punto <- st_point(c(0, 0))
  buffer_geom <- st_buffer(punto, dist = 1)
  cat("‚úÖ Prueba geom√©trica (GEOS): Buffer creado correctamente\n")

  # Generaci√≥n del Plot Espacial
  # Usamos st_geometry para graficar solo la forma
  plot(st_geometry(buffer_geom), 
       col = 'lightblue', 
       border = 'blue', 
       main = "Validaci√≥n R-Spatial: Buffer GEOS",
       axes = TRUE,
       graticule = TRUE)
  
  # A√±adimos el punto original para referencia
  plot(st_geometry(punto), add = TRUE, col = 'red', pch = 20)
  
  cat("‚úÖ Visualizaci√≥n sf: Mapa generado con √©xito\n")
  
}, error = function(e) {
  cat("‚ùå Error en el stack sf/GEOS:", conditionMessage(e), "\n")
})

# 3. Prueba de Raster (terra)
tryCatch({
  r <- rast(ncols=10, nrows=10)
  values(r) <- 1:ncell(r)
  cat("‚úÖ Paquete 'terra' operativo: Objetos Raster verificados\n")
}, error = function(e) {
  cat("‚ùå Error en el stack terra:", conditionMessage(e), "\n")
})

cat("--- Verificaci√≥n Finalizada ---\n")
```
:::
:::

```{r}
#| label: r_verificacion
library(DBI)
library(RPostgres)
library(sf)
library(terra)

cat("--- Inicio de Verificaci√≥n de R-Spatial ---\n")

# 1. Prueba de conexi√≥n a la base de datos PostGIS
tryCatch({
  con <- dbConnect(
    RPostgres::Postgres(), 
    host = "db-postgis", 
    dbname = "sig_db_unal", 
    user = "profe_unal", 
    password = "geomatica2025"
  )
  cat("‚úÖ Conexi√≥n a PostGIS: Exitosa\n")
  dbDisconnect(con)
}, error = function(e) {
  cat("‚ùå Error de conexi√≥n a PostGIS:", conditionMessage(e), "\n")
})

# 2. Prueba de Motores de Sistema y Visualizaci√≥n (sf)
tryCatch({
  conf <- sf_extSoftVersion()
  cat(paste0("‚úÖ sf operativo. Motores detectados:\n",
             "   - GDAL: ", conf["GDAL"], "\n",
             "   - GEOS: ", conf["GEOS"], "\n",
             "   - PROJ: ", conf["PROJ"], "\n"))
  
  # Creamos el punto y el buffer
  punto <- st_point(c(0, 0))
  buffer_geom <- st_buffer(punto, dist = 1)
  cat("‚úÖ Prueba geom√©trica (GEOS): Buffer creado correctamente\n")

  # Generaci√≥n del Plot Espacial
  # Usamos st_geometry para graficar solo la forma
  plot(st_geometry(buffer_geom), 
       col = 'lightblue', 
       border = 'blue', 
       main = "Validaci√≥n R-Spatial: Buffer GEOS",
       axes = TRUE,
       graticule = TRUE)
  
  # A√±adimos el punto original para referencia
  plot(st_geometry(punto), add = TRUE, col = 'red', pch = 20)
  
  cat("‚úÖ Visualizaci√≥n sf: Mapa generado con √©xito\n")
  
}, error = function(e) {
  cat("‚ùå Error en el stack sf/GEOS:", conditionMessage(e), "\n")
})

# 3. Prueba de Raster (terra)
tryCatch({
  r <- rast(ncols=10, nrows=10)
  values(r) <- 1:ncell(r)
  cat("‚úÖ Paquete 'terra' operativo: Objetos Raster verificados\n")
}, error = function(e) {
  cat("‚ùå Error en el stack terra:", conditionMessage(e), "\n")
})

cat("--- Verificaci√≥n Finalizada ---\n")
```

### Julia

::: {.content-visible when-format="html"}
::: {.callout-tip collapse="true" icon="false"}
#### ‚ñ∑ C√ìDIGO PURO (Copiar y Pegar)
```{julia}
#| label: julia_verificacion_codigo
#| eval: false
using LibPQ
using LibGEOS
using ArchGDAL
using Plots

println("--- Inicio de Verificaci√≥n de Julia SIG ---")

# 1. Prueba de conexi√≥n a la base de datos PostGIS
try
    conn = LibPQ.Connection("host=db-postgis dbname=sig_db_unal user=profe_unal password=geomatica2025")
    println("‚úÖ Conexi√≥n a PostGIS: Exitosa")
    close(conn)
catch e
    println("‚ùå Error de conexi√≥n a PostGIS: ", e)
end

# 2. Verificaci√≥n de LibGEOS y Visualizaci√≥n de Geometr√≠a
try
    # Creamos un punto y le aplicamos un buffer de 1.0 unidades
    # Esto valida la integraci√≥n de Julia con la librer√≠a GEOS del sistema
    punto = LibGEOS.readgeom("POINT (0 0)")
    buffer_geom = LibGEOS.buffer(punto, 1.0)
    
    println("‚úÖ LibGEOS operativo: Motores geom√©tricos verificados")
    
    # Graficamos el objeto del buffer
    # fillcolor y alpha ayudan a ver que es un pol√≠gono real
    plt = plot(buffer_geom, 
               title="Validaci√≥n Julia SIG: Buffer GEOS", 
               fillcolor=:blue, 
               fillalpha=0.3, 
               aspect_ratio=:equal, 
               legend=false)
    
    # display() es OBLIGATORIO para mostrar gr√°ficos dentro de bloques try/catch
    display(plt) 
    
catch e
    println("‚ùå Error en LibGEOS o Visualizaci√≥n: ", e)
end

# 3. Verificaci√≥n de ArchGDAL (Usando llamada de bajo nivel)
try
    # Accedemos directamente al motor de C para evitar errores de exportaci√≥n
    gdal_ver = ArchGDAL.GDAL.gdalversioninfo("--version")
    println("‚úÖ ArchGDAL operativo (Versi√≥n GDAL: $gdal_ver)")
catch e
    println("‚ùå Error en ArchGDAL: ", e)
end

println("--- Verificaci√≥n Finalizada ---")
```
:::
:::


```{r}
#| label: julia_verificacion
#| results: asis
# #| eval: false
j_plot('
using LibPQ
using LibGEOS
using ArchGDAL
using Plots

println("--- Inicio de Verificaci√≥n de Julia SIG ---")

# 1. Prueba de conexi√≥n a la base de datos PostGIS
try
    conn = LibPQ.Connection("host=db-postgis dbname=sig_db_unal user=profe_unal password=geomatica2025")
    println("‚úÖ Conexi√≥n a PostGIS: Exitosa")
    close(conn)
catch e
    println("‚ùå Error de conexi√≥n a PostGIS: ", e)
end

# 2. Verificaci√≥n de LibGEOS y Visualizaci√≥n de Geometr√≠a
try
    # Creamos un punto y le aplicamos un buffer de 1.0 unidades
    # Esto valida la integraci√≥n de Julia con la librer√≠a GEOS del sistema
    punto = LibGEOS.readgeom("POINT (0 0)")
    buffer_geom = LibGEOS.buffer(punto, 1.0)
    
    println("‚úÖ LibGEOS operativo: Motores geom√©tricos verificados")
    
    # Graficamos el objeto del buffer
    # fillcolor y alpha ayudan a ver que es un pol√≠gono real
    plt = plot(buffer_geom, 
               title="Validaci√≥n Julia SIG: Buffer GEOS", 
               fillcolor=:blue, 
               fillalpha=0.3, 
               aspect_ratio=:equal, 
               legend=false)
    
    # display() es OBLIGATORIO para mostrar gr√°ficos dentro de bloques try/catch
    display(plt) 
    
catch e
    println("‚ùå Error en LibGEOS o Visualizaci√≥n: ", e)
end

# 3. Verificaci√≥n de ArchGDAL (Usando llamada de bajo nivel)
try
    # Accedemos directamente al motor de C para evitar errores de exportaci√≥n
    gdal_ver = ArchGDAL.GDAL.gdalversioninfo("--version")
    println("‚úÖ ArchGDAL operativo (Versi√≥n GDAL: $gdal_ver)")
catch e
    println("‚ùå Error en ArchGDAL: ", e)
end

println("--- Verificaci√≥n Finalizada ---")
')
```


::: {.content-visible when-format="html"}
::: {.callout-tip collapse="true" icon="false"}
#### ‚ñ∑ C√ìDIGO PURO (Copiar y Pegar)
```{julia}
#| label: julia_verificacion2_codigo
#| eval: false


# codigo

```
:::
:::

```{r}
#| label: julia_verificacion2
#| results: asis
# Validaci√≥n de Motores SIG y Conectividad
j_plot('
using LibPQ, LibGEOS, ArchGDAL, Plots

# 1. Prueba de conexi√≥n a PostGIS
try
    conn = LibPQ.Connection("host=db-postgis dbname=sig_db_unal user=profe_unal password=geomatica2025")
    println("‚úÖ Conexi√≥n a PostGIS: Exitosa")
    close(conn)
catch e
    println("‚ùå Error de conexi√≥n: ", e)
end

# 2. Prueba de Motores Geom√©tricos (GEOS)
try
    punto = LibGEOS.readgeom("POINT (0 0)")
    buffer_geom = LibGEOS.buffer(punto, 1.0)
    println("‚úÖ Motores geom√©tricos operativos (GEOS)")
    
    # Visualizaci√≥n del Buffer
    plt = plot(buffer_geom, title="Validaci√≥n SIG: Buffer GEOS", 
               fillcolor=:blue, fillalpha=0.3, aspect_ratio=:equal)
    display(plt)
catch e
    println("‚ùå Error en motores geom√©tricos o gr√°ficos: ", e)
end
')
```


:::


