---
format:
  html: default
  pdf:
    keep-tex: true
    mermaid-format: png
    include-in-header:
      - text: \usepackage{pdflscape}
---

# Bucles y Declaraciones Condicionales {#sec-ciclos_condicionales}

## Funciones j_eval y j_plot en R

```{r}
#| label: j_eval_j_plot
#| code-fold: true
# #| include: false
source("./docs/j_eval_j_plot.r")
```

## Introducci√≥n


## Objetivos de aprendizaje

## Ciclos for

Los **ciclos for** (bucles `for`) son la herramienta principal para la automatizaci√≥n de tareas repetitivas. En el an√°lisis espacial, casi siempre trabajamos con colecciones de datos: cientos de coordenadas en una ruta, m√∫ltiples pol√≠gonos en un *Shapefile* o docenas de im√°genes satelitales en una carpeta. Un ciclo `for` nos permite tomar cada uno de esos elementos, uno por uno, y aplicarle una misma operaci√≥n matem√°tica o l√≥gica.

A continuaci√≥n, veremos tres aplicaciones cl√°sicas: 

1. Iterar y "desempaquetar" coordenadas.
2. Aplicar una funci√≥n de distancia a m√∫ltiples puntos.
3. Recorrer una lista de nombres de ciudades llevando la cuenta de su posici√≥n (√≠ndice).

Trabajaremos con coordenadas de nuestras principales ciudades en Colombia.

::: {.panel-tabset}

### Python

::: {.content-visible when-format="html"}
::: {.callout-tip collapse="true" icon="false"}
#### ‚ñ∑ C√ìDIGO PURO (Copiar y Pegar)
```{python}
#| label: python_ciclos_for_codigo
#| eval: false

# 1. Sintaxis b√°sica del ciclo for
# Creamos una lista de tuplas con las coordenadas geogr√°ficas de las ciudades
coordenadas = [
    (4.6097, -74.0817),  # Bogot√°
    (6.2442, -75.5812),  # Medell√≠n
    (3.4516, -76.5320),  # Cali
]

# Python permite desempaquetar la tupla directamente en el for
print("--- Extracci√≥n de coordenadas ---")
for lat, lon in coordenadas:
    # IMPORTANTE: Observa el espacio (tabulador) al inicio de esta l√≠nea.
    # El est√°ndar oficial de Python (llamado PEP 8) dicta que deben ser 4 espacios en blanco.
    # As√≠ sabe Python que esta instrucci√≥n pertenece al bucle for.
    print(f"Latitud: {lat}, Longitud: {lon}")

# 2. Procesamiento de m√∫ltiples puntos
def calcular_distancia(lat1, lon1, lat2, lon2):
    # C√°lculo de distancia euclidiana simple (fines pedag√≥gicos)
    return ((lat2 - lat1) ** 2 + (lon2 - lon1) ** 2) ** 0.5

punto_referencia = (4.0846, -72.9560)  # Centro geogr√°fico (Puerto L√≥pez)

print("\n--- Distancia al centro geogr√°fico ---")
for lat, lon in coordenadas:
    distancia = calcular_distancia(punto_referencia[0], punto_referencia[1], lat, lon)
    print(f"Distancia a ({lat}, {lon}): {distancia:.2f} grados")

# 3. Iterar colecciones llevando la cuenta (enumerate)
# Creamos una lista simple de textos con los nombres
ciudades = ["Bogot√°", "Medell√≠n", "Cali", "Barranquilla", "Cartagena"]

print("\n--- Principales ciudades de Colombia ---")
# enumerate nos da el √≠ndice (i) y el valor (ciudad) en cada vuelta
for i, ciudad in enumerate(ciudades):
    print(f"{i+1}. {ciudad}")
```
:::
:::

```{python}
#| label: python_ciclos_for
# #| eval: false

# 1. Sintaxis b√°sica del ciclo for
# Creamos una lista de tuplas con las coordenadas geogr√°ficas de las ciudades
coordenadas = [
    (4.6097, -74.0817),  # Bogot√°
    (6.2442, -75.5812),  # Medell√≠n
    (3.4516, -76.5320),  # Cali
]

# Python permite desempaquetar la tupla directamente en el for
print("--- Extracci√≥n de coordenadas ---")
for lat, lon in coordenadas:
    # IMPORTANTE: Observa el espacio (tabulador) al inicio de esta l√≠nea. 
    # As√≠ sabe Python que esta instrucci√≥n pertenece al bucle for.
    print(f"Latitud: {lat}, Longitud: {lon}")

# 2. Procesamiento de m√∫ltiples puntos
def calcular_distancia(lat1, lon1, lat2, lon2):
    # C√°lculo de distancia euclidiana simple (fines pedag√≥gicos)
    return ((lat2 - lat1) ** 2 + (lon2 - lon1) ** 2) ** 0.5

punto_referencia = (4.0846, -72.9560)  # Centro geogr√°fico (Puerto L√≥pez)

print("\n--- Distancia al centro geogr√°fico ---")
for lat, lon in coordenadas:
    distancia = calcular_distancia(punto_referencia[0], punto_referencia[1], lat, lon)
    print(f"Distancia a ({lat}, {lon}): {distancia:.2f} grados")

# 3. Iterar colecciones llevando la cuenta (enumerate)
# Creamos una lista simple de textos con los nombres
ciudades = ["Bogot√°", "Medell√≠n", "Cali", "Barranquilla", "Cartagena"]

print("\n--- Principales ciudades de Colombia ---")
# enumerate nos da el √≠ndice (i) y el valor (ciudad) en cada vuelta
for i, ciudad in enumerate(ciudades):
    print(f"{i+1}. {ciudad}")
```

### R

::: {.content-visible when-format="html"}
::: {.callout-tip collapse="true" icon="false"}
#### ‚ñ∑ C√ìDIGO PURO (Copiar y Pegar)
```{r}
#| label: r_ciclos_for_codigo
#| eval: false

# 1. Sintaxis b√°sica del ciclo for
# En R usamos una lista que contiene vectores num√©ricos 'c()' para las coordenadas
coordenadas <- list(
    c(4.6097, -74.0817),  # Bogot√°
    c(6.2442, -75.5812),  # Medell√≠n
    c(3.4516, -76.5320)   # Cali
)

cat("--- Extracci√≥n de coordenadas ---\n")
# En R, el bloque de c√≥digo del ciclo se encierra entre llaves { }
for (coord in coordenadas) {
    lat <- coord[1]
    lon <- coord[2]
    cat(sprintf("Latitud: %.4f, Longitud: %.4f\n", lat, lon))
}

# 2. Procesamiento de m√∫ltiples puntos
calcular_distancia <- function(lat1, lon1, lat2, lon2) {
    return(sqrt((lat2 - lat1)^2 + (lon2 - lon1)^2))
}

punto_referencia <- c(4.0846, -72.9560)  # Centro geogr√°fico (Puerto L√≥pez)

cat("\n--- Distancia al centro geogr√°fico ---\n")
for (coord in coordenadas) {
    distancia <- calcular_distancia(punto_referencia[1], punto_referencia[2], coord[1], coord[2])
    cat(sprintf("Distancia a (%.4f, %.4f): %.2f grados\n", coord[1], coord[2], distancia))
}

# 3. Iterar colecciones llevando la cuenta (seq_along)
ciudades <- c("Bogot√°", "Medell√≠n", "Cali", "Barranquilla", "Cartagena")

cat("\n--- Principales ciudades de Colombia ---\n")
# seq_along genera una secuencia de n√∫meros del 1 al tama√±o del vector
for (i in seq_along(ciudades)) {
    cat(sprintf("%d. %s\n", i, ciudades[i]))
}
```
:::
:::

```{r}
#| label: r_ciclos_for
# #| eval: false

# 1. Sintaxis b√°sica del ciclo for
# En R usamos una lista que contiene vectores num√©ricos 'c()' para las coordenadas
coordenadas <- list(
    c(4.6097, -74.0817),  # Bogot√°
    c(6.2442, -75.5812),  # Medell√≠n
    c(3.4516, -76.5320)   # Cali
)

cat("--- Extracci√≥n de coordenadas ---\n")
# En R, el bloque de c√≥digo del ciclo se encierra entre llaves { }
for (coord in coordenadas) {
    lat <- coord[1]
    lon <- coord[2]
    cat(sprintf("Latitud: %.4f, Longitud: %.4f\n", lat, lon))
}

# 2. Procesamiento de m√∫ltiples puntos
calcular_distancia <- function(lat1, lon1, lat2, lon2) {
    return(sqrt((lat2 - lat1)^2 + (lon2 - lon1)^2))
}

punto_referencia <- c(4.0846, -72.9560)  # Centro geogr√°fico (Puerto L√≥pez)

cat("\n--- Distancia al centro geogr√°fico ---\n")
for (coord in coordenadas) {
    distancia <- calcular_distancia(punto_referencia[1], punto_referencia[2], coord[1], coord[2])
    cat(sprintf("Distancia a (%.4f, %.4f): %.2f grados\n", coord[1], coord[2], distancia))
}

# 3. Iterar colecciones llevando la cuenta (seq_along)
ciudades <- c("Bogot√°", "Medell√≠n", "Cali", "Barranquilla", "Cartagena")

cat("\n--- Principales ciudades de Colombia ---\n")
# seq_along genera una secuencia de n√∫meros del 1 al tama√±o del vector
for (i in seq_along(ciudades)) {
    cat(sprintf("%d. %s\n", i, ciudades[i]))
}
```

### Julia

::: {.content-visible when-format="html"}
::: {.callout-tip collapse="true" icon="false"}
#### ‚ñ∑ C√ìDIGO PURO (Copiar y Pegar)
```{julia}
#| label: julia_ciclos_for_codigo
#| eval: false

# 1. Sintaxis b√°sica del ciclo for
# Creamos un arreglo (Array) de tuplas con las coordenadas geogr√°ficas
coordenadas = [
    (4.6097, -74.0817),  # Bogot√°
    (6.2442, -75.5812),  # Medell√≠n
    (3.4516, -76.5320),  # Cali
]

# Al igual que Python, Julia puede desempaquetar la tupla
println("--- Extracci√≥n de coordenadas ---")
# En Julia el ciclo finaliza expl√≠citamente con la palabra 'end'
for (lat, lon) in coordenadas
    println("Latitud: $lat, Longitud: $lon")
end

# 2. Procesamiento de m√∫ltiples puntos
function calcular_distancia(lat1, lon1, lat2, lon2)
    return sqrt((lat2 - lat1)^2 + (lon2 - lon1)^2)
end

punto_referencia = (4.0846, -72.9560)  # Centro geogr√°fico

using Printf
println("\n--- Distancia al centro geogr√°fico ---")
for (lat, lon) in coordenadas
    distancia = calcular_distancia(punto_referencia[1], punto_referencia[2], lat, lon)
    @printf("Distancia a (%.4f, %.4f): %.2f grados\n", lat, lon, distancia)
end

# 3. Iterar colecciones llevando la cuenta (enumerate)
ciudades = ["Bogot√°", "Medell√≠n", "Cali", "Barranquilla", "Cartagena"]

println("\n--- Principales ciudades de Colombia ---")
# enumerate funciona id√©ntico que en Python, pero arrancando en 1
for (i, ciudad) in enumerate(ciudades)
    println("$i. $ciudad")
end
```
:::
:::

```{r}
#| label: julia_ciclos_for
#| results: asis
# #| eval: false
j_eval(r"-(
# 1. Sintaxis b√°sica del ciclo for
# Creamos un arreglo (Array) de tuplas con las coordenadas geogr√°ficas
coordenadas = [
    (4.6097, -74.0817),  # Bogot√°
    (6.2442, -75.5812),  # Medell√≠n
    (3.4516, -76.5320),  # Cali
]

# Al igual que Python, Julia puede desempaquetar la tupla
println("--- Extracci√≥n de coordenadas ---")
# En Julia el ciclo finaliza expl√≠citamente con la palabra 'end'
for (lat, lon) in coordenadas
    println("Latitud: $lat, Longitud: $lon")
end

# 2. Procesamiento de m√∫ltiples puntos
function calcular_distancia(lat1, lon1, lat2, lon2)
    return sqrt((lat2 - lat1)^2 + (lon2 - lon1)^2)
end

punto_referencia = (4.0846, -72.9560)  # Centro geogr√°fico

using Printf
println("\n--- Distancia al centro geogr√°fico ---")
for (lat, lon) in coordenadas
    distancia = calcular_distancia(punto_referencia[1], punto_referencia[2], lat, lon)
    @printf("Distancia a (%.4f, %.4f): %.2f grados\n", lat, lon, distancia)
end

# 3. Iterar colecciones llevando la cuenta (enumerate)
ciudades = ["Bogot√°", "Medell√≠n", "Cali", "Barranquilla", "Cartagena"]

println("\n--- Principales ciudades de Colombia ---")
# enumerate funciona id√©ntico que en Python, pero arrancando en 1
for (i, ciudad) in enumerate(ciudades)
    println("$i. $ciudad")
end
)-")
```

:::

### Resumen de sintaxis: ciclos for

| Operaci√≥n | Python | R | Julia |
| :--- | :--- | :--- | :--- |
| **Sintaxis B√°sica** | `for item in lista:` | `for (item in vector) { }` | `for item in lista ... end` |
| **Desempaquetar** | `for x, y in tuplas:` | *(No nativo, extraer manual)* | `for (x, y) in tuplas` |
| **Iterar con √çndice** | `for i, v in enumerate(L):`| `for (i in seq_along(v)) { }` | `for (i, v) in enumerate(L)` |
| **Rango Num√©rico** | `for i in range(1, 6):` | `for (i in 1:5) { }` | `for i in 1:5` |

: Equivalencias para el manejo de bucles for {#tbl-operaciones_for tbl-colwidths="[20,28,26,26]"}

---

**Nota t√©cnica de iteraci√≥n:** Observe un detalle fundamental al usar la funci√≥n de enumeraci√≥n. En Python, `enumerate()` genera √≠ndices comenzando desde `0`, por lo que tuvimos que imprimir `i + 1` para que la lista de ciudades empezara en el n√∫mero uno. Por el contrario, tanto R (`seq_along()`) como Julia (`enumerate()`) son lenguajes de **Base 1**, por lo que sus √≠ndices naturales arrancan directamente en el n√∫mero 1, haciendo la impresi√≥n mucho m√°s directa.

## Ciclos while

A diferencia del ciclo `for` (que se usa cuando sabemos exactamente cu√°ntos elementos vamos a recorrer), el **ciclo while** se ejecuta de manera indefinida **mientras una condici√≥n siga siendo verdadera**. 

En el contexto espacial, esto es sumamente √∫til para procesos de simulaci√≥n o lectura de sensores. Por ejemplo: "*sigue leyendo el puerto del GPS mientras la precisi√≥n sea mayor a 5 metros*" o "*sigue intentando descargar la imagen satelital mientras el servidor devuelva un error*".

A continuaci√≥n, exploraremos dos escenarios:

1. Usar un `while` como contador tradicional para recorrer una lista de coordenadas.
2. Simular un sensor GPS que busca "enganchar" una coordenada cerca de Bogot√° (Latitud 4.6), con un n√∫mero m√°ximo de intentos para no crear un ciclo infinito.

::: {.panel-tabset}

### Python

::: {.content-visible when-format="html"}
::: {.callout-tip collapse="true" icon="false"}
#### ‚ñ∑ C√ìDIGO PURO (Copiar y Pegar)
```{python}
#| label: python_ciclos_while_codigo
#| eval: false

# 1. Estructura b√°sica de un ciclo while
# Crearemos un vector de tuplas con coordenadas de Bogot√° y Medell√≠n
coordenadas = [(4.6097, -74.0817), (6.2442, -75.5812)]
contador = 0

print("--- Procesamiento secuencial ---")
while contador < len(coordenadas):
    lat, lon = coordenadas[contador]
    # Todo lo que est√© indentado (movido a la derecha) se repetir√°
    print(f"Procesando coordenada: ({lat}, {lon})")
    contador += 1  # Crucial: Si no incrementamos, el ciclo ser√° infinito

# 2. Ejemplo pr√°ctico: Simulador de se√±al GPS
import random

latitud_objetivo = 4.6097  # Objetivo: Latitud de Bogot√°
tolerancia = 0.1
intentos = 0
max_intentos = 10

print(f"\n--- Buscando se√±al GPS cerca de la latitud {latitud_objetivo} ---")

while intentos < max_intentos:
    # random.uniform genera un n√∫mero con decimales de manera aleatoria.
    # El primer par√°metro (4.0) es el l√≠mite inferior y el segundo (5.0) es el l√≠mite superior.
    lat_aleatoria = random.uniform(4.0, 5.0)
    intentos += 1
    
    print(f"Intento {intentos}: Lectura ({lat_aleatoria:.4f})")
    
    # Comprobamos si la lectura est√° dentro del rango aceptable
    if abs(lat_aleatoria - latitud_objetivo) <= tolerancia:
        print(f"‚úì Se√±al estable encontrada en {intentos} intentos!")
        break  # Rompe el ciclo inmediatamente y no ejecuta el 'else'
else:
    # Python tiene esta estructura √∫nica: el bloque 'else' se ejecuta 
    # SOLO si el ciclo while termin√≥ de forma natural (sin usar 'break').
    print(f"‚úó No se logr√≥ estabilizar la se√±al tras {max_intentos} intentos.")
```
:::
:::

```{python}
#| label: python_ciclos_while
# #| eval: false

# 1. Estructura b√°sica de un ciclo while
# Crearemos un vector de tuplas con coordenadas de Bogot√° y Medell√≠n
coordenadas = [(4.6097, -74.0817), (6.2442, -75.5812)]
contador = 0

print("--- Procesamiento secuencial ---")
while contador < len(coordenadas):
    lat, lon = coordenadas[contador]
    # Todo lo que est√© indentado (movido a la derecha) se repetir√°
    print(f"Procesando coordenada: ({lat}, {lon})")
    contador += 1  # Crucial: Si no incrementamos, el ciclo ser√° infinito

# 2. Ejemplo pr√°ctico: Simulador de se√±al GPS
import random

latitud_objetivo = 4.6097  # Objetivo: Latitud de Bogot√°
tolerancia = 0.1
intentos = 0
max_intentos = 10

print(f"\n--- Buscando se√±al GPS cerca de la latitud {latitud_objetivo} ---")

while intentos < max_intentos:
    # random.uniform genera un n√∫mero con decimales de manera aleatoria.
    # El primer par√°metro (4.0) es el l√≠mite inferior y el segundo (5.0) es el l√≠mite superior.
    lat_aleatoria = random.uniform(4.0, 5.0)
    intentos += 1
    
    print(f"Intento {intentos}: Lectura ({lat_aleatoria:.4f})")
    
    # Comprobamos si la lectura est√° dentro del rango aceptable
    if abs(lat_aleatoria - latitud_objetivo) <= tolerancia:
        print(f"‚úì Se√±al estable encontrada en {intentos} intentos!")
        break  # Rompe el ciclo inmediatamente y no ejecuta el 'else'
else:
    # Python tiene esta estructura √∫nica: el bloque 'else' se ejecuta 
    # SOLO si el ciclo while termin√≥ de forma natural (sin usar 'break').
    print(f"‚úó No se logr√≥ estabilizar la se√±al tras {max_intentos} intentos.")
```

### R

::: {.content-visible when-format="html"}
::: {.callout-tip collapse="true" icon="false"}
#### ‚ñ∑ C√ìDIGO PURO (Copiar y Pegar)
```{r}
#| label: r_ciclos_while_codigo
#| eval: false

# 1. Estructura b√°sica de un ciclo while
# Crearemos una lista que contiene vectores num√©ricos de coordenadas
coordenadas <- list(c(4.6097, -74.0817), c(6.2442, -75.5812))
contador <- 1  # Recuerda: R usa Base 1

cat("--- Procesamiento secuencial ---\n")
while (contador <= length(coordenadas)) {
    # Todo lo que est√© entre las llaves { } se repetir√°
    coord <- coordenadas[[contador]] # Abrimos la caja fuerte con [[ ]]
    cat(sprintf("Procesando coordenada: (%.4f, %.4f)\n", coord[1], coord[2]))
    contador <- contador + 1
}

# 2. Ejemplo pr√°ctico: Simulador de se√±al GPS
latitud_objetivo <- 4.6097  # Objetivo: Latitud de Bogot√°
tolerancia <- 0.1
intentos <- 0
max_intentos <- 10

# R no tiene el "while...else" de Python, as√≠ que usamos una bandera l√≥gica (flag)
senal_encontrada <- FALSE 

cat(sprintf("\n--- Buscando se√±al GPS cerca de la latitud %.4f ---\n", latitud_objetivo))

while (intentos < max_intentos) {
    # runif genera n√∫meros aleatorios con decimales.
    # El primer par√°metro (1) es la cantidad. min (4.0) y max (5.0) son los l√≠mites.
    lat_aleatoria <- runif(1, min = 4.0, max = 5.0)
    intentos <- intentos + 1
    
    cat(sprintf("Intento %d: Lectura (%.4f)\n", intentos, lat_aleatoria))
    
    if (abs(lat_aleatoria - latitud_objetivo) <= tolerancia) {
        cat(sprintf("‚úì Se√±al estable encontrada en %d intentos!\n", intentos))
        senal_encontrada <- TRUE
        break
    }
}

# Comprobamos la bandera fuera del ciclo
if (!senal_encontrada) {
    cat(sprintf("‚úó No se logr√≥ estabilizar la se√±al tras %d intentos.\n", max_intentos))
}
```
:::
:::

```{r}
#| label: r_ciclos_while
# #| eval: false

# 1. Estructura b√°sica de un ciclo while
# Crearemos una lista que contiene vectores num√©ricos de coordenadas
coordenadas <- list(c(4.6097, -74.0817), c(6.2442, -75.5812))
contador <- 1  # Recuerda: R usa Base 1

cat("--- Procesamiento secuencial ---\n")
while (contador <= length(coordenadas)) {
    # Todo lo que est√© entre las llaves { } se repetir√°
    coord <- coordenadas[[contador]] # Abrimos la caja fuerte con [[ ]]
    cat(sprintf("Procesando coordenada: (%.4f, %.4f)\n", coord[1], coord[2]))
    contador <- contador + 1
}

# 2. Ejemplo pr√°ctico: Simulador de se√±al GPS
latitud_objetivo <- 4.6097  # Objetivo: Latitud de Bogot√°
tolerancia <- 0.1
intentos <- 0
max_intentos <- 10

# R no tiene el "while...else" de Python, as√≠ que usamos una bandera l√≥gica (flag)
senal_encontrada <- FALSE 

cat(sprintf("\n--- Buscando se√±al GPS cerca de la latitud %.4f ---\n", latitud_objetivo))

while (intentos < max_intentos) {
    # runif genera n√∫meros aleatorios con decimales.
    # El primer par√°metro (1) es la cantidad. min (4.0) y max (5.0) son los l√≠mites.
    lat_aleatoria <- runif(1, min = 4.0, max = 5.0)
    intentos <- intentos + 1
    
    cat(sprintf("Intento %d: Lectura (%.4f)\n", intentos, lat_aleatoria))
    
    if (abs(lat_aleatoria - latitud_objetivo) <= tolerancia) {
        cat(sprintf("‚úì Se√±al estable encontrada en %d intentos!\n", intentos))
        senal_encontrada <- TRUE
        break
    }
}

# Comprobamos la bandera fuera del ciclo
if (!senal_encontrada) {
    cat(sprintf("‚úó No se logr√≥ estabilizar la se√±al tras %d intentos.\n", max_intentos))
}
```

### Julia

::: {.content-visible when-format="html"}
::: {.callout-tip collapse="true" icon="false"}
#### ‚ñ∑ C√ìDIGO PURO (Copiar y Pegar)
```{julia}
#| label: julia_ciclos_while_codigo
#| eval: false

# 1. Estructura b√°sica de un ciclo while
# Creamos un arreglo de tuplas con coordenadas de Bogot√° y Medell√≠n
coordenadas = [(4.6097, -74.0817), (6.2442, -75.5812)]
contador = 1  # Julia usa Base 1

println("--- Procesamiento secuencial ---")
while contador <= length(coordenadas)
    lat, lon = coordenadas[contador]
    println("Procesando coordenada: ($lat, $lon)")
    global contador += 1 
end # La palabra 'end' marca donde termina el bucle

# 2. Ejemplo pr√°ctico: Simulador de se√±al GPS
using Printf

latitud_objetivo = 4.6097  # Objetivo: Latitud de Bogot√°
tolerancia = 0.1
intentos = 0
max_intentos = 10
senal_encontrada = false # Bandera l√≥gica de control

println("\n--- Buscando se√±al GPS cerca de la latitud $latitud_objetivo ---")

while intentos < max_intentos
    # rand() genera un decimal entre 0.0 y 1.0
    # Multiplicar por 1.0 (tama√±o del rango deseado) y sumar 4.0 (l√≠mite inferior)
    # nos da un valor aleatorio entre 4.0 y 5.0
    lat_aleatoria = 4.0 + rand() * 1.0
    global intentos += 1
    
    @printf("Intento %d: Lectura (%.4f)\n", intentos, lat_aleatoria)
    
    if abs(lat_aleatoria - latitud_objetivo) <= tolerancia
        println("‚úì Se√±al estable encontrada en $intentos intentos!")
        global senal_encontrada = true
        break
    end
end

if !senal_encontrada
    println("‚úó No se logr√≥ estabilizar la se√±al tras $max_intentos intentos.")
end
```
:::
:::

```{r}
#| label: julia_ciclos_while
#| results: asis
# #| eval: false
j_eval(r"-(
# 1. Estructura b√°sica de un ciclo while
# Creamos un arreglo de tuplas con coordenadas de Bogot√° y Medell√≠n
coordenadas = [(4.6097, -74.0817), (6.2442, -75.5812)]
contador = 1  # Julia usa Base 1

println("--- Procesamiento secuencial ---")
while contador <= length(coordenadas)
    lat, lon = coordenadas[contador]
    println("Procesando coordenada: ($lat, $lon)")
    global contador += 1 
end # La palabra 'end' marca donde termina el bucle

# 2. Ejemplo pr√°ctico: Simulador de se√±al GPS
using Printf

latitud_objetivo = 4.6097  # Objetivo: Latitud de Bogot√°
tolerancia = 0.1
intentos = 0
max_intentos = 10
senal_encontrada = false # Bandera l√≥gica de control

println("\n--- Buscando se√±al GPS cerca de la latitud $latitud_objetivo ---")

while intentos < max_intentos
    # rand() genera un decimal entre 0.0 y 1.0
    # Multiplicar por 1.0 (tama√±o del rango deseado) y sumar 4.0 (l√≠mite inferior)
    # nos da un valor aleatorio entre 4.0 y 5.0
    lat_aleatoria = 4.0 + rand() * 1.0
    global intentos += 1
    
    @printf("Intento %d: Lectura (%.4f)\n", intentos, lat_aleatoria)
    
    if abs(lat_aleatoria - latitud_objetivo) <= tolerancia
        println("‚úì Se√±al estable encontrada en $intentos intentos!")
        global senal_encontrada = true
        break
    end
end

if !senal_encontrada
    println("‚úó No se logr√≥ estabilizar la se√±al tras $max_intentos intentos.")
end
)-")
```

:::

### Resumen de sintaxis: ciclos while

| Operaci√≥n | Python | R | Julia |
| :--- | :--- | :--- | :--- |
| **Delimitador de Bloque** | Indentaci√≥n (Tabulador) | Llaves `{ }` | Palabra clave `end` |
| **Sintaxis B√°sica** | `while condicion:` | `while (condicion) { }` | `while condicion ... end` |
| **Romper Ciclo** | `break` | `break` | `break` |
| **Saltar a siguiente iteraci√≥n** | `continue` | `next` | `continue` |
| **Control de Cierre Natural** | `while... else:` | *(Usar banderas l√≥gicas)* | *(Usar banderas l√≥gicas)* |

: Equivalencias para el manejo de bucles while {#tbl-operaciones_while tbl-colwidths="[25,25,25,25]"}



::: {.callout-important}
### La trampa de la indentaci√≥n en Python
Note un cambio cr√≠tico en la primera fila de la tabla anterior. En **R** y **Julia**, el computador sabe qu√© instrucciones pertenecen a un bucle porque est√°n atrapadas entre llaves `{}` o terminan con la palabra `end`. 

En **Python**, las llaves no existen. El lenguaje utiliza la **indentaci√≥n** (los 4 espacios en blanco o tabuladores a la izquierda del c√≥digo en VSCode) para definir qu√© pertenece a cada ciclo o condici√≥n. Si olvidas presionar la tecla *Tab* (en VSCode: 4 espacios en blanco) despu√©s de declarar un `while:` o un `for:`, Python te arrojar√° un error de sintaxis inmediatamente.
:::

## Declaraciones de control (toma de decisiones)

En la programaci√≥n espacial, rara vez aplicamos la misma regla a todos los datos. Las **declaraciones condicionales** (`if`, `else if`, `else`) funcionan como "agujas de tren" que desv√≠an el flujo de nuestro programa dependiendo de si los datos cumplen o no con ciertas condiciones l√≥gicas. 

Por ejemplo, podr√≠amos necesitar un algoritmo que dicte: "Si el predio es rural, aplique el impuesto A; si es urbano, aplique el impuesto B; y si no tiene categor√≠a, clasif√≠quelo como error". 

Antes de construir estas condiciones, necesitamos conocer las herramientas b√°sicas para comparar datos matem√°ticamente. Afortunadamente, los **operadores de comparaci√≥n** son pr√°cticamente id√©nticos en Python, R y Julia:

| Comparaci√≥n | Operador universal | Ejemplo |
| :--- | :---: | :--- |
| **Igual a** | `==` | `lat == 0` *(Nota: ¬°Doble igual! Un solo `=` es para asignar variables)* |
| **Diferente de** | `!=` | `depto != "Bogot√°"` |
| **Mayor / Menor que** | `>`, `<` | `poblacion > 1000` |
| **Mayor o igual / Menor o igual**| `>=`, `<=` | `elevacion >= 2600` |

: Operadores de comparaci√≥n matem√°ticos {#tbl-operadores_comparacion tbl-colwidths="[30,20,50]"}

A continuaci√≥n, analizaremos un conjunto mixto de coordenadas (colombianas, internacionales y un error intencional) para clasificarlas seg√∫n su hemisferio y cuadrante global. 

Para que este ejercicio tenga sentido geogr√°fico y matem√°tico, es fundamental recordar que **las latitudes v√°lidas van de -90¬∞ a 90¬∞**, y **las longitudes v√°lidas van de -180¬∞ a 180¬∞**. Usaremos esta regla para filtrar datos err√≥neos.

::: {.panel-tabset}

### Python

::: {.content-visible when-format="html"}
::: {.callout-tip collapse="true" icon="false"}
#### ‚ñ∑ C√ìDIGO PURO (Copiar y Pegar)
```{python}
#| label: python_condicionales_codigo
#| eval: false

# Conjunto de an√°lisis: Bogot√°, Leticia, Tokio, y una coordenada err√≥nea
coordenadas = [
    (4.6097, -74.0817),   # Bogot√° (Norte, Oeste)
    (-4.2153, -69.9406),  # Leticia (Sur, Oeste)
    (0.0000, -76.0000),   # Sobre el Ecuador
    (35.6762, 139.6503),  # Tokio (Norte, Este)
    (105.0000, -75.0000)  # ¬°Error! La latitud no puede pasar de 90
]

norte_count = 0
sur_count = 0
este_count = 0
oeste_count = 0
coordenadas_validas = []

print("--- An√°lisis de Coordenadas ---")

for lat, lon in coordenadas:
    
    # 1. Validaci√≥n de rango (Operador l√≥gico 'and' y encadenamiento)
    # Python permite encadenar comparaciones matem√°ticas directamente
    if -90 <= lat <= 90 and -180 <= lon <= 180:
        
        coordenadas_validas.append((lat, lon))
        
        # 2. Clasificaci√≥n simple (if / elif / else)
        if lat > 0:
            hemisferio = "Norte"
            norte_count += 1
        elif lat < 0:
            hemisferio = "Sur"
            sur_count += 1
        else:
            hemisferio = "Ecuador"
            
        if lon > 0:
            este_count += 1
        else:
            oeste_count += 1

        # 3. Clasificaci√≥n compleja por cuadrantes (m√∫ltiples condiciones)
        if lat > 0 and lon > 0:
            cuadrante = "Noreste"
        elif lat > 0 and lon < 0:
            cuadrante = "Noroeste"
        elif lat < 0 and lon > 0:
            cuadrante = "Sureste"
        else:  # Por descarte
            cuadrante = "Suroeste"
            
        print(f"‚úì V√°lida: ({lat:7.4f}, {lon:8.4f}) -> {cuadrante} ({hemisferio})")
        
    else:
        print(f"‚úó Inv√°lida: ({lat}, {lon}) - Fuera de rango global.")

print("\n--- Resumen Estad√≠stico ---")
print(f"Total v√°lidas: {len(coordenadas_validas)}")
print(f"Puntos en el Norte: {norte_count} | Sur: {sur_count}")
print(f"Puntos en el Este: {este_count} | Oeste: {oeste_count}")
```
:::
:::

```{python}
#| label: python_condicionales
# #| eval: false

# Conjunto de an√°lisis: Bogot√°, Leticia, Tokio, y una coordenada err√≥nea
coordenadas = [
    (4.6097, -74.0817),   # Bogot√° (Norte, Oeste)
    (-4.2153, -69.9406),  # Leticia (Sur, Oeste)
    (0.0000, -76.0000),   # Sobre el Ecuador
    (35.6762, 139.6503),  # Tokio (Norte, Este)
    (105.0000, -75.0000)  # ¬°Error! La latitud no puede pasar de 90
]

norte_count = 0
sur_count = 0
este_count = 0
oeste_count = 0
coordenadas_validas = []

print("--- An√°lisis de Coordenadas ---")

for lat, lon in coordenadas:
    
    # 1. Validaci√≥n de rango (Operador l√≥gico 'and' y encadenamiento)
    # Python permite encadenar comparaciones matem√°ticas directamente
    if -90 <= lat <= 90 and -180 <= lon <= 180:
        
        coordenadas_validas.append((lat, lon))
        
        # 2. Clasificaci√≥n simple (if / elif / else)
        if lat > 0:
            hemisferio = "Norte"
            norte_count += 1
        elif lat < 0:
            hemisferio = "Sur"
            sur_count += 1
        else:
            hemisferio = "Ecuador"
            
        if lon > 0:
            este_count += 1
        else:
            oeste_count += 1

        # 3. Clasificaci√≥n compleja por cuadrantes (m√∫ltiples condiciones)
        if lat > 0 and lon > 0:
            cuadrante = "Noreste"
        elif lat > 0 and lon < 0:
            cuadrante = "Noroeste"
        elif lat < 0 and lon > 0:
            cuadrante = "Sureste"
        else:  # Por descarte
            cuadrante = "Suroeste"
            
        print(f"‚úì V√°lida: ({lat:7.4f}, {lon:8.4f}) -> {cuadrante} ({hemisferio})")
        
    else:
        print(f"‚úó Inv√°lida: ({lat}, {lon}) - Fuera de rango global.")

print("\n--- Resumen Estad√≠stico ---")
print(f"Total v√°lidas: {len(coordenadas_validas)}")
print(f"Puntos en el Norte: {norte_count} | Sur: {sur_count}")
print(f"Puntos en el Este: {este_count} | Oeste: {oeste_count}")
```

### R

::: {.content-visible when-format="html"}
::: {.callout-tip collapse="true" icon="false"}
#### ‚ñ∑ C√ìDIGO PURO (Copiar y Pegar)
```{r}
#| label: r_condicionales_codigo
#| eval: false

coordenadas <- list(
    c(4.6097, -74.0817),   
    c(-4.2153, -69.9406),  
    c(0.0000, -76.0000),   
    c(35.6762, 139.6503),  
    c(105.0000, -75.0000)  
)

norte_count <- 0
sur_count <- 0
este_count <- 0
oeste_count <- 0
coordenadas_validas <- list()

cat("--- An√°lisis de Coordenadas ---\n")

for (coord in coordenadas) {
    lat <- coord[1]
    lon <- coord[2]
    
    # 1. Validaci√≥n con el operador && (AND l√≥gico para valores individuales)
    # A diferencia de Python, en R debemos separar las condiciones completas
    if (lat >= -90 && lat <= 90 && lon >= -180 && lon <= 180) {
        
        coordenadas_validas <- append(coordenadas_validas, list(c(lat, lon)))
        
        # 2. Clasificaci√≥n simple
        # R estila poner el 'else if' en la misma l√≠nea que cierra la llave anterior
        if (lat > 0) {
            hemisferio <- "Norte"
            norte_count <- norte_count + 1
        } else if (lat < 0) {
            hemisferio <- "Sur"
            sur_count <- sur_count + 1
        } else {
            hemisferio <- "Ecuador"
        }
            
        if (lon > 0) {
            este_count <- este_count + 1
        } else {
            oeste_count <- oeste_count + 1
        }

        # 3. Clasificaci√≥n por cuadrantes
        if (lat > 0 && lon > 0) {
            cuadrante <- "Noreste"
        } else if (lat > 0 && lon < 0) {
            cuadrante <- "Noroeste"
        } else if (lat < 0 && lon > 0) {
            cuadrante <- "Sureste"
        } else {
            cuadrante <- "Suroeste"
        }
            
        cat(sprintf("‚úì V√°lida: (%7.4f, %8.4f) -> %s (%s)\n", lat, lon, cuadrante, hemisferio))
        
    } else {
        cat(sprintf("‚úó Inv√°lida: (%.4f, %.4f) - Fuera de rango global.\n", lat, lon))
    }
}

cat("\n--- Resumen Estad√≠stico ---\n")
cat(sprintf("Total v√°lidas: %d\n", length(coordenadas_validas)))
cat(sprintf("Puntos en el Norte: %d | Sur: %d\n", norte_count, sur_count))
cat(sprintf("Puntos en el Este: %d | Oeste: %d\n", este_count, oeste_count))
```
:::
:::

```{r}
#| label: r_condicionales
# #| eval: false

coordenadas <- list(
    c(4.6097, -74.0817),   
    c(-4.2153, -69.9406),  
    c(0.0000, -76.0000),   
    c(35.6762, 139.6503),  
    c(105.0000, -75.0000)  
)

norte_count <- 0
sur_count <- 0
este_count <- 0
oeste_count <- 0
coordenadas_validas <- list()

cat("--- An√°lisis de Coordenadas ---\n")

for (coord in coordenadas) {
    lat <- coord[1]
    lon <- coord[2]
    
    # 1. Validaci√≥n con el operador && (AND l√≥gico para valores individuales)
    # A diferencia de Python, en R debemos separar las condiciones completas
    if (lat >= -90 && lat <= 90 && lon >= -180 && lon <= 180) {
        
        coordenadas_validas <- append(coordenadas_validas, list(c(lat, lon)))
        
        # 2. Clasificaci√≥n simple
        # R estila poner el 'else if' en la misma l√≠nea que cierra la llave anterior
        if (lat > 0) {
            hemisferio <- "Norte"
            norte_count <- norte_count + 1
        } else if (lat < 0) {
            hemisferio <- "Sur"
            sur_count <- sur_count + 1
        } else {
            hemisferio <- "Ecuador"
        }
            
        if (lon > 0) {
            este_count <- este_count + 1
        } else {
            oeste_count <- oeste_count + 1
        }

        # 3. Clasificaci√≥n por cuadrantes
        if (lat > 0 && lon > 0) {
            cuadrante <- "Noreste"
        } else if (lat > 0 && lon < 0) {
            cuadrante <- "Noroeste"
        } else if (lat < 0 && lon > 0) {
            cuadrante <- "Sureste"
        } else {
            cuadrante <- "Suroeste"
        }
            
        cat(sprintf("‚úì V√°lida: (%7.4f, %8.4f) -> %s (%s)\n", lat, lon, cuadrante, hemisferio))
        
    } else {
        cat(sprintf("‚úó Inv√°lida: (%.4f, %.4f) - Fuera de rango global.\n", lat, lon))
    }
}

cat("\n--- Resumen Estad√≠stico ---\n")
cat(sprintf("Total v√°lidas: %d\n", length(coordenadas_validas)))
cat(sprintf("Puntos en el Norte: %d | Sur: %d\n", norte_count, sur_count))
cat(sprintf("Puntos en el Este: %d | Oeste: %d\n", este_count, oeste_count))
```

### Julia

::: {.content-visible when-format="html"}
::: {.callout-tip collapse="true" icon="false"}
#### ‚ñ∑ C√ìDIGO PURO (Copiar y Pegar)
```{julia}
#| label: julia_condicionales_codigo
#| eval: false

coordenadas = [
    (4.6097, -74.0817),   
    (-4.2153, -69.9406),  
    (0.0000, -76.0000),   
    (35.6762, 139.6503),  
    (105.0000, -75.0000)  
]

norte_count = 0
sur_count = 0
este_count = 0
oeste_count = 0
coordenadas_validas = []

using Printf
println("--- An√°lisis de Coordenadas ---")

for (lat, lon) in coordenadas
    
    # 1. Julia soporta el encadenamiento matem√°tico igual que Python
    # pero el operador AND se escribe && (como en R)
    if -90 <= lat <= 90 && -180 <= lon <= 180
        
        push!(coordenadas_validas, (lat, lon))
        
        # 2. Clasificaci√≥n simple (if / elseif / else)
        if lat > 0
            hemisferio = "Norte"
            global norte_count += 1
        elseif lat < 0
            hemisferio = "Sur"
            global sur_count += 1
        else
            hemisferio = "Ecuador"
        end
            
        if lon > 0
            global este_count += 1
        else
            global oeste_count += 1
        end

        # 3. Clasificaci√≥n por cuadrantes
        if lat > 0 && lon > 0
            cuadrante = "Noreste"
        elseif lat > 0 && lon < 0
            cuadrante = "Noroeste"
        elseif lat < 0 && lon > 0
            cuadrante = "Sureste"
        else
            cuadrante = "Suroeste"
        end
            
        @printf("‚úì V√°lida: (%7.4f, %8.4f) -> %s (%s)\n", lat, lon, cuadrante, hemisferio)
        
    else
        println("‚úó Inv√°lida: ($lat, $lon) - Fuera de rango global.")
    end
end

println("\n--- Resumen Estad√≠stico ---")
println("Total v√°lidas: $(length(coordenadas_validas))")
println("Puntos en el Norte: $norte_count | Sur: $sur_count")
println("Puntos en el Este: $este_count | Oeste: $oeste_count")
```
:::
:::

```{r}
#| label: julia_condicionales
#| results: asis
# #| eval: false
j_eval(r"-(
coordenadas = [
    (4.6097, -74.0817),   
    (-4.2153, -69.9406),  
    (0.0000, -76.0000),   
    (35.6762, 139.6503),  
    (105.0000, -75.0000)  
]

norte_count = 0
sur_count = 0
este_count = 0
oeste_count = 0
coordenadas_validas = []

using Printf
println("--- An√°lisis de Coordenadas ---")

for (lat, lon) in coordenadas
    
    # 1. Julia soporta el encadenamiento matem√°tico igual que Python
    # pero el operador AND se escribe && (como en R)
    if -90 <= lat <= 90 && -180 <= lon <= 180
        
        push!(coordenadas_validas, (lat, lon))
        
        # 2. Clasificaci√≥n simple (if / elseif / else)
        if lat > 0
            hemisferio = "Norte"
            global norte_count += 1
        elseif lat < 0
            hemisferio = "Sur"
            global sur_count += 1
        else
            hemisferio = "Ecuador"
        end
            
        if lon > 0
            global este_count += 1
        else
            global oeste_count += 1
        end

        # 3. Clasificaci√≥n por cuadrantes
        if lat > 0 && lon > 0
            cuadrante = "Noreste"
        elseif lat > 0 && lon < 0
            cuadrante = "Noroeste"
        elseif lat < 0 && lon > 0
            cuadrante = "Sureste"
        else
            cuadrante = "Suroeste"
        end
            
        @printf("‚úì V√°lida: (%7.4f, %8.4f) -> %s (%s)\n", lat, lon, cuadrante, hemisferio)
        
    else
        println("‚úó Inv√°lida: ($lat, $lon) - Fuera de rango global.")
    end
end

println("\n--- Resumen Estad√≠stico ---")
println("Total v√°lidas: $(length(coordenadas_validas))")
println("Puntos en el Norte: $norte_count | Sur: $sur_count")
println("Puntos en el Este: $este_count | Oeste: $oeste_count")
)-")
```

:::

### Resumen de sintaxis: condicionales y operadores l√≥gicos

| Operaci√≥n | Python | R | Julia |
| :--- | :--- | :--- | :--- |
| **Si (Principal)** | `if condicion:` | `if (condicion) { }` | `if condicion` |
| **O si (Intermedio)** | `elif condicion:` | `else if (condicion) { }` | `elseif condicion` |
| **Sino (Descarte)** | `else:` | `else { }` | `else` |
| **Cierre del bloque** | Indentaci√≥n | Llave de cierre `}` | Palabra `end` |
| **Y l√≥gico (AND)** | `and` | `&&` | `&&` |
| **O l√≥gico (OR)** | `or` | `||` | `||` |
| **NO l√≥gico (NOT)** | `not` | `!` | `!` |

: Equivalencias para el manejo de condicionales l√≥gicos {#tbl-operaciones_condicionales tbl-colwidths="[20,20,30,30]"}

### Agrupaci√≥n y orden de evaluaci√≥n (el poder de los par√©ntesis)

Cuando combinamos m√∫ltiples condiciones (usando `AND` y `OR` en la misma frase), el computador eval√∫a las reglas en un orden estricto (generalmente el `AND` tiene prioridad sobre el `OR`). Esto puede llevar a resultados desastrosos si no le decimos expl√≠citamente qu√© agrupar.

**Imagina este escenario:** Queremos filtrar los puntos que caigan en el cuadrante *Noroeste* **O** en el cuadrante *Sureste*, pero en ambos casos, su elevaci√≥n **DEBE** ser mayor a 1000 metros.

* ‚ùå **Forma incorrecta (Ambigua):**
  `if lat > 0 and lon < 0 or lat < 0 and lon > 0 and elevacion > 1000:`
  *¬øQu√© har√° el computador aqu√≠?* Podr√≠a aprobar puntos del Noroeste sin importar su elevaci√≥n, porque el `OR` parti√≥ la regla en dos universos distintos.

* ‚úÖ **Forma correcta (Agrupada con par√©ntesis):**
  `if ((lat > 0 and lon < 0) or (lat < 0 and lon > 0)) and elevacion > 1000:`
  *Aqu√≠ le dijimos:* "Primero eval√∫a los par√©ntesis internos (los cuadrantes). Luego, agarra el resultado de eso y, obligatoriamente, ex√≠gele la elevaci√≥n".

**Regla de oro:** Siempre que mezcles un `AND` y un `OR` en la misma l√≠nea, usa par√©ntesis `()` para aislar la l√≥gica, independientemente del lenguaje que est√©s usando.

---

::: {.callout-warning icon="false"}
### La met√°fora del portero y el colador (Operadores l√≥gicos en R y Julia)

R y Julia tienen **dos familias** de operadores l√≥gicos que confunden constantemente a los analistas de datos. Para no olvidarlos nunca, piensa en ellos as√≠:

1. **El operador doble (`&&`, `||`) es el "portero de la discoteca":** Est√° dise√±ado para decidir si abre o no la puerta (el `if`). Por lo tanto, exige revisar **una sola c√©dula a la vez** (un valor escalar). Si t√∫ le entregas una lista completa con 30 c√©dulas de golpe (un vector), el portero se confunde, se bloquea y arroja un error. Adem√°s, es perezoso (*cortocircuito*): si ve que la primera condici√≥n falla, ni siquiera mira la segunda.
2. **El operador sencillo (`&`, `|` en R; `.&`, `.|` en Julia) es el "filtro de colador":** Est√° dise√±ado exactamente para trabajar con datos masivos. Recibe la lista completa de 30 datos, los eval√∫a todos al mismo tiempo (recuerda que en Julia el punto `.` de *broadcasting* es obligatorio para que el filtro act√∫e elemento por elemento), y te devuelve una lista nueva dici√©ndote cu√°les pasaron la prueba (`TRUE`) y cu√°les no (`FALSE`). Esa lista resultante es la que usamos para filtrar la base de datos original.



A continuaci√≥n, veremos c√≥mo el "colador" filtra correctamente un vector de alturas (elevaciones topogr√°ficas), y c√≥mo el "portero" hace que el programa colapse al no saber qu√© hacer con tantos datos a la vez.

::: {.panel-tabset}

### R

::: {.content-visible when-format="html"}
::: {.callout-tip collapse="true" icon="false"}
#### ‚ñ∑ C√ìDIGO PURO (Copiar y Pegar)
```{r}
#| label: r_operadores_logicos_codigo
#| eval: false

alturas <- c(1500, 2500, 800)

cat("--- 1. El Colador: Operador sencillo '&' (Vectorizado) ---\n")
# Eval√∫a elemento por elemento y devuelve un vector l√≥gico:
filtro_logico <- alturas > 1000 & alturas < 3000
print(filtro_logico)

# Usamos ese vector de TRUE/FALSE para extraer los datos originales:
alturas_validas <- alturas[filtro_logico]
cat("Alturas filtradas:", alturas_validas, "\n\n")

cat("--- 2. El Portero: Operador doble '&&' en un vector ---\n")
# Esto generar√° un error porque el portero (&&) espera una sola c√©dula para el 'if'
if (alturas > 1000 && alturas < 3000) {
    cat("Esto no se imprimir√°.\n")
}
```
:::
:::

```{r}
#| label: r_operadores_logicos
#| error: true
#| collapse: true
# #| eval: false

alturas <- c(1500, 2500, 800)

cat("--- 1. El Colador: Operador sencillo '&' (Vectorizado) ---\n")
# Eval√∫a elemento por elemento y devuelve un vector l√≥gico:
filtro_logico <- alturas > 1000 & alturas < 3000
print(filtro_logico)

# Usamos ese vector de TRUE/FALSE para extraer los datos originales:
alturas_validas <- alturas[filtro_logico]
cat("Alturas filtradas:", alturas_validas, "\n\n")

cat("--- 2. El Portero: Operador doble '&&' en un vector ---\n")
# Esto generar√° un error porque el portero (&&) espera una sola c√©dula para el 'if'
if (alturas > 1000 && alturas < 3000) {
    cat("Esto no se imprimir√°.\n")
}
```

### Julia

::: {.content-visible when-format="html"}
::: {.callout-tip collapse="true" icon="false"}
#### ‚ñ∑ C√ìDIGO PURO (Copiar y Pegar)
```{julia}
#| label: julia_operadores_logicos_codigo
#| eval: false

alturas = [1500, 2500, 800]

println("--- 1. El Colador: Operador sencillo '.&' (Vectorizado) ---")
# En Julia agregamos un punto (.) antes del operador matem√°tico y l√≥gico 
# para indicar expl√≠citamente que la operaci√≥n es elemento por elemento.
filtro_logico = (alturas .> 1000) .& (alturas .< 3000)
println(filtro_logico)

# Usamos el resultado para filtrar el arreglo:
alturas_validas = alturas[filtro_logico]
println("Alturas filtradas: ", alturas_validas, "\n")

println("--- 2. El Portero: Operador doble '&&' en un vector ---")
# Intentar meter un arreglo completo en un condicional doble genera error.
# Usamos try/catch para atrapar el error y que el programa no explote.
try
    if (alturas .> 1000) && (alturas .< 3000)
        println("Esto no se imprimir√°.")
    end
catch e
    println("¬°ERROR!: ", typeof(e))
    println("Motivo: El 'if' y el '&&' exigen una sola c√©dula (true/false), no la lista completa.")
end
```
:::
:::

```{r}
#| label: julia_operadores_logicos
#| results: asis
# #| eval: false
j_eval(r"-(
alturas = [1500, 2500, 800]

println("--- 1. El Colador: Operador sencillo '.&' (Vectorizado) ---")
# En Julia agregamos un punto (.) antes del operador matem√°tico y l√≥gico 
# para indicar expl√≠citamente que la operaci√≥n es elemento por elemento.
filtro_logico = (alturas .> 1000) .& (alturas .< 3000)
println(filtro_logico)

# Usamos el resultado para filtrar el arreglo:
alturas_validas = alturas[filtro_logico]
println("Alturas filtradas: ", alturas_validas, "\n")

println("--- 2. El Portero: Operador doble '&&' en un vector ---")
# Intentar meter un arreglo completo en un condicional doble genera error.
# Usamos try/catch para atrapar el error y que el programa no explote.
try
    if (alturas .> 1000) && (alturas .< 3000)
        println("Esto no se imprimir√°.")
    end
catch e
    println("¬°ERROR!: ", typeof(e))
    println("Motivo: El 'if' y el '&&' exigen una sola c√©dula (true/false), no la lista completa.")
end
)-")
```

:::
:::

## Gu√≠a de toma de decisiones sobre declaraciones de control y bucles

Cuando nos enfrentamos a un problema de programaci√≥n espacial, el mayor reto no es escribir el c√≥digo, sino saber **qu√© estructura l√≥gica elegir**. Para no perder tiempo intentando forzar una herramienta que no es la adecuada, hazte las siguientes preguntas en orden:



1. **¬øNecesito tomar una decisi√≥n o clasificar un dato?**
   * *Ejemplo:* Si la elevaci√≥n es > 2000m, clasificar como "P√°ramo".
   * üëâ **Usa:** `if` / `elif` (`else if`) / `else`.

2. **¬øNecesito repetir una tarea varias veces?**

   * **Opci√≥n A: S√© exactamente cu√°ntos datos hay.** 
     * *Ejemplo:* Tengo una lista de 50 municipios y quiero calcular el √°rea de cada uno.
     * üëâ **Usa:** Ciclo `for`. Es seguro, predecible y se detiene solo cuando se acaban los elementos.
   * **Opci√≥n B: No s√© cu√°ntas veces debo repetir, depende de un evento.**
     * *Ejemplo:* Quiero intentar descargar un mapa hasta que el servidor de la NASA responda correctamente.
     * üëâ **Usa:** Ciclo `while`. Aseg√∫rate de incluir un contador de intentos o un `break` para evitar un ciclo infinito.

3. **¬øEstoy trabajando con R o Julia y necesito filtrar miles de datos de un solo golpe?**
   * *Ejemplo:* Extraer todas las parcelas con √°rea > 100 hect√°reas de un vector completo.
   * üëâ **Usa:** Operadores l√≥gicos sencillos para crear un "filtro de colador" (vectorizado), evitando usar un `if` tradicional. En **R** usa `&` o `|`. En **Julia**, no olvides el punto de *broadcasting*: `.&` o `.|`.


## Resumen de aprendizajes (cheat sheet)

En este cap√≠tulo hemos explorado c√≥mo tomar decisiones l√≥gicas y automatizar tareas repetitivas. A continuaci√≥n, se presenta tu **Hoja de Referencia (Cheat Sheet)** para traducir estos conceptos estructurales entre Python, R y Julia.

### 1. Declaraciones condicionales y l√≥gica

| Estructura / Operador | Python | R | Julia |
|:---|:---|:---|:---|
| **Condicional B√°sico** | `if x > 0:` | `if (x > 0) { }` | `if x > 0 ... end` |
| **Condicional M√∫ltiple** | `elif x == 0:` | `else if (x == 0) { }`| `elseif x == 0` |
| **Descarte (Sino)** | `else:` | `else { }` | `else` |
| **Delimitador de Bloque** | Indentaci√≥n (Tab) | Llaves `{ }` | Palabra `end` |
| **Y (Escalar - para 'if')**| `and` | `&&` | `&&` |
| **O (Escalar - para 'if')**| `or` | `||` | `||` |
| **Y (Vectorizado - filtros)**| *(Usa Pandas/Numpy)*| `&` | `.&` |
| **O (Vectorizado - filtros)**| *(Usa Pandas/Numpy)*| `|` | `.|` |

: Equivalencias de toma de decisiones l√≥gicas {#tbl-cheat_condicionales tbl-colwidths="[25,25,25,25]"}

### 2. Ciclos for (iteraciones definidas)

| Objetivo / Acci√≥n | Python | R | Julia |
|:---|:---|:---|:---|
| **Sintaxis B√°sica** | `for v in lista:` | `for (v in lista) { }`| `for v in lista` |
| **Rango Num√©rico** | `for i in range(1, 6):`| `for (i in 1:5) { }` | `for i in 1:5` |
| **Iterar con √çndice** | `for i, v in enumerate(L):`| `for (i in seq_along(L))`| `for (i, v) in enumerate(L)`|
| **Inicio del √çndice** | **Empieza en 0** | **Empieza en 1** | **Empieza en 1** |
| **Desempaquetar Tupla** | `for lat, lon in coords:`| *(Extracci√≥n manual)* | `for (lat, lon) in coords` |

: Equivalencias para bucles definidos {#tbl-cheat_for tbl-colwidths="[25,25,25,25]"}

### 3. Ciclos while (iteraciones indefinidas)

| Objetivo / Acci√≥n | Python | R | Julia |
|:---|:---|:---|:---|
| **Sintaxis B√°sica** | `while condicion:` | `while (condicion) { }` | `while condicion` |
| **Romper el Ciclo** | `break` | `break` | `break` |
| **Saltar Iteraci√≥n** | `continue` | `next` | `continue` |
| **Cierre sin 'break'** | `while... else:` | *(Bandera l√≥gica)* | *(Bandera l√≥gica)* |

: Equivalencias para bucles indefinidos y control de flujo {#tbl-cheat_while tbl-colwidths="[25,25,25,25]"}

---

::: {.callout-important}
### Conclusiones cr√≠ticas del m√≥dulo

1. **La tiran√≠a de la indentaci√≥n en Python:** A diferencia de R (que usa `{}`) y Julia (que usa `end`), Python lee los espacios en blanco para saber qu√© c√≥digo va dentro de un `if` o un `for`. Olvidar un tabulador o mezclar espacios con tabuladores destruir√° tu c√≥digo inmediatamente (*IndentationError*).
2. **El "portero" vs el "colador" en R y Julia:** Nunca metas un vector entero dentro de un `if(x > 0 && y > 0)`. El operador doble (`&&`, `||`) colapsar√° al ver tantos datos. Si necesitas filtrar cientos de parcelas o coordenadas simult√°neamente, usa la evaluaci√≥n vectorizada con el operador simple (`&`, `|` en R; `.&`, `.|` en Julia).
3. **El desfase de los √≠ndices num√©ricos:** Al usar funciones como `enumerate()` (Python/Julia) o `seq_along()` (R) para numerar elementos en un bucle, recuerda tu base matem√°tica. En Python tu primera ciudad ser√° la n√∫mero `0`, mientras que en R y Julia ser√° la n√∫mero `1`. Ajusta tus impresiones en pantalla (`i + 1`) para no confundir al usuario final.
4. **La trampa del ciclo infinito:** El error m√°s com√∫n al programar un `while` es olvidar actualizar la condici√≥n que lo mantiene vivo. Si usas un contador num√©rico, aseg√∫rate de sumarle 1 (`contador += 1`) dentro del bloque de repetici√≥n; de lo contrario, tu programa se congelar√° para siempre.
:::

## Ejercicios

Para poner en pr√°ctica los conceptos aprendidos sobre bucles y declaraciones condicionales, deber√°s resolver los siguientes dos ejercicios. Puedes elegir resolverlos en **Python, R o Julia** (o implementar la soluci√≥n en varios lenguajes si deseas retarte).

### Ejercicio 1: Clasificaci√≥n iterativa (ciclo for e if-else)

**Contexto:** Est√°s trabajando en un proyecto de zonificaci√≥n agr√≠cola en el Eje Cafetero. Tienes una lista de fincas con su respectiva altitud. Sabiendo que el caf√© de especialidad de la regi√≥n requiere alturas entre los 1700 y los 2200 metros sobre el nivel del mar (msnm), necesitas crear un algoritmo que clasifique autom√°ticamente cada finca.

**Instrucciones de c√≥digo:**

1. Crea una colecci√≥n (lista o vector) llamada `altitudes_fincas` que contenga los siguientes valores num√©ricos: `1350, 1750, 1900, 2300, 1600, 2100`.
2. Inicializa dos contadores en cero: `conteo_especial` y `conteo_tradicional`.
3. Inicializa dos colecciones vac√≠as (listas o vectores) llamadas `fincas_especiales` y `fincas_tradicionales`.
4. Construye un ciclo **`for`** que recorra uno a uno los valores de `altitudes_fincas`.
5. Dentro del ciclo, utiliza una declaraci√≥n **`if - else`** con operadores l√≥gicos (`AND`) para evaluar cada altitud:

   * **Si** la altitud es mayor o igual a 1700 **Y** menor o igual a 2200, agrega la altitud a la colecci√≥n `fincas_especiales` y suma 1 al `conteo_especial`.
   * **De lo contrario**, agr√©gala a la colecci√≥n `fincas_tradicionales` y suma 1 al `conteo_tradicional`.
6. Fuera del ciclo, imprime un reporte final que muestre cu√°ntas fincas son aptas para caf√© de especialidad y cu√°ntas para caf√© tradicional, mostrando adem√°s los valores guardados en ambas colecciones.

### Ejercicio 2: Monitoreo de sensores (ciclo while y control de flujo)

**Contexto:** El IDEAM te ha encargado programar el software de una estaci√≥n hidrol√≥gica automatizada en el R√≠o Magdalena. El sensor debe tomar lecturas continuas del nivel del agua. Si el r√≠o supera los 8.5 metros, el sistema debe disparar una alerta de inundaci√≥n y detener las mediciones para proteger el equipo. Si despu√©s de cierto n√∫mero de lecturas todo est√° normal, el sensor entra en modo de reposo.



**Instrucciones de c√≥digo:**

1. Define las siguientes variables de configuraci√≥n:

   * `nivel_alerta` = 8.5
   * `max_lecturas` = 12
   * `lectura_actual` = 0
   * Una bandera l√≥gica (Booleana) llamada `alerta_inundacion` inicializada como Falsa (`False` / `FALSE` / `false`).
2. Construye un ciclo **`while`** que se ejecute **mientras** `lectura_actual` sea menor a `max_lecturas`.
3. Dentro del ciclo, simula la medici√≥n del r√≠o generando un n√∫mero decimal aleatorio entre 5.0 y 9.0 (usa la funci√≥n nativa de tu lenguaje para n√∫meros aleatorios, ej. `random.uniform` en Python, `runif` en R, o `rand` en Julia).
4. Incrementa en 1 la variable `lectura_actual`. Imprime en pantalla el n√∫mero del intento y el nivel del agua medido (con dos decimales).
5. Usa un condicional **`if`** para verificar si la medici√≥n super√≥ o igual√≥ el `nivel_alerta`. Si es as√≠:

   * Cambia la bandera `alerta_inundacion` a Verdadera.
   * Imprime un mensaje de "¬°ALERTA ROJA! Posible desbordamiento."
   * Rompe el ciclo inmediatamente usando el comando adecuado (`break`).
6. Fuera del ciclo `while`, utiliza un condicional para evaluar tu bandera l√≥gica. Si la bandera sigue siendo Falsa, imprime: "Monitoreo finalizado. Niveles estables."

### Entregables y criterios de evaluaci√≥n

El objetivo de esta evaluaci√≥n no es solo que el c√≥digo funcione, sino que seas capaz de documentar y explicar tus decisiones t√©cnicas de control de flujo.

**1. Archivos de C√≥digo:**
Debes desarrollar los algoritmos en al menos uno de los siguientes formatos de archivo:

* Script tradicional (`.py`, `.R`, `.jl`)
* Notebook interactivo (`.ipynb`)
* Documento computacional (`.qmd` con *chunks* de c√≥digo)

**2. Documento Anal√≠tico (Quarto):**
Independientemente del formato de tu c√≥digo fuente, **debes redactar un documento en Quarto (`.qmd`) y renderizarlo tanto en HTML como en PDF**. En este documento debes incluir tus bloques de c√≥digo y responder argumentativamente a las siguientes preguntas:

* **Sobre el Ejercicio 1 (Indentaci√≥n y Bloques):** Si estuvieras desarrollando el c√≥digo en **Python**, ¬øc√≥mo sabe el computador qu√© instrucciones pertenecen dentro del ciclo `for`, cu√°les pertenecen al `if`, y cu√°les deben ejecutarse solo al final del programa? ¬øQu√© diferencia estructural existe frente a c√≥mo lo resolver√≠as en **R** o **Julia**?
* **Sobre el Ejercicio 2 (Ciclos Infinitos):** En el ciclo `while` de la simulaci√≥n del r√≠o, ¬øqu√© suceder√≠a exactamente con la memoria y la ejecuci√≥n del programa si olvidas incluir la instrucci√≥n que incrementa la variable `lectura_actual` en 1? ¬øPor qu√© este riesgo no existe al usar un ciclo `for`?
* **Pregunta General (Operadores L√≥gicos):** Si est√°s programando en **R** o **Julia**, explica detalladamente por qu√© es peligroso usar el operador doble (`&&`) cuando intentas filtrar un vector completo de altitudes, y por qu√© en ese caso espec√≠fico debes usar el operador sencillo (`&` o `.&`).

**3. Repositorio en GitHub:**
Sube tu carpeta del proyecto (que debe contener tus scripts, el archivo `.qmd` y los renders finales en HTML y PDF) a un repositorio p√∫blico en tu cuenta personal de **GitHub**.

* **Entrega:** Deber√°s enviar √∫nicamente el enlace (URL) a tu repositorio de GitHub para la calificaci√≥n.