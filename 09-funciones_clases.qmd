---
format:
  html: default
  pdf:
    screenshot: true  # <--- ESTO ES CLAVE
    # Opcionalmente, si falla, intenta:
    prefer-html: true    
    keep-tex: true
    mermaid-format: png
    include-in-header:
      - text: \usepackage{pdflscape}
---

# Funciones y Clases: El camino a la Modularizaci√≥n {#sec-funciones_clases}

## Funciones j_eval y j_plot en R

```{r}
#| label: j_eval_j_plot
#| code-fold: true
# #| include: false
source("./docs/j_eval_j_plot.r")
```

## Introducci√≥n

Hasta ahora, hemos escrito c√≥digo que se ejecuta de arriba hacia abajo, como una lista de mercado. Pero en proyectos reales de geom√°tica, necesitamos reutilizar l√≥gica. Si tienes un c√°lculo complejo para medir distancias o para valuar un predio, no quieres copiar y pegar ese c√≥digo cien veces.

Para eso existen las **funciones** (m√°quinas que procesan datos) y las **clases** (moldes para crear objetos complejos). En este cap√≠tulo aprender√°s a encapsular tu l√≥gica para que tu c√≥digo sea modular, limpio y f√°cil de mantener.

## Objetivos de aprendizaje

* Crear funciones reutilizables para automatizar c√°lculos espaciales recurrentes.
* Manejar par√°metros opcionales, valores por defecto y argumentos din√°micos.
* Entender los principios b√°sicos de la Programaci√≥n Orientada a Objetos (POO) para modelar elementos del mundo real.

## 1. Funciones: bloques de c√≥digo reutilizables

Una funci√≥n es como una receta de cocina: t√∫ le pasas los ingredientes (par√°metros de entrada), ella realiza un proceso interno (cuerpo de la funci√≥n) y te entrega un resultado (valor de retorno). 

Para ilustrar el poder de las funciones, vamos a construir tres herramientas fundamentales para cualquier analista espacial. Cada una nos ense√±ar√° un concepto nuevo de programaci√≥n:

1. **La calculadora matem√°tica (`haversine`):** Resolveremos el c√°lculo de la distancia entre dos ciudades. Como la Tierra no es plana, no podemos usar una simple l√≠nea recta (Pit√°goras). 
2. **El procesador por lotes (`medir_ruta`):** Crearemos una funci√≥n que reciba una lista completa de coordenadas, la recorra con un ciclo `for` y llame a nuestra primera funci√≥n (`haversine`) repetidas veces para medir los tramos de una ruta.
3. **El recolector din√°mico (`describir_punto`):** Crearemos una funci√≥n que use **argumentos din√°micos** (`**kwargs` en Python, `...` en R y `kwargs...` en Julia) para atrapar cualquier cantidad de variables extra (clima, poblaci√≥n, etc.) que el usuario decida enviarnos.



### La matem√°tica detr√°s de nuestra calculadora espacial

La **f√≥rmula de Haversine** calcula la distancia de c√≠rculo m√°ximo (*great-circle distance*) (@fig-great_circle) entre dos puntos en la superficie de una esfera, como la Tierra, a partir de sus coordenadas de latitud y longitud. La f√≥rmula tiene en cuenta la curvatura de la esfera, lo que la hace mucho m√°s precisa que una simple distancia euclidiana (l√≠nea recta) para aplicaciones geoespaciales.

![Distancia de C√≠rculo M√°ximo - f√≥rmula de Haversine](./images/great_circle_distance.png){#fig-great_circle width="60%" fig-align="center"}

Matem√°ticamente, adaptada a las variables de nuestro c√≥digo, la ecuaci√≥n general se ve as√≠:

$$distancia = 2 \cdot radio \cdot \arcsin\left(\sqrt{\sin^2\left(\frac{lat2 - lat1}{2}\right) + \cos(lat1) \cdot \cos(lat2) \cdot \sin^2\left(\frac{lon2 - lon1}{2}\right)}\right)$$

Donde:

* **$distancia$**: Distancia f√≠sica entre los dos puntos a lo largo de la curva de la esfera.
* **$radio$**: Radio de la esfera de referencia (para la Tierra, aproximadamente 6371.0 km).
* **$lat1$, $lat2$**: Latitudes del punto de origen y destino, estrictamente en radianes.
* **$lon1$, $lon2$**: Longitudes del punto de origen y destino, estrictamente en radianes.

*El truco del radio:* El c√°lculo trigonom√©trico interno solo produce un √°ngulo sin unidad f√≠sica (radianes). Para convertirlo en distancia real, lo multiplicamos por el radio de la Tierra. Si metemos el radio en kil√≥metros (6371.0), sale en kil√≥metros; si lo metemos en millas (3958.8), sale en millas. 

En programaci√≥n, solemos dividir esta gran f√≥rmula en partes m√°s peque√±as (las variables `dlat`, `dlon`, `a` y `c`) para facilitar la lectura del c√≥digo y evitar errores, reemplazando el $\arcsin$ por la funci√≥n `atan2` que es computacionalmente m√°s estable.

En la pr√°ctica, para que el computador procese esta gran ecuaci√≥n sin ahogarse (y para evitar errores de par√©ntesis), los programadores la dividen en tres pasos secuenciales usando las variables `a`, `c` y `distancia`:

1. **El ajuste esf√©rico ($a$):** Calcula el cuadrado de la mitad de la cuerda recta entre los dos puntos.
$$a = \sin^2\left(\frac{dlat}{2}\right) + \cos(lat1) \cdot \cos(lat2) \cdot \sin^2\left(\frac{dlon}{2}\right)$$

2. **El √°ngulo central ($c$):** Usa la funci√≥n arcotangente (`atan2`) para hallar el √°ngulo exacto en radianes desde el centro de la Tierra.
$$c = 2 \cdot \text{atan2}\left(\sqrt{a}, \sqrt{1 - a}\right)$$

3. **La distancia f√≠sica ($distancia$):** Convierte el √°ngulo en una longitud real multiplic√°ndolo por el radio.
$$distancia = radio \cdot c$$

::: {.callout-note}
### Nota t√©cnica: ¬øPor qu√© usamos atan2 en lugar de arcsin en el c√≥digo?
Si buscas la f√≥rmula matem√°tica cl√°sica de Haversine en un libro, notar√°s que utiliza la funci√≥n arcoseno ($\arcsin$). Sin embargo, en nuestro c√≥digo de programaci√≥n usamos la funci√≥n arcotangente (`atan2`). ¬øPor qu√© esta diferencia?

Todo se reduce a la **precisi√≥n computacional (punto flotante)**. Cuando dos coordenadas est√°n muy cerca la una de la otra, usar $\arcsin(\sqrt{a})$ puede generar imprecisiones severas de redondeo en el procesador. 

Para solucionarlo, la programaci√≥n aprovecha la trigonometr√≠a b√°sica ($\tan = \frac{\sin}{\cos}$) usando la funci√≥n `atan2(y, x)`:

* Sabiendo que $a = \sin^2$, entonces el seno (cateto opuesto, $y$) es $\sqrt{a}$.
* Por la regla pitag√≥rica ($\sin^2 + \cos^2 = 1$), el coseno (cateto adyacente, $x$) es $\sqrt{1 - a}$.

Al ingresar $c = 2 \cdot \text{atan2}\left(\sqrt{a}, \sqrt{1 - a}\right)$, obligamos al computador a calcular el √°ngulo exacto usando ambos lados del tri√°ngulo, garantizando mediciones perfectas ya sea que midamos la distancia entre dos continentes o entre dos pasos en la calle.
:::

Veamos c√≥mo se programan estas m√°quinas paso a paso, explicando cada l√≠nea de su funcionamiento:

::: {.panel-tabset}

### Python

::: {.content-visible when-format="html"}
::: {.callout-tip collapse="true" icon="false"}
#### ‚ñ∑ C√ìDIGO PURO (Copiar y Pegar)
```{python}
#| label: python_funciones_codigo
#| eval: false

# Importamos la librer√≠a matem√°tica nativa de Python para usar senos, cosenos y radianes
import math

# --- FUNCI√ìN 1: C√ÅLCULO MATEM√ÅTICO B√ÅSICO ---
def haversine(lat1, lon1, lat2, lon2, radio=6371.0):
    # RECIBE: 4 n√∫meros (lat/lon de dos puntos) y un radio opcional (por defecto 6371.0)
    
    # Convierte la diferencia de latitudes a radianes (el idioma de los computadores)
    dlat = math.radians(lat2 - lat1)
    
    # Convierte la diferencia de longitudes a radianes
    dlon = math.radians(lon2 - lon1)
    
    # Calcula 'a': el cuadrado de la mitad de la cuerda recta entre los puntos
    a = (math.sin(dlat / 2) ** 2 + 
         math.cos(math.radians(lat1)) * math.cos(math.radians(lat2)) * math.sin(dlon / 2) ** 2)
    
    # Calcula 'c': la distancia angular central usando la funci√≥n arcotangente (atan2)
    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))
    
    # SACA: La multiplicaci√≥n del √°ngulo por el radio, dando la distancia f√≠sica real
    return radio * c

print("--- C√°lculo de distancia simple ---")
# Ejecutamos la funci√≥n. Como no le damos el radio, usa el defecto en km.
distancia_km = haversine(4.6097, -74.0817, 6.2442, -75.5812)
print(f"Distancia Bogot√°-Medell√≠n: {distancia_km:.2f} km")

# Sobrescribimos el par√°metro 'radio' para obtener el resultado en millas (3958.8)
distancia_millas = haversine(4.6097, -74.0817, 6.2442, -75.5812, radio=3958.8)
print(f"Distancia en millas: {distancia_millas:.2f} mi")

# Aplicamos el "truco" matem√°tico: si le pasamos el radio en metros, el resultado sale en metros
distancia_metros = haversine(4.6097, -74.0817, 6.2442, -75.5812, radio=6371000.0)
print(f"Distancia en metros: {distancia_metros:.2f} m")


# --- FUNCI√ìN 2: PROCESADOR POR LOTES ---
def medir_ruta(lista_coords):
    # RECIBE: Una lista que contiene m√∫ltiples tuplas de coordenadas
    
    # Creamos una lista vac√≠a para ir guardando las distancias calculadas
    distancias_tramos = []
    
    # Iniciamos un ciclo que recorre la lista. Paramos un √≠ndice antes del final (- 1)
    # para no desbordar la lista cuando intentemos buscar el punto 'i + 1'
    for i in range(len(lista_coords) - 1):
        
        # Extraemos latitud y longitud del punto actual (donde estamos parados)
        lat1, lon1 = lista_coords[i]
        
        # Extraemos latitud y longitud del punto siguiente (hacia donde vamos)
        lat2, lon2 = lista_coords[i + 1]
        
        # Llamamos a nuestra funci√≥n 'haversine' para calcular la distancia de este tramo
        distancia_tramo = haversine(lat1, lon1, lat2, lon2)
        
        # Guardamos el resultado de este tramo en nuestra lista final
        distancias_tramos.append(distancia_tramo)
        
    # SACA: La lista completa con todas las distancias de los tramos calculados
    return distancias_tramos

# Definimos una ruta con 3 puntos (2 tramos)
ruta_colombiana = [(4.6097, -74.0817), (6.2442, -75.5812), (3.4516, -76.5320)]
# Ejecutamos nuestra funci√≥n procesadora
tramos = medir_ruta(ruta_colombiana)

print("\n--- Distancia por tramos en una ruta ---")
# Imprimimos la lista de resultados usando una comprensi√≥n de lista para redondear a 2 decimales
print(f"Tramos (km): {[round(d, 2) for d in tramos]}")


# --- FUNCI√ìN 3: RECOLECTOR DIN√ÅMICO ---
def describir_punto(lat, lon, **kwargs):
    # RECIBE: Latitud, longitud obligatorias, y un diccionario '**kwargs' con datos extra inventados
    
    # Iniciamos creando un texto base con las coordenadas obligatorias
    descripcion = f"Punto ({lat}, {lon})"
    
    # Iniciamos un ciclo para "abrir" el diccionario de par√°metros extra.
    # .items() nos separa el nombre de la variable (clave) y su contenido (valor)
    for clave, valor in kwargs.items():
        
        # Sumamos al texto base una barrita (|) seguida del nombre y valor del dato extra
        descripcion += f" | {clave}: {valor}"
        
    # SACA: Un solo texto largo que concatena toda la informaci√≥n del punto
    return descripcion

print("\n--- Creaci√≥n de atributos din√°micos ---")
# Ejecutamos enviando variables inventadas (ciudad, elevacion, costero, clima)
print(describir_punto(4.6097, -74.0817, ciudad="Bogot√°", elevacion=2640))
print(describir_punto(10.3997, -75.4795, ciudad="Cartagena", costero=True, clima="C√°lido"))
```
:::
:::

```{python}
#| label: python_funciones
# #| eval: false

# Importamos la librer√≠a matem√°tica nativa de Python para usar senos, cosenos y radianes
import math

# --- FUNCI√ìN 1: C√ÅLCULO MATEM√ÅTICO B√ÅSICO ---
def haversine(lat1, lon1, lat2, lon2, radio=6371.0):
    # RECIBE: 4 n√∫meros (lat/lon de dos puntos) y un radio opcional (por defecto 6371.0)
    
    # Convierte la diferencia de latitudes a radianes (el idioma de los computadores)
    dlat = math.radians(lat2 - lat1)
    
    # Convierte la diferencia de longitudes a radianes
    dlon = math.radians(lon2 - lon1)
    
    # Calcula 'a': el cuadrado de la mitad de la cuerda recta entre los puntos
    a = (math.sin(dlat / 2) ** 2 + 
         math.cos(math.radians(lat1)) * math.cos(math.radians(lat2)) * math.sin(dlon / 2) ** 2)
    
    # Calcula 'c': la distancia angular central usando la funci√≥n arcotangente (atan2)
    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))
    
    # SACA: La multiplicaci√≥n del √°ngulo por el radio, dando la distancia f√≠sica real
    return radio * c

print("--- C√°lculo de distancia simple ---")
# Ejecutamos la funci√≥n. Como no le damos el radio, usa el defecto en km.
distancia_km = haversine(4.6097, -74.0817, 6.2442, -75.5812)
print(f"Distancia Bogot√°-Medell√≠n: {distancia_km:.2f} km")

# Sobrescribimos el par√°metro 'radio' para obtener el resultado en millas (3958.8)
distancia_millas = haversine(4.6097, -74.0817, 6.2442, -75.5812, radio=3958.8)
print(f"Distancia en millas: {distancia_millas:.2f} mi")

# Aplicamos el "truco" matem√°tico: si le pasamos el radio en metros, el resultado sale en metros
distancia_metros = haversine(4.6097, -74.0817, 6.2442, -75.5812, radio=6371000.0)
print(f"Distancia en metros: {distancia_metros:.2f} m")


# --- FUNCI√ìN 2: PROCESADOR POR LOTES ---
def medir_ruta(lista_coords):
    # RECIBE: Una lista que contiene m√∫ltiples tuplas de coordenadas
    
    # Creamos una lista vac√≠a para ir guardando las distancias calculadas
    distancias_tramos = []
    
    # Iniciamos un ciclo que recorre la lista. Paramos un √≠ndice antes del final (- 1)
    # para no desbordar la lista cuando intentemos buscar el punto 'i + 1'
    for i in range(len(lista_coords) - 1):
        
        # Extraemos latitud y longitud del punto actual (donde estamos parados)
        lat1, lon1 = lista_coords[i]
        
        # Extraemos latitud y longitud del punto siguiente (hacia donde vamos)
        lat2, lon2 = lista_coords[i + 1]
        
        # Llamamos a nuestra funci√≥n 'haversine' para calcular la distancia de este tramo
        distancia_tramo = haversine(lat1, lon1, lat2, lon2)
        
        # Guardamos el resultado de este tramo en nuestra lista final
        distancias_tramos.append(distancia_tramo)
        
    # SACA: La lista completa con todas las distancias de los tramos calculados
    return distancias_tramos

# Definimos una ruta con 3 puntos (2 tramos)
ruta_colombiana = [(4.6097, -74.0817), (6.2442, -75.5812), (3.4516, -76.5320)]
# Ejecutamos nuestra funci√≥n procesadora
tramos = medir_ruta(ruta_colombiana)

print("\n--- Distancia por tramos en una ruta ---")
# Imprimimos la lista de resultados usando una comprensi√≥n de lista para redondear a 2 decimales
print(f"Tramos (km): {[round(d, 2) for d in tramos]}")


# --- FUNCI√ìN 3: RECOLECTOR DIN√ÅMICO ---
def describir_punto(lat, lon, **kwargs):
    # RECIBE: Latitud, longitud obligatorias, y un diccionario '**kwargs' con datos extra inventados
    
    # Iniciamos creando un texto base con las coordenadas obligatorias
    descripcion = f"Punto ({lat}, {lon})"
    
    # Iniciamos un ciclo para "abrir" el diccionario de par√°metros extra.
    # .items() nos separa el nombre de la variable (clave) y su contenido (valor)
    for clave, valor in kwargs.items():
        
        # Sumamos al texto base una barrita (|) seguida del nombre y valor del dato extra
        descripcion += f" | {clave}: {valor}"
        
    # SACA: Un solo texto largo que concatena toda la informaci√≥n del punto
    return descripcion

print("\n--- Creaci√≥n de atributos din√°micos ---")
# Ejecutamos enviando variables inventadas (ciudad, elevacion, costero, clima)
print(describir_punto(4.6097, -74.0817, ciudad="Bogot√°", elevacion=2640))
print(describir_punto(10.3997, -75.4795, ciudad="Cartagena", costero=True, clima="C√°lido"))
```

### R

::: {.content-visible when-format="html"}
::: {.callout-tip collapse="true" icon="false"}
#### ‚ñ∑ C√ìDIGO PURO (Copiar y Pegar)
```{r}
#| label: r_funciones_codigo
#| eval: false

# R no tiene una funci√≥n nativa directa para radianes, la creamos r√°pido
pasar_a_radianes <- function(grados) { 
    return(grados * pi / 180) 
}

# --- FUNCI√ìN 1: C√ÅLCULO MATEM√ÅTICO B√ÅSICO ---
haversine <- function(lat1, lon1, lat2, lon2, radio = 6371.0) {
    # RECIBE: 4 coordenadas decimales y un radio opcional (por defecto 6371.0)
    
    # Convierte la diferencia de latitudes a radianes llamando a nuestra mini-funci√≥n
    dlat <- pasar_a_radianes(lat2 - lat1)
    
    # Convierte la diferencia de longitudes a radianes
    dlon <- pasar_a_radianes(lon2 - lon1)
    
    # Calcula 'a': Ajuste trigonom√©trico esf√©rico
    a <- (sin(dlat / 2)^2 + 
          cos(pasar_a_radianes(lat1)) * cos(pasar_a_radianes(lat2)) * sin(dlon / 2)^2)
          
    # Calcula 'c': √Ångulo central en radianes usando arcotangente (atan2)
    c <- 2 * atan2(sqrt(a), sqrt(1 - a))
    
    # SACA: Multiplica el √°ngulo por el radio para darnos la distancia f√≠sica
    distancia <- radio * c
    return(distancia) 
}

cat("--- C√°lculo de distancia simple ---\n")
# Ejecutamos la funci√≥n usando el radio en kil√≥metros por defecto
distancia_km <- haversine(4.6097, -74.0817, 6.2442, -75.5812)
cat(sprintf("Distancia Bogot√°-Medell√≠n: %.2f km\n", distancia_km))

# Sobrescribimos el par√°metro 'radio' para obtener el resultado en millas (3958.8)
distancia_millas <- haversine(4.6097, -74.0817, 6.2442, -75.5812, radio = 3958.8)
cat(sprintf("Distancia en millas: %.2f mi\n", distancia_millas))

# Aplicamos el "truco" matem√°tico: si le pasamos el radio en metros, el resultado sale en metros
distancia_metros <- haversine(4.6097, -74.0817, 6.2442, -75.5812, radio = 6371000.0)
cat(sprintf("Distancia en metros: %.2f m\n", distancia_metros))


# --- FUNCI√ìN 2: PROCESADOR POR LOTES ---
medir_ruta <- function(lista_coords) {
    # RECIBE: Una lista de listas num√©ricas (coordenadas)
    
    # Creamos un vector num√©rico vac√≠o donde depositaremos las respuestas
    distancias_tramos <- c() 
    
    # Iniciamos el ciclo restando 1 al tama√±o total. Si no restamos 1, 
    # al final del ciclo R buscar√° el punto 'i + 1' que no existe y arrojar√° error.
    for (i in 1:(length(lista_coords) - 1)) {
        
        # Extraemos el punto actual (i)
        punto_a <- lista_coords[[i]]
        
        # Extraemos el punto siguiente (i+1)
        punto_b <- lista_coords[[i + 1]]
        
        # Llamamos a 'haversine' d√°ndole latitud y longitud de ambos puntos
        d <- haversine(punto_a[1], punto_a[2], punto_b[1], punto_b[2])
        
        # A√±adimos (concatenamos) la distancia reci√©n calculada a nuestro vector
        distancias_tramos <- c(distancias_tramos, d)
    }
    
    # SACA: El vector repleto con las distancias de todos los tramos
    return(distancias_tramos)
}

# Definimos una ruta con 3 puntos (2 tramos)
ruta_colombiana <- list(c(4.6097, -74.0817), c(6.2442, -75.5812), c(3.4516, -76.5320))
# Ejecutamos la funci√≥n
tramos <- medir_ruta(ruta_colombiana)

cat("\n--- Distancia por tramos en una ruta ---\n")
cat(sprintf("Tramos (km): %.2f, %.2f\n", tramos[1], tramos[2]))


# --- FUNCI√ìN 3: RECOLECTOR DIN√ÅMICO ---
describir_punto <- function(lat, lon, ...) {
    # RECIBE: lat, lon, y unos tres puntos (...) que atrapan variables extra nombradas
    
    # Creamos el texto base principal
    descripcion <- sprintf("Punto (%.4f, %.4f)", lat, lon)
    
    # Extraemos las variables atrapadas en los '...' y las metemos a una lista
    args_extra <- list(...)
    
    # Verificamos si la lista tiene datos (si el usuario envi√≥ algo extra)
    if (length(args_extra) > 0) {
        
        # Recorremos cada nombre de variable (clave) en la lista extra
        for (clave in names(args_extra)) {
            
            # Pegamos (paste0) la barra, la clave y su valor al texto original
            descripcion <- paste0(descripcion, sprintf(" | %s: %s", clave, args_extra[[clave]]))
        }
    }
    
    # SACA: El texto unificado
    return(descripcion)
}

cat("\n--- Creaci√≥n de atributos din√°micos ---\n")
# Pasamos las coordenadas y le inventamos datos (ciudad, elevacion, etc.)
cat(describir_punto(4.6097, -74.0817, ciudad="Bogot√°", elevacion=2640), "\n")
cat(describir_punto(10.3997, -75.4795, ciudad="Cartagena", costero=TRUE), "\n")
```
:::
:::

```{r}
#| label: r_funciones
# #| eval: false

# R no tiene una funci√≥n nativa directa para radianes, la creamos r√°pido
pasar_a_radianes <- function(grados) { 
    return(grados * pi / 180) 
}

# --- FUNCI√ìN 1: C√ÅLCULO MATEM√ÅTICO B√ÅSICO ---
haversine <- function(lat1, lon1, lat2, lon2, radio = 6371.0) {
    # RECIBE: 4 coordenadas decimales y un radio opcional (por defecto 6371.0)
    
    # Convierte la diferencia de latitudes a radianes llamando a nuestra mini-funci√≥n
    dlat <- pasar_a_radianes(lat2 - lat1)
    
    # Convierte la diferencia de longitudes a radianes
    dlon <- pasar_a_radianes(lon2 - lon1)
    
    # Calcula 'a': Ajuste trigonom√©trico esf√©rico
    a <- (sin(dlat / 2)^2 + 
          cos(pasar_a_radianes(lat1)) * cos(pasar_a_radianes(lat2)) * sin(dlon / 2)^2)
          
    # Calcula 'c': √Ångulo central en radianes usando arcotangente (atan2)
    c <- 2 * atan2(sqrt(a), sqrt(1 - a))
    
    # SACA: Multiplica el √°ngulo por el radio para darnos la distancia f√≠sica
    distancia <- radio * c
    return(distancia) 
}

cat("--- C√°lculo de distancia simple ---\n")
# Ejecutamos la funci√≥n usando el radio en kil√≥metros por defecto
distancia_km <- haversine(4.6097, -74.0817, 6.2442, -75.5812)
cat(sprintf("Distancia Bogot√°-Medell√≠n: %.2f km\n", distancia_km))

# Sobrescribimos el par√°metro 'radio' para obtener el resultado en millas (3958.8)
distancia_millas <- haversine(4.6097, -74.0817, 6.2442, -75.5812, radio = 3958.8)
cat(sprintf("Distancia en millas: %.2f mi\n", distancia_millas))

# Aplicamos el "truco" matem√°tico: si le pasamos el radio en metros, el resultado sale en metros
distancia_metros <- haversine(4.6097, -74.0817, 6.2442, -75.5812, radio = 6371000.0)
cat(sprintf("Distancia en metros: %.2f m\n", distancia_metros))


# --- FUNCI√ìN 2: PROCESADOR POR LOTES ---
medir_ruta <- function(lista_coords) {
    # RECIBE: Una lista de listas num√©ricas (coordenadas)
    
    # Creamos un vector num√©rico vac√≠o donde depositaremos las respuestas
    distancias_tramos <- c() 
    
    # Iniciamos el ciclo restando 1 al tama√±o total. Si no restamos 1, 
    # al final del ciclo R buscar√° el punto 'i + 1' que no existe y arrojar√° error.
    for (i in 1:(length(lista_coords) - 1)) {
        
        # Extraemos el punto actual (i)
        punto_a <- lista_coords[[i]]
        
        # Extraemos el punto siguiente (i+1)
        punto_b <- lista_coords[[i + 1]]
        
        # Llamamos a 'haversine' d√°ndole latitud y longitud de ambos puntos
        d <- haversine(punto_a[1], punto_a[2], punto_b[1], punto_b[2])
        
        # A√±adimos (concatenamos) la distancia reci√©n calculada a nuestro vector
        distancias_tramos <- c(distancias_tramos, d)
    }
    
    # SACA: El vector repleto con las distancias de todos los tramos
    return(distancias_tramos)
}

# Definimos una ruta con 3 puntos (2 tramos)
ruta_colombiana <- list(c(4.6097, -74.0817), c(6.2442, -75.5812), c(3.4516, -76.5320))
# Ejecutamos la funci√≥n
tramos <- medir_ruta(ruta_colombiana)

cat("\n--- Distancia por tramos en una ruta ---\n")
cat(sprintf("Tramos (km): %.2f, %.2f\n", tramos[1], tramos[2]))


# --- FUNCI√ìN 3: RECOLECTOR DIN√ÅMICO ---
describir_punto <- function(lat, lon, ...) {
    # RECIBE: lat, lon, y unos tres puntos (...) que atrapan variables extra nombradas
    
    # Creamos el texto base principal
    descripcion <- sprintf("Punto (%.4f, %.4f)", lat, lon)
    
    # Extraemos las variables atrapadas en los '...' y las metemos a una lista
    args_extra <- list(...)
    
    # Verificamos si la lista tiene datos (si el usuario envi√≥ algo extra)
    if (length(args_extra) > 0) {
        
        # Recorremos cada nombre de variable (clave) en la lista extra
        for (clave in names(args_extra)) {
            
            # Pegamos (paste0) la barra, la clave y su valor al texto original
            descripcion <- paste0(descripcion, sprintf(" | %s: %s", clave, args_extra[[clave]]))
        }
    }
    
    # SACA: El texto unificado
    return(descripcion)
}

cat("\n--- Creaci√≥n de atributos din√°micos ---\n")
# Pasamos las coordenadas y le inventamos datos (ciudad, elevacion, etc.)
cat(describir_punto(4.6097, -74.0817, ciudad="Bogot√°", elevacion=2640), "\n")
cat(describir_punto(10.3997, -75.4795, ciudad="Cartagena", costero=TRUE), "\n")
```

### Julia

::: {.content-visible when-format="html"}
::: {.callout-tip collapse="true" icon="false"}
#### ‚ñ∑ C√ìDIGO PURO (Copiar y Pegar)
```{julia}
#| label: julia_funciones_codigo
#| eval: false

# --- FUNCI√ìN 1: C√ÅLCULO MATEM√ÅTICO B√ÅSICO ---
# En Julia, los argumentos opcionales con nombre DEBEN ir despu√©s de un punto y coma (;)
function haversine(lat1, lon1, lat2, lon2; radio=6371.0)
    # RECIBE: 4 n√∫meros flotantes y un radio (por defecto en km)
    
    # Convierte la diferencia de latitudes a radianes con la funci√≥n nativa 'deg2rad'
    dlat = deg2rad(lat2 - lat1)
    
    # Convierte la diferencia de longitudes a radianes
    dlon = deg2rad(lon2 - lon1)
    
    # Calcula 'a': Ajuste esf√©rico para la Tierra
    a = (sin(dlat / 2)^2 + 
         cos(deg2rad(lat1)) * cos(deg2rad(lat2)) * sin(dlon / 2)^2)
         
    # Calcula 'c': √Ångulo central en radianes (Ojo: en Julia es solo 'atan', no 'atan2')
    c = 2 * atan(sqrt(a), sqrt(1 - a)) 
    
    # SACA: Multiplica el √°ngulo por el radio para la distancia real
    return radio * c
end

using Printf

println("--- C√°lculo de distancia simple ---")
# Ejecutamos con el radio por defecto (km)
distancia_km = haversine(4.6097, -74.0817, 6.2442, -75.5812)
@printf("Distancia Bogot√°-Medell√≠n: %.2f km\n", distancia_km)

# Sobrescribimos el par√°metro 'radio' para obtener el resultado en millas (3958.8)
distancia_millas = haversine(4.6097, -74.0817, 6.2442, -75.5812, radio=3958.8)
@printf("Distancia en millas: %.2f mi\n", distancia_millas)

# Aplicamos el "truco" matem√°tico: si le pasamos el radio en metros, el resultado sale en metros
distancia_metros = haversine(4.6097, -74.0817, 6.2442, -75.5812, radio=6371000.0)
@printf("Distancia en metros: %.2f m\n", distancia_metros)


# --- FUNCI√ìN 2: PROCESADOR POR LOTES ---
function medir_ruta(lista_coords)
    # RECIBE: Un arreglo con tuplas de coordenadas
    
    # Creamos un arreglo vac√≠o pero tipado (Float64) para que Julia procese m√°s r√°pido
    distancias_tramos = Float64[] 
    
    # Iniciamos el ciclo restando 1. Si no restamos 1, al final del ciclo
    # Julia intentar√° buscar el punto 'i + 1', el cual no existe, y colapsar√°.
    for i in 1:(length(lista_coords) - 1)
        
        # Extraemos coordenadas iniciales (i) y finales (i+1)
        lat1, lon1 = lista_coords[i]
        lat2, lon2 = lista_coords[i + 1]
        
        # Invocamos la funci√≥n 'haversine' y 'empujamos' (push!) el dato al arreglo final
        push!(distancias_tramos, haversine(lat1, lon1, lat2, lon2))
    end
    
    # SACA: Arreglo con las distancias parciales
    return distancias_tramos
end

# Definimos una ruta con 3 puntos (2 tramos)
ruta_colombiana = [(4.6097, -74.0817), (6.2442, -75.5812), (3.4516, -76.5320)]
# Ejecutamos la funci√≥n
tramos = medir_ruta(ruta_colombiana)

println("\n--- Distancia por tramos en una ruta ---")
@printf("Tramos (km): [%.2f, %.2f]\n", tramos[1], tramos[2])


# --- FUNCI√ìN 3: RECOLECTOR DIN√ÅMICO ---
# Usamos 'kwargs...' despu√©s del punto y coma (;) para atrapar variables extra con nombre
function describir_punto(lat, lon; kwargs...)
    # RECIBE: Coordenadas y una "bolsa" con par√°metros extra
    
    # Creamos la cadena de texto base
    descripcion = "Punto ($lat, $lon)"
    
    # Desempaquetamos la bolsa iterando sobre la clave (nombre de variable) y el valor
    for (clave, valor) in kwargs
        
        # En Julia el operador *= sirve para concatenarle m√°s texto a una cadena existente
        descripcion *= " | $clave: $valor"
    end
    
    # SACA: El texto concatenado
    return descripcion
end

println("\n--- Creaci√≥n de atributos din√°micos ---")
# Le mandamos variables extra (ciudad, elevacion, etc)
println(describir_punto(4.6097, -74.0817, ciudad="Bogot√°", elevacion=2640))
println(describir_punto(10.3997, -75.4795, ciudad="Cartagena", costero=true))
```
:::
:::

```{r}
#| label: julia_funciones
#| results: asis
#| code-fold: true
# #| eval: false
j_eval(r"-(
# --- FUNCI√ìN 1: C√ÅLCULO MATEM√ÅTICO B√ÅSICO ---
# En Julia, los argumentos opcionales con nombre DEBEN ir despu√©s de un punto y coma (;)
function haversine(lat1, lon1, lat2, lon2; radio=6371.0)
    # RECIBE: 4 n√∫meros flotantes y un radio (por defecto en km)
    
    # Convierte la diferencia de latitudes a radianes con la funci√≥n nativa 'deg2rad'
    dlat = deg2rad(lat2 - lat1)
    
    # Convierte la diferencia de longitudes a radianes
    dlon = deg2rad(lon2 - lon1)
    
    # Calcula 'a': Ajuste esf√©rico para la Tierra
    a = (sin(dlat / 2)^2 + 
         cos(deg2rad(lat1)) * cos(deg2rad(lat2)) * sin(dlon / 2)^2)
         
    # Calcula 'c': √Ångulo central en radianes (Ojo: en Julia es solo 'atan', no 'atan2')
    c = 2 * atan(sqrt(a), sqrt(1 - a)) 
    
    # SACA: Multiplica el √°ngulo por el radio para la distancia real
    return radio * c
end

using Printf

println("--- C√°lculo de distancia simple ---")
# Ejecutamos con el radio por defecto (km)
distancia_km = haversine(4.6097, -74.0817, 6.2442, -75.5812)
@printf("Distancia Bogot√°-Medell√≠n: %.2f km\n", distancia_km)

# Sobrescribimos el par√°metro 'radio' para obtener el resultado en millas (3958.8)
distancia_millas = haversine(4.6097, -74.0817, 6.2442, -75.5812, radio=3958.8)
@printf("Distancia en millas: %.2f mi\n", distancia_millas)

# Aplicamos el "truco" matem√°tico: si le pasamos el radio en metros, el resultado sale en metros
distancia_metros = haversine(4.6097, -74.0817, 6.2442, -75.5812, radio=6371000.0)
@printf("Distancia en metros: %.2f m\n", distancia_metros)


# --- FUNCI√ìN 2: PROCESADOR POR LOTES ---
function medir_ruta(lista_coords)
    # RECIBE: Un arreglo con tuplas de coordenadas
    
    # Creamos un arreglo vac√≠o pero tipado (Float64) para que Julia procese m√°s r√°pido
    distancias_tramos = Float64[] 
    
    # Iniciamos el ciclo restando 1. Si no restamos 1, al final del ciclo
    # Julia intentar√° buscar el punto 'i + 1', el cual no existe, y colapsar√°.
    for i in 1:(length(lista_coords) - 1)
        
        # Extraemos coordenadas iniciales (i) y finales (i+1)
        lat1, lon1 = lista_coords[i]
        lat2, lon2 = lista_coords[i + 1]
        
        # Invocamos la funci√≥n 'haversine' y 'empujamos' (push!) el dato al arreglo final
        push!(distancias_tramos, haversine(lat1, lon1, lat2, lon2))
    end
    
    # SACA: Arreglo con las distancias parciales
    return distancias_tramos
end

# Definimos una ruta con 3 puntos (2 tramos)
ruta_colombiana = [(4.6097, -74.0817), (6.2442, -75.5812), (3.4516, -76.5320)]
# Ejecutamos la funci√≥n
tramos = medir_ruta(ruta_colombiana)

println("\n--- Distancia por tramos en una ruta ---")
@printf("Tramos (km): [%.2f, %.2f]\n", tramos[1], tramos[2])


# --- FUNCI√ìN 3: RECOLECTOR DIN√ÅMICO ---
# Usamos 'kwargs...' despu√©s del punto y coma (;) para atrapar variables extra con nombre
function describir_punto(lat, lon; kwargs...)
    # RECIBE: Coordenadas y una "bolsa" con par√°metros extra
    
    # Creamos la cadena de texto base
    descripcion = "Punto ($lat, $lon)"
    
    # Desempaquetamos la bolsa iterando sobre la clave (nombre de variable) y el valor
    for (clave, valor) in kwargs
        
        # En Julia el operador *= sirve para concatenarle m√°s texto a una cadena existente
        descripcion *= " | $clave: $valor"
    end
    
    # SACA: El texto concatenado
    return descripcion
end

println("\n--- Creaci√≥n de atributos din√°micos ---")
# Le mandamos variables extra (ciudad, elevacion, etc)
println(describir_punto(4.6097, -74.0817, ciudad="Bogot√°", elevacion=2640))
println(describir_punto(10.3997, -75.4795, ciudad="Cartagena", costero=true))
)-")
```

:::

### Resumen de sintaxis: estructura de funciones

| Caracter√≠stica | Python | R | Julia |
| :--- | :--- | :--- | :--- |
| **Declaraci√≥n** | `def calc(x):` | `calc <- function(x) { }` | `function calc(x) ... end` |
| **Retorno** | `return y` | `return(y)` | `return y` |
| **Par√°metro x defecto** | `def calc(r=6371):` | `function(r=6371)` | `function calc(; r=6371)` |
| **M√∫ltiples args extra**| `**kwargs` | `...` | `kwargs...` |

: Diferencias en el empaquetado y argumentos de funciones {#tbl-funciones_argumentos tbl-colwidths="[25,25,25,25]"}


## 2. Clases: organizando datos y comportamiento juntos

En el mundo del desarrollo de software, existen diferentes formas de estructurar el c√≥digo. Tradicionalmente, la programaci√≥n separaba los datos por un lado y las funciones que operaban sobre esos datos por el otro. Sin embargo, la **Programaci√≥n Orientada a Objetos (POO)** propone un paradigma distinto: agrupar los datos y los comportamientos relacionados en una sola entidad unificada.

Para dominar este paradigma, primero debemos entender sus conceptos gen√©ricos fundamentales:

* **Clase:** Es el plano, la plantilla o el molde abstracto. No contiene datos reales, sino que define qu√© estructura tendr√°n los datos y qu√© acciones se podr√°n realizar.
* **Objeto (o instancia):** Es la materializaci√≥n de la clase. Es el producto final creado a partir del molde, que ocupa un espacio real en la memoria de la computadora y contiene datos espec√≠ficos.
* **Atributos (o estado):** Son las variables internas que guardan las caracter√≠sticas √∫nicas de cada objeto.
* **M√©todos (o comportamiento):** Son las funciones que viven dentro (o asociadas) al objeto. Definen lo que el objeto "sabe hacer" con sus propios datos.
* **Constructor:** Es la puerta de entrada. Es el mecanismo inicial que toma los datos crudos y los ensambla siguiendo las reglas de la clase para dar vida a un nuevo objeto.

### Analog√≠a entre clases/objetos y moldes/arepas

* **La Clase (el molde):** Es como el plano arquitect√≥nico de una casa o el molde para hacer arepas. El molde define que toda arepa tendr√° un grosor y un di√°metro, pero el molde en s√≠ no se puede comer.
* **El Objeto (la instancia):** Es la arepa ya hecha, salida del molde. Puedes sacar mil arepas distintas (unas de queso, otras de carne) usando el mismo molde. Todas comparten la misma estructura, pero contienen datos (rellenos) diferentes.


### El reto: de simples n√∫meros a entidades inteligentes

En el an√°lisis de datos espaciales, solemos trabajar con coordenadas crudas (simples pares de n√∫meros). Si los dejamos sueltos, son solo texto sin significado. Nuestro objetivo en este ejercicio es aplicar los conceptos de la POO para tomar esos n√∫meros y "darles vida".

Queremos tomar dos simples coordenadas geogr√°ficas y convertirlas en un **Objeto Espacial Inteligente** que tenga la capacidad intr√≠nseca de realizar tres tareas fundamentales:

1.  **Representarse a s√≠ mismo (Texto):** Que el objeto pueda decirnos su nombre y ubicaci√≥n en un formato legible para humanos.
2.  **Anal√≠tica espacial (Matem√°ticas):** Que el objeto tenga la capacidad de calcular la distancia hacia otro punto.
3.  **Visualizaci√≥n (Gr√°ficos):** Que el objeto, al recibir un punto de destino, sepa c√≥mo dibujar un mapa interactivo mostrando la ruta y la distancia entre ambos.

A continuaci√≥n, ilustramos conceptualmente este flujo de transformaci√≥n:

::: {.content-visible when-format="html"}
```{mermaid}
%%| label: fig-flujo-conceptual
%%| fig-cap: "Flujo conceptual: Transformaci√≥n de datos crudos en un objeto inteligente con capacidades."
%%| fig-width: 6
%%| out-width: 100%
%%| fig-align: center

flowchart LR
    %% ESTILOS
    classDef raw fill:#FDEBD0,stroke:#F39C12,stroke-width:2px,color:#7E5109,font-size:15px,padding:10px
    classDef obj fill:#E8F8F5,stroke:#2ECC71,stroke-width:3px,color:#145A32,font-size:14px,font-weight:bold,padding:15px
    classDef objSmall fill:#E8F8F5,stroke:#2ECC71,stroke-width:2px,color:#145A32,font-size:14px,font-weight:bold,padding:8px,stroke-dasharray: 4 4
    classDef action fill:#EAEDED,stroke:#34495E,stroke-width:2px,color:#2C3E50,font-size:14px,text-align:left

    %% NODOS DE ORIGEN (PUNTO 1)
    DATOS1["üìÑ Datos Crudos 1<br/>(Origen)"]:::raw
    OBJETO["üìç Objeto Inteligente<br/>(Origen)"]:::obj

    %% NODOS DE DESTINO (PUNTO 2)
    DATOS2["üìÑ Datos Crudos 2<br/>(Destino)"]:::raw
    DESTINO["üìç Otro Objeto Punto<br/>(Destino)"]:::objSmall

    %% PROCESOS DE INSTANCIACI√ìN
    DATOS1 -- "‚öôÔ∏è Instanciaci√≥n" --> OBJETO
    DATOS2 -- "‚öôÔ∏è Instanciaci√≥n" --> DESTINO

    %% ACCI√ìN A (Interna del objeto)
    OBJETO --> A["üí¨ a) Imprimirse en texto"]:::action

    %% ACCIONES B y C (Interacci√≥n entre objetos)
    OBJETO --> B["üìè b) Medir distancia (num√©rica)"]:::action
    OBJETO --> C["üó∫Ô∏èüìè c) Mapa con l√≠nea de distancia"]:::action

    %% EL DESTINO ENTRA COMO ARGUMENTO A LAS ACCIONES DEL ORIGEN
    DESTINO -.->|Entrada| B
    DESTINO -.->|Entrada| C
```

:::

::: {.content-visible when-format="pdf"}
![Flujo conceptual: Transformaci√≥n de datos crudos en un objeto inteligente con capacidades.](./images/ejercicio_clases.png){#fig-flujo-conceptual}
:::


En esta secci√≥n, crearemos una Clase llamada `PuntoEspacial`. Este "molde" le ense√±ar√° a la computadora cuatro cosas fundamentales:


### Python y la Programaci√≥n Orientada a Objetos (OOP)

En Python, la creaci√≥n de estructuras de datos y su comportamiento sigue un enfoque cl√°sico y estricto de **Programaci√≥n Orientada a Objetos (OOP)**. A diferencia de otros lenguajes donde los datos y las funciones operan por separado, Python prefiere encapsularlo todo (el estado y las acciones) dentro de una √∫nica fortaleza l√≥gica: **La Clase**.

::: {.callout-tip title="La Analog√≠a: El Molde y la Arepa"}
Para visualizar c√≥mo Python maneja la memoria, imaginemos una cocina:

* **La Clase (`class PuntoEspacial`):** Es el **molde de hierro**. Por s√≠ solo no contiene ingredientes ni alimenta a nadie; es simplemente un dise√±o est√°tico que dicta la estructura geom√©trica, qu√© datos son obligatorios y qu√© acciones se pueden realizar.
* **El Objeto (La Instancia):** Es la **arepa f√≠sica y calientita**. Cuando pasamos ingredientes reales (latitud, longitud, nombre) a trav√©s del molde, el computador reserva un espacio en memoria para crear una instancia concreta y √∫nica. Podemos sacar mil "arepas" (objetos) del mismo molde, y cada una tendr√° sus propios datos independientes.
:::

*Como ilustra la siguiente figura, en Python el paradigma es encapsulado: el objeto nace con sus datos y sus herramientas listas para usar.*

![**El paradigma de Python (POO Cl√°sica):** La Clase act√∫a como una f√°brica o molde que estampa objetos. Cada objeto (la arepa) no solo contiene datos, sino que lleva incrustadas sus propias herramientas y m√©todos (como la navaja suiza o la calculadora) para resolver problemas por s√≠ mismo.](./images/python_classes_analogy.png){#fig-analogia-python fig-align="center" width="50%"}

#### La anatom√≠a del molde

Cuando dise√±amos una clase en Python, establecemos un contrato estricto con la m√°quina a trav√©s de m√©todos m√°gicos y atributos:

1.  **El Constructor (`__init__`):** Es la puerta de entrada. Cada vez que intentamos crear un objeto nuevo, Python llama autom√°ticamente a esta funci√≥n para recibir los par√°metros iniciales y "ensamblar" la estructura en la memoria.
2.  **El Auto-reconocimiento (`self`):** En Python, la clase necesita una forma de referirse a la "arepa" espec√≠fica que est√° cocinando en ese momento. El par√°metro `self` es ese ancla; garantiza que si modificamos la latitud del "Punto A", no estropeemos accidentalmente la latitud del "Punto B".
3.  **La representaci√≥n (`__str__`):** C√≥mo debe presentarse el objeto si intentamos imprimirlo en pantalla.
4.  **Los M√©todos (Comportamiento):** Son las funciones que viven **dentro** de la clase. Una vez instanciado el objeto, este carga consigo mismo todas sus herramientas. Un punto espacial en Python "sabe" c√≥mo calcular su propia distancia hacia otro punto o c√≥mo graficarse a s√≠ mismo en un mapa.

    * **Los m√©todos anal√≠ticos (`distancia_hacia`):** Funciones que viven *dentro* del objeto. Nuestro punto ser√° tan inteligente que sabr√° calcular la distancia hacia otro punto por s√≠ mismo, invocando internamente a la funci√≥n `haversine` que programamos en la secci√≥n anterior. Adem√°s, le agregaremos un par√°metro din√°mico para que pueda devolver la distancia en **metros** si se lo pedimos.
    * **El m√©todo gr√°fico (`graficar_ruta`):** Un m√©todo que le permite al objeto usar una librer√≠a cartogr√°fica para dibujarse a s√≠ mismo en un mapa base. Adem√°s, usaremos nuestro m√©todo anal√≠tico para calcular el punto medio y ¬°escribir la distancia calculada directamente sobre la l√≠nea de la ruta!

A continuaci√≥n, visualizamos este ciclo de vida completo: primero, el diagrama estructural del molde (la Clase) y sus m√©todos internos; y luego, el mapa de ejecuci√≥n que muestra c√≥mo sacamos las instancias (Objetos) a la memoria para interactuar con ellas.

::: {.content-visible when-format="html"}

```{r}
#| label: fig-clases-python-final-vertical3
#| fig-cap: "Diagrama del flujo de instanciaci√≥n: El molde (Clase) y las arepas (Objetos)."
#| results: asis
#| echo: false
#| out-width: "100%"
#| fig-width: 7

mermaid_code <- c(
  "%%{init: {\"flowchart\": {\"nodeSpacing\": -90, \"rankSpacing\": -90, \"useMaxWidth\": true}}}%%",
  "flowchart TB",
  "    %% ESTILOS",
  "    classDef num fill:#E67E22,color:#FFF,stroke:none,font-weight:bold,font-size:16px",
  "    classDef codeBox fill:#EAEDED,color:#2C3E50,stroke:#34495E,stroke-width:2px",
  "    classDef light fill:#E8F8F5,color:#145A32,stroke:#2ECC71,stroke-width:2px,font-size:16px",
  "    classDef light2 fill:#E8F8F5,color:#145A32,stroke:#2ECC71,stroke-width:2px,font-size:16px,white-space:nowrap,width:300px,padding:0px",
  "    classDef input fill:#FDEBD0,color:#7E5109,stroke:#F39C12,stroke-width:2px,font-size:16px",
  "    classDef box fill:none,stroke:#3498DB,stroke-width:3px,stroke-dasharray: 5 5",
  "    classDef giantPin fill:none,stroke:none,font-size:50px",
  "    classDef extNode fill:#EBDEF0,color:#512E5F,stroke:#8E44AD,stroke-width:2px,font-size:14px,text-align:center,text-align:left,white-space:nowrap,width:300px,padding:0px",
  "    classDef codeBoxLeft1 fill:#EAEDED,color:#2C3E50,stroke:#34495E,stroke-width:2px,text-align:left,white-space:nowrap,width:300px,padding:0px",
  "    classDef codeBoxLeft2 fill:#EAEDED,color:#2C3E50,stroke:#34495E,stroke-width:2px,text-align:left,white-space:nowrap,width:365px,padding:0px",
  "    classDef codeBoxLeft3 fill:#EAEDED,color:#2C3E50,stroke:#34495E,stroke-width:2px,text-align:left,white-space:nowrap,width:350px,padding:0px",
  "    classDef codeBoxLeft4 fill:#EAEDED,color:#2C3E50,stroke:#34495E,stroke-width:2px,text-align:left,white-space:nowrap,width:260px,padding:0px",
  "    classDef classTitle fill:none,color:#2C3E50,stroke:none,font-weight:bold,font-size:18px",
  "    classDef piso fill:#EAEDED,stroke:transparent,color:transparent,stroke-width:0px",
  "    classDef colchon fill:#EAEDED,stroke:#34495E,height:0px,width:0px",
  "",
  "    %% BLOQUE SUPERIOR",
  "    subgraph SUPERIOR [\" \"]",
  "        direction LR",
  "        style SUPERIOR fill:none,stroke:none",
  "",
  "        ENTRADA[\"üìÑ&nbsp;Entrada:<br/>y,&nbsp;x,&nbsp;'nb'<br/><br/>üìÑ&nbsp;Entrada especial:<br/>y,&nbsp;x\"]:::input",
  "",
  "        subgraph CLASE [\"(El&nbsp;Molde&nbsp;de&nbsp;Arepas)&nbsp;üì¶\"]",
  "            direction TB",
  "            ",
  "            CERO[\"                          class PuntoEspacial:                     \"]:::classTitle",
  "",
  "            n1((\"1 üìç\")):::num",
  "            m1[\"def __init__(self, lt, lg, nb='no name')<br/>&emsp;self.lt = lt<br/>&emsp;self.lg = lg<br/>&emsp;self.nb = nb\"]:::codeBoxLeft1",
  "            PIN[\"üìç\"]:::giantPin",
  "            r1[\"üìçself (La Arepa ü´ì)\"]:::light",
  "",
  "            n2((\"2 üí¨\")):::num",
  "            m2[\"def __str__(self):<br/>&emsp;return f'[{self.nb}] (Lat: {self.lt}, Lon: {self.lg})'\"]:::codeBoxLeft2",
  "            r2[\"üí¨ '[nb] (Lat: lt, Lon: lg)'\"]:::light",
  "            ",
  "            n3((\"3 üìê\")):::num",
  "            m3[\"def distancia_hacia(self, p2, r):<br/>&emsp;d = haversine(self.lt, self.lg, p2.lt, p2.lg, r)\"]:::codeBoxLeft3",
  "",
  "            r3[\"km = p1.distancia_hacia(p2) ‚û°Ô∏è 242.5 km\"]:::light2",
  "            ",
  "            n4((\"4 üó∫Ô∏èüìê\")):::num",
  "            m4[\"def graficar_ruta(self, p2):<br/>&emsp;d = self.distancia_hacia(p2)<br/>&emsp;mapa = folium.Map(...)\"]:::codeBoxLeft4",
  "            r4[\"üó∫Ô∏è Mapa interactivo<br/>(folium)\"]:::light",
  "            ",
  "            CERO ~~~ n1",
  "            n1 --- m1",
  "            m1 --> PIN",
  "            PIN --> r1",
  "            r1 --> n2",
  "            n2 --- m2",
  "            m2 --> r2",
  "            r2 ~~~ n3",
  "            n3 --- m3",
  "            m3 --> r3",
  "            r3 ~~~ n4",
  "            n4 --- m4",
  "            m4 --> r4",
  "        end",
  "",
  "        ENTRADA ==>|'    Instanciaci√≥n    '| CLASE",
  "        class CLASE box",
  "",
  "        %% CONTENEDOR VERTICAL PARA LOS ACCESORIOS DE LA DERECHA",
  "        subgraph DERECHA [\" \"]",
  "            direction TB",
  "            style DERECHA fill:none,stroke:none",
  "",
  "            subgraph EXTERNO[\" \"]",
  "                direction TB",
  "                HAVERSINE[\"‚öôÔ∏è&nbsp;Funci√≥n&nbsp;externa:<br/>def&nbsp;haversine(lt1, lg1, lt2, lg2, r=6371):<br/>&emsp;...\"]:::extNode",
  "            end",
  "            style EXTERNO fill:none,stroke:none",
  "",
  "            subgraph SEPARADOR[\" \"]",
  "                direction TB",
  "                SEP[\" \"]:::colchon",
  "            end",
  "            style SEPARADOR fill:none,stroke:none",
  "",
  "            subgraph LEYENDA [\"üìã&nbsp;Leyenda Python\"]",
  "                direction TB",
  "                l1((\"1 üìç\")) --- t1[\"Constructor\"]",
  "                t1 ~~~ l3((\"3 üìê\")) ",
  "                l3 --- t3[\"M√©todo Anal√≠tico\"]",
  "                l2((\"2 üí¨\")) ",
  "                l2 --- t2[\"Representaci√≥n\"]",
  "                t2 ~~~ l4((\"4 üó∫Ô∏èüìê\")) ",
  "                l4 --- t4[\"M√©todo Gr√°fico\"]",
  "            end",
  "            style LEYENDA fill:#FCF3CF,stroke:#D4AC0D,stroke-width:2px,color:#1A1A1A",
  "            ",
  "        end",
  "        ",
  "        CLASE .->|3 invoca| HAVERSINE",
  "        CLASE .->|4 invoca 3, 3 invoca| HAVERSINE",
  "        CLASE ~~~ DERECHA",
  "    end"
)

cat("```{mermaid}\n")
writeLines(mermaid_code)
cat("```\n")
```

:::

::: {.content-visible when-format="pdf"}
![Diagrama del flujo de instanciaci√≥n: El molde (Clase) y las arepas (Objetos).](./images/clase_python.png){#fig-clases-python-final-vertical}
:::


Resumen del c√≥digo necesario para crear una clase en Python:

```{python}
#| label: python_clases_codigo_resumen
#| eval: false

# --- 1. DEFINICI√ìN DEL MOLDE (LA CLASE) ---
class PuntoEspacial:

    # [1 üìç] 1.1 EL CONSTRUCTOR (__init__)
    def __init__(self, ...):
        ...

    # [2 üí¨] 1.2 LA REPRESENTACI√ìN TEXTUAL (__str__)
    def __str__(self):
        ...

    # [3 üìê] 1.3 LOS M√âTODOS (COMPORTAMIENTO ANAL√çTICO)
    def distancia_hacia(self, ...):
        ...

    # [4 üó∫Ô∏èüìê] 1.4 EL M√âTODO GR√ÅFICO (MAPA BASE CON ETIQUETA VISIBLE)
    def graficar_ruta(self, otro_punto):
        ...        
```

::: {.content-visible when-format="html"}
```{mermaid}
%%| label: fig-clases-python-codigo
%%| fig-cap: "Ejecuci√≥n del c√≥digo en Python instanciando los objetos en memoria."
%%| out-width: 50%
%%| fig-align: center

flowchart LR
    classDef scriptBox fill:#FFFFFF,color:#000000,stroke:#333333,stroke-width:2px,text-align:left,font-family:monospace,font-size:12px,white-space:nowrap,padding:0px
    
    %% Usamos el s√≠mbolo Unicode ÔºÉ en lugar del numeral de teclado #
    SCRIPT["ÔºÉ --- EJECUCI√ìN DEL C√ìDIGO ---<br/><br/>ÔºÉ [1 üìç] INSTANCIACI√ìN: Sacando arepas del molde<br/>punto_origen = PuntoEspacial(4.6097, -74.0817, 'Bogot√°')      ÔºÉ ü´ì Arepa 1<br/>punto_destino = PuntoEspacial(6.2442, -75.5812, 'Medell√≠n')   ÔºÉ ü´ì Arepa 2<br/>punto_misterioso = PuntoEspacial(12.5847, -81.7006)           ÔºÉ ü´ì Arepa Especial 3<br/><br/>ÔºÉ [2 üí¨] REPRESENTACI√ìN: Ver los objetos<br/>print(punto_origen)<br/>print(punto_destino)<br/>print(punto_misterioso)<br/><br/>ÔºÉ [3 üìê] M√âTODOS ANAL√çTICOS: Uso de la m√°quina matem√°tica interna<br/>resultado_km = punto_origen.distancia_hacia(punto_destino)<br/>resultado_metros = punto_origen.distancia_hacia(punto_destino, radio=6371000.0)<br/><br/>ÔºÉ [4 üó∫Ô∏èüìê] M√âTODO GR√ÅFICO: Mapas generados por el objeto<br/>mapa_final = punto_origen.graficar_ruta(punto_destino)"]:::scriptBox
```


:::

::: {.content-visible when-format="pdf"}
![Ejecuci√≥n del c√≥digo instanciando los objetos en memoria.](./images/clase_python_codigo.png){#fig-clases-python-codigo}
:::

### R y el sistema S3: la ilusi√≥n del molde y el poder de la etiqueta

Mientras que Python utiliza un enfoque estricto donde cada objeto nace de un "molde de hierro" predefinido, R aborda la programaci√≥n orientada a objetos de una manera mucho m√°s relajada e informal, principalmente a trav√©s de su **sistema S3**.

En R, las clases no se definen formalmente. No hay una b√≥veda blindada que encierre los datos y los m√©todos juntos. En su lugar, el sistema S3 conf√≠a en el "sistema de honor" y en el uso inteligente de etiquetas.

::: {.callout-note title="La analog√≠a: el recipiente com√∫n y el post-it"}
Si en Python ten√≠amos un molde de hierro para hacer arepas, en R la cocina funciona muy distinto:

* **Los ingredientes (la lista):** En lugar de un molde, tomamos un recipiente pl√°stico com√∫n y corriente (como el "porta" del almuerzo o una `list` en R), y echamos ah√≠ nuestros ingredientes crudos (latitud, longitud y nombre).
* **La "clase" (el post-it):** Para convertir esa lista gen√©rica en un objeto espacial, literalmente le pegamos un "post-it" en la tapa del recipiente. Al asignarle un atributo de clase (`class(objeto) <- 'PuntoEspacial'`), le estamos diciendo a R: *"De ahora en adelante, conf√≠a en m√≠ y trata a este recipiente como si fuera una arepa"*.
:::

*En R, el sistema es mucho m√°s flexible e informal, dependiendo enteramente de c√≥mo etiquetamos nuestros contenedores de datos:*

![**El paradigma de R (Sistema S3):** Los objetos no tienen herramientas por dentro; son contenedores pl√°sticos est√°ndar (listas) llenos de datos crudos. Lo que les da "poder" es una simple etiqueta o post-it (la Clase S3). Las funciones externas act√∫an como inspectores que leen esta etiqueta para decidir qu√© herramienta usar.](./images/r_classes_analogy.png){#fig-analogia-r fig-align="center" width="50%"}

#### La anatom√≠a del sistema S3

Dado que no hay un "molde" real, la instanciaci√≥n y el comportamiento en R se dividen en tres pilares fundamentales que flotan libremente en el entorno:

1.  **El constructor informal:** Es simplemente una funci√≥n normal (como `nuevo_punto_espacial()`) que recibe los datos, los empaqueta en una lista y, lo m√°s importante, le estampa la etiqueta de la clase antes de devolverla.
2.  **Las funciones gen√©ricas (los inspectores):** Funciones como `print()` o `distancia_hacia()` son gen√©ricas. No saben c√≥mo calcular nada por s√≠ mismas; su √∫nico trabajo es mirar el "post-it" del objeto que reciben y decir: *"Ah, eres un PuntoEspacial, d√©jame buscar al experto que sabe tratar contigo"*. Esto se logra mediante el comando interno `UseMethod()`.
3.  **Los m√©todos espec√≠ficos (el despacho):** Son las funciones que realmente hacen el trabajo duro, y se nombran uniendo el gen√©rico y la clase (por ejemplo, `distancia_hacia.PuntoEspacial()`). El gen√©rico le "despacha" el objeto a esta funci√≥n especializada.

A continuaci√≥n, visualizamos este paradigma en acci√≥n: primero, el diagrama arquitect√≥nico que muestra c√≥mo los m√©todos flotan fuera de la estructura de datos; y luego, el bloque de ejecuci√≥n donde vemos la magia del etiquetado y el despacho S3 en tiempo real.

::: {.content-visible when-format="html"}
```{mermaid}
%%| label: fig-clases-r-final-vertical
%%| fig-cap: "Diagrama del flujo de instanciaci√≥n en R (S3): El molde y las arepas."
%%| fig-width: 6
%%| out-width: 20%
%%| fig-align: center

%% COMPRESI√ìN TOTAL: La misma f√≥rmula maestra de Python
%%{init: {"flowchart": {"nodeSpacing": -60, "rankSpacing": -60}}}%%

flowchart TB
    %% ESTILOS ADAPTADOS A R
    classDef num fill:#E67E22,color:#FFF,stroke:none,font-weight:bold,font-size:16px
    classDef codeBox fill:#EAEDED,color:#2C3E50,stroke:#34495E,stroke-width:2px
    classDef light fill:#E8F8F5,color:#145A32,stroke:#2ECC71,stroke-width:2px,font-size:16px
    classDef light2 fill:#E8F8F5,color:#145A32,stroke:#2ECC71,stroke-width:2px,font-size:16px,white-space:nowrap,width:320px,padding:0px    
    classDef input fill:#FDEBD0,color:#7E5109,stroke:#F39C12,stroke-width:2px,font-size:16px
    %%classDef box fill:none,stroke:#3498DB,stroke-width:3px,stroke-dasharray: 5 5
    classDef box fill:none,stroke:#3498DB,stroke-width:3px,stroke-dasharray: 10 30
    classDef giantPin fill:none,stroke:none,font-size:50px
    classDef extNode fill:#EBDEF0,color:#512E5F,stroke:#8E44AD,stroke-width:2px,font-size:14px,text-align:left,white-space:nowrap,width:360px,padding:0px
    
    %% ANCHOS ESCULPIDOS PARA LA SINTAXIS S3 (UseMethod ocupa m√°s espacio)
    classDef codeBoxLeft1 fill:#EAEDED,color:#2C3E50,stroke:#34495E,stroke-width:2px,text-align:left,white-space:nowrap,width:440px,padding:0px
    classDef codeBoxLeft2 fill:#EAEDED,color:#2C3E50,stroke:#34495E,stroke-width:2px,text-align:left,white-space:nowrap,width:440px,padding:0px
    classDef codeBoxLeft3 fill:#EAEDED,color:#2C3E50,stroke:#34495E,stroke-width:2px,text-align:left,white-space:nowrap,width:430px,padding:0px
    classDef codeBoxLeft4 fill:#EAEDED,color:#2C3E50,stroke:#34495E,stroke-width:2px,text-align:left,white-space:nowrap,width:380px,padding:0px            
    
    classDef classTitle fill:none,color:#2C3E50,stroke:none,font-weight:bold,font-size:18px

    %%classDef classTitle fill:none,color:#2C3E50,stroke:none,font-weight:bold,font-size:18px,width:450px,white-space:nowrap

    %%classDef piso fill:transparent,stroke:transparent,color:transparent,stroke-width:0px
    classDef piso fill:none,stroke:none,color:transparent,font-size:1px,line-height:0px
    classDef colchon fill:none,stroke:none,height:25px,width:0px
    %% ESTILO PARA EL NODO FANTASMA ENSANCHADOR",
    %% height:0px y font-size:1px aseguran que no agregue altura visible",
    %% width:500px es el ancho forzado que queremos para la caja",
    %%classDef widener fill:none,stroke:none,color:transparent,font-size:1px,height:0px,width:1000px
    
    %% BLOQUE SUPERIOR
    subgraph SUPERIOR [" "]
        direction LR
        style SUPERIOR fill:none,stroke:none

        ENTRADA["üìÑ&nbsp;Entrada:<br/>lt,&nbsp;lg,&nbsp;'nb'<br/><br/>üìÑ&nbsp;Entrada m√≠nima:<br/>lt,&nbsp;lg"]:::input

        %% T√çTULO CORTO
        subgraph CLASE ["(Entidad&nbsp;L√≥gica&nbsp;S3)&nbsp;üì¶"]
            direction TB
            
            CERO["class 'PuntoEspacial'"]:::classTitle

            n1(("1 üìç")):::num
            m1["nuevo_punto_espacial <- function(lt, lg, nb='no name') {<br/>&emsp;obj <- list(lt=lt, lg=lg, nb=nb)<br/>&emsp;class(obj) <- 'PuntoEspacial'<br/>&emsp;return(obj)<br/>}"]:::codeBoxLeft1
            PIN["üìç"]:::giantPin
            r1["üìçobj (Lista Etiquetada ü´ì)"]:::light

            n2(("2 üí¨")):::num
            m2["print.PuntoEspacial <- function(x) {<br/>&emsp;cat(sprintf('[%s] (Lat: %.4f, Lon: %.4f)', x$nb, x$lt, x$lg))<br/>}"]:::codeBoxLeft2
            r2["üí¨ '[nb] (Lat: lt, Lon: lg)'"]:::light
            
            n3(("3 üìê")):::num
            m3["distancia_hacia <- function(o, d, r=6371) {<br/>&emsp;UseMethod('distancia_hacia')<br/>}<br/>distancia_hacia.PuntoEspacial <- function(o, d, r=6371) {<br/>&emsp;d <- haversine(o$lt, o$lg, d$lt, d$lg, r=r)<br/>}"]:::codeBoxLeft3

            r3["km = distancia_hacia(p1, p2) ‚û°Ô∏è 242.5 km"]:::light2
            
            n4(("4 üó∫Ô∏èüìê")):::num
            m4["graficar_ruta <- function(o, d) {<br/>&emsp;UseMethod('graficar_ruta')<br/>}<br/>graficar_ruta.PuntoEspacial <- function(o, d) {<br/>&emsp;d <- distancia_hacia(o, d)<br/>&emsp;mapa <- leaflet(...)<br/>}"]:::codeBoxLeft4
            r4["üó∫Ô∏è Mapa interactivo (leaflet)"]:::light
            %%PISO["..........................................................................................................................."]:::piso
            %% NODO FANTASMA: Invisible, sin altura, pero muy ancho
            %% WIDENER[" "]:::widener

            %% SU CONEXI√ìN LINEAL INTACTA
            CERO ~~~ n1
            n1 --- m1
            m1 --> PIN
            PIN --> r1
            r1 --> n2
            n2 --- m2
            m2 --> r2
            r2 ~~~ n3
            n3 --- m3
            m3 --> r3
            r3 ~~~ n4
            n4 --- m4
            m4 --> r4
            %% r4 ~~~ WIDENER
        end

        ENTRADA ==>|Creaci√≥n S3| CLASE
        class CLASE box

        %% SU CONTENEDOR VERTICAL INTACTO
        subgraph DERECHA [" "]
            direction TB
            style DERECHA fill:none,stroke:none

            subgraph EXTERNO[" "]
                direction TB
                HAVERSINE["‚öôÔ∏è&nbsp;Funci√≥n&nbsp;externa:<br/>haversine <- function(lt1, lg1, lt2, lg2, r=6371) {<br/>&emsp;...<br/>}"]:::extNode
            end
            style EXTERNO fill:none,stroke:none

            subgraph SEPARADOR[" "]
                direction TB
                SEP[" "]:::colchon
            end
            style SEPARADOR fill:none,stroke:none

            subgraph LEYENDA ["üìã&nbsp;Leyenda R"]
                direction TB
                l1(("1 üìç")) --- t1["Constructor S3"]
                t1 ~~~ l3(("3 üìê")) 
                l3 --- t3["M√©todo S3 (Anal√≠tico)"]
                l2(("2 üí¨")) 
                l2 --- t2["Representaci√≥n"]
                t2 ~~~ l4(("4 üó∫Ô∏èüìê")) 
                l4 --- t4["M√©todo S3 (Gr√°fico)"]
            end
            style LEYENDA fill:#FCF3CF,stroke:#D4AC0D,stroke-width:2px,color:#1A1A1A
        end
        
        %% CONEXIONES DE DEPENDENCIA
        CLASE -.->|3 invoca| HAVERSINE
        CLASE -.->|4 invoca 3, 3 invoca| HAVERSINE
        CLASE ~~~ DERECHA
    end
```

:::

::: {.content-visible when-format="pdf"}
![Diagrama del flujo de instanciaci√≥n en R (S3): El molde y las arepas.](./images/clase_r.png){#fig-clases-r-final-vertical}
:::

Resumen del c√≥digo para una clase en R:

```{r}
#| label: resumen_codigo_clase_r
#| eval: false

# --- 1. DEFINICI√ìN DEL MOLDE (FUNCI√ìN CONSTRUCTORA) ---
# [1 üìç] 1.1 EL CONSTRUCTOR INFORMAL
nuevo_punto_espacial <- function(...) {
    # Creamos una lista para los atributos
    objeto <- list(
        latitud = ...,
        ...
    )
    
    # Etiquetado de clase (MAGIA)
    class(objeto) <- "PuntoEspacial"
    
    return(objeto)
}

# [2 üí¨] 1.2 LA REPRESENTACI√ìN TEXTUAL (Sobrescribir 'print')
print.PuntoEspacial <- function(obj) {
    ...
}

# [3 üìê] 1.3 LOS M√âTODOS (COMPORTAMIENTO ANAL√çTICO)
# funci√≥n gen√©rica
distancia_hacia <- function(...) {
    UseMethod("distancia_hacia")
}

# Ese m√©todo SOLO para la clase "PuntoEspacial"
distancia_hacia.PuntoEspacial <- function(...) {
    ...
}

# [4 üó∫Ô∏èüìê] 1.4 EL M√âTODO GR√ÅFICO
graficar_ruta <- function(...) {
    UseMethod("graficar_ruta")
}

# Ese m√©todo SOLO para la clase PuntoEspacial
graficar_ruta.PuntoEspacial <- function(...) {
    ...
}
```


::: {.content-visible when-format="html"}
```{mermaid}
%%| label: fig-clases-r-codigo
%%| fig-cap: "Ejecuci√≥n del c√≥digo en R (S3) instanciando los objetos en memoria."
%%| out-width: 50%
%%| fig-align: center
flowchart LR
    %% Agregamos el mismo blindaje de estilo que en Python
    classDef scriptBox fill:#FFFFFF,color:#000000,stroke:#333333,stroke-width:2px,text-align:left,font-family:monospace,font-size:12px,white-space:nowrap,padding:5px
    
    %% Usamos el s√≠mbolo Unicode ÔºÉ en lugar de &#35;
    SCRIPT["ÔºÉ --- EJECUCI√ìN DEL C√ìDIGO EN R (S3) ---<br/><br/>ÔºÉ [1 üìç] INSTANCIACI√ìN: Etiquetando listas con el molde<br/>punto_origen = nuevo_punto_espacial(4.6097, -74.0817, 'Bogot√°')      ÔºÉ ü´ì Arepa 1<br/>punto_destino = nuevo_punto_espacial(6.2442, -75.5812, 'Medell√≠n')   ÔºÉ ü´ì Arepa 2<br/>punto_misterioso = nuevo_punto_espacial(12.5847, -81.7006)           ÔºÉ ü´ì Arepa Especial 3<br/><br/>ÔºÉ [2 üí¨] REPRESENTACI√ìN: R busca el m√©todo 'print.PuntoEspacial'<br/>print(punto_origen)<br/>print(punto_destino)<br/>print(punto_misterioso)<br/><br/>ÔºÉ [3 üìê] M√âTODOS ANAL√çTICOS: Uso del UseMethod() para despachar<br/>resultado_km = distancia_hacia(punto_origen, punto_destino)<br/>resultado_metros = distancia_hacia(punto_origen, punto_destino, radio = 6371000.0)<br/><br/>ÔºÉ [4 üó∫Ô∏èüìê] M√âTODO GR√ÅFICO: Mapa interactivo leaflet<br/>mapa_final = graficar_ruta(punto_origen, punto_destino)"]:::scriptBox
```

:::

::: {.content-visible when-format="pdf"}
![Ejecuci√≥n del c√≥digo en R (S3) instanciando los objetos en memoria.](./images/clase_r_codigo.png){#fig-clases-r-codigo}
:::


### Julia y el despacho m√∫ltiple: separando los ingredientes de la receta

Julia rechaza por completo el concepto tradicional de clases que vimos en Python. En su lugar, abraza un paradigma donde los datos (las variables) y el comportamiento (las funciones) est√°n estrictamente separados, pero trabajan en una armon√≠a perfecta gracias al n√∫cleo absoluto del lenguaje: el **despacho m√∫ltiple** (Multiple Dispatch).

::: {.callout-tip title="La analog√≠a: el contenedor r√≠gido y los chefs expertos"}
Si Python es un molde de hierro y R es un post-it, Julia es una cocina de alta eficiencia:

* **El contenedor (`struct`):** Es un contenedor pl√°stico r√≠gido (como un "porta" de cristal). Su √∫nica funci√≥n es guardar los ingredientes (latitud, longitud, nombre) de forma organizada y con etiquetas de tipo muy estrictas (`Float64`, `String`). El `struct` es "tonto"; no sabe hacer absolutamente nada por s√≠ solo, no tiene m√©todos ni recetas grabadas en sus paredes.
* **El comportamiento (las funciones libres):** Son un batall√≥n de chefs expertos que est√°n esperando en la cocina. Cuando usted grita "¬°Quiero la distancia!", el jefe de cocina (el compilador de Julia) mira exactamente qu√© ingredientes le entreg√≥ en el porta. Dependiendo de los tipos de datos que usted mande, le asigna el trabajo al chef que tenga la receta matem√°tica m√°s optimizada para esos tipos exactos.
:::

*Julia lleva la separaci√≥n entre datos y herramientas al extremo, usando una estrategia de clasificaci√≥n ultrarr√°pida:*

![**El paradigma de Julia (Despacho M√∫ltiple):** Los datos est√°n resguardados en contenedores inmutables (Structs). Las funciones son chefs externos altamente especializados. Cuando pides una operaci√≥n, el compilador (el "Jefe de Cocina") escanea con l√°ser los tipos de datos exactos y llama instant√°neamente al chef que tiene la receta matem√°tica perfecta para esa combinaci√≥n.](./images/julia_struct_analogy.png){#fig-analogia-julia fig-align="center" width="50%"}

#### La anatom√≠a de la arquitectura en Julia

En este lenguaje, construimos la estructura definiendo tipos de datos crudos y luego escribimos funciones libres que declaran para qu√© combinaciones de tipos est√°n preparadas.

1.  **La estructura base (`struct`):** A diferencia de las clases, aqu√≠ solo organizamos las variables en la memoria. Esto garantiza un tipado fuerte que le permite a Julia ser tan r√°pido como C o Fortran.
2.  **El constructor:** Julia crea un constructor autom√°tico b√°sico, pero podemos crear constructores propios si necesitamos reglas especiales (como asignar 'no name' si el usuario olvida el nombre al llenar el contenedor).
3.  **El despacho m√∫ltiple en acci√≥n:** La magia ocurre al llamar a una funci√≥n. Si tenemos una funci√≥n `distancia_hacia(a, b)`, Julia analiza el tipo de dato exacto de **todos** los argumentos que le pasamos. Basado en esa combinaci√≥n de tipos, el lenguaje enruta la ejecuci√≥n al m√©todo m√°s espec√≠fico de forma instant√°nea.

A continuaci√≥n, visualizamos este potente paradigma: primero, la representaci√≥n de c√≥mo el `struct` y el despacho m√∫ltiple interact√∫an conceptualmente en una "caja virtual" (con l√≠neas muy espaciadas para notar que no es una prisi√≥n de c√≥digo); y luego, el bloque de ejecuci√≥n donde vemos a Julia activando los m√©todos correctos al vuelo.

::: {.content-visible when-format="html"}
```{mermaid}
%%| label: fig-clases-julia-final-vertical
%%| fig-cap: "Diagrama del flujo de instanciaci√≥n en Julia (Despacho M√∫ltiple): El molde (Struct) y las arepas."
%%| fig-width: 6
%%| out-width: 20%
%%| fig-align: center

%% COMPRESI√ìN TOTAL: La f√≥rmula maestra
%%{init: {"flowchart": {"nodeSpacing": -30, "rankSpacing": -30}}}%%

flowchart TB
    %% ESTILOS ADAPTADOS A JULIA
    classDef num fill:#E67E22,color:#FFF,stroke:none,font-weight:bold,font-size:16px
    classDef codeBox fill:#EAEDED,color:#2C3E50,stroke:#34495E,stroke-width:2px
    classDef light fill:#E8F8F5,color:#145A32,stroke:#2ECC71,stroke-width:2px,font-size:16px
    classDef light2 fill:#E8F8F5,color:#145A32,stroke:#2ECC71,stroke-width:2px,font-size:16px,white-space:nowrap,width:330px,padding:0px    
    classDef input fill:#FDEBD0,color:#7E5109,stroke:#F39C12,stroke-width:2px,font-size:16px
    
    %% CAJA VIRTUAL JULIA: Representa el Despacho M√∫ltiple (Agrupaci√≥n conceptual, no f√≠sica)
    classDef box fill:none,stroke:#3498DB,stroke-width:3px,stroke-dasharray: 7 45
    
    classDef giantPin fill:none,stroke:none,font-size:50px
    classDef extNode fill:#EBDEF0,color:#512E5F,stroke:#8E44AD,stroke-width:2px,font-size:14px,text-align:left,white-space:nowrap,width:370px,padding:0px
    
    %% ANCHOS ESCULPIDOS PARA LA SINTAXIS JULIA (El tipado ::PuntoEspacial alarga las l√≠neas)
    classDef codeBoxLeft0 fill:#EAEDED,color:#2C3E50,stroke:#34495E,stroke-width:2px,text-align:left,white-space:nowrap,width:260px,padding:0px
    classDef codeBoxLeft1 fill:#EAEDED,color:#2C3E50,stroke:#34495E,stroke-width:2px,text-align:left,white-space:nowrap,width:430px,padding:0px
    classDef codeBoxLeft2 fill:#EAEDED,color:#2C3E50,stroke:#34495E,stroke-width:2px,text-align:left,white-space:nowrap,width:400px,padding:0px
    classDef codeBoxLeft3 fill:#EAEDED,color:#2C3E50,stroke:#34495E,stroke-width:2px,text-align:left,white-space:nowrap,width:530px,padding:0px
    classDef codeBoxLeft4 fill:#EAEDED,color:#2C3E50,stroke:#34495E,stroke-width:2px,text-align:left,white-space:nowrap,width:450px,padding:0px            
    
    classDef classTitle fill:none,color:#2C3E50,stroke:none,font-weight:bold,font-size:18px
    classDef piso fill:transparent,stroke:transparent,color:transparent,stroke-width:0px
    classDef colchon fill:none,stroke:none,height:25px,width:0px

    %% BLOQUE SUPERIOR
    subgraph SUPERIOR [" "]
        direction LR
        style SUPERIOR fill:none,stroke:none

        ENTRADA["üìÑ&nbsp;Entrada:<br/>lt,&nbsp;lg,&nbsp;'nb'<br/><br/>üìÑ&nbsp;Entrada m√≠nima:<br/>lt,&nbsp;lg"]:::input

        %% T√çTULO CORTO
        subgraph CLASE ["(Despacho&nbsp;M√∫ltiple)&nbsp;üì¶"]
            direction TB
            
            CERO["struct PuntoEspacial"]:::classTitle

            %% EL STRUCT: La base de datos cruda
            m0["struct PuntoEspacial<br/>&emsp;lt::Float64<br/>&emsp;lg::Float64<br/>&emsp;nb::String<br/>end"]:::codeBoxLeft0

            n1(("1 üìç")):::num
            m1["PuntoEspacial(lt, lg) = PuntoEspacial(lt, lg, 'no name')"]:::codeBoxLeft1
            PIN["üìç"]:::giantPin
            r1["üìçobj::PuntoEspacial (Struct ü´ì)"]:::light

            n2(("2 üí¨")):::num
            m2["function Base.show(io::IO, o::PuntoEspacial)<br/>&emsp;print(io, '[$(o.nb)] (Lat: $(o.lt), Lon: $(o.lg))')<br/>end"]:::codeBoxLeft2
            r2["üí¨ '[nb] (Lat: lt, Lon: lg)'"]:::light
            
            n3(("3 üìê")):::num
            m3["function distancia_hacia(o::PuntoEspacial, d::PuntoEspacial, r=6371) = <br/>&emsp;d = haversine(o.lt, o.lg, d.lt, d.lg, r)<br/>end"]:::codeBoxLeft3

            r3["km = distancia_hacia(p1, p2) ‚û°Ô∏è 242.5 km"]:::light2
            
            n4(("4 üó∫Ô∏èüìê")):::num
            m4["function graficar_ruta(o::PuntoEspacial, d::PuntoEspacial)<br/>&emsp;d = distancia_hacia(o, d)<br/>&emsp;mapa = plot(...)<br/>end"]:::codeBoxLeft4
            r4["üó∫Ô∏è Mapa est√°tico<br/>(Plots.jl)"]:::light
            
            %% CONEXI√ìN LINEAL INTACTA (El struct encabeza la fila)
            CERO ~~~ m0
            m0 ~~~ n1
            n1 --- m1
            m1 --> PIN
            PIN --> r1
            r1 --> n2
            n2 --- m2
            m2 --> r2
            r2 ~~~ n3
            n3 --- m3
            m3 --> r3
            r3 ~~~ n4
            n4 --- m4
            m4 --> r4
        end

        ENTRADA ==>|Creaci√≥n Struct| CLASE
        class CLASE box

        %% CONTENEDOR VERTICAL INTACTO
        subgraph DERECHA [" "]
            direction TB
            style DERECHA fill:none,stroke:none

            subgraph EXTERNO[" "]
                direction TB
                HAVERSINE["‚öôÔ∏è&nbsp;Funci√≥n&nbsp;externa:<br/>function haversine(lt1, lg1, lt2, lg2; r=6371)<br/>&emsp;...<br/>end"]:::extNode
            end
            style EXTERNO fill:none,stroke:none

            subgraph SEPARADOR[" "]
                direction TB
                SEP[" "]:::colchon
            end
            style SEPARADOR fill:none,stroke:none

            subgraph LEYENDA ["üìã&nbsp;Leyenda Julia"]
                direction TB
                l1(("1 üìç")) --- t1["Struct + Constructor"]
                t1 ~~~ l3(("3 üìê")) 
                l3 --- t3["Despacho M√∫ltiple"]                
                l2(("2 üí¨")) 
                l2 --- t2["M√©todo Base.show"]
                t2 ~~~ l4(("4 üó∫Ô∏èüìê")) 
                l4 --- t4["Despacho M√∫ltiple"]
            end           
            style LEYENDA fill:#FCF3CF,stroke:#D4AC0D,stroke-width:2px,color:#1A1A1A
        end
        
        %% CONEXIONES DE DEPENDENCIA
        CLASE -.->|3 invoca| HAVERSINE
        CLASE -.->|4 invoca 3, 3 invoca| HAVERSINE
        CLASE ~~~ DERECHA
    end
```

:::

::: {.content-visible when-format="pdf"}
![Diagrama del flujo de instanciaci√≥n en Julia (Despacho M√∫ltiple): El molde (Struct) y las arepas.](./images/clase_julia.png){#fig-clases-julia-final-vertical}
:::

Resumen del c√≥digo para un tipo (struct) en Julia

```{julia}
#| label: resumen_codigo_struct_julia
#| eval: false

# --- 1. DEFINICI√ìN DE LA CLASE (MOLDE) ---
# [1 üìç] 1.1 EL CONSTRUCTOR (LA ESTRUCTURA)

struct PuntoEspacial
    latitud::Float64   # Coordenada Y
    ...
end

# Definimos un m√©todo constructor adicional
PuntoEspacial(lat, lon) = PuntoEspacial(lat, lon, "No Name")


# [2 üí¨] 1.2 LA REPRESENTACI√ìN TEXTUAL
function Base.show(io::IO, obj::PuntoEspacial)
    print(...)
end


# [3 üìê] 1.3 M√âTODOS ANAL√çTICOS (DESPACHO M√öLTIPLE)
function distancia_hacia(o::PuntoEspacial, d::PuntoEspacial; r=6371.0)
    ...
    return distancia
end


# [4 üó∫Ô∏èüìê] 1.4 M√âTODO GR√ÅFICO (DIBUJO Y MANIPULACI√ìN DE CADENAS)
function graficar_ruta(o::PuntoEspacial, d::PuntoEspacial)
    ...
    return mapa
end
```


::: {.content-visible when-format="html"}
```{mermaid}
%%| label: fig-clases-julia-codigo
%%| fig-cap: "Ejecuci√≥n del c√≥digo en Julia instanciando las estructuras en memoria."
%%| out-width: 50%
%%| fig-align: center
flowchart LR
    %% Agregamos el blindaje de estilo: nowrap y padding
    classDef scriptBox fill:#FFFFFF,color:#000000,stroke:#333333,stroke-width:2px,text-align:left,font-family:monospace,font-size:12px,white-space:nowrap,padding:5px
    %% Reemplazamos &#35; por el s√≠mbolo Unicode ÔºÉ
    SCRIPT["ÔºÉ --- EJECUCI√ìN DEL C√ìDIGO EN JULIA ---<br/><br/>ÔºÉ [1 üìç] INSTANCIACI√ìN: Construyendo la estructura (struct)<br/>punto_origen = PuntoEspacial(4.6097, -74.0817, 'Bogot√°')      ÔºÉ ü´ì Arepa 1<br/>punto_destino = PuntoEspacial(6.2442, -75.5812, 'Medell√≠n')   ÔºÉ ü´ì Arepa 2<br/>punto_misterioso = PuntoEspacial(12.5847, -81.7006, '')       ÔºÉ ü´ì Arepa Especial 3<br/><br/>ÔºÉ [2 üí¨] REPRESENTACI√ìN: Julia activa autom√°ticamente Base.show()<br/>println(punto_origen)<br/>println(punto_destino)<br/>println(punto_misterioso)<br/><br/>ÔºÉ [3 üìê] M√âTODOS ANAL√çTICOS: El Despacho M√∫ltiple elige el m√©todo correcto<br/>resultado_km = distancia_hacia(punto_origen, punto_destino)<br/>resultado_metros = distancia_hacia(punto_origen, punto_destino, radio = 6371000.0)<br/><br/>ÔºÉ [4 üó∫Ô∏èüìê] M√âTODO GR√ÅFICO: Ejecutando la funci√≥n tipada<br/>mapa_final = graficar_ruta(punto_origen, punto_destino)"]:::scriptBox
```

:::

::: {.content-visible when-format="pdf"}
![Ejecuci√≥n del c√≥digo en Julia instanciando las estructuras en memoria.](./images/clase_julia_codigo.png){#fig-clases-julia-codigo}
:::

### Laboratorio comparativo: implementaci√≥n del c√≥digo completo

A continuaci√≥n, presentamos el c√≥digo completo y funcional para los tres lenguajes. Te invitamos a navegar entre las pesta√±as para comparar c√≥mo cada arquitectura resuelve el mismo problema. 

üí° **Tip de lectura:** Busca las etiquetas con emojis (`[1 üìç]`, `[2 üí¨]`, `[3 üìê]`, `[4 üó∫Ô∏èüìê]`) dentro de los comentarios del c√≥digo. Estas te ayudar√°n a conectar cada bloque de c√≥digo directamente con los diagramas de arquitectura que vimos en las secciones anteriores.


::: {.panel-tabset}

#### Python

::: {.content-visible when-format="html"}
::: {.callout-tip collapse="true" icon="false"}
##### ‚ñ∑ C√ìDIGO PURO (Copiar y Pegar)

```{python}
#| label: python_clases_codigo
#| eval: false

import math
import folium # Librer√≠a indispensable en Python para generar mapas interactivos

# --- 0. TRAEMOS NUESTRA M√ÅQUINA MATEM√ÅTICA ---
# Pegamos aqu√≠ la funci√≥n que ya hab√≠amos creado para que este c√≥digo funcione por s√≠ solo
def haversine(lat1, lon1, lat2, lon2, radio=6371.0):
    dlat, dlon = math.radians(lat2 - lat1), math.radians(lon2 - lon1)
    a = math.sin(dlat / 2)**2 + math.cos(math.radians(lat1)) * math.cos(math.radians(lat2)) * math.sin(dlon / 2)**2
    return radio * (2 * math.atan2(math.sqrt(a), math.sqrt(1 - a)))


# --- 1. DEFINICI√ìN DEL MOLDE (LA CLASE) ---
# Usamos la palabra reservada 'class' seguida del nombre (en may√∫scula por convenci√≥n)
class PuntoEspacial:
    
    # [1 üìç] 1.1 EL CONSTRUCTOR (__init__)
    # Esta funci√≥n especial se ejecuta autom√°ticamente el momento en que "nace" un punto.
    # 'self' significa "yo mismo". Es la forma en que el objeto se refiere a sus propios datos.
    # Definimos que latitud y longitud son obligatorios, pero el nombre tiene un valor por defecto.
    def __init__(self, latitud, longitud, nombre="Punto sin nombre"):
        
        # Guardamos la latitud que nos entregaron dentro del cuerpo del objeto (self)
        self.latitud = latitud
        
        # Guardamos la longitud dentro del objeto
        self.longitud = longitud
        
        # Guardamos el nombre dentro del objeto
        self.nombre = nombre

    # [2 üí¨] 1.2 LA REPRESENTACI√ìN TEXTUAL (__str__)
    # Si le decimos a Python print(objeto), por defecto imprimir√° basura t√©cnica.
    # Esta funci√≥n especial le ense√±a a Python c√≥mo queremos que se lea el objeto en pantalla.
    def __str__(self):
        # SACA: Un texto bonito combinando el nombre y las coordenadas
        return f"[{self.nombre}] (Lat: {self.latitud}, Lon: {self.longitud})"

    # [3 üìê] 1.3 LOS M√âTODOS (COMPORTAMIENTO ANAL√çTICO)
    # Es una funci√≥n normal, pero como tiene 'self', vive dentro del objeto.
    # Agregamos el par√°metro 'radio' para que el usuario pueda pedir el resultado en metros.
    def distancia_hacia(self, otro_punto, radio=6371.0):
        
        # Llamamos a nuestra funci√≥n haversine externa pas√°ndole el radio solicitado
        # Le enviamos NUESTRAS coordenadas (self) y las coordenadas DEL OTRO (otro_punto)
        distancia = haversine(self.latitud, self.longitud, otro_punto.latitud, otro_punto.longitud, radio)
        
        # SACA: La distancia num√©rica calculada entre los dos objetos
        return distancia
        
    # [4 üó∫Ô∏èüìê] 1.4 EL M√âTODO GR√ÅFICO (MAPA BASE CON ETIQUETA VISIBLE)
    # Este m√©todo le da la habilidad al objeto de dibujarse en un mapa web interactivo.
    def graficar_ruta(self, otro_punto):
        
        # Primero, le decimos al objeto que calcule su propia distancia hacia el destino
        distancia_calculada = self.distancia_hacia(otro_punto)
        
        # Calculamos el punto medio geom√©trico para centrar la c√°mara y poner el texto
        centro_lat = (self.latitud + otro_punto.latitud) / 2
        centro_lon = (self.longitud + otro_punto.longitud) / 2
        
        # Creamos el lienzo del mapa base (estilo OpenStreetMap por defecto)
        mapa = folium.Map(location=[centro_lat, centro_lon], zoom_start=6)
        
        # Ponemos un pin en nuestra ubicaci√≥n de origen (self)
        folium.Marker([self.latitud, self.longitud], popup=self.nombre).add_to(mapa)
        
        # Ponemos un pin en el destino (otro_punto)
        folium.Marker([otro_punto.latitud, otro_punto.longitud], popup=otro_punto.nombre).add_to(mapa)
        
        # Trazamos una l√≠nea roja que conecte ambas coordenadas
        folium.PolyLine([(self.latitud, self.longitud), (otro_punto.latitud, otro_punto.longitud)], color="red", weight=3).add_to(mapa)
        
        # ¬°NUEVO!: Ponemos un marcador transparente en el medio con un 'Tooltip' permanente.
        # Esto obliga a Folium a mostrar el texto de la distancia sin necesidad de hacer clic.
        etiqueta = f"Distancia: {distancia_calculada:.2f} km"
        folium.Marker(
            [centro_lat, centro_lon],
            icon=folium.DivIcon(html=""), # Ocultamos el √≠cono tradicional
            tooltip=folium.Tooltip(etiqueta, permanent=True, direction="top")
        ).add_to(mapa)
        
        # SACA: El objeto mapa listo para ser mostrado
        return mapa


# --- 2. CREACI√ìN DE OBJETOS (INSTANCIACI√ìN) ---

print("--- Creando objetos a partir del molde ---")

# [1 üìç] INSTANCIACI√ìN: Creamos el primer objeto (Bogot√°). 
# Noten que no le pasamos el par√°metro 'self', Python hace eso invisiblemente.
punto_origen = PuntoEspacial(4.6097, -74.0817, "Bogot√°")

# Creamos el segundo objeto (Medell√≠n). Usamos los mismos planos, pero con otros datos.
punto_destino = PuntoEspacial(6.2442, -75.5812, "Medell√≠n")

# Creamos un tercer objeto, pero omitimos el nombre para ver si funciona el valor por defecto
punto_misterioso = PuntoEspacial(12.5847, -81.7006)

# [2 üí¨] REPRESENTACI√ìN: Probamos nuestra funci√≥n especial __str__ imprimiendo los objetos
print(punto_origen)
print(punto_destino)
print(punto_misterioso)

print("\n--- Usando los m√©todos del objeto ---")

# [3 üìê] M√âTODOS ANAL√çTICOS: Le pedimos al objeto que mida la distancia hacia 'punto_destino'
resultado_km = punto_origen.distancia_hacia(punto_destino)
print(f"La distancia desde {punto_origen.nombre} hasta {punto_destino.nombre} es: {resultado_km:.2f} km")

# Truco de conversi√≥n: Pedimos el resultado en metros modificando el par√°metro 'radio' a 6371000.0
resultado_metros = punto_origen.distancia_hacia(punto_destino, radio=6371000.0)
print(f"O expresado en metros: {resultado_metros:.2f} m")

# [4 üó∫Ô∏èüìê] M√âTODO GR√ÅFICO: Finalmente, le pedimos al objeto que dibuje el mapa de su ruta
mapa_final = punto_origen.graficar_ruta(punto_destino)
print("\n¬°Mapa interactivo generado con √©xito en la variable 'mapa_final'!")
# Nota: Si est√°s en un Notebook, basta con escribir 'mapa_final' en una celda para visualizarlo.
```
:::

:::

```{python}
#| label: python_clases
#| screenshot: true
#| fig-format: png  # <--- FUERZA LA CONVERSI√ìN A IMAGEN
#| screenshot-opts:
#|   delay: 10

# #| echo: false
# #| eval: false
import math
import folium # Librer√≠a indispensable en Python para generar mapas interactivos

# --- 0. TRAEMOS NUESTRA M√ÅQUINA MATEM√ÅTICA ---
# Pegamos aqu√≠ la funci√≥n que ya hab√≠amos creado para que este c√≥digo funcione por s√≠ solo
def haversine(lat1, lon1, lat2, lon2, radio=6371.0):
    dlat, dlon = math.radians(lat2 - lat1), math.radians(lon2 - lon1)
    a = math.sin(dlat / 2)**2 + math.cos(math.radians(lat1)) * math.cos(math.radians(lat2)) * math.sin(dlon / 2)**2
    return radio * (2 * math.atan2(math.sqrt(a), math.sqrt(1 - a)))


# --- 1. DEFINICI√ìN DEL MOLDE (LA CLASE) ---
# Usamos la palabra reservada 'class' seguida del nombre (en may√∫scula por convenci√≥n)
class PuntoEspacial:
    
    # [1 üìç] 1.1 EL CONSTRUCTOR (__init__)
    # Esta funci√≥n especial se ejecuta autom√°ticamente el momento en que "nace" un punto.
    # 'self' significa "yo mismo". Es la forma en que el objeto se refiere a sus propios datos.
    # Definimos que latitud y longitud son obligatorios, pero el nombre tiene un valor por defecto.
    def __init__(self, latitud, longitud, nombre="Punto sin nombre"):
        
        # Guardamos la latitud que nos entregaron dentro del cuerpo del objeto (self)
        self.latitud = latitud
        
        # Guardamos la longitud dentro del objeto
        self.longitud = longitud
        
        # Guardamos el nombre dentro del objeto
        self.nombre = nombre

    # [2 üí¨] 1.2 LA REPRESENTACI√ìN TEXTUAL (__str__)
    # Si le decimos a Python print(objeto), por defecto imprimir√° basura t√©cnica.
    # Esta funci√≥n especial le ense√±a a Python c√≥mo queremos que se lea el objeto en pantalla.
    def __str__(self):
        # SACA: Un texto bonito combinando el nombre y las coordenadas
        return f"[{self.nombre}] (Lat: {self.latitud}, Lon: {self.longitud})"

    # [3 üìê] 1.3 LOS M√âTODOS (COMPORTAMIENTO ANAL√çTICO)
    # Es una funci√≥n normal, pero como tiene 'self', vive dentro del objeto.
    # Agregamos el par√°metro 'radio' para que el usuario pueda pedir el resultado en metros.
    def distancia_hacia(self, otro_punto, radio=6371.0):
        
        # Llamamos a nuestra funci√≥n haversine externa pas√°ndole el radio solicitado
        # Le enviamos NUESTRAS coordenadas (self) y las coordenadas DEL OTRO (otro_punto)
        distancia = haversine(self.latitud, self.longitud, otro_punto.latitud, otro_punto.longitud, radio)
        
        # SACA: La distancia num√©rica calculada entre los dos objetos
        return distancia
        
    # [4 üó∫Ô∏èüìê] 1.4 EL M√âTODO GR√ÅFICO (MAPA BASE CON ETIQUETA VISIBLE)
    # Este m√©todo le da la habilidad al objeto de dibujarse en un mapa web interactivo.
    def graficar_ruta(self, otro_punto):
        
        # Primero, le decimos al objeto que calcule su propia distancia hacia el destino
        distancia_calculada = self.distancia_hacia(otro_punto)
        
        # Calculamos el punto medio geom√©trico para centrar la c√°mara y poner el texto
        centro_lat = (self.latitud + otro_punto.latitud) / 2
        centro_lon = (self.longitud + otro_punto.longitud) / 2
        
        # Creamos el lienzo del mapa base (estilo OpenStreetMap por defecto)
        mapa = folium.Map(location=[centro_lat, centro_lon], zoom_start=6)
        
        # Ponemos un pin en nuestra ubicaci√≥n de origen (self)
        folium.Marker([self.latitud, self.longitud], popup=self.nombre).add_to(mapa)
        
        # Ponemos un pin en el destino (otro_punto)
        folium.Marker([otro_punto.latitud, otro_punto.longitud], popup=otro_punto.nombre).add_to(mapa)
        
        # Trazamos una l√≠nea roja que conecte ambas coordenadas
        folium.PolyLine([(self.latitud, self.longitud), (otro_punto.latitud, otro_punto.longitud)], color="red", weight=3).add_to(mapa)
        
        # ¬°NUEVO!: Ponemos un marcador transparente en el medio con un 'Tooltip' permanente.
        # Esto obliga a Folium a mostrar el texto de la distancia sin necesidad de hacer clic.
        etiqueta = f"Distancia: {distancia_calculada:.2f} km"
        folium.Marker(
            [centro_lat, centro_lon],
            icon=folium.DivIcon(html=""), # Ocultamos el √≠cono tradicional
            tooltip=folium.Tooltip(etiqueta, permanent=True, direction="top")
        ).add_to(mapa)
        
        # SACA: El objeto mapa listo para ser mostrado
        return mapa


# --- 2. CREACI√ìN DE OBJETOS (INSTANCIACI√ìN) ---

print("--- Creando objetos a partir del molde ---")

# [1 üìç] INSTANCIACI√ìN: Creamos el primer objeto (Bogot√°). 
# Noten que no le pasamos el par√°metro 'self', Python hace eso invisiblemente.
punto_origen = PuntoEspacial(4.6097, -74.0817, "Bogot√°")

# Creamos el segundo objeto (Medell√≠n). Usamos los mismos planos, pero con otros datos.
punto_destino = PuntoEspacial(6.2442, -75.5812, "Medell√≠n")

# Creamos un tercer objeto, pero omitimos el nombre para ver si funciona el valor por defecto
punto_misterioso = PuntoEspacial(12.5847, -81.7006)

# [2 üí¨] REPRESENTACI√ìN: Probamos nuestra funci√≥n especial __str__ imprimiendo los objetos
print(punto_origen)
print(punto_destino)
print(punto_misterioso)

print("\n--- Usando los m√©todos del objeto ---")

# [3 üìê] M√âTODOS ANAL√çTICOS: Le pedimos al objeto que mida la distancia hacia 'punto_destino'
resultado_km = punto_origen.distancia_hacia(punto_destino)
print(f"La distancia desde {punto_origen.nombre} hasta {punto_destino.nombre} es: {resultado_km:.2f} km")

# Truco de conversi√≥n: Pedimos el resultado en metros modificando el par√°metro 'radio' a 6371000.0
resultado_metros = punto_origen.distancia_hacia(punto_destino, radio=6371000.0)
print(f"O expresado en metros: {resultado_metros:.2f} m")

# [4 üó∫Ô∏èüìê] M√âTODO GR√ÅFICO: Finalmente, le pedimos al objeto que dibuje el mapa de su ruta
mapa_final = punto_origen.graficar_ruta(punto_destino)
print("\n¬°Mapa interactivo generado con √©xito en la variable 'mapa_final'!")
mapa_final
```

#### R

::: {.content-visible when-format="html"}
::: {.callout-tip collapse="true" icon="false"}
##### ‚ñ∑ C√ìDIGO PURO (Copiar y Pegar)
```{r}
#| label: r_clases_codigo
#| eval: false

# Cargamos leaflet, la librer√≠a top para mapas base interactivos en R
library(leaflet) 

# R funciona diferente a Python. Usa un sistema llamado "S3" donde construimos 
# listas normales y les pegamos una "etiqueta" invisible para volverlas objetos.

# --- 0. TRAEMOS NUESTRA M√ÅQUINA MATEM√ÅTICA ---
haversine <- function(lat1, lon1, lat2, lon2, radio = 6371.0) {
    rad <- function(g) { g * pi / 180 }
    a <- sin(rad(lat2 - lat1) / 2)^2 + cos(rad(lat1)) * cos(rad(lat2)) * sin(rad(lon2 - lon1) / 2)^2
    return(radio * (2 * atan2(sqrt(a), sqrt(1 - a))))
}


# --- 1. DEFINICI√ìN DEL MOLDE (FUNCI√ìN CONSTRUCTORA) ---
# [1 üìç] 1.1 EL CONSTRUCTOR INFORMAL
# En R, el "molde" es simplemente una funci√≥n que empaca los datos
nuevo_punto_espacial <- function(latitud, longitud, nombre = "Punto sin nombre") {
    
    # Creamos una lista tradicional de R para guardar los atributos
    objeto <- list(
        latitud = latitud,
        longitud = longitud,
        nombre = nombre
    )
    
    # AQU√ç OCURRE LA MAGIA: Le pegamos la etiqueta de Clase "PuntoEspacial" a nuestra lista
    class(objeto) <- "PuntoEspacial"
    
    # SACA: El objeto ya etiquetado y listo para usarse
    return(objeto)
}

# [2 üí¨] 1.2 LA REPRESENTACI√ìN TEXTUAL (Sobrescribir 'print')
# Le ense√±amos a la funci√≥n nativa print() de R qu√© hacer cuando reciba un "PuntoEspacial"
print.PuntoEspacial <- function(obj) {
    # Imprimimos un texto bonito en pantalla usando cat() y sprintf()
    cat(sprintf("[%s] (Lat: %.4f, Lon: %.4f)\n", obj$nombre, obj$latitud, obj$longitud))
}

# [3 üìê] 1.3 LOS M√âTODOS (COMPORTAMIENTO ANAL√çTICO)
# Primero creamos una "funci√≥n gen√©rica" vac√≠a que avisa que este m√©todo existe,
# y le agregamos el par√°metro opcional 'radio' para poder convertir a metros.
distancia_hacia <- function(obj_origen, obj_destino, radio = 6371.0) {
    UseMethod("distancia_hacia")
}

# Luego le decimos a R c√≥mo debe funcionar ese m√©todo SOLO para la clase "PuntoEspacial"
distancia_hacia.PuntoEspacial <- function(obj_origen, obj_destino, radio = 6371.0) {
    
    # Extraemos los datos de ambos objetos y llamamos a nuestra m√°quina matem√°tica
    distancia <- haversine(obj_origen$latitud, obj_origen$longitud, 
                           obj_destino$latitud, obj_destino$longitud, radio = radio)
                           
    # SACA: La distancia calculada
    return(distancia)
}

# [4 üó∫Ô∏èüìê] 1.4 EL M√âTODO GR√ÅFICO (MAPA BASE CON ETIQUETA)
# Declaramos la funci√≥n gen√©rica
graficar_ruta <- function(obj_origen, obj_destino) {
    UseMethod("graficar_ruta")
}

# Creamos el comportamiento espec√≠fico para nuestros objetos
graficar_ruta.PuntoEspacial <- function(obj_origen, obj_destino) {
    
    # Calculamos la distancia usando nuestro propio m√©todo anal√≠tico
    distancia_calc <- distancia_hacia(obj_origen, obj_destino)
    
    # Calculamos el punto medio de la ruta para anclar el texto de la distancia
    mid_lat <- (obj_origen$latitud + obj_destino$latitud) / 2
    mid_lon <- (obj_origen$longitud + obj_destino$longitud) / 2
    
    # Creamos el lienzo, a√±adimos baldosas (OpenStreetMap) y los marcadores/l√≠neas
    mapa <- leaflet() %>%
        addTiles() %>%  # A√±ade el mapa base tradicional
        addMarkers(lng = c(obj_origen$longitud, obj_destino$longitud), 
                   lat = c(obj_origen$latitud, obj_destino$latitud), 
                   popup = c(obj_origen$nombre, obj_destino$nombre)) %>%
        addPolylines(lng = c(obj_origen$longitud, obj_destino$longitud), 
                     lat = c(obj_origen$latitud, obj_destino$latitud), 
                     color = "red", weight = 3) %>%
        # ¬°NUEVO!: Clavamos un popup fijo en el centro geom√©trico con el resultado
        addPopups(lng = mid_lon, lat = mid_lat, 
                  popup = sprintf("<b>Distancia:</b> %.2f km", distancia_calc))
                     
    # SACA: El mapa interactivo listo
    return(mapa)
}


# --- 2. CREACI√ìN DE OBJETOS (INSTANCIACI√ìN) ---

cat("--- Creando objetos a partir del molde ---\n")

# [1 üìç] INSTANCIACI√ìN: Usamos nuestra funci√≥n constructora para crear a Bogot√°
punto_origen <- nuevo_punto_espacial(4.6097, -74.0817, "Bogot√°")

# Creamos a Medell√≠n
punto_destino <- nuevo_punto_espacial(6.2442, -75.5812, "Medell√≠n")

# Creamos un punto sin nombre para probar el valor por defecto
punto_misterioso <- nuevo_punto_espacial(12.5847, -81.7006)

# [2 üí¨] REPRESENTACI√ìN: Probamos nuestra modificaci√≥n al comando print()
print(punto_origen)
print(punto_destino)
print(punto_misterioso)

cat("\n--- Usando los m√©todos del objeto ---\n")

# [3 üìê] M√âTODOS ANAL√çTICOS: Ejecutamos nuestra funci√≥n de clase enviando los dos objetos
resultado_km <- distancia_hacia(punto_origen, punto_destino)
cat(sprintf("La distancia desde %s hasta %s es: %.2f km\n", 
            punto_origen$nombre, punto_destino$nombre, resultado_km))

# Truco de conversi√≥n: Forzamos que el m√©todo devuelva la respuesta en metros
resultado_metros <- distancia_hacia(punto_origen, punto_destino, radio = 6371000.0)
cat(sprintf("O expresado en metros: %.2f m\n", resultado_metros))

# [4 üó∫Ô∏èüìê] M√âTODO GR√ÅFICO: Lanzamos la creaci√≥n del mapa
mapa_final <- graficar_ruta(punto_origen, punto_destino)
cat("\n¬°Mapa interactivo generado con √©xito en la variable 'mapa_final'!\n")
# Imprimir 'mapa_final' en la consola o Quarto abrir√° el visor web
```
:::
:::

```{r}
#| label: r_clases
#| screenshot.opts:
#|   delay: 10
# #| eval: false
# #| echo: false
# Cargamos leaflet, la librer√≠a top para mapas base interactivos en R
library(leaflet) 

# R funciona diferente a Python. Usa un sistema llamado "S3" donde construimos 
# listas normales y les pegamos una "etiqueta" invisible para volverlas objetos.

# --- 0. TRAEMOS NUESTRA M√ÅQUINA MATEM√ÅTICA ---
haversine <- function(lat1, lon1, lat2, lon2, radio = 6371.0) {
    rad <- function(g) { g * pi / 180 }
    a <- sin(rad(lat2 - lat1) / 2)^2 + cos(rad(lat1)) * cos(rad(lat2)) * sin(rad(lon2 - lon1) / 2)^2
    return(radio * (2 * atan2(sqrt(a), sqrt(1 - a))))
}


# --- 1. DEFINICI√ìN DEL MOLDE (FUNCI√ìN CONSTRUCTORA) ---
# [1 üìç] 1.1 EL CONSTRUCTOR INFORMAL
# En R, el "molde" es simplemente una funci√≥n que empaca los datos
nuevo_punto_espacial <- function(latitud, longitud, nombre = "Punto sin nombre") {
    
    # Creamos una lista tradicional de R para guardar los atributos
    objeto <- list(
        latitud = latitud,
        longitud = longitud,
        nombre = nombre
    )
    
    # AQU√ç OCURRE LA MAGIA: Le pegamos la etiqueta de Clase "PuntoEspacial" a nuestra lista
    class(objeto) <- "PuntoEspacial"
    
    # SACA: El objeto ya etiquetado y listo para usarse
    return(objeto)
}

# [2 üí¨] 1.2 LA REPRESENTACI√ìN TEXTUAL (Sobrescribir 'print')
# Le ense√±amos a la funci√≥n nativa print() de R qu√© hacer cuando reciba un "PuntoEspacial"
print.PuntoEspacial <- function(obj) {
    # Imprimimos un texto bonito en pantalla usando cat() y sprintf()
    cat(sprintf("[%s] (Lat: %.4f, Lon: %.4f)\n", obj$nombre, obj$latitud, obj$longitud))
}

# [3 üìê] 1.3 LOS M√âTODOS (COMPORTAMIENTO ANAL√çTICO)
# Primero creamos una "funci√≥n gen√©rica" vac√≠a que avisa que este m√©todo existe,
# y le agregamos el par√°metro opcional 'radio' para poder convertir a metros.
distancia_hacia <- function(obj_origen, obj_destino, radio = 6371.0) {
    UseMethod("distancia_hacia")
}

# Luego le decimos a R c√≥mo debe funcionar ese m√©todo SOLO para la clase "PuntoEspacial"
distancia_hacia.PuntoEspacial <- function(obj_origen, obj_destino, radio = 6371.0) {
    
    # Extraemos los datos de ambos objetos y llamamos a nuestra m√°quina matem√°tica
    distancia <- haversine(obj_origen$latitud, obj_origen$longitud, 
                           obj_destino$latitud, obj_destino$longitud, radio = radio)
                           
    # SACA: La distancia calculada
    return(distancia)
}

# [4 üó∫Ô∏èüìê] 1.4 EL M√âTODO GR√ÅFICO (MAPA BASE CON ETIQUETA)
# Declaramos la funci√≥n gen√©rica
graficar_ruta <- function(obj_origen, obj_destino) {
    UseMethod("graficar_ruta")
}

# Creamos el comportamiento espec√≠fico para nuestros objetos
graficar_ruta.PuntoEspacial <- function(obj_origen, obj_destino) {
    
    # Calculamos la distancia usando nuestro propio m√©todo anal√≠tico
    distancia_calc <- distancia_hacia(obj_origen, obj_destino)
    
    # Calculamos el punto medio de la ruta para anclar el texto de la distancia
    mid_lat <- (obj_origen$latitud + obj_destino$latitud) / 2
    mid_lon <- (obj_origen$longitud + obj_destino$longitud) / 2
    
    # Creamos el lienzo, a√±adimos baldosas (OpenStreetMap) y los marcadores/l√≠neas
    mapa <- leaflet() %>%
        addTiles() %>%  # A√±ade el mapa base tradicional
        addMarkers(lng = c(obj_origen$longitud, obj_destino$longitud), 
                   lat = c(obj_origen$latitud, obj_destino$latitud), 
                   popup = c(obj_origen$nombre, obj_destino$nombre)) %>%
        addPolylines(lng = c(obj_origen$longitud, obj_destino$longitud), 
                     lat = c(obj_origen$latitud, obj_destino$latitud), 
                     color = "red", weight = 3) %>%
        # ¬°NUEVO!: Clavamos un popup fijo en el centro geom√©trico con el resultado
        addPopups(lng = mid_lon, lat = mid_lat, 
                  popup = sprintf("<b>Distancia:</b> %.2f km", distancia_calc))
                     
    # SACA: El mapa interactivo listo
    return(mapa)
}


# --- 2. CREACI√ìN DE OBJETOS (INSTANCIACI√ìN) ---

cat("--- Creando objetos a partir del molde ---\n")

# [1 üìç] INSTANCIACI√ìN: Usamos nuestra funci√≥n constructora para crear a Bogot√°
punto_origen <- nuevo_punto_espacial(4.6097, -74.0817, "Bogot√°")

# Creamos a Medell√≠n
punto_destino <- nuevo_punto_espacial(6.2442, -75.5812, "Medell√≠n")

# Creamos un punto sin nombre para probar el valor por defecto
punto_misterioso <- nuevo_punto_espacial(12.5847, -81.7006)

# [2 üí¨] REPRESENTACI√ìN: Probamos nuestra modificaci√≥n al comando print()
print(punto_origen)
print(punto_destino)
print(punto_misterioso)

cat("\n--- Usando los m√©todos del objeto ---\n")

# [3 üìê] M√âTODOS ANAL√çTICOS: Ejecutamos nuestra funci√≥n de clase enviando los dos objetos
resultado_km <- distancia_hacia(punto_origen, punto_destino)
cat(sprintf("La distancia desde %s hasta %s es: %.2f km\n", 
            punto_origen$nombre, punto_destino$nombre, resultado_km))

# Truco de conversi√≥n: Forzamos que el m√©todo devuelva la respuesta en metros
resultado_metros <- distancia_hacia(punto_origen, punto_destino, radio = 6371000.0)
cat(sprintf("O expresado en metros: %.2f m\n", resultado_metros))

# [4 üó∫Ô∏èüìê] M√âTODO GR√ÅFICO: Lanzamos la creaci√≥n del mapa
mapa_final <- graficar_ruta(punto_origen, punto_destino)
cat("\n¬°Mapa interactivo generado con √©xito en la variable 'mapa_final'!\n")
mapa_final
```

#### Julia

::: {.content-visible when-format="html"}
::: {.callout-tip collapse="true" icon="false"}
##### ‚ñ∑ C√ìDIGO PURO (Copiar y Pegar)

```{julia}
#| label: julia_clases_codigo
#| eval: false

using Printf
using Plots 

# --- 0. FUNCI√ìN MATEM√ÅTICA DE APOYO ---
# Reutilizamos la f√≥rmula del semiverseno (haversine) para el c√°lculo de distancias
function haversine(lat1, lon1, lat2, lon2; radio=6371.0)
    a = sin(deg2rad(lat2 - lat1) / 2)^2 + cos(deg2rad(lat1)) * cos(deg2rad(lat2)) * sin(deg2rad(lon2 - lon1) / 2)^2
    return radio * (2 * atan(sqrt(a), sqrt(1 - a)))
end


# --- 1. DEFINICI√ìN DE LA CLASE (MOLDE) ---
# [1 üìç] 1.1 EL CONSTRUCTOR (LA ESTRUCTURA)
# En Julia, la programaci√≥n orientada a objetos se basa en 'structs' (estructuras).
# Aqu√≠ definimos las propiedades fundamentales que componen un punto espacial.
struct PuntoEspacial
    latitud::Float64   # Coordenada Y
    longitud::Float64  # Coordenada X
    nombre::String     # Etiqueta o nombre del lugar
end

# Definimos un m√©todo constructor adicional. Si el usuario no proporciona un nombre,
# el objeto se crear√° autom√°ticamente con la etiqueta "Punto sin nombre".
PuntoEspacial(lat, lon) = PuntoEspacial(lat, lon, "Punto sin nombre")


# [2 üí¨] 1.2 LA REPRESENTACI√ìN TEXTUAL
# Sobrescribimos la funci√≥n 'show' de Julia. Esto nos permite controlar exactamente
# c√≥mo se imprimir√° nuestro objeto en la consola cuando usemos print().
function Base.show(io::IO, obj::PuntoEspacial)
    print(io, "[$(obj.nombre)] (Lat: $(obj.latitud), Lon: $(obj.longitud))")
end


# [3 üìê] 1.3 M√âTODOS ANAL√çTICOS (DESPACHO M√öLTIPLE)
# En lugar de encapsular la funci√≥n dentro de la clase, en Julia pasamos el objeto
# expl√≠citamente definiendo su tipo (::PuntoEspacial).
function distancia_hacia(origen::PuntoEspacial, destino::PuntoEspacial; radio=6371.0)
    distancia = haversine(origen.latitud, origen.longitud, destino.latitud, destino.longitud, radio=radio)
    return distancia
end


# [4 üó∫Ô∏èüìê] 1.4 M√âTODO GR√ÅFICO (DIBUJO Y MANIPULACI√ìN DE CADENAS)
# Este m√©todo ense√±a c√≥mo leer datos espaciales crudos sin depender de librer√≠as externas.
function graficar_ruta(origen::PuntoEspacial, destino::PuntoEspacial)
    
    # 1. Calculamos la distancia usando el m√©todo anal√≠tico del objeto
    dist = distancia_hacia(origen, destino)
    
    # 2. Preparamos vectores con las coordenadas para facilitar la gr√°fica
    lons = [origen.longitud, destino.longitud]
    lats = [origen.latitud, destino.latitud]
    nombres = [origen.nombre, destino.nombre]
    
    # Calculamos el punto medio para ubicar la etiqueta de la distancia
    mid_lon = (origen.longitud + destino.longitud) / 2
    mid_lat = (origen.latitud + destino.latitud) / 2
    
    # Preparamos el lienzo base
    mapa = plot(aspect_ratio=:equal, legend=false,
                xlabel="Longitud", ylabel="Latitud", title="Mapa Cartogr√°fico Est√°tico")
                
    # 3. Usamos un bloque try-catch para evitar que el programa falle si el archivo no existe
    try
        # Leemos el archivo GeoJSON como texto plano (String). 
        # Usamos Base.read expl√≠citamente para evitar ambig√ºedades con otras funciones.
        texto_json = Base.read("./data/COL.geo.json", String)
        
        # Buscamos los delimitadores estructurales del arreglo de coordenadas en el JSON
        idx_inicio = findfirst("[[[", texto_json)
        idx_fin = findlast("]]]", texto_json)
        
        if idx_inicio !== nothing && idx_fin !== nothing
            # Aislamos √∫nicamente el bloque de texto que contiene los n√∫meros
            bloque = texto_json[last(idx_inicio)+1 : first(idx_fin)-1]
            puntos = split(bloque, "],[")
            
            xs = Float64[]
            ys = Float64[]
            
            # Iteramos sobre cada coordenada, limpiamos los caracteres extra y convertimos a n√∫mero
            for pt in puntos
                limpio = replace(pt, "[" => "", "]" => "", " " => "")
                vals = split(limpio, ",")
                push!(xs, parse(Float64, vals[1]))
                push!(ys, parse(Float64, vals[2]))
            end
            
            # Dibujamos la geometr√≠a extra√≠da (silueta del pa√≠s)
            plot!(mapa, xs, ys, seriestype=:shape, fillcolor=:lightgrey, linecolor=:white)
        end
    catch e
        # Mensaje de respaldo si la lectura del mapa base falla
        annotate!(mapa, mid_lon, mid_lat + 1.5, text("(Sin mapa base)", :gray, 9))
    end
    
    # Trazamos la l√≠nea de la ruta que conecta los puntos
    plot!(mapa, lons, lats, linecolor=:red, linewidth=2)
    
    # A√±adimos los marcadores de las ciudades
    scatter!(mapa, lons, lats, color=:blue, markersize=6, 
             series_annotations=text.(nombres, :bottom))
             
    # Insertamos el texto con el resultado de la distancia en el centro
    texto_distancia = " $(round(dist, digits=2)) km"
    annotate!(mapa, mid_lon, mid_lat, text(texto_distancia, :black, 10, :bottom))
             
    return mapa
end


# --- 2. CREACI√ìN DE OBJETOS (INSTANCIACI√ìN) ---

println("--- Creando objetos a partir del molde ---")

# [1 üìç] INSTANCIACI√ìN: Construyendo los objetos usando el 'struct'
punto_origen = PuntoEspacial(4.6097, -74.0817, "Bogot√°")
punto_destino = PuntoEspacial(6.2442, -75.5812, "Medell√≠n")
# Creamos un punto sin nombre para comprobar el comportamiento por defecto
punto_misterioso = PuntoEspacial(12.5847, -81.7006)

# [2 üí¨] REPRESENTACI√ìN: Al imprimir, Julia aplica el formato definido en Base.show
println(punto_origen)
println(punto_destino)
println(punto_misterioso)

println("\n--- Usando los m√©todos del objeto ---")

# [3 üìê] M√âTODOS ANAL√çTICOS: Calculamos las distancias din√°micamente
resultado_km = distancia_hacia(punto_origen, punto_destino)
@printf("La distancia desde %s hasta %s es: %.2f km\n", punto_origen.nombre, punto_destino.nombre, resultado_km)

# Truco de conversi√≥n
resultado_metros = distancia_hacia(punto_origen, punto_destino, radio=6371000.0)
@printf("O expresado en metros: %.2f m\n", resultado_metros)

# [4 üó∫Ô∏èüìê] M√âTODO GR√ÅFICO: Generamos y visualizamos el mapa
mapa_final = graficar_ruta(punto_origen, punto_destino)
mapa_final
```

:::
:::

::: {.callout-note}
#### Nota T√©cnica: El Motor de Interoperabilidad Geom√°tica
Si revisas el c√≥digo fuente de este documento Quarto, notar√°s que en **Julia** estamos usando dos funciones especiales llamadas `j_eval()` y `j_plot()`, en lugar del bloque de c√≥digo est√°ndar. Esto se debe a que estamos usando un Motor de Interoperabilidad que conecta R y Julia por debajo.
Para garantizar que la memoria se mantenga y el gr√°fico se exporte correctamente en el PDF/HTML, usamos `j_eval()` para compilar la l√≥gica, y `j_plot()` **√∫nicamente** al final para pedirle a la librer√≠a de gr√°ficos que procese la imagen.
:::

```{r}
#| label: julia_clases
#| results: asis
#| echo: false
#| fig-align: center
#| code-fold: true
#| out-width: "70%"
#| fig-pos: "H"

# 1. EVALUAMOS LA L√ìGICA EN LA SESI√ìN DE JULIA
j_eval(r"-(
# --- MAGIA NEGRA PARA DOCKER ---
ENV["GKSwstype"] = "100" 

using Printf
using Plots  

# --- 0. FUNCI√ìN MATEM√ÅTICA DE APOYO ---
function haversine(lat1, lon1, lat2, lon2; radio=6371.0)
    a = sin(deg2rad(lat2 - lat1) / 2)^2 + cos(deg2rad(lat1)) * cos(deg2rad(lat2)) * sin(deg2rad(lon2 - lon1) / 2)^2
    return radio * (2 * atan(sqrt(a), sqrt(1 - a)))
end

# --- 1. DEFINICI√ìN DE LA CLASE (MOLDE) ---

# [1 üìç] 1.1 EL CONSTRUCTOR (LA ESTRUCTURA)
struct PuntoEspacial
    latitud::Float64
    longitud::Float64
    nombre::String
end

# Constructor auxiliar para valores por defecto
PuntoEspacial(lat, lon) = PuntoEspacial(lat, lon, "Punto sin nombre")


# [2 üí¨] 1.2 LA REPRESENTACI√ìN TEXTUAL
# Sobrescribimos show para controlar c√≥mo se ve el objeto al imprimirlo
function Base.show(io::IO, obj::PuntoEspacial)
    print(io, "[$(obj.nombre)] (Lat: $(obj.latitud), Lon: $(obj.longitud))")
end


# [3 üìê] 1.3 M√âTODOS ANAL√çTICOS (DESPACHO M√öLTIPLE)
function distancia_hacia(origen::PuntoEspacial, destino::PuntoEspacial; radio=6371.0)
    return haversine(origen.latitud, origen.longitud, destino.latitud, destino.longitud, radio=radio)
end


# [4 üó∫Ô∏èüìê] 1.4 M√âTODO GR√ÅFICO (GENERACI√ìN DE MAPA)
function graficar_ruta(origen::PuntoEspacial, destino::PuntoEspacial)
    dist = distancia_hacia(origen, destino)
    lons = [origen.longitud, destino.longitud]
    lats = [origen.latitud, destino.latitud]
    nombres = [origen.nombre, destino.nombre]
    
    mid_lon = (origen.longitud + destino.longitud) / 2
    mid_lat = (origen.latitud + destino.latitud) / 2
    
    mapa = plot(aspect_ratio=:equal, legend=false,
                xlabel="Longitud", ylabel="Latitud", title="Mapa Cartogr√°fico Est√°tico")
                
    try
        texto_json = Base.read("./data/COL.geo.json", String)
        idx_inicio = findfirst("[[[", texto_json)
        idx_fin = findlast("]]]", texto_json)
        
        if idx_inicio !== nothing && idx_fin !== nothing
            bloque = texto_json[last(idx_inicio)+1 : first(idx_fin)-1]
            puntos = split(bloque, "],[")
            xs, ys = Float64[], Float64[]
            
            for pt in puntos
                limpio = replace(pt, "[" => "", "]" => "", " " => "")
                vals = split(limpio, ",")
                push!(xs, parse(Float64, vals[1]))
                push!(ys, parse(Float64, vals[2]))
            end
            plot!(mapa, xs, ys, seriestype=:shape, fillcolor=:lightgrey, linecolor=:white)
        end
    catch e
        annotate!(mapa, mid_lon, mid_lat + 1.5, text("(Sin mapa base)", :gray, 9))
    end
    
    plot!(mapa, lons, lats, linecolor=:red, linewidth=2)
    scatter!(mapa, lons, lats, color=:blue, markersize=6, series_annotations=text.(nombres, :bottom))
    annotate!(mapa, mid_lon, mid_lat, text(" $(round(dist, digits=2)) km", :black, 10, :bottom))
             
    return mapa
end

# --- 2. CREACI√ìN DE OBJETOS E INSTANCIACI√ìN ---
println("--- Creando objetos a partir del molde ---")

# [1 üìç] INSTANCIACI√ìN: Creamos los puntos origen y destino en la memoria global
global punto_origen = PuntoEspacial(4.6097, -74.0817, "Bogot√°")
global punto_destino = PuntoEspacial(6.2442, -75.5812, "Medell√≠n")
global punto_misterioso = PuntoEspacial(12.5847, -81.7006)

# [2 üí¨] REPRESENTACI√ìN: Julia activa autom√°ticamente Base.show()
println(punto_origen)
println(punto_destino)
println(punto_misterioso)

println("\n--- Usando los m√©todos del objeto ---")

# [3 üìê] M√âTODOS ANAL√çTICOS: El despacho m√∫ltiple elige la funci√≥n correcta
resultado_km = distancia_hacia(punto_origen, punto_destino)
@printf("La distancia desde %s hasta %s es: %.2f km\n", punto_origen.nombre, punto_destino.nombre, resultado_km)

resultado_metros = distancia_hacia(punto_origen, punto_destino, radio=6371000.0)
@printf("O expresado en metros: %.2f m\n", resultado_metros)

# [4 üó∫Ô∏èüìê] M√âTODO GR√ÅFICO: Generamos el mapa y lo guardamos directamente en el disco
mapa_final = graficar_ruta(punto_origen, punto_destino)
savefig(mapa_final, "mapa_julia_poo.png")
)-")

# Le decimos a R/Quarto que lea la imagen generada por Julia
knitr::include_graphics("mapa_julia_poo.png")
```

:::

### Los pilares de la POO en Geom√°tica (sin complicaciones)

Aunque nuestro objetivo principal ha sido organizar el c√≥digo, sin darte cuenta acabas de implementar los dos pilares m√°s poderosos de la **Programaci√≥n Orientada a Objetos (POO)**. No son conceptos abstractos de libros; son herramientas reales que acabas de usar en tus mapas:

#### 1. Abstracci√≥n: El arte de la "Caja Negra"

Cuando llamaste al m√©todo `punto_origen.distancia_hacia(punto_destino)`, aplicaste la **Abstracci√≥n**. 

* **Lo que ves:** Una simple orden que te devuelve un n√∫mero.
* **Lo que ignoras:** Los senos, cosenos, arcosenos y conversiones a radianes de la f√≥rmula de Haversine.

Abstraer es **simplificar la realidad**. En geom√°tica, esto es vital: no queremos pensar en la curvatura de la Tierra cada vez que medimos un predio; queremos una herramienta que "sepa hacerlo" y nos entregue el resultado. Al crear la clase o estructura, convertiste una matem√°tica compleja en un bot√≥n f√°cil de presionar.

#### 2. Encapsulamiento: El "Todo Incluido"

Recuerda nuestra analog√≠a del **porta-comidas** o el **Food Truck**. Al crear el objeto `PuntoEspacial`, aplicaste el **Encapsulamiento**.

En lugar de tener la latitud por un lado, el nombre por otro y la funci√≥n de medir flotando en un archivo perdido, lo encerraste todo en una sola "c√°psula".

* **El beneficio:** Tus datos est√°n protegidos. Sabes que el m√©todo `distancia_hacia` solo funciona con los datos que est√°n dentro de esa c√°psula. Esto evita que, en un proyecto grande con miles de puntos, termines midiendo accidentalmente la distancia entre el nombre de una ciudad y la temperatura de otra.

> **En resumen:** La **Abstracci√≥n** oculta la complejidad matem√°tica y el **Encapsulamiento** mantiene tus datos ordenados y seguros dentro de una misma entidad.


### El motor bajo el cap√≥: Despacho y Velocidad

A lo largo del cap√≠tulo vimos c√≥mo se estructuran las clases, pero queda una pregunta cr√≠tica: **¬øPor qu√© Julia es tan famoso por su velocidad frente a R y Python en c√°lculos cient√≠ficos pesados?** La respuesta no est√° en la sintaxis, sino en dos conceptos fundamentales que ocurren tras bambalinas: el tipo de despacho y el momento en que se procesa.

1. **Python (Despacho Interno):** Act√∫a como un **Food Truck aut√≥nomo**. El objeto es el due√±o de sus m√©todos. Cuando llamas a `punto.distancia()`, Python busca dentro del objeto `punto` y ejecuta su propia herramienta integrada. Es muy intuitivo, pero cargar "una cocina completa" dentro de cada objeto consume mucha memoria si tienes millones de ellos.
2. **R (Despacho Simple en Runtime):** Act√∫a como un **inspector de correos perezoso**. R usa funciones gen√©ricas; cuando llamas a `distancia(origen, destino)`, R solo mira el "post-it" (la clase) del *primer* argumento (`origen`). Luego, busca manualmente en su directorio qu√© funci√≥n usar y la ejecuta. Como R hace esto en "Tiempo de Ejecuci√≥n" (*Runtime*), si tienes un ciclo con un mill√≥n de coordenadas, R se detiene a leer el post-it un mill√≥n de veces. ¬°Ese papeleo es lo que lo hace lento!
3. **Julia (Despacho M√∫ltiple + Compilaci√≥n JIT):** Act√∫a como una **f√°brica industrial l√°ser**. Cuando llamas a `distancia(origen, destino)`, el compilador revisa con l√°ser las etiquetas de *todos* los ingredientes al mismo tiempo. Pero el verdadero secreto es *cu√°ndo* lo hace: la primera vez que Julia ve esa combinaci√≥n, detiene el tiempo, traduce la receta a **c√≥digo de m√°quina nativo** (ceros y unos hiper-optimizados) y construye un "tubo de ensamblaje" directo (Compilaci√≥n *Just-In-Time* o JIT). Las siguientes 999,999 veces del ciclo, los datos pasan por el tubo a la velocidad de la luz sin leer etiquetas.

*La siguiente analog√≠a visualiza las diferencias entre los tres motores de ejecuci√≥n:*

![**Analog√≠a de los motores de ejecuci√≥n:** El Food Truck aut√≥nomo (Python), la lenta Oficina de Correos de revisi√≥n manual (R) y la veloz F√°brica Industrial L√°ser (Julia).](./images/comparativa_despacho_python_r_julia.png){#fig-analogia-motores fig-align="center" width="85%"}

T√©cnicamente, podemos estructurar el flujo de decisiones de cada motor mediante el siguiente diagrama:

```{mermaid}
%%| label: fig-diagrama-motores
%%| fig-cap: "Flujo l√≥gico de los motores de ejecuci√≥n: Python, R y Julia."
%%| fig-width: 6.5
%%| out-width: 80%
%%| fig-align: center
%%| fig-responsive: true

flowchart LR
    %% ESTILOS DE LOS NODOS (Pasteles para que resalten)
    classDef python fill:#FDEBD0,stroke:#F39C12,stroke-width:2px,color:#7E5109,font-size:14px
    classDef rlang fill:#E8F8F5,stroke:#2ECC71,stroke-width:2px,color:#145A32,font-size:14px
    classDef julia fill:#EBDEF0,stroke:#8E44AD,stroke-width:2px,color:#512E5F,font-size:14px
    classDef action fill:#EAEDED,stroke:#34495E,stroke-width:1px,color:#2C3E50,font-size:13px
    classDef decision fill:#EAEDED,stroke:#34495E,stroke-width:1px,color:#2C3E50,font-size:13px,shape:diamond
    
    %% SUBGRAFO PYTHON
    subgraph PY ["üêç PYTHON (POO Cl√°sica)"]
        direction TB
        P1["Objeto llama a su m√©todo<br/>obj.distancia(destino)"]:::python
        P2["El objeto busca en su<br/>propio inventario interno"]:::action
        P3["Ejecuci√≥n Est√°ndar"]:::python
        P1 --> P2 --> P3
    end
    %% FUERZA BRUTA: Pintamos el fondo de la caja de Python de blanco
    style PY fill:#ffffff,stroke:#cccccc,stroke-width:2px,color:#000000

    %% SUBGRAFO R
    subgraph RL ["üîµ R (Despacho Simple + Runtime)"]
        direction TB
        R1["Funci√≥n Gen√©rica<br/>distancia(origen, destino)"]:::rlang
        R2["Revisa S√ìLO la clase<br/>del PRIMER objeto"]:::action
        R3{"B√∫squeda<br/>en manual"}:::decision
        R4["Ejecuci√≥n lenta<br/>(Se repite en cada ciclo)"]:::rlang
        R1 --> R2 --> R3 --> R4
    end
    %% FUERZA BRUTA: Pintamos el fondo de la caja de R de blanco
    style RL fill:#ffffff,stroke:#cccccc,stroke-width:2px,color:#000000

    %% SUBGRAFO JULIA
    subgraph JU ["üü£ JULIA (Despacho M√∫ltiple + JIT)"]
        direction TB
        J1["Funci√≥n Libre<br/>distancia(origen, destino)"]:::julia
        J2["Escanea los tipos exactos<br/>de TODOS los argumentos"]:::action
        J3{"1ra Vez:<br/>Compila a<br/>C√≥digo M√°quina"}:::decision
        J4["Ejecuci√≥n Velocidad Luz<br/>(Pasa directo por el tubo)"]:::julia
        J1 --> J2 --> J3 --> J4
    end
    %% FUERZA BRUTA: Pintamos el fondo de la caja de Julia de blanco
    style JU fill:#ffffff,stroke:#cccccc,stroke-width:2px,color:#000000

    %% ALINEACI√ìN HORIZONTAL
    PY ~~~ RL ~~~ JU
```


### Resumen de sintaxis: programaci√≥n orientada a objetos

Como pudiste observar, cada lenguaje aborda las clases con una filosof√≠a arquitect√≥nica distinta: Python encapsula los m√©todos dentro del objeto, R usa funciones sueltas que leen etiquetas invisibles (S3), y Julia usa estructuras r√≠gidas con funciones que exigen el tipo de dato exacto (despacho m√∫ltiple).

| Caracter√≠stica | Python (POO Cl√°sica) | R (Sistema S3) | Julia (Despacho M√∫ltiple) |
| :--- | :--- | :--- | :--- |
| **Definir Molde** | `class Objeto:` | Funci√≥n que retorna una `list()` | `struct Objeto ... end` |
| **Constructor** | `def __init__(self):` | Asignar etiqueta: `class(obj) <- 'Tipo'` | `Objeto()` (Autom√°tico o expl√≠cito) |
| **Auto-referencia**| Usa la palabra `self` | Pasa el objeto `obj` como argumento | Pasa el objeto tipado `obj::Tipo` |
| **M√©todos** | Van dentro de `class` | Gen√©rico (`UseMethod`) + `metodo.Clase` | Funciones independientes enrutadas por tipo |
| **Representaci√≥n** | `def __str__(self):` | `print.Clase <- function(obj)` | `Base.show(io, obj::Clase)` |

: Diferencias en la creaci√≥n de Clases y Objetos {#tbl-clases_objetos tbl-colwidths="[20,26,27,27]"}



## Gu√≠as de dise√±o para funciones y clases

Escribir c√≥digo que la m√°quina entienda es f√°cil; escribir c√≥digo que otro ser humano (o usted mismo en seis meses) pueda entender, es un arte. Ya sea que est√© usando el molde estricto de Python, las etiquetas de R o los chefs de Julia, existen reglas de oro universales para que su arquitectura sea s√≥lida, limpia y profesional.

A continuaci√≥n, presentamos los mandamientos del buen dise√±o de software para la ciencia de datos.

### 1. El dise√±o de Funciones: los obreros de la obra

Las funciones son la unidad b√°sica de acci√≥n en su c√≥digo. Si sus funciones son un enredo, todo el proyecto lo ser√°.



* **Hagan una sola cosa (Single Responsibility):** Una funci√≥n debe tener un √∫nico prop√≥sito claro. Si su funci√≥n descarga los datos, los limpia, calcula la distancia y de paso le imprime un mapa, est√° haciendo demasiado. Div√≠dala en cuatro funciones peque√±as. La navaja suiza es √∫til para acampar, pero en programaci√≥n es un peligro.
* **Nombres que cuenten la historia:** El nombre de una funci√≥n debe ser un verbo que describa exactamente su acci√≥n. Evite abreviaturas jerogl√≠ficas. Es preferible escribir `calcular_distancia_km()` que `calc_dist()`. 
* **Evite las "novelas" (Mantenlas cortas):** Si el cuerpo de su funci√≥n no cabe en la pantalla de su monitor sin hacer *scroll*, es momento de machetearla y dividirla. Las funciones cortas son f√°ciles de testear y rara vez esconden errores.
* **Sin efectos secundarios (Pureza):** Lo ideal es que una funci√≥n reciba datos, haga su trabajo y devuelva un resultado sin alterar silenciosamente variables globales u otras partes del sistema. Lo que pasa en la funci√≥n, se queda en la funci√≥n.

::: {.callout-tip title="La regla DRY (Don't Repeat Yourself)"}
"No te repitas". Si usted se descubre copiando y pegando el mismo bloque de c√≥digo tres veces seguidas y solo cambi√°ndole una variable, det√©ngase. Ese bloque debe convertirse inmediatamente en una funci√≥n.
:::

---

### 2. El dise√±o de Clases (y Estructuras): los cimientos del edificio

Cuando decida agrupar sus datos y funciones en un objeto o estructura, h√°galo con prudencia. No todo necesita ser una clase.



* **Alta cohesi√≥n:** Todo lo que viva dentro de su clase (o `struct`) debe estar √≠ntimamente relacionado. Siguiendo nuestra analog√≠a, no meta la receta del sancocho en el molde de las arepas. Si un `PuntoEspacial` tiene latitud y longitud, perfecto; pero si tambi√©n le agrega un atributo para el "color_favorito_del_usuario", est√° rompiendo la cohesi√≥n.
* **Oculte las tuber√≠as (Encapsulamiento):** El usuario de su objeto no necesita saber c√≥mo funcionan las matem√°ticas internamente, solo necesita el resultado. Exponga √∫nicamente los m√©todos y atributos que son estrictamente necesarios para usar el objeto (la interfaz p√∫blica) y mantenga la complejidad "escondida" en el motor.
* **Evite el "S√≠ndrome de Dios":** Una "clase Dios" es aquella que sabe demasiado y hace de todo (ej. `GestorDeMapasYDatosYCalculos`). Si su clase maneja toda la l√≥gica del proyecto, div√≠dala en objetos m√°s peque√±os y delegue responsabilidades. Un objeto `Coordenada` interact√∫a con un objeto `Mapa`, no son el mismo ente.
* **Si no hay estado, no hay clase:** Especialmente en Python y R. Si usted crea una clase que solo tiene m√©todos pero no guarda ning√∫n dato (atributos), no necesita una clase; lo que usted necesita es un simple archivo con funciones sueltas.

### 3. Comentarios y documentaci√≥n

* **El c√≥digo explica el *Qu√©*, el comentario explica el *Por qu√©*:** No escriba comentarios obvios como `# Esto suma 2 + 2`. Use los comentarios para explicar decisiones de negocio o atajos matem√°ticos: `# Usamos la f√≥rmula de Haversine porque es m√°s precisa para distancias cortas`.
* **Docstrings siempre:** Todo molde (clase/struct) y toda funci√≥n importante debe tener una breve cadena de documentaci√≥n en la parte superior explicando qu√© recibe (argumentos) y qu√© devuelve (retorno).


## Resumen de aprendizajes (cheat sheet)

¬°Felicidades! Has completado uno de los cap√≠tulos m√°s densos y fundamentales para tu carrera como analista espacial. Al dominar las funciones y los objetos, has pasado de escribir "scripts desechables" a construir herramientas profesionales. 

Repasemos los conceptos clave que te llevas en la mochila:

* **Las funciones son m√°quinas:** Reciben ingredientes (par√°metros), aplican una l√≥gica interna sin afectar el entorno exterior (pureza), y devuelven un resultado procesado. Son la m√°xima expresi√≥n de la regla DRY (*Don't Repeat Yourself*).
* **Par√°metros din√°micos:** Aprendiste a usar `**kwargs` (Python), `...` (R) y `kwargs...` (Julia) para atrapar un n√∫mero indefinido de variables, d√°ndole flexibilidad total a tus herramientas.
* **La POO no es igual en todas partes:**
  * **Python (Molde estricto):** Usa Clases formales. El objeto lleva sus propios datos y herramientas por dentro. El despacho es interno (`objeto.metodo()`).
  * **R (Sistema S3 flexible):** Construye listas est√°ndar y les pega una "etiqueta" (post-it). Las funciones gen√©ricas leen la etiqueta y despachan el trabajo a la herramienta adecuada.
  * **Julia (Estructuras y Despacho M√∫ltiple):** Separa radicalmente los datos (en `structs` r√≠gidos) de las funciones. El Jefe de Cocina (compilador) escanea los tipos de todos los ingredientes y compila una tuber√≠a de alta velocidad (JIT) para ejecutarlos.
* **Dise√±o limpio:** Un buen c√≥digo se lee como un buen libro. Mant√©n tus funciones enfocadas en una sola tarea, dise√±a clases con alta cohesi√≥n y nunca olvides explicar el *por qu√©* en tus comentarios.

A continuaci√≥n, se presenta tu **Hoja de Referencia (Cheat Sheet)** para traducir la sintaxis de estos conceptos entre Python, R y Julia.

### 1. Estructura de funciones

| Caracter√≠stica | Python | R | Julia |
| :--- | :--- | :--- | :--- |
| **Declaraci√≥n** | `def calc(x):` | `calc <- function(x) { }` | `function calc(x) ... end` |
| **Retorno** | `return y` | `return(y)` | `return y` |
| **Par√°metro x defecto** | `def calc(r=6371):` | `function(r=6371)` | `function calc(; r=6371)` |
| **M√∫ltiples args extra**| `**kwargs` | `...` | `kwargs...` |

: Diferencias en el empaquetado y argumentos de funciones {#tbl-funciones_argumentos tbl-colwidths="[25,25,25,25]"}

### 2. Programaci√≥n Orientada a Objetos (POO)

| Caracter√≠stica | Python (POO Cl√°sica) | R (Sistema S3) | Julia (Despacho M√∫ltiple) |
| :--- | :--- | :--- | :--- |
| **Definir Molde** | `class Objeto:` | Funci√≥n que retorna una `list()` | `struct Objeto ... end` |
| **Constructor** | `def __init__(self):` | Asignar etiqueta: `class(obj) <- 'Tipo'` | `Objeto()` (Autom√°tico o expl√≠cito) |
| **Auto-referencia**| Usa la palabra `self` | Pasa el objeto `obj` como argumento | Pasa el objeto tipado `obj::Tipo` |
| **M√©todos** | Van dentro de `class` | Gen√©rico (`UseMethod`) + `metodo.Clase` | Funciones independientes enrutadas por tipo |
| **Representaci√≥n** | `def __str__(self):` | `print.Clase <- function(obj)` | `Base.show(io, obj::Clase)` |

: Diferencias en la creaci√≥n de Clases y Objetos {#tbl-clases_objetos tbl-colwidths="[20,26,27,27]"}


## Ejercicios

Para poner en pr√°ctica los conceptos aprendidos sobre encapsulamiento y dise√±o de objetos, deber√°s resolver los siguientes dos ejercicios. Puedes elegir resolverlos en **Python, R o Julia** (o implementar la soluci√≥n en varios lenguajes si deseas retarte).

### Ejercicio 1: El cazador de coordenadas (Funciones y abstracci√≥n)

En geom√°tica, a menudo necesitamos saber cu√°l es la "caja delimitadora" (*Bounding Box*) de un conjunto de puntos para encuadrar un mapa. 

* Escribe una funci√≥n pura llamada `calcular_bbox` que reciba una lista de m√∫ltiples coordenadas (latitud, longitud).
* La funci√≥n debe recorrer la lista internamente y devolver cuatro valores: la latitud m√≠nima, la latitud m√°xima, la longitud m√≠nima y la longitud m√°xima.
* Aseg√∫rate de que la funci√≥n incluya una cadena de documentaci√≥n (Docstring) o comentarios claros explicando qu√© entra y qu√© sale.

### Ejercicio 2: Modelando una ruta espacial (Clases e interacci√≥n)

Vamos a llevar los objetos al siguiente nivel haciendo que interact√∫en entre s√≠. Toma el c√≥digo base del `PuntoEspacial` que desarrollamos en este cap√≠tulo y crea una nueva estructura superior:

* Crea una clase (o sistema S3 / struct en Julia) llamada `RutaGeografica`.
* Su constructor debe recibir un nombre (ej. "Ruta de los Andes") y una lista vac√≠a que almacenar√° objetos del tipo `PuntoEspacial`.
* Escribe un m√©todo `agregar_punto()` que reciba un objeto `PuntoEspacial` y lo guarde en la lista interna de la ruta.
* Escribe un m√©todo `medir_distancia_total()` que use un ciclo para sumar la distancia de todos los tramos de la ruta, llamando al m√©todo `distancia_hacia()` que los puntos ya tienen integrado. 


### Entregables y criterios de evaluaci√≥n

El objetivo de esta evaluaci√≥n no es solo que el c√≥digo funcione, sino que seas capaz de documentar y explicar tus decisiones de arquitectura de software y el comportamiento del motor de ejecuci√≥n subyacente.

**1. Archivos de C√≥digo:**
Debes desarrollar los algoritmos en al menos uno de los siguientes formatos de archivo:

* Script tradicional (`.py`, `.R`, `.jl`)
* Notebook interactivo (`.ipynb`)
* Documento computacional (`.qmd` con *chunks* de c√≥digo)

**2. Documento Anal√≠tico (Quarto):**
Independientemente del formato de tu c√≥digo fuente, **debes redactar un documento en Quarto (`.qmd`) y renderizarlo tanto en HTML como en PDF**. En este documento debes incluir tus bloques de c√≥digo y responder argumentativamente a las siguientes preguntas:

* **Sobre el Ejercicio 1 (Regla DRY y Pureza):** Explica con tus propias palabras qu√© es la regla DRY (*Don't Repeat Yourself*). ¬øPor qu√© es un riesgo para la mantenibilidad de un proyecto copiar y pegar la gran f√≥rmula matem√°tica de Haversine en m√∫ltiples partes de tu c√≥digo en lugar de usar la funci√≥n que creaste?
* **Sobre el Ejercicio 2 (Paradigmas de POO):** Si resolviste (o resolvieras) este ejercicio en **Python**, ¬ød√≥nde "viven" f√≠sicamente los m√©todos anal√≠ticos como `medir_distancia_total()`? Contrasta esta filosof√≠a con el enfoque del **Sistema S3 de R**. Usa la analog√≠a del "Molde" vs el "Post-it" vista en clase para explicarlo.
* **Pregunta General (Eficiencia y Motores):** Imagina que tu `RutaGeografica` tiene 5 millones de puntos recolectados por un GPS y necesitas calcular la distancia total. Si usar√°s **Julia**, explica brevemente c√≥mo la combinaci√≥n del **Despacho M√∫ltiple** y la **Compilaci√≥n JIT** lograr√≠a ejecutar este c√°lculo masivo mucho m√°s r√°pido que el int√©rprete est√°ndar de R.

**3. Repositorio en GitHub:**
Sube tu carpeta del proyecto (que debe contener tus scripts, el archivo `.qmd` y los renders finales en HTML y PDF) a un repositorio p√∫blico en tu cuenta personal de **GitHub**.

* **Entrega:** Deber√°s enviar √∫nicamente el enlace (URL) a tu repositorio de GitHub para la calificaci√≥n.