---
# Este bloque vacío obliga a Quarto a entender que aquí empieza un documento nuevo
---

# Variables y tipos de datos {#sec-variables_tipos_datos}

## Funciones j_eval y j_plot en R

```{r}
#| label: j_eval_j_plot
#| code-fold: true
# #| include: false
source("./docs/j_eval_j_plot.r")
```



## Introducción

En el análisis espacial, un dato nunca es solo un número o una letra; es la representación digital de un fenómeno físico. La latitud de una estación GPS, el nombre de un municipio en una tabla de atributos o la firma espectral de una imagen satelital deben almacenarse en la memoria del computador de una forma específica para poder procesarse.

Una **variable** actúa como un contenedor etiquetado en la memoria del sistema, permitiéndonos guardar, recuperar y manipular esa información. Sin embargo, la forma en que **Python**, **R** y **Julia** gestionan estos contenedores varía significativamente.

![Abstracción de una Variable: En lenguajes modernos como Python o R, funciona más como una etiqueta que apunta a un objeto en memoria.](images/variables.png){#fig-concepto-variable width=50%}

Entender la diferencia entre un entero (`int`) y un decimal de doble precisión (`float64`) no es solo una curiosidad informática: en geomática, usar el tipo de dato incorrecto puede significar la diferencia entre localizar un punto con precisión milimétrica o desviarlo por cientos de metros debido a errores de redondeo. Este capítulo sienta las bases para manipular la "materia prima" de cualquier Sistema de Información Geográfica (SIG).

## Objetivos de aprendizaje

Al finalizar este capítulo, el estudiante estará en capacidad de:

1.  **Definir y asignar variables** correctamente en Python, R y Julia, comprendiendo las diferencias de sintaxis y asignación de memoria.
2.  **Diferenciar tipos de datos fundamentales** (enteros, flotantes, cadenas y lógicos) y seleccionar el más adecuado para optimizar el almacenamiento de datos masivos (Big Data Geoespacial).
3.  **Manipular cadenas de texto** para la limpieza y estandarización automática de tablas de atributos (corrección de mayúsculas, eliminación de espacios, interpolación).
4.  **Aplicar formatos de precisión** para controlar la salida de coordenadas y datos numéricos en reportes técnicos.
5.  **Comprender la mutabilidad**, distinguiendo cuándo una operación modifica los datos originales (Python/Julia) y cuándo genera una copia nueva (R).

## Variables

| Lenguaje | Operador de asignación | Comando para imprimir | Descripción y Alternativas |
| :- | :-: | :-: | :-------- |
| **Python** | `=` | `print()` | El operador `=` es el estándar único para asignación. Para imprimir, `print()` añade automáticamente un salto de línea. En entornos interactivos, se puede usar `display()` para una representación visual más rica. |
| **R** | `<-` | `print()` | Aunque `=` funciona, se prefiere `<-`. Además de `print()`, existe `cat()`, útil para concatenar texto sin mostrar índices de vector. |
| **Julia** | `=` | `println()` | Se usa `=` para asignación. `println()` imprime con salto de línea, mientras que `print()` lo hace sin él. Al igual que en Python, existe `display()`. |

: Comparación de sintaxis básica entre Python, R y Julia {#tbl-comp_sintaxis_basica}

::: {.panel-tabset}


### Python

::: {.content-visible when-format="html"}
::: {.callout-tip collapse="true" icon="false"}
#### ▷ CÓDIGO PURO (Copiar y Pegar)
```{python}
#| label: python_variables_codigo
#| eval: false

#Variable numérica
numero_dptos = 32

#Imprimir
print(numero_dptos)

#Ver contenido (en modo interactivo)
numero_dptos
```
:::
:::


```{python}
#| label: python_variables
# #| eval: false
#Variable numérica
numero_dptos = 32

#Imprimir
print(numero_dptos)

#Ver contenido (en modo interactivo)
numero_dptos
```

### R

::: {.content-visible when-format="html"}
::: {.callout-tip collapse="true" icon="false"}
#### ▷ CÓDIGO PURO (Copiar y Pegar)
```{r}
#| label: r_variables_codigo
#| eval: false

# Variable numérica (en R se prefiere el operador <-)
numero_dptos <- 32

# Imprimir
print(numero_dptos)

# Ver contenido
numero_dptos
```
:::
:::

```{r}
#| label: r_variables
# #| eval: false
# Variable numérica (en R se prefiere el operador <-)
numero_dptos <- 32

# Imprimir
print(numero_dptos)

# Ver contenido
numero_dptos
```

### Julia

::: {.content-visible when-format="html"}
::: {.callout-tip collapse="true" icon="false"}
#### ▷ CÓDIGO PURO (Copiar y Pegar)
```{julia}
#| label: julia_variables_codigo
#| eval: false

# Variable numérica
numero_dptos = 32

# Imprimir
println(numero_dptos)

# Ver contenido
numero_dptos
```
:::
:::

```{r}
#| label: julia_variables
#| results: asis
# #| eval: false
j_eval('
# Variable numérica
numero_dptos = 32

# Imprimir
println(numero_dptos)

# Ver contenido
numero_dptos

atributos_elemento
')
```

:::


### Asignación de variables

| Lenguaje | Colección Base | Operador | Descripción y Flexibilidad |
|:-|:--:|:-:|:-------|
| **Python** | Lista `[]` | `=` | Permite mezclar tipos en una lista. Es dinámico y **fuerte**: no permite operaciones inválidas entre tipos (ej. sumarle un texto a un número). |
| **R** | Vector `c()` | `<-` | El vector atómico (`c`) exige que todos los elementos sean del mismo tipo. Si se mezclan, R los convierte automáticamente (coerción). |
| **Julia** | Arreglo `[]` | `=` | Muy similar a la lista de Python pero optimizado para rendimiento. Es dinámico pero permite declarar tipos para ganar velocidad. |

: Estructuras de datos y comportamiento de asignación {#tbl-estructuras_reasignacion tbl-colwidths="[15,20,15,50]"}

### Conceptos clave de programación

Para entender cómo estos lenguajes manejan la información de la @tbl-estructuras_reasignacion, es fundamental diferenciar los sistemas de tipado:

1. **Tipado Dinámico:** El tipo de la variable se define en tiempo de ejecución. No es necesario declarar que una variable es un entero o un texto antes de usarla; el lenguaje lo infiere. (Python, R y Julia son dinámicos).
2. **Tipado Estático:** El tipo de la variable debe definirse al momento de escribir el código (ej. C++ o Java). Una vez definida como "entero", no puede guardar texto. Esto previene errores antes de ejecutar el programa.
3. **Tipado Fuerte:** El lenguaje no permite operaciones entre tipos incompatibles sin una conversión explícita. Por ejemplo, en **Python**, `5 + "10"` arrojará un error.
4. **Tipado Débil:** El lenguaje intenta realizar conversiones automáticas (coerción) para que la operación funcione. En **R**, si intentas unir un número y un texto en un vector `c(1, "Bogotá")`, R convertirá el `1` en texto `"1"` silenciosamente.

![Comparativa de Tipado: La flexibilidad tiene un costo en seguridad, pero gana en velocidad de desarrollo.](images/tipado_estatico_dinamico.png){#fig-tipado width=60%}

::: {.panel-tabset}


#### Python

::: {.content-visible when-format="html"}
::: {.callout-tip collapse="true" icon="false"}
##### ▷ CÓDIGO PURO (Copiar y Pegar)
```{python}
#| label: python_asignacion_variables_codigo
#| eval: false

# Iniciar con un número (Latitud de Monserrate)
datos_ubicacion = 4.6052

# Cambiar a texto (Nombre del lugar)
datos_ubicacion = "Cerro de Monserrate"

# Cambiar a una lista de coordenadas [Lat, Lon]
datos_ubicacion = [4.6052, -74.0554]

# Imprimir resultado final
print(datos_ubicacion)
```
:::
:::


```{python}
#| label: python_asignacion_variables
# #| eval: false
# Iniciar con un número (Latitud de Monserrate)
datos_ubicacion = 4.6052

# Cambiar a texto (Nombre del lugar)
datos_ubicacion = "Cerro de Monserrate"

# Cambiar a una lista de coordenadas [Lat, Lon]
datos_ubicacion = [4.6052, -74.0554]

# Imprimir resultado final
print(datos_ubicacion)
```

#### R

::: {.content-visible when-format="html"}
::: {.callout-tip collapse="true" icon="false"}
##### ▷ CÓDIGO PURO (Copiar y Pegar)
```{r}
#| label: r_asignacion_variables_codigo
#| eval: false

# Iniciar con un número (Latitud de Monserrate)
datos_ubicacion <- 4.6052

# Cambiar a texto (Nombre del lugar)
datos_ubicacion <- "Cerro de Monserrate"

# Cambiar a un vector de coordenadas (c es para combinar/concatenar)
datos_ubicacion <- c(4.6052, -74.0554)

# Imprimir resultado final
print(datos_ubicacion)
```
:::
:::

```{r}
#| label: r_asignacion_variables
# #| eval: false
# Iniciar con un número (Latitud de Monserrate)
datos_ubicacion <- 4.6052

# Cambiar a texto (Nombre del lugar)
datos_ubicacion <- "Cerro de Monserrate"

# Cambiar a un vector de coordenadas (c es para combinar/concatenar)
datos_ubicacion <- c(4.6052, -74.0554)

# Imprimir resultado final
print(datos_ubicacion)
```

#### Julia

::: {.content-visible when-format="html"}
::: {.callout-tip collapse="true" icon="false"}
##### ▷ CÓDIGO PURO (Copiar y Pegar)
```{julia}
#| label: julia_asignacion_variables_codigo
#| eval: false

# Iniciar con un número (Latitud de Monserrate)
datos_ubicacion = 4.6052

# Cambiar a texto (Nombre del lugar)
datos_ubicacion = "Cerro de Monserrate"

# Cambiar a un arreglo (Array) de coordenadas
datos_ubicacion = [4.6052, -74.0554]

# Imprimir resultado final
println(datos_ubicacion)
```
:::
:::

```{r}
#| label: julia_asignacion_variables
#| results: asis
# #| eval: false
j_eval('
# Iniciar con un número (Latitud de Monserrate)
datos_ubicacion = 4.6052

# Cambiar a texto (Nombre del lugar)
datos_ubicacion = "Cerro de Monserrate"

# Cambiar a un arreglo (Array) de coordenadas
datos_ubicacion = [4.6052, -74.0554]

# Imprimir resultado final
println(datos_ubicacion)
')
```

:::


## Nombres para las variables

**¿Por qué es clave usar nombres adecuados?**

En programación, los nombres que eliges para tus variables no son solo etiquetas; son las instrucciones que permiten que otras personas (y tú mismo en el futuro) entiendan la lógica del código sin errores. Usar nombres estandarizados es vital por las siguientes razones:

1.  **Evitar errores técnicos:** Los lenguajes de programación son muy estrictos. Un espacio, una tilde o una `ñ` pueden hacer que un programa que funciona bien en tu computadora falle al abrirlo en otra.
2.  **Claridad en la lectura:** Es mucho más fácil entender un proceso si la variable se llama `distancia_metros` en lugar de simplemente `d`.
3.  **Portabilidad:** El uso de estándares internacionales asegura que tus datos e investigaciones puedan integrarse fácilmente entre diferentes plataformas como **Python**, **R** o **Julia**.

::: {.callout-note collapse="true"}
### Resumen de Reglas de Estilo (snake_case)

Para que tus programas sean profesionales y compatibles, sigue estas reglas básicas:

* **Todo en minúsculas:** Evita mezclar mayúsculas para mantener la uniformidad.
* **Usa el guion bajo (`_`):** Dado que los espacios están prohibidos, el guion bajo une las palabras (ej. `precio_gasolina`).
* **Solo letras básicas y números:** Usa solo caracteres de la `a` a la `z`. Evita tildes, eñes o símbolos especiales (`!`, `#`, `$`).
* **Prohibido el guion medio (`-`):** El computador lo interpreta como una operación de resta.
:::

```python

#| code-summary: "Ejemplos comparativos (Python, R, Julia)"

# FORMA CORRECTA: Clara y sin errores
estacion_climatologica = "Dorado"
temperatura_celsius = 20.5
conteo_puntos_gps = 15

# FORMA INCORRECTA: Genera errores o confusión
estacion climatologica = "Dorado"  # ERROR: Los espacios no están permitidos
temperatura-celsius = 20.5         # ERROR: El guion medio intenta restar
t = 20.5                           # MAL: Es una variable muy vaga
año_inicio = 2024                  # EVITAR: La 'ñ' causa fallos de lectura
```

::: {.panel-tabset}


### Python

::: {.content-visible when-format="html"}
::: {.callout-tip collapse="true" icon="false"}
#### ▷ CÓDIGO PURO (Copiar y Pegar)
```{python}
#| label: python_varname_codigo
#| eval: false

# Nombres de variables recomendados
# Variables geoespaciales claras
latitud_bogota = 4.7110
longitud_bogota = -74.0721
altura_msnm = 2640.0
municipio_nombre = "Chinchiná"
conteo_viviendas_afectadas = 150
sistema_referencia = "MAGNA-SIRGAS / Origen Nacional"


# Nombres de variables NO recomendados
# Evitar nombres genéricos o confusos
x = 4.7110  # ¿Es latitud o un índice?
d = "Chinchiná"  # Muy vago (¿Distrito, Departamento, Dato?)
val = 2640  # Ambiguo: ¿Valor, Valencia, Variable?
coords = [4.71, -74.07]  # Lista sin etiquetas claras
```
:::
:::


```{python}
#| label: python_varname
# #| eval: false
# Nombres de variables recomendados
# Variables geoespaciales claras
latitud_bogota = 4.7110
longitud_bogota = -74.0721
altura_msnm = 2640.0
municipio_nombre = "Chinchiná"
conteo_viviendas_afectadas = 150
sistema_referencia = "MAGNA-SIRGAS / Origen Nacional"


# Nombres de variables NO recomendados
# Evitar nombres genéricos o confusos
x = 4.7110  # ¿Es latitud o un índice?
d = "Chinchiná"  # Muy vago (¿Distrito, Departamento, Dato?)
val = 2640  # Ambiguo: ¿Valor, Valencia, Variable?
coords = [4.71, -74.07]  # Lista sin etiquetas claras
```

### R

::: {.content-visible when-format="html"}
::: {.callout-tip collapse="true" icon="false"}
#### ▷ CÓDIGO PURO (Copiar y Pegar)
```{r}
#| label: r_varname_codigo
#| eval: false

# Nombres de variables recomendados
# Estilo snake_case (común en R para análisis de datos)
latitud_medellin <- 6.2442
longitud_medellin <- -75.5812
cota_terreno <- 1495
nombre_departamento <- "Antioquia"
poblacion_censo_2018 <- 6407000
proyeccion_cartografica <- "EPSG:9377"


# Nombres de variables NO recomendados
# Evitar abreviaturas extremas
l <- 6.2442 # ¿Latitud, Longitud, Límite, Localidad?
nom <- "Antioquia" # "nombre" es mejor
temp <- 1495 # ¿Temperatura o un archivo temporal?
p <- 6407000 # ¿Población, Perímetro, Pendiente, P-value?
```
:::
:::

```{r}
#| label: r_varname
# #| eval: false
# Nombres de variables recomendados
# Estilo snake_case (común en R para análisis de datos)
latitud_medellin <- 6.2442
longitud_medellin <- -75.5812
cota_terreno <- 1495
nombre_departamento <- "Antioquia"
poblacion_censo_2018 <- 6407000
proyeccion_cartografica <- "EPSG:9377"


# Nombres de variables NO recomendados
# Evitar abreviaturas extremas
l <- 6.2442 # ¿Latitud, Longitud, Límite, Localidad?
nom <- "Antioquia" # "nombre" es mejor
temp <- 1495 # ¿Temperatura o un archivo temporal?
p <- 6407000 # ¿Población, Perímetro, Pendiente, P-value?
```

### Julia

::: {.content-visible when-format="html"}
::: {.callout-tip collapse="true" icon="false"}
#### ▷ CÓDIGO PURO (Copiar y Pegar)
```{julia}
#| label: julia_varname_codigo
#| eval: false

# Nombres de variables recomendados
# Aprovechando el soporte Unicode de Julia
latitud_cali = 3.4516
longitud_cali = -76.5320
elevación_cauca = 995.0
nombre_vereda = "La Elvira"
densidad_poblacional = 120.5
referencia_espacial = "MAGNA-SIRGAS"


# Nombres de variables NO recomendados
# Nombres que no dicen nada del contexto geográfico
var1 = 3.4516
info = "La Elvira"
tmp = 995.0 # Típico error: ¿Temperatura o Temporal?
lista = [3.45, -76.53] # Difícil de leer en modelos de optimización
```
:::
:::

```{r}
#| label: julia_varname
#| results: asis
# #| eval: false
j_eval('
# Nombres de variables recomendados
# Aprovechando el soporte Unicode de Julia
latitud_cali = 3.4516
longitud_cali = -76.5320
elevación_cauca = 995.0
nombre_vereda = "La Elvira"
densidad_poblacional = 120.5
referencia_espacial = "MAGNA-SIRGAS"
')

j_eval('
# Nombres de variables NO recomendados
# Nombres que no dicen nada del contexto geográfico
var1 = 3.4516
info = "La Elvira"
tmp = 995.0 # Típico error: ¿Temperatura o Temporal?
lista = [3.45, -76.53] # Difícil de leer en modelos de optimización
')
```

:::


## Tipos de datos

::: {.panel-tabset}

### Python

::: {.content-visible when-format="html"}
::: {.callout-tip collapse="true" icon="false"}
#### ▷ CÓDIGO PURO (Copiar y Pegar)
```{python}
#| label: python_tipos_datos_codigo
#| eval: false

# Representa el número de elementos en un dataset geoespacial
num_elementos = 500 # Igual a num_elementos = int(500)

# Validación de tipo (Type Checking)
# Lanza un error si no es un entero, ideal para debugging en scripts de Geomatización
if not isinstance(num_elementos, int):
    raise TypeError(f"Se esperaba un entero, pero se recibió {type(num_elementos)}")

# Representa la altitud de un punto (Nevado del Ruiz)
import numpy as np
altitud_32 = np.float32(2640.5) # np.float32() para simple
altitud_64 = 2640.5   # float() es el defecto (doble)

# Representa la latitud de un punto (Nevado del Ruiz)
latitud = 4.8920  

# Representa la longitud de un punto
longitud = -75.3188  

# Representa el sistema de referencia oficial de Colombia
sistema_coordenadas = "MAGNA-SIRGAS / Origen Nacional"  

# Representa si el dataset está georreferenciado o no
esta_georeferenciado = True  

# Una lista que representa latitud y longitud
coordenadas = [4.8920, -75.3188]  

# Un diccionario con los atributos del elemento geográfico
atributos_elemento = {
    "nombre": "Nevado del Ruiz",
    "altura_msnm": 5321,
    "tipo": "Estratovolcán",
    "ubicacion": [4.8920, -75.3188],
}

print(atributos_elemento)

# Tipo de dato
type(atributos_elemento)

# Acceder a la primera coordenada (índice 0) dentro de la clave 'ubicacion'
latitud_ruiz = atributos_elemento["ubicacion"][0]
latitud_ruiz
```
:::
:::


```{python}
#| label: python_tipos_datos
# #| eval: false

# Representa el número de elementos en un dataset geoespacial
num_elementos = 500 # Igual a num_elementos = int(500)

# Validación de tipo (Type Checking)
# Lanza un error si no es un entero, ideal para debugging en scripts de Geomatización
if not isinstance(num_elementos, int):
    raise TypeError(f"Se esperaba un entero, pero se recibió {type(num_elementos)}")

# Representa la altitud de un punto (Nevado del Ruiz)
import numpy as np
altitud_32 = np.float32(2640.5) # np.float32() para simple
altitud_64 = 2640.5   # float() es el defecto (doble)

# Representa la latitud de un punto (Nevado del Ruiz)
latitud = 4.8920  

# Representa la longitud de un punto
longitud = -75.3188  

# Representa el sistema de referencia oficial de Colombia
sistema_coordenadas = "MAGNA-SIRGAS / Origen Nacional"  

# Representa si el dataset está georreferenciado o no
esta_georeferenciado = True  

# Una lista que representa latitud y longitud
coordenadas = [4.8920, -75.3188]  

# Un diccionario con los atributos del elemento geográfico
atributos_elemento = {
    "nombre": "Nevado del Ruiz",
    "altura_msnm": 5321,
    "tipo": "Estratovolcán",
    "ubicacion": [4.8920, -75.3188],
}

print(atributos_elemento)

# Tipo de dato
type(atributos_elemento)

# Acceder a la primera coordenada (índice 0) dentro de la clave 'ubicacion'
latitud_ruiz = atributos_elemento["ubicacion"][0]
latitud_ruiz
```

### R

::: {.content-visible when-format="html"}
::: {.callout-tip collapse="true" icon="false"}
#### ▷ CÓDIGO PURO (Copiar y Pegar)
```{r}
#| label: r_tipos_datos_codigo
#| eval: false

# Representa el número de elementos (L indica tipo integer)
num_elementos <- 500L  # Diferente a num_elementos = 500 (numeric)

# Validación del tipo de dato
if (!is.integer(num_elementos)) {
  stop(paste("Error: Se esperaba un tipo 'integer', pero se recibió uno de tipo '", 
             class(num_elementos), "'.", sep = ""))
}

# Representa la altitud de un punto (Nevado del Ruiz)
altitud_32 <- as.single(5321.0) # as.single() para precisión simple (32 bits)
altitud_64 <- 5321.0            # double es el defecto en R (64 bits)

# Representa la latitud de un punto (Nevado del Ruiz)
latitud <- 4.8920  

# Representa la longitud de un punto
longitud <- -75.3188  

# Representa el sistema de referencia oficial (tipo character)
sistema_coordenadas <- "MAGNA-SIRGAS / Origen Nacional"  

# Representa si el dataset está georreferenciado (logical)
esta_georeferenciado <- TRUE  

# Un vector que representa latitud y longitud
coordenadas <- c(4.8920, -75.3188)  

# Una lista que representa los atributos del elemento geográfico
atributos_elemento <- list(
    "nombre" = "Nevado del Ruiz",
    "altura_msnm" = 5321,
    "tipo" = "Estratovolcán",
    "ubicacion" = c(4.8920, -75.3188)
)

print(atributos_elemento)

# Tipo de dato
class(atributos_elemento)

# Acceder a la latitud (índice 1 en R) dentro del elemento 'ubicacion'
latitud_ruiz <- atributos_elemento$ubicacion[1]
latitud_ruiz
```
:::
:::

```{r}
#| label: r_tipos_datos
# #| eval: false

# Representa el número de elementos (L indica tipo integer)
num_elementos <- 500L  # Diferente a num_elementos = 500 (numeric)

# Validación del tipo de dato
if (!is.integer(num_elementos)) {
  stop(paste("Error: Se esperaba un tipo 'integer', pero se recibió uno de tipo '", 
             class(num_elementos), "'.", sep = ""))
}

# Representa la altitud de un punto (Nevado del Ruiz)
altitud_32 <- as.single(5321.0) # as.single() para precisión simple (32 bits)
altitud_64 <- 5321.0            # double es el defecto en R (64 bits)

# Representa la latitud de un punto (Nevado del Ruiz)
latitud <- 4.8920  

# Representa la longitud de un punto
longitud <- -75.3188  

# Representa el sistema de referencia oficial (tipo character)
sistema_coordenadas <- "MAGNA-SIRGAS / Origen Nacional"  

# Representa si el dataset está georreferenciado (logical)
esta_georeferenciado <- TRUE  

# Un vector que representa latitud y longitud
coordenadas <- c(4.8920, -75.3188)  

# Una lista que representa los atributos del elemento geográfico
atributos_elemento <- list(
    "nombre" = "Nevado del Ruiz",
    "altura_msnm" = 5321,
    "tipo" = "Estratovolcán",
    "ubicacion" = c(4.8920, -75.3188)
)

print(atributos_elemento)

# Tipo de dato
class(atributos_elemento)

# Acceder a la latitud (índice 1 en R) dentro del elemento 'ubicacion'
latitud_ruiz <- atributos_elemento$ubicacion[1]
latitud_ruiz
```

### Julia

::: {.content-visible when-format="html"}
::: {.callout-tip collapse="true" icon="false"}
#### ▷ CÓDIGO PURO (Copiar y Pegar)
```{julia}
#| label: julia_tipos_datos_codigo
#| eval: false

# Representa el número de elementos en el dataset
num_elementos = 500  # Igual a num_elementos = Int64(500)
typeof(num_elementos)

# Validación del tipo de dato
if !(num_elementos isa Int64)
    error("Error: Se esperaba un 'Int64', pero se recibió un '$(typeof(num_elementos))'.")
end

# Representa la altitud de un punto (Nevado del Ruiz)
altitud_32 = Float32(5321.0) # Float32() para precisión simple (32 bits)
altitud_64 = 5321.0          # Float64 es el defecto en Julia (64 bits)

# Representa la latitud del punto (Nevado del Ruiz)
latitud = 4.8920  

# Representa la longitud del punto
longitud = -75.3188  

# Representa el sistema de referencia espacial
sistema_coordenadas = "MAGNA-SIRGAS / Origen Nacional"  

# Representa el estado de georreferenciación (tipo Bool)
esta_georeferenciado = true  

# Un arreglo que representa latitud y longitud
coordenadas = [4.8920, -75.3188]  

# Un diccionario (Dict) para almacenar los atributos
atributos_elemento = Dict(
    "nombre" => "Nevado del Ruiz",
    "altura_msnm" => 5321,
    "tipo" => "Estratovolcán",
    "ubicacion" => [4.8920, -75.3188],
)

print(atributos_elemento)

# Tipo de dato
typeof(atributos_elemento)

# Acceder a la latitud (índice 1 en Julia) dentro de la clave "ubicacion"
latitud_ruiz = atributos_elemento["ubicacion"][1]
latitud_ruiz
```
:::
:::

```{r}
#| label: julia_tipos_datos
#| results: asis
# #| eval: false
j_eval('
# Representa el número de elementos en el dataset
num_elementos = 500  # Igual a num_elementos = Int64(500)
typeof(num_elementos)

# Validación del tipo de dato
if !(num_elementos isa Int64)
    error("Error: Se esperaba un \'Int64\', pero se recibió un \'$(typeof(num_elementos))\'.")
end

# Representa la altitud de un punto (Nevado del Ruiz)
altitud_32 = Float32(5321.0) # Float32() para precisión simple (32 bits)
altitud_64 = 5321.0          # Float64 es el defecto en Julia (64 bits)

# Representa la latitud del punto (Nevado del Ruiz)
latitud = 4.8920  

# Representa la longitud del punto
longitud = -75.3188  

# Representa el sistema de referencia espacial
sistema_coordenadas = "MAGNA-SIRGAS / Origen Nacional"  

# Representa el estado de georreferenciación (tipo Bool)
esta_georeferenciado = true  

# Un arreglo que representa latitud y longitud
coordenadas = [4.8920, -75.3188]  

# Un diccionario (Dict) para almacenar los atributos
atributos_elemento = Dict(
    "nombre" => "Nevado del Ruiz",
    "altura_msnm" => 5321,
    "tipo" => "Estratovolcán",
    "ubicacion" => [4.8920, -75.3188],
)

println(atributos_elemento)

# Tipo de dato
typeof(atributos_elemento)

# Acceder a la latitud (índice 1 en Julia) dentro de la clave "ubicacion"
latitud_ruiz = atributos_elemento["ubicacion"][1]
latitud_ruiz
')
```

:::

| Característica / Variable | Python | R | Julia |
|:---|:---:|:---:|:---|
| **Sufijo `L`** (num_elementos)| No se usa. `500` es entero. | Se usa `500L` para `integer`. Sin `L` es `numeric`. | No se usa. `500` es `Int64`. |
| **Asignación en Diccionario** | `v = {clave: valor, ...}` (Usa `:`). | `v <- list(clave = valor, ...)`. (Usa `=` ) | `v = Dict(clave => valor, ...)` (Usa `=>`). |
| **`num_elementos`** | `int` (Automático) | `integer` (Requiere `L`) | `Int64` (Automático) |
| **`latitud` (doble precisión por defecto)** | `float` | `numeric` | `Float64` |
| **`altitud_32` (simple precisión)** | `np.float32()` | `as.single()` | `Float32` |
| **`sistema_coordenadas`** | `str` | `character` | `String` |
| **`esta_georeferenciado`** | `bool` (`True` / `False`) | `logical` (`TRUE` / `FALSE`) | `Bool` (`true` / `false`) |
| **`coordenadas`** | `list` `[ , ]`: Colección mutable de objetos. | `vector` `c( , )`: Colección indexada de elementos del mismo tipo. | `Array` `[ , ]` (Vector): Arreglo indexado y optimizado para cómputo. |
| **`atributos_elemento`** | `dict` `{ : }`: Estructura nativa de pares clave-valor. | `list` `list( = )`: Lista con nombres (etiquetas) para cada elemento. | `Dict` `Dict( => )`: Tipo de dato optimizado para mapeos clave-valor. |

: Comparación detallada de sintaxis y tipos de datos {#tbl-comparativa_tecnica_sig tbl-colwidths="[25,25,25,25]"}

### ¿Qué es un diccionario?

Un **Diccionario** es una estructura de datos que organiza la información mediante pares de **Clave-Valor** (*Key-Value*). A diferencia de las secuencias indexadas (como las listas o vectores) donde los elementos se recuperan por su posición numérica, en un diccionario se accede a la información a través de etiquetas únicas llamadas claves.

* **Identificación:** Cada valor almacenado debe tener una clave asociada que funciona como su identificador único.
* **Heterogeneidad:** Permite agrupar diversos tipos de datos (cadenas, números, arreglos) bajo un mismo objeto.
* **Acceso Directo:** Su implementación técnica permite que la recuperación de un dato sea extremadamente eficiente, sin importar el volumen de información.
* **Estándares:** Es el concepto fundamental detrás de formatos como JSON, facilitando la organización jerárquica de los datos.

## Caracteres de escape

::: {.panel-tabset}

### Python

::: {.content-visible when-format="html"}
::: {.callout-tip collapse="true" icon="false"}
#### ▷ CÓDIGO PURO (Copiar y Pegar)
```{python}
#| label: python_escape_codigo
#| eval: false

# Salto de línea para separar información de capas geográficas
print("Capa: Departamentos_Colombia\nEstado: Procesada exitosamente.")

# Salto de línea y tabulación para jerarquizar metadatos
print("Metadatos del proyecto:\n\tAutor: IGAC\n\tEscala: 1:100.000")

# Uso de comillas simples dentro de dobles para nombres propios
print("Nombre del archivo: 'Mapa_Relieve_Colombia.shp'")
```
:::
:::


```{python}
#| label: python_escape
# #| eval: false

# Salto de línea para separar información de capas geográficas
print("Capa: Departamentos_Colombia\nEstado: Procesada exitosamente.")

# Salto de línea y tabulación para jerarquizar metadatos
print("Metadatos del proyecto:\n\tAutor: IGAC\n\tEscala: 1:100.000")

# Uso de comillas simples dentro de dobles para nombres propios
print("Nombre del archivo: 'Mapa_Relieve_Colombia.shp'")
```

### R

::: {.content-visible when-format="html"}
::: {.callout-tip collapse="true" icon="false"}
#### ▷ CÓDIGO PURO (Copiar y Pegar)
```{r}
#| label: r_escape_codigo
#| eval: false

# Salto de línea para separar información de capas geográficas
print("Capa: Departamentos_Colombia\nEstado: Procesada exitosamente.")

# Salto de línea y tabulación para jerarquizar metadatos
cat("Metadatos del proyecto:\n\tAutor: IGAC\n\tEscala: 1:100.000")

# Uso de comillas simples dentro de dobles para nombres propios
print("Nombre del archivo: 'Mapa_Relieve_Colombia.shp'")
```
:::
:::

```{r}
#| label: r_escape
# #| eval: false

# Salto de línea para separar información de capas geográficas
print("Capa: Departamentos_Colombia\nEstado: Procesada exitosamente.")

# Salto de línea y tabulación para jerarquizar metadatos (cat interpreta mejor los caracteres)
cat("Metadatos del proyecto:\n\tAutor: IGAC\n\tEscala: 1:100.000")

# Uso de comillas simples dentro de dobles para nombres propios
print("Nombre del archivo: 'Mapa_Relieve_Colombia.shp'")
```

### Julia

::: {.content-visible when-format="html"}
::: {.callout-tip collapse="true" icon="false"}
#### ▷ CÓDIGO PURO (Copiar y Pegar)
```{julia}
#| label: julia_escape_codigo
#| eval: false

# Salto de línea para separar información de capas geográficas
println("Capa: Departamentos_Colombia\nEstado: Procesada exitosamente.")

# Salto de línea y tabulación para jerarquizar metadatos
println("Metadatos del proyecto:\n\tAutor: IGAC\n\tEscala: 1:100.000")

# Uso de comillas simples dentro de dobles para nombres propios
println("Nombre del archivo: 'Mapa_Relieve_Colombia.shp'")
```
:::
:::

```{r}
#| label: julia_escape
#| results: asis
# #| eval: false
j_eval('
# Salto de línea para separar información de capas geográficas
println("Capa: Departamentos_Colombia\nEstado: Procesada exitosamente.")

# Salto de línea y tabulación para jerarquizar metadatos
println("Metadatos del proyecto:\n\tAutor: IGAC\n\tEscala: 1:100.000")

# Uso de comillas simples dentro de dobles para nombres propios
println("Nombre del archivo: \'Mapa_Relieve_Colombia.shp\'")
')
```

:::

### Caracteres especiales de escape

| Carácter | Nombre | Descripción Técnica |
|:---:|:---|:---|
| `\n` | Salto de línea (Newline) | Mueve el cursor al inicio de la siguiente línea para organizar texto. |
| `\t` | Tabulación (Tab) | Inserta un espacio horizontal para crear jerarquías o sangrías. |
| `\\` | Barra invertida | Permite imprimir el carácter `\` (crucial para rutas de archivos en sistemas locales). |
| `\"` | Comilla doble | Permite insertar comillas dobles sin cerrar prematuramente la cadena de texto. |
| `\'` | Comilla simple | Permite insertar comillas simples; en Julia/R dentro de `j_eval` suele requerir escape extra. |

: Caracteres de escape comunes en lenguajes de programación {#tbl-caracteres_escape tbl-colwidths="[15,25,60]"}


## Comentarios

::: {.panel-tabset}

### Python

::: {.content-visible when-format="html"}
::: {.callout-tip collapse="true" icon="false"}
#### ▷ CÓDIGO PURO (Copiar y Pegar)
```{python}
#| label: python_escape_comentarios_codigo
#| eval: false

# Comentario de bloque: Información de procesamiento
print("Capa: Departamentos_Colombia\nEstado: Procesada exitosamente.")

# Comentario en línea: RMSE en metros
rmse = 0.05  # Tolerancia para precisión submétrica

# El intérprete lo procesa (""") como un string, 
# pero al no asignarse a una variable, actúa como comentario.
"""
Este es un comentario multilínea en Python.
Se utilizan triples comillas (aunque técnicamente son cadenas
de texto no asignadas, se usan para documentar bloques extensos).
"""
print("Nombre del archivo: 'Mapa_Relieve_Colombia.shp'")
```
:::
:::


```{python}
#| label: python_escape_comentarios
# #| eval: false

# Comentario de bloque: Información de procesamiento
print("Capa: Departamentos_Colombia\nEstado: Procesada exitosamente.")

# Comentario en línea: RMSE en metros
rmse = 0.05  # Tolerancia para precisión submétrica

# El intérprete lo procesa (""") como un string, 
# pero al no asignarse a una variable, actúa como comentario.
"""
Este es un comentario multilínea en Python.
Se utilizan triples comillas (aunque técnicamente son cadenas
de texto no asignadas, se usan para documentar bloques extensos).
"""
print("Nombre del archivo: 'Mapa_Relieve_Colombia.shp'")
```

### R

::: {.content-visible when-format="html"}
::: {.callout-tip collapse="true" icon="false"}
#### ▷ CÓDIGO PURO (Copiar y Pegar)
```{r}
#| label: r_escape_comentarios_codigo
#| eval: false

# Comentario de bloque: Información de procesamiento
print("Capa: Departamentos_Colombia\nEstado: Procesada exitosamente.")

# Comentario en línea: RMSE en metros
rmse <- 0.05  # Tolerancia para precisión submétrica

# R no tiene un operador nativo para comentarios multilínea.
# Se deben usar múltiples numerales consecutivos para
# documentar bloques de código extensos.
cat("Metadatos del proyecto:\n\tAutor: IGAC\n\tEscala: 1:100.000")
```
:::
:::

```{r}
#| label: r_escape_comentarios
# #| eval: false

# Comentario de bloque: Información de procesamiento
print("Capa: Departamentos_Colombia\nEstado: Procesada exitosamente.")

# Comentario en línea: RMSE en metros
rmse <- 0.05  # Tolerancia para precisión submétrica

# R no tiene un operador nativo para comentarios multilínea.
# Se deben usar múltiples numerales consecutivos para
# documentar bloques de código extensos.
cat("Metadatos del proyecto:\n\tAutor: IGAC\n\tEscala: 1:100.000")
```

### Julia

::: {.content-visible when-format="html"}
::: {.callout-tip collapse="true" icon="false"}
#### ▷ CÓDIGO PURO (Copiar y Pegar)
```{julia}
#| label: julia_escape_comentarios_codigo
#| eval: false

# Comentario de bloque: Información de procesamiento
println("Capa: Departamentos_Colombia\nEstado: Procesada exitosamente.")

# Comentario en línea: RMSE en metros
rmse = 0.05  # Tolerancia para precisión submétrica

#=
Este es un comentario multilínea nativo en Julia.
Permite comentar grandes bloques de código o explicaciones
extensas sin necesidad de colocar numerales en cada línea.
=#

# En Julia las tres comillas sirven para 
# definir archivos de texto en memoria (no son comentarios)
csv_data = """
municipio,altitud
Bogota,2625
Medellin,1495
Cali,1018
Quibdo,43
"""
csv_data

println("Nombre del archivo: 'Mapa_Relieve_Colombia.shp'")
```
:::
:::

```{r}
#| label: julia_escape_comentarios
#| results: asis
# #| eval: false
j_eval('
# Comentario de bloque: Información de procesamiento
println("Capa: Departamentos_Colombia\nEstado: Procesada exitosamente.")

# Comentario en línea: RMSE en metros
rmse = 0.05  # Tolerancia para precisión submétrica

#=
Este es un comentario multilínea nativo en Julia.
Permite comentar grandes bloques de código o explicaciones
extensas sin necesidad de colocar numerales en cada línea.
=#

# En Julia las tres comillas sirven para 
# definir archivos de texto en memoria (no son comentarios)
csv_data = """
municipio,altitud
Bogota,2625
Medellin,1495
Cali,1018
Quibdo,43
"""
csv_data

println("Nombre del archivo: \'Mapa_Relieve_Colombia.shp\'")
')
```

:::

### Documentación y caracteres especiales

| Carácter | Nombre | Función Técnica |
|:---:|:---|:---|
| `#` | Numeral | Inicia comentarios de una sola línea en los tres lenguajes. |
| `\n` | Newline | Inserta un salto de línea dentro de una cadena de texto. |
| `\t` | Tab | Inserta una tabulación horizontal (sangría). |
| `"""` | Triple comilla | **Python:** Documentación de bloques (*docstrings*). <br>**Julia:** Cadenas multilínea (útil para definir archivos o bloques de texto en memoria). <br>**R:** No se utiliza (causa error de sintaxis). |
| `#= =#` | Block comment | Delimitador nativo de **Julia** para comentarios multilínea. |

: Sintaxis de documentación, escape y cadenas especiales {#tbl-doc_escape_final tbl-colwidths="[15,25,60]"}

---

**Nota técnica:** En el desarrollo de herramientas automatizadas, los comentarios multilínea son el estándar para definir el **encabezado del script**, detallando licencias, el sistema de referencia de coordenadas (CRS) y las dependencias. Es fundamental diferenciar entre un comentario real y una cadena de texto: mientras que `#` y `#= =#` son ignorados por el compilador, las triples comillas `"""` en Python y Julia generan objetos en la memoria. En Python, estas actúan como comentarios "de facto" solo si no se asignan a una variable (siendo la base de los *docstrings*), mientras que en Julia su propósito principal es la creación de bloques de texto estructurado o archivos en memoria.

## Trabajando con variables y tipos de datos

::: {.panel-tabset}

### Python

::: {.content-visible when-format="html"}
::: {.callout-tip collapse="true" icon="false"}
#### ▷ CÓDIGO PURO (Copiar y Pegar)
```{python}
#| label: python_trabajo_variables_codigo
#| eval: false

import math

# Inicialización de variables para asegurar la ejecución
num_elementos = 500

# Incrementar el número de elementos existentes
num_elementos += 20
num_elementos

# Convertir la latitud de grados decimales a radianes
latitud_ruiz = 4.8920
latitud_radianes = math.radians(latitud_ruiz)

# Latitud, Longitud del Nevado del Ruíz
coordenadas = [4.8920, -75.3188]

# Agregar datos de Bogotá al FINAL de la lista
coordenadas.append(4.6097)   # Agrega Latitud de Bogotá al final
coordenadas.append(-74.0817)  # Agrega Longitud de Bogotá al final

# --- Uso de INSERT ---
# Supongamos que queremos insertar el nombre del país al principio de la lista
# El método .insert(índice, valor) desplaza los demás elementos
coordenadas.insert(0, "Colombia") # Inserta en la posición inicial (índice 0)

# Ver el resultado final
coordenadas

# Acceso y formateo de cadenas usando el diccionario de atributos
nombre_volcan = atributos_elemento["nombre"]
altura_volcan = atributos_elemento["altura_msnm"]
mensaje = f"{nombre_volcan} tiene una altura de {altura_volcan} metros."

# Mostrar el resultado final
mensaje
```
:::
:::


```{python}
#| label: python_trabajo_variables
# #| eval: false

import math

# Inicialización de variables para asegurar la ejecución
num_elementos = 500

# Incrementar el número de elementos existentes
num_elementos += 20
num_elementos

# Convertir la latitud de grados decimales a radianes
latitud_ruiz = 4.8920
latitud_radianes = math.radians(latitud_ruiz)

# Latitud, Longitud del Nevado del Ruíz
coordenadas = [4.8920, -75.3188]

# Agregar datos de Bogotá al FINAL de la lista
coordenadas.append(4.6097)   # Agrega Latitud de Bogotá al final
coordenadas.append(-74.0817)  # Agrega Longitud de Bogotá al final

# --- Uso de INSERT ---
# Supongamos que queremos insertar el nombre del país al principio de la lista
# El método .insert(índice, valor) desplaza los demás elementos
coordenadas.insert(0, "Colombia") # Inserta en la posición inicial (índice 0)

# Ver el resultado final
coordenadas

# Acceso y formateo de cadenas usando el diccionario de atributos
nombre_volcan = atributos_elemento["nombre"]
altura_volcan = atributos_elemento["altura_msnm"]
mensaje = f"{nombre_volcan} tiene una altura de {altura_volcan} metros."

# Mostrar el resultado final
mensaje
```

### R

::: {.content-visible when-format="html"}
::: {.callout-tip collapse="true" icon="false"}
#### ▷ CÓDIGO PURO (Copiar y Pegar)
```{r}
#| label: r_trabajo_variables_codigo
#| eval: false

# Inicialización de variables necesarias
num_elementos <- 500
# Incrementar el número de elementos
num_elementos <- num_elementos + 20
num_elementos

# Convertir latitud a radianes
latitud_ruiz <- 4.8920
latitud_radianes <- latitud_ruiz * (pi / 180)

# Latitud, Longitud del Nevado del Ruíz
coordenadas <- c(4.8920, -75.3188)

# --- Uso de c() para combinar (Equivalente a append) ---
# Agregar elementos a un vector (creando una copia combinada)
# Adicionamos coordenadas de Bogotá al final
coordenadas <- c(coordenadas, 4.6097, -74.0817) 

# --- ADVERTENCIA DE COERCIÓN ---
# Si intentamos insertar un texto en este vector numérico, 
# R convertirá TODO el vector a tipo 'character'.
# coordenadas <- c("Colombia", coordenadas) # ¡Cuidado con esto!

# --- Uso de append() con after (Equivalente a insert en Python) ---
# Insertar "Colombia" al inicio (after = 0)
# ¡ADVERTENCIA!: Al insertar un texto, R convertirá todos los números 
# del vector a tipo 'character' (coerción).
coordenadas <- append(coordenadas, "Colombia", after = 0)

# Acceso a lista y formateo de cadenas
nombre_volcan <- atributos_elemento$nombre
altura_volcan <- atributos_elemento$altura_msnm
mensaje <- paste(nombre_volcan, "tiene una altura de", altura_volcan, "metros.", sep = " ")
mensaje
# Si no quieres NINGÚN espacio, puedes usar paste0() o sep = ""
mensaje <- paste(nombre_volcan, " tiene una altura de ", altura_volcan, " metros.", sep = "")
mensaje
mensaje <- paste0(nombre_volcan, " tiene una altura de ", altura_volcan, " metros.")
mensaje

# El formato define exactamente qué caracteres van entre las variables
# %s para texto (string), %d para enteros, %f para decimales
# La máscara de texto define el espacio natural entre las variables
mensaje <- sprintf("%s tiene una altura de %d metros.", nombre_volcan, altura_volcan)
mensaje

# Interpolación con más de una variable entera, texto o decimal
# Definición de variables
pais <- "Colombia"
nombre_volcan <- "Nevado del Ruiz"
altura_volcan <- 5321L          # Entero (Integer)
num_sensores <- 12L             # Entero (Integer)
latitud <- 4.8920               # Decimal (Double)
longitud <- -75.3188            # Decimal (Double)

# Interpolación: 2 strings (%s), 2 enteros (%d) y 2 decimales con precisión (%f)
# Usamos %.4f para asegurar 4 decimales en las coordenadas
mensaje <- sprintf("En %s, el %s (Altitud: %d m) tiene %d sensores. Ubicación: %.4f, %.4f", 
                   pais, 
                   nombre_volcan, 
                   altura_volcan, 
                   num_sensores, 
                   latitud, 
                   longitud)
mensaje
```
:::
:::

```{r}
#| label: r_trabajo_variables
# #| eval: false

# Inicialización de variables necesarias
num_elementos <- 500
# Incrementar el número de elementos
num_elementos <- num_elementos + 20
num_elementos

# Convertir latitud a radianes
latitud_ruiz <- 4.8920
latitud_radianes <- latitud_ruiz * (pi / 180)

# Latitud, Longitud del Nevado del Ruíz
coordenadas <- c(4.8920, -75.3188)

# --- Uso de c() para combinar (Equivalente a append) ---
# Agregar elementos a un vector (creando una copia combinada)
# Adicionamos coordenadas de Bogotá al final
coordenadas <- c(coordenadas, 4.6097, -74.0817) 

# --- ADVERTENCIA DE COERCIÓN ---
# Si intentamos insertar un texto en este vector numérico, 
# R convertirá TODO el vector a tipo 'character'.
# coordenadas <- c("Colombia", coordenadas) # ¡Cuidado con esto!

# --- Uso de append() con after (Equivalente a insert en Python) ---
# Insertar "Colombia" al inicio (after = 0)
# ¡ADVERTENCIA!: Al insertar un texto, R convertirá todos los números 
# del vector a tipo 'character' (coerción).
coordenadas <- append(coordenadas, "Colombia", after = 0)

# Acceso a lista y formateo de cadenas
nombre_volcan <- atributos_elemento$nombre
altura_volcan <- atributos_elemento$altura_msnm
mensaje <- paste(nombre_volcan, "tiene una altura de", altura_volcan, "metros.", sep = " ")
mensaje
# Si no quieres NINGÚN espacio, puedes usar paste0() o sep = ""
mensaje <- paste(nombre_volcan, " tiene una altura de ", altura_volcan, " metros.", sep = "")
mensaje
mensaje <- paste0(nombre_volcan, " tiene una altura de ", altura_volcan, " metros.")
mensaje

# El formato define exactamente qué caracteres van entre las variables
# %s para texto (string), %d para enteros, %f para decimales
# La máscara de texto define el espacio natural entre las variables
mensaje <- sprintf("%s tiene una altura de %d metros.", nombre_volcan, altura_volcan)
mensaje

# Interpolación con más de una variable entera, texto o decimal
# Definición de variables
pais <- "Colombia"
nombre_volcan <- "Nevado del Ruiz"
altura_volcan <- 5321L          # Entero (Integer)
num_sensores <- 12L             # Entero (Integer)
latitud <- 4.8920               # Decimal (Double)
longitud <- -75.3188            # Decimal (Double)

# Interpolación: 2 strings (%s), 2 enteros (%d) y 2 decimales con precisión (%f)
# Usamos %.4f para asegurar 4 decimales en las coordenadas
mensaje <- sprintf("En %s, el %s (Altitud: %d m) tiene %d sensores. Ubicación: %.4f, %.4f", 
                   pais, 
                   nombre_volcan, 
                   altura_volcan, 
                   num_sensores, 
                   latitud, 
                   longitud)
mensaje
```

### Julia

::: {.content-visible when-format="html"}
::: {.callout-tip collapse="true" icon="false"}
#### ▷ CÓDIGO PURO (Copiar y Pegar)
```{julia}
#| label: julia_trabajo_variables_codigo
#| eval: false

# Inicialización de variables necesarias
num_elementos = 500
# Incrementar el número de elementos
num_elementos += 20
num_elementos

# Convertir latitud a radianes usando la función nativa deg2rad
latitud_ruiz = 4.8920
latitud_radianes = deg2rad(latitud_ruiz)

# Latitud, Longitud del Nevado del Ruiz
coordenadas = [4.8920, -75.3188]

# --- Uso de push!() (Equivalente a append de Python) ---
# Agregar elementos al final del vector original
# Agregar coordenadas de Bogotá al final
push!(coordenadas, 4.6097, -74.0817)

# --- ADVERTENCIA DE TIPO (Type Safety) ---
# A diferencia de R, Julia NO convertirá los números a texto automáticamente.
# Si el vector es de tipo Float64, esta línea lanzará un ERROR:
# insert!(coordenadas, 1, "Colombia") 

# Para que funcione como en Python (mezclando tipos), el vector 
# debe ser de tipo 'Any' o estar predefinido para aceptar strings.
coordenadas_mix = Any[4.8920, -75.3188, 4.6097, -74.0817]

# --- Uso de insert!() (Equivalente a insert en Python) ---
# Insertar "Colombia" al inicio (Índice 1 en Julia)
insert!(coordenadas_mix, 1, "Colombia")

# Ver el resultado
coordenadas_mix

# Acceso a Diccionario e interpolación de texto
nombre_volcan = atributos_elemento["nombre"]
altura_volcan = atributos_elemento["altura_msnm"]
mensaje = "$nombre_volcan tiene una altura de $altura_volcan metros."

# Mostrar el resultado final
mensaje
```
:::
:::

```{r}
#| label: julia_trabajo_variables
#| results: asis
# #| eval: false
j_eval('
# Inicialización de variables necesarias
num_elementos = 500
# Incrementar el número de elementos
num_elementos += 20
num_elementos

# Convertir latitud a radianes usando la función nativa deg2rad
latitud_ruiz = 4.8920
latitud_radianes = deg2rad(latitud_ruiz)

# Latitud, Longitud del Nevado del Ruiz
coordenadas = [4.8920, -75.3188]

# --- Uso de push!() (Equivalente a append de Python) ---
# Agregar elementos al final del vector original
# Agregar coordenadas de Bogotá al final
push!(coordenadas, 4.6097, -74.0817)

# --- ADVERTENCIA DE TIPO (Type Safety) ---
# A diferencia de R, Julia NO convertirá los números a texto automáticamente.
# Si el vector es de tipo Float64, esta línea lanzará un ERROR:
# insert!(coordenadas, 1, "Colombia") 

# Para que funcione como en Python (mezclando tipos), el vector 
# debe ser de tipo \'Any\' o estar predefinido para aceptar strings.
coordenadas_mix = Any[4.8920, -75.3188, 4.6097, -74.0817]

# --- Uso de insert!() (Equivalente a insert en Python) ---
# Insertar "Colombia" al inicio (Índice 1 en Julia)
insert!(coordenadas_mix, 1, "Colombia")

# Ver el resultado
coordenadas_mix

# Acceso e interpolación de texto
nombre_volcan = atributos_elemento["nombre"]
altura_volcan = atributos_elemento["altura_msnm"]
mensaje = "$nombre_volcan tiene una altura de $altura_volcan metros."

# Mostrar el resultado final
mensaje
')
```

:::

| Operación | Python | R | Julia |
|:---|:---:|:---:|:---|
| **Incremento** | `+=` | `x <- x + n` | `+=` |
| **Grados a Radianes** | `math.radians()` | `x * (pi/180)` | `deg2rad()` |
| **Agregar al final** | `.append()` (Mutable) | `c(x, n)` (Copia/Coerción) | `push!()` (Mutable) |
| **Insertar en posición** | `.insert(índice, v)` | `append(x, v, after=n)` | `insert!(x, índice, v)` |
| **Primer índice** | `0` | `1` | `1` |
| **Mezclar tipos (Heterogéneo)** | Nativo (Listas) | No (Coerción a texto) | Requiere `Any[]` |
| **Interpolación de texto** | `f"{var}"` | `sprintf()` / `paste()` | `"$var"` |
| **Marcadores (Formato)** | Ver @sec-especificadores-formato | `%s`, `%d`, `%f` | Ver @sec-especificadores-formato |
| **Precisión (4 dec)** | `f"{v:.4f}"` | `sprintf("%.4f", v)` | `@sprintf("%.4f", v)` |

: Comparación de operaciones comunes con variables {#tbl-operaciones_variables tbl-colwidths="[25,25,25,25]"}

**Donde los marcadores representan:**

* **s**: String (Texto).
* **d**: Integer (Entero).
* **f**: Float (Decimal).
* **.4f**: Precisión a 4 decimales.

**Nota técnica:** En el desarrollo de algoritmos geográficos, la mutabilidad es un concepto clave. Mientras que Python y Julia permiten modificar una lista de coordenadas directamente (`append` / `push!`), en R los vectores son atómicos e inmutables; cada vez que "agregamos" un dato, R crea una copia nueva del vector en memoria. Esta diferencia es explicada en @fig-mutabilidad y @fig-inmutabilidad.

::: {#fig-comparacion-memoria layout-ncol=2 layout-valign="bottom"}

![Python/Julia: Listas Mutables. El objeto cambia sin cambiar de dirección de memoria.](images/mutabilidad.png){#fig-mutabilidad width="50%"}

![R: Vectores Inmutables. Al modificar, R crea una copia nueva silenciosamente.](images/inmutabilidad.png){#fig-inmutabilidad width="50%"}

Comparativa de manejo de memoria y mutabilidad.
:::

## Operaciones básicas con texto

::: {.panel-tabset}

### Python

::: {.content-visible when-format="html"}
::: {.callout-tip collapse="true" icon="false"}
#### ▷ CÓDIGO PURO (Copiar y Pegar)
```{python}
#| label: python_texto_codigo
#| eval: false

# Inicialización de la variable de texto
nombre_ciudad = "cartagena de indias"

# Convertir a minúsculas
ciudad_minusculas = nombre_ciudad.lower()
print("Minúsculas:", ciudad_minusculas)

# Convertir a mayúsculas (útil para estandarizar tablas de atributos)
ciudad_mayusculas = nombre_ciudad.upper()
print("Mayúsculas:", ciudad_mayusculas)

# Convertir a formato título (primera letra de cada palabra en mayúscula)
ciudad_titulo = nombre_ciudad.title()
print("Formato título:", ciudad_titulo)

# Reemplazar texto específico dentro de una cadena
ciudad_original = "San Andrés"
nueva_ciudad = ciudad_original.replace("San", "Isla de San")
print("Original:", ciudad_original)
print("Modificada:", nueva_ciudad)

# Limpiar espacios en blanco al inicio y al final (Trim)
datos_ubicacion = "   Bogotá D.C.   "
ubicacion_limpia = datos_ubicacion.strip()
print("Texto limpio:", f"'{ubicacion_limpia}'")
```
:::
:::


```{python}
#| label: python_texto
# #| eval: false

# Inicialización de la variable de texto
nombre_ciudad = "cartagena de indias"

# Convertir a minúsculas
ciudad_minusculas = nombre_ciudad.lower()
print("Minúsculas:", ciudad_minusculas)

# Convertir a mayúsculas (útil para estandarizar tablas de atributos)
ciudad_mayusculas = nombre_ciudad.upper()
print("Mayúsculas:", ciudad_mayusculas)

# Convertir a formato título (primera letra de cada palabra en mayúscula)
ciudad_titulo = nombre_ciudad.title()
print("Formato título:", ciudad_titulo)

# Reemplazar texto específico dentro de una cadena
ciudad_original = "San Andrés"
nueva_ciudad = ciudad_original.replace("San", "Isla de San")
print("Original:", ciudad_original)
print("Modificada:", nueva_ciudad)

# Limpiar espacios en blanco al inicio y al final (Trim)
datos_ubicacion = "   Bogotá D.C.   "
ubicacion_limpia = datos_ubicacion.strip()
print("Texto limpio:", f"'{ubicacion_limpia}'")
```

### R

::: {.content-visible when-format="html"}
::: {.callout-tip collapse="true" icon="false"}
#### ▷ CÓDIGO PURO (Copiar y Pegar)
```{r}
#| label: r_texto_codigo
#| eval: false

# Cargar paquete nativo recomendado para formato título
library(tools)

# Inicialización de la variable de texto
nombre_ciudad <- "cartagena de indias"

# Convertir a minúsculas
ciudad_minusculas <- tolower(nombre_ciudad)
cat("Minúsculas:", ciudad_minusculas, "\n")

# Convertir a mayúsculas (útil para estandarizar tablas de atributos)
ciudad_mayusculas <- toupper(nombre_ciudad)
cat("Mayúsculas:", ciudad_mayusculas, "\n")

# Convertir a formato título
ciudad_titulo <- toTitleCase(nombre_ciudad)
cat("Formato título:", ciudad_titulo, "\n")

# Reemplazar texto específico dentro de una cadena
ciudad_original <- "San Andrés"
nueva_ciudad <- gsub("San", "Isla de San", ciudad_original)
cat("Original:", ciudad_original, "\n")
cat("Modificada:", nueva_ciudad, "\n")

# Limpiar espacios en blanco al inicio y al final (Trim)
datos_ubicacion <- "   Bogotá D.C.   "
ubicacion_limpia <- trimws(datos_ubicacion)
cat("Texto limpio: '", ubicacion_limpia, "'\n", sep="")
```
:::
:::

```{r}
#| label: r_texto
# #| eval: false

# Cargar paquete nativo recomendado para formato título
library(tools)

# Inicialización de la variable de texto
nombre_ciudad <- "cartagena de indias"

# Convertir a minúsculas
ciudad_minusculas <- tolower(nombre_ciudad)
cat("Minúsculas:", ciudad_minusculas, "\n")

# Convertir a mayúsculas (útil para estandarizar tablas de atributos)
ciudad_mayusculas <- toupper(nombre_ciudad)
cat("Mayúsculas:", ciudad_mayusculas, "\n")

# Convertir a formato título
ciudad_titulo <- toTitleCase(nombre_ciudad)
cat("Formato título:", ciudad_titulo, "\n")

# Reemplazar texto específico dentro de una cadena
ciudad_original <- "San Andrés"
nueva_ciudad <- gsub("San", "Isla de San", ciudad_original)
cat("Original:", ciudad_original, "\n")
cat("Modificada:", nueva_ciudad, "\n")

# Limpiar espacios en blanco al inicio y al final (Trim)
datos_ubicacion <- "   Bogotá D.C.   "
ubicacion_limpia <- trimws(datos_ubicacion)
cat("Texto limpio: '", ubicacion_limpia, "'\n", sep="")
```

### Julia

::: {.content-visible when-format="html"}
::: {.callout-tip collapse="true" icon="false"}
#### ▷ CÓDIGO PURO (Copiar y Pegar)
```{julia}
#| label: julia_texto_codigo
#| eval: false

# Inicialización de la variable de texto
nombre_ciudad = "cartagena de indias"

# Convertir a minúsculas
ciudad_minusculas = lowercase(nombre_ciudad)
println("Minúsculas: ", ciudad_minusculas)

# Convertir a mayúsculas (útil para estandarizar tablas de atributos)
ciudad_mayusculas = uppercase(nombre_ciudad)
println("Mayúsculas: ", ciudad_mayusculas)

# Convertir a formato título (primera letra de cada palabra en mayúscula)
ciudad_titulo = titlecase(nombre_ciudad)
println("Formato título: ", ciudad_titulo)

# Reemplazar texto específico dentro de una cadena (usa el operador Pair =>)
ciudad_original = "San Andrés"
nueva_ciudad = replace(ciudad_original, "San" => "Isla de San")
println("Original: ", ciudad_original)
println("Modificada: ", nueva_ciudad)

# Limpiar espacios en blanco al inicio y al final (Trim)
datos_ubicacion = "   Bogotá D.C.   "
ubicacion_limpia = strip(datos_ubicacion)
println("Texto limpio: '", ubicacion_limpia, "'")
```
:::
:::

```{r}
#| label: julia_texto
#| results: asis
# #| eval: false
j_eval('
# Inicialización de la variable de texto
nombre_ciudad = "cartagena de indias"

# Convertir a minúsculas
ciudad_minusculas = lowercase(nombre_ciudad)
println("Minúsculas: ", ciudad_minusculas)

# Convertir a mayúsculas (útil para estandarizar tablas de atributos)
ciudad_mayusculas = uppercase(nombre_ciudad)
println("Mayúsculas: ", ciudad_mayusculas)

# Convertir a formato título (primera letra de cada palabra en mayúscula)
ciudad_titulo = titlecase(nombre_ciudad)
println("Formato título: ", ciudad_titulo)

# Reemplazar texto específico dentro de una cadena (usa el operador Pair =>)
ciudad_original = "San Andrés"
nueva_ciudad = replace(ciudad_original, "San" => "Isla de San")
println("Original: ", ciudad_original)
println("Modificada: ", nueva_ciudad)

# Limpiar espacios en blanco al inicio y al final (Trim)
datos_ubicacion = "   Bogotá D.C.   "
ubicacion_limpia = strip(datos_ubicacion)
println("Texto limpio: \'", ubicacion_limpia, "\'")
')
```

:::

| Operación | Python | R | Julia |
|:---|:---:|:---:|:---|
| **Minúsculas** | `.lower()` | `tolower()` | `lowercase()` |
| **Mayúsculas** | `.upper()` | `toupper()` | `uppercase()` |
| **Formato Título** | `.title()` | `tools::toTitleCase()` | `titlecase()` |
| **Reemplazar** | `.replace("viejo", "nuevo")` | `gsub("viejo", "nuevo", var)` | `replace(var, "viejo" => "nuevo")` |
| **Limpiar Espacios** | `.strip()` | `trimws()` | `strip()` |

: Equivalencias de funciones para manipulación de cadenas de texto {#tbl-operaciones_texto tbl-colwidths="[20,25,30,25]"}



---

**Nota técnica:** En el geoprocesamiento, la limpieza de cadenas de texto (*string parsing*) es una fase crítica antes de realizar cruces espaciales o uniones de tablas (joins). Diferencias imperceptibles como espacios en blanco accidentales (`"Bogotá "` vs `"Bogotá"`) o discrepancias de mayúsculas y minúsculas provocarán que el software GIS falle al emparejar los registros. Las funciones de `strip()` y `upper()` son la primera línea de defensa para garantizar la integridad topológica y tabular de los datos.


## Resumen de aprendizajes (cheat sheet)

En esta sección hemos abordado los cimientos de la programación aplicados al análisis de datos. A continuación, se presenta un **Cheat Sheet (Hoja de Referencia)** consolidado con las equivalencias sintácticas y funcionales entre Python, R y Julia.

### 1. Asignación y Operaciones Básicas

| Concepto / Operación | Python | R | Julia |
|:---|:---|:---|:---|
| **Asignación Básica** | `=` | `<-` (Estándar) | `=` |
| **Imprimir en consola** | `print(var)` | `print(var)` o `cat(var)` | `println(var)` |
| **Incrementar valor** | `x += 1` | `x <- x + 1` | `x += 1` |
| **Índice Inicial (Arrays)** | `[0]` (Base 0) | `[1]` (Base 1) | `[1]` (Base 1) |
| **Último elemento** | `[-1]` | `[length(x)]` | `[end]` |

: Resumen de sintaxis y manejo de variables {#tbl-resumen_variables tbl-colwidths="[25,25,25,25]"}

### 2. Estructuras, Tipos y Gestión de Memoria

| Concepto | Python | R | Julia |
|:---|:---|:---|:---|
| **Número Entero** | `int` (ej. `500`) | `integer` (ej. `500L`) | `Int64` (ej. `500`) |
| **Número Decimal** | `float` | `numeric` (Double) | `Float64` |
| **Booleano** | `bool` (`True`/`False`) | `logical` (`TRUE`/`FALSE`) | `Bool` (`true`/`false`) |
| **Lista/Vector** | `list` `[...]` | `vector` `c(...)` | `Array` `[...]` |
| **Agregar al Final** | `lista.append(x)` | `v <- c(v, x)` | `push!(lista, x)` |
| **Insertar en Posición** | `lista.insert(i, x)` | `append(v, x, after=i)` | `insert!(lista, i, x)` |
| **Comportamiento Memoria** | **Mutable** (In-place). Modifica el objeto original. | **Inmutable** (Copy-on-modify). Crea una copia nueva. | **Mutable** (In-place). Modifica el objeto original. |
| **Diccionario** | `dict` `{k: v}` | `list` `list(k = v)` | `Dict` `Dict(k => v)` |

: Resumen de estructuras de datos y su comportamiento en memoria (Mutabilidad) {#tbl-resumen_tipos_datos tbl-colwidths="[20,25,30,25]"}

### 3. Interpolación y Formato de Salida (Formatters)

Esta tabla resume cómo insertar variables dentro de texto y controlar su precisión (ej. coordenadas).

| Operación | Python | R | Julia |
|:---|:---|:---|:---|
| **Interpolación Básica** | `f"Texto {var}"` | `paste("Texto", var)` | `"Texto $var"` |
| **Interpolación con Formato** | `f"Valor: {var:.4f}"` | `sprintf("Valor: %.4f", var)` | `@sprintf "Valor: %.4f" var` |
| **Marcador Texto** | `{var}` | `%s` | `%s` |
| **Marcador Entero** | `{var}` o `{:d}` | `%d` | `%d` |
| **Marcador Decimal** | `{var}` o `{:f}` | `%f` | `%f` |
| **Control Decimales** | `:.4f` (4 decimales) | `%.4f` (4 decimales) | `%.4f` (4 decimales) |

: Resumen de técnicas de interpolación y formateo numérico. Nota: En Julia `@sprintf` requiere `using Printf`. {#tbl-resumen_formato tbl-colwidths="[25,25,25,25]"}

### 4. Manipulación de Cadenas de Texto (Limpieza Tabular)

| Operación | Python | R | Julia |
|:---|:---|:---|:---|
| **A minúsculas** | `var.lower()` | `tolower(var)` | `lowercase(var)` |
| **A MAYÚSCULAS** | `var.upper()` | `toupper(var)` | `uppercase(var)` |
| **Formato Título** | `var.title()` | `tools::toTitleCase(var)` | `titlecase(var)` |
| **Reemplazar texto** | `var.replace("a", "b")` | `gsub("a", "b", var)` | `replace(var, "a" => "b")` |
| **Quitar espacios vacíos** | `var.strip()` | `trimws(var)` | `strip(var)` |

: Resumen de funciones para limpieza de texto (String Parsing) {#tbl-resumen_texto tbl-colwidths="[25,25,25,25]"}

### 5. Documentación y caracteres especiales

| Carácter | Python | R | Julia |
|:---:|:---|:---|:---|
| `#` | Comentario en línea. | Comentario en línea. | Comentario en línea. |
| `\n` | Salto de línea. | Salto de línea. | Salto de línea. |
| `\t` | Tabulación. | Tabulación. | Tabulación. |
| `"""` | *Docstrings* (Documentación). | No soportado (Error). | Cadenas/Archivos multilínea. |
| `#= =#` | No soportado. | No soportado. | Comentario de bloque nativo. |

: Resumen de caracteres de escape y sintaxis de documentación {#tbl-resumen_caracteres tbl-colwidths="[15,25,25,35]"}

---

**Conclusión del Módulo:**
La correcta elección de los tipos de datos (Listas vs. Diccionarios), la comprensión del índice de origen (Base 0 vs. Base 1) y el control estricto del formato (`%.4f` vs `.4f`) son pilares fundamentales para evitar errores de redondeo en coordenadas. Asimismo, entender la **mutabilidad** es vital: mientras Python y Julia permiten **insertar** o modificar datos "in-place" (eficiente), R tiende a generar copias en memoria, lo cual debe considerarse al procesar grandes volúmenes de información geoespacial.

## Ejercicios

Para poner en práctica los conceptos aprendidos, deberás resolver los siguientes dos ejercicios. Puedes elegir resolverlos en **Python, R o Julia** (o implementar la solución en varios lenguajes si deseas retarte).

### Ejercicio 1: Asignación de variables y operaciones básicas

**Contexto:** Formas parte del equipo SIG de una corporación autónoma regional y necesitas estructurar los metadatos de una nueva estación de monitoreo ambiental antes de ingresarla a la base de datos espacial.

**Instrucciones de código:**

1. Define las siguientes variables respetando estrictamente el estándar `snake_case`:
   * Nombre de la estación: "Páramo de Santurbán"
   * Latitud: `7.2514`
   * Longitud: `-72.9069`
   * Elevación en metros: `3350`
   * ¿Está activa?: `Verdadero` (Usa el tipo booleano correcto según tu lenguaje).
2. Crea una estructura de colección (Lista en Python, Vector en R, o Array en Julia) que contenga la Latitud y la Longitud, en ese orden.
3. Crea un **Diccionario** (o Lista con nombres en R) llamado `metadatos_estacion` que agrupe todas las variables anteriores bajo claves descriptivas.
4. Usando la indexación adecuada (Base 0 o Base 1, según el lenguaje que elegiste), extrae específicamente la **Longitud** desde la colección de coordenadas que está dentro del diccionario y guárdala en una nueva variable.
5. Se ha realizado una nueva medición topográfica y la elevación real es 12.5 metros más alta. Actualiza la variable de elevación utilizando el operador de incremento.
6. Imprime en consola un mensaje dinámico utilizando interpolación de texto (ej. `f-strings`, `paste()` o `$`) que diga exactamente: *"La estación [Nombre] se encuentra operativa en la longitud [Longitud] a una altura actualizada de [Elevación] msnm."*

### Ejercicio 2: Trabajando con strings

**Contexto:** Has recibido una tabla de Excel con la toponimia de áreas protegidas de Colombia capturada manualmente por diferentes operarios. Los textos están sucios y, si intentas hacer un cruce espacial (*Spatial Join*) con la capa oficial del IGAC, el software arrojará errores de topología tabular.

**Instrucciones de código:**

1. Inicializa una variable con el siguiente texto crudo y problemático:
   `registro_crudo = "   sAnTuaRio de fAuna Y flora iGuaQue   "`
2. **Utiliza el método o función nativa de tu lenguaje** (vista en la sección anterior) para eliminar los espacios en blanco accidentales al inicio y al final del texto.
3. **Usa el comando correspondiente para convertir** el texto limpio a formato de Título (*Title Case*), estandarizando así las mayúsculas y minúsculas.
4. **Emplea la herramienta de reemplazo** de texto para cambiar la letra " Y " por " y " (en minúscula), de modo que el conector gramatical sea correcto.
5. Utiliza caracteres de escape (`\n` y `\t`) para imprimir un pequeño reporte estructurado que muestre el antes y el después, similar a esto:

```text
Reporte de Limpieza Toponímica:
	Registro Original: "   sAnTuaRio de fAuna Y flora iGuaQue   "
	Registro Limpio: "Santuario De Fauna y Flora Iguaque"
Estado: Listo para cruce espacial.
```

### Entregables y Criterios de Evaluación

El objetivo de esta evaluación no es solo que el código funcione, sino que seas capaz de documentar y explicar tus decisiones técnicas.

**1. Archivos de Código:**
Debes desarrollar los algoritmos en al menos uno de los siguientes formatos de archivo:

* Script tradicional (`.py`, `.R`, `.jl`)
* Notebook interactivo (`.ipynb`)
* Documento computacional (`.qmd` con *chunks* de código)

**2. Documento Analítico (Quarto):**
Independientemente del formato de tu código fuente, **debes redactar un documento en Quarto (`.qmd`) y renderizarlo tanto en HTML como en PDF**. En este documento debes incluir tus bloques de código y responder argumentativamente a las siguientes preguntas:

* **Sobre el Ejercicio 1:** ¿Qué índice numérico utilizaste para extraer la longitud de la colección y por qué ese número específicamente? ¿Qué error arrojaría el lenguaje si usas el índice del lenguaje opuesto (ej. usar 0 en R o 1 en Python buscando el primer elemento)?
* **Sobre el Ejercicio 2:** En términos de geoprocesamiento de bases de datos relacionales, ¿por qué es un paso crítico y obligatorio aplicar métodos de limpieza como `.strip()` o `trimws()` antes de realizar uniones de tablas (*Joins*) basadas en nombres de municipios o regiones?
* **Pregunta General:** Explica brevemente la diferencia fundamental entre el uso de triples comillas `"""` en Python versus su uso en Julia.

**3. Repositorio en GitHub:**
Sube tu carpeta del proyecto (que debe contener tus scripts, el archivo `.qmd` y los renders finales en HTML y PDF) a un repositorio público en tu cuenta personal de **GitHub**.

* **Entrega:** Deberás enviar únicamente el enlace (URL) a tu repositorio de GitHub para la calificación.
