[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Programación SIG: Python, R y Julia",
    "section": "",
    "text": "Bienvenida\nBienvenido a la documentación del curso Programación en SIG de la Maestría en Geomática de la Universidad Nacional de Colombia.\nEste recurso ha sido diseñado como una guía teórico-práctica para el análisis y procesamiento de datos geográficos utilizando los tres lenguajes más potentes en la ciencia de datos actual: Python, R y Julia.",
    "crumbs": [
      "Bienvenida"
    ]
  },
  {
    "objectID": "index.html#objetivos-del-curso",
    "href": "index.html#objetivos-del-curso",
    "title": "Programación SIG: Python, R y Julia",
    "section": "Objetivos del curso",
    "text": "Objetivos del curso\nEl objetivo principal es que el estudiante desarrolle habilidades para automatizar procesos geoespaciales y construir flujos de trabajo reproducibles.\n\nPython: Lenguaje principal de enfoque.\nR: Comparativa para análisis estadístico espacial.\nJulia: Alternativa de alto rendimiento para computación científica.",
    "crumbs": [
      "Bienvenida"
    ]
  },
  {
    "objectID": "index.html#cómo-usar-este-libro",
    "href": "index.html#cómo-usar-este-libro",
    "title": "Programación SIG: Python, R y Julia",
    "section": "Cómo usar este libro",
    "text": "Cómo usar este libro\nA lo largo de los capítulos, encontrarás ejemplos de código organizados en pestañas (tabs). Aunque el énfasis de las explicaciones está en Python, puedes alternar entre lenguajes para ver cómo se implementa la misma lógica en los otros entornos:\n\n\n\n\n\n\nNota\n\n\n\nUtiliza las pestañas superiores en los bloques de código para cambiar entre Python, R y Julia.",
    "crumbs": [
      "Bienvenida"
    ]
  },
  {
    "objectID": "index.html#requisitos-previos",
    "href": "index.html#requisitos-previos",
    "title": "Programación SIG: Python, R y Julia",
    "section": "Requisitos previos",
    "text": "Requisitos previos\nPara seguir este curso, se proveen guías de instalación de: - Docker Desktop (para el entorno unificado). - Editor de código VSCode. - QGIS - ArcGIS Pro - Conocimientos básicos de Sistemas de Información Geográfica (SIG) y manejo de datos vectoriales/raster.",
    "crumbs": [
      "Bienvenida"
    ]
  },
  {
    "objectID": "index.html#sec-licencia",
    "href": "index.html#sec-licencia",
    "title": "Programación SIG: Python, R y Julia",
    "section": "Licencia y citación del material",
    "text": "Licencia y citación del material\n\nLicencia de uso\nEste material de curso se distribuye bajo una licencia Creative Commons Atribución-NoComercial 4.0 Internacional (CC BY-NC 4.0).\n\n\n\n\n\n\nLo que esto significa para el estudiante:\n\n\n\nBajo los principios de Open Science, usted es libre de: 1. Compartir: Copiar y redistribuir el material en cualquier medio o formato. 2. Adaptar: Remezclar, transformar y construir sobre el material para fines académicos e investigativos.\nBajo las siguientes condiciones: * Atribución: Debe dar crédito de manera adecuada, brindar un enlace a la licencia e indicar si se han realizado cambios. * No comercial: No puede hacer uso del material con fines comerciales o de lucro.\n\n\n\n\n\nCómo citar este material\nSi utiliza este código, las guías o los datos en sus propios proyectos o investigaciones, por favor incluya las siguientes referencias:\n\nReferencia en formato APA (7ma edición)\n\nRodríguez-Avellaneda, A. H. (2026). Programación en SIG: R, Python y Julia [Material de curso]. Maestría en Geomática, Universidad Nacional de Colombia. Recuperado de https://github.com/alexyshr/ProgramacionSIG2026\n\n\n\nReferencia en formato BibTeX (Para LaTeX/Zotero)\n@misc{rodriguez2026sig,\n  author = {Rodriguez-Avellaneda, Alexys H.},\n  title = {Programación en SIG: R, Python y Julia},\n  year = {2026},\n  howpublished = {Material de curso, Maestría en Geomática},\n  publisher = {Universidad Nacional de Colombia},\n  url = {[https://github.com/alexyshr/ProgramacionSIG2026](https://github.com/alexyshr/ProgramacionSIG2026)},\n  note = {Licencia CC BY-NC 4.0}\n}",
    "crumbs": [
      "Bienvenida"
    ]
  },
  {
    "objectID": "index.html#sec-contacto",
    "href": "index.html#sec-contacto",
    "title": "Programación SIG: Python, R y Julia",
    "section": "Contacto y colaboración",
    "text": "Contacto y colaboración\nEste documento es una obra en construcción permanente en el marco de la ciencia abierta. Si encuentra errores, omisiones o desea proponer mejoras técnicas en los flujos de R, Python o Julia, puede colaborar de las siguientes formas:\n\nAbrir un Issue: Para reportar errores en el código o en la redacción.\nEnviar un Pull Request: Si desea proponer una corrección directa o una nueva funcionalidad.\n\n\n\n\n\n\n\nReconocimiento a herramientas de IA\n\n\n\nGran parte de la orquestación técnica de este entorno (especialmente la resolución de conflictos de librerías en Docker y la creación de funciones puente como j_eval) ha sido refinada con el apoyo de herramientas de Inteligencia Artificial, bajo la supervisión y validación del autor principal.",
    "crumbs": [
      "Bienvenida"
    ]
  },
  {
    "objectID": "00-prefacio.html",
    "href": "00-prefacio.html",
    "title": "Prefacio",
    "section": "",
    "text": "Filosofía del curso: El enfoque “Políglota”\nA diferencia de los cursos tradicionales centrados exclusivamente en un software o un solo lenguaje, este curso adopta una visión inspirada en el trabajo de Edzer Pebesma y Roger Bivand en Spatial Data Science (Pebesma & Bivand, 2023, 2025).\nNuestro enfoque es Python-céntrico, reconociendo su dominio en la industria y la inteligencia artificial, pero integramos R y Julia como aliados estratégicos:",
    "crumbs": [
      "Prefacio"
    ]
  },
  {
    "objectID": "00-prefacio.html#filosofía-del-curso-el-enfoque-políglota",
    "href": "00-prefacio.html#filosofía-del-curso-el-enfoque-políglota",
    "title": "Prefacio",
    "section": "",
    "text": "Python: Nuestra base para la automatización, desarrollo de scripts y flujos de trabajo en la nube.\nR: Para cuando el análisis requiere un rigor estadístico espacial profundo y una visualización cartográfica de alta calidad.\nJulia: Para computación científica de alto rendimiento donde la velocidad de ejecución es crítica.",
    "crumbs": [
      "Prefacio"
    ]
  },
  {
    "objectID": "00-prefacio.html#por-qué-tres-lenguajes",
    "href": "00-prefacio.html#por-qué-tres-lenguajes",
    "title": "Prefacio",
    "section": "¿Por qué tres lenguajes?",
    "text": "¿Por qué tres lenguajes?\nEl objetivo no es que el estudiante sea un experto programador en los tres, sino que comprenda que los motores geoespaciales subyacentes (como GDAL, GEOS y PROJ) son los mismos. Al aprender a interactuar con ellos desde diferentes sintaxis, el estudiante desarrolla una flexibilidad mental que le permitirá adaptarse a cualquier tecnología futura.",
    "crumbs": [
      "Prefacio"
    ]
  },
  {
    "objectID": "00-prefacio.html#datos-de-colombia-como-eje-central",
    "href": "00-prefacio.html#datos-de-colombia-como-eje-central",
    "title": "Prefacio",
    "section": "Datos de Colombia como eje central",
    "text": "Datos de Colombia como eje central\nLa teoría es universal, pero la práctica es local. Todos los ejemplos y ejercicios de este curso están diseñados utilizando datos reales del contexto colombiano:\n\nCapas vectoriales del IGAC y límites administrativos del DANE.\nModelos Digitales de Elevación y productos satelitales sobre la geografía nacional.\nSistemas de Referencia de Coordenadas basados en MAGNA-SIRGAS.",
    "crumbs": [
      "Prefacio"
    ]
  },
  {
    "objectID": "00-prefacio.html#estructura-de-la-documentación",
    "href": "00-prefacio.html#estructura-de-la-documentación",
    "title": "Prefacio",
    "section": "Estructura de la documentación",
    "text": "Estructura de la documentación\nPara facilitar el aprendizaje comparado, esta guía utiliza un sistema de pestañas. En la mayoría de los capítulos, verás bloques de código organizados así:\n\nPython (principal)R (alternativa)Julia (alto rendimiento)\n\n\nExplicación de la implementación en Python usando librerías como geopandas, rasterio o shapely.\n\n\nEquivalente funcional utilizando sf, terra o stars.\n\n\nImplementación moderna usando ArchGDAL.jl, GeomStats.jl o Rasters.jl.",
    "crumbs": [
      "Prefacio"
    ]
  },
  {
    "objectID": "00-prefacio.html#reproducibilidad",
    "href": "00-prefacio.html#reproducibilidad",
    "title": "Prefacio",
    "section": "Reproducibilidad",
    "text": "Reproducibilidad\nSiguiendo los estándares de la ciencia abierta, todo el entorno de este curso está preconfigurado en contenedores Docker. Esto garantiza que el código que funciona en el computador del profesor funcionará exactamente igual en el del estudiante, eliminando el “infierno de las dependencias” de instalación.\n\n\n\n\nPebesma, E., & Bivand, R. (2023). Spatial Data Science: With Applications in R. Chapman; Hall/CRC. https://doi.org/10.1201/9780429459016\n\n\nPebesma, E., & Bivand, R. (2025). Spatial Data Science: With Applications in R and Python. https://r-spatial.org/python/",
    "crumbs": [
      "Prefacio"
    ]
  },
  {
    "objectID": "01-introduccion-entornos.html",
    "href": "01-introduccion-entornos.html",
    "title": "1  Introducción a Entornos de Desarrollo SIG",
    "section": "",
    "text": "1.1 Estrategia de Trabajo: Arquitectura Híbrida\nPara el desarrollo del curso, utilizaremos tres enfoques que permiten equilibrar la potencia del software de escritorio (comercial y libre) con el rigor de la ciencia de datos reproducible. Esta estructura garantiza que el estudiante adquiera competencias tanto en la automatización de software SIG tradicional como en el análisis de datos geoespaciales moderno.",
    "crumbs": [
      "Instalación y Entornos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción a Entornos de Desarrollo SIG</span>"
    ]
  },
  {
    "objectID": "01-introduccion-entornos.html#estrategia-de-trabajo-arquitectura-híbrida",
    "href": "01-introduccion-entornos.html#estrategia-de-trabajo-arquitectura-híbrida",
    "title": "1  Introducción a Entornos de Desarrollo SIG",
    "section": "",
    "text": "Comparativa de Entornos\n\n\n\n\n\n\n\n\n\nCriterio\nOpción A: Contenedor (Docker)\nOpción B: Nativo (OSGeo4W)\nOpción C: Nativo (ArcGIS Pro)\n\n\n\n\nTecnología\nDocker (Inc., 2025) Compose (JupyterLab).\nOSGeo4W - QGIS (Rosas-Chavoya et al., 2022) LTR.\nArcGIS Pro (Law & Collins, 2019) (Conda Environment).\n\n\nUso Principal\nAnálisis masivo y Ciencia de Datos.\nAutomatización SIG con PyQGIS (Lawhead, 2017).\nGeoprocesamiento y ArcPy (Toms, 2015).\n\n\nVentaja\nEntorno idéntico y reproducible.\nAcceso a drivers locales y QGIS.\nHerramientas comerciales avanzadas.\n\n\nLenguajes\nPython (Python, 2021), R (R Core Team, 2025) y Julia (Bezanson et al., 2017) (Preconfigurados).\nPython (PyQGIS).\nPython (ArcPy).\n\n\n\n\n\nSecuencia Didáctica y Uso de Entornos\nEl curso seguirá una progresión lógica desde la abstracción de datos y bases de datos hacia la automatización en software especializado:\n\n\n\n\n\n\n\n\n\nEtapa\nEntorno Sugerido\nContenido Temático\nRazón\n\n\n\n\nFase 1: Fundamentos y DB (Semanas 1-7)\nOpción A: Docker\nPrincipios de programación, estructuras básicas, Ciencia de Datos políglota y PostGIS.\nEntorno controlado para aprender lógica de programación y gestión de bases de datos sin conflictos de instalación.\n\n\nFase 2: Extensibilidad Libre (Semanas 8-11)\nOpción B: OSGeo4W\nDesarrollo de scripts, complementos y automatización dentro de QGIS.\nUso de Python (PyQGIS) para extender las capacidades del software libre más relevante.\n\n\nFase 3: Extensibilidad Comercial (Semanas 12-15)\nOpción C: ArcGIS\nScripts de geoprocesamiento, Toolbox y flujos de trabajo en ArcGIS Pro.\nUso de Python (ArcPy) para automatizar procesos en el entorno comercial líder.\n\n\n\n\n\nPropósito según el Escenario\n\n\n\n\n\n\n\n\n\nEscenario\nUsa la Opción A (Docker/PostGIS)\nUsa la Opción B (QGIS/Python)\nUsa la Opción C (ArcGIS/Python)\n\n\n\n\nPrácticas de clase\nPara aprender Python y consultas SQL espaciales.\nPara automatizar tareas repetitivas en QGIS.\nPara crear herramientas dentro de ArcGIS Pro.\n\n\nAutomatización\nPara flujos de análisis de datos masivos.\nPara interactuar con la API de QGIS (PyQGIS).\nPara interactuar con la API de ArcGIS (ArcPy).\n\n\nEcosistema\nIndependiente del Sistema Operativo.\nEcosistema de Código Abierto (OSGeo).\nEcosistema Comercial (ESRI).",
    "crumbs": [
      "Instalación y Entornos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción a Entornos de Desarrollo SIG</span>"
    ]
  },
  {
    "objectID": "01-introduccion-entornos.html#decisiones-de-diseño-del-entorno",
    "href": "01-introduccion-entornos.html#decisiones-de-diseño-del-entorno",
    "title": "1  Introducción a Entornos de Desarrollo SIG",
    "section": "1.2 Decisiones de Diseño del Entorno",
    "text": "1.2 Decisiones de Diseño del Entorno\nLa Opción A constituye el núcleo de la Ciencia de Datos Espaciales del curso. Al integrar PostGIS en este entorno, se garantiza que los estudiantes practiquen la persistencia de datos y el análisis SQL desde la primera fase.\nLas Opciones B y C tienen como propósito específico el dominio de Python dentro de los entornos de software SIG de mayor relevancia, permitiendo al estudiante tener acceso a todas las funcionalidades, motores de renderizado y herramientas de geoprocesamiento nativas de QGIS y ArcGIS respectivamente.\n\n\n\n\nBezanson, J., Edelman, A., Karpinski, S., & Shah, V. B. (2017). Julia: A fresh approach to numerical computing. SIAM review, 59(1), 65-98.\n\n\nInc., D. (2025). Docker Desktop Documentation. https://docs.docker.com\n\n\nLaw, M., & Collins, A. (2019). Getting to know ArcGIS PRO. (No Title).\n\n\nLawhead, J. (2017). QGIS python programming cookbook. Packt Publishing Ltd.\n\n\nPython, W. (2021). Python. Python releases for windows, 24. http://static.softwaresuggest.com.s3.amazonaws.com/ssguides/1604480172_Python_read%20(1).pdf\n\n\nR Core Team. (2025). R: A Language and Environment for Statistical Computing. R Foundation for Statistical Computing. https://www.R-project.org/\n\n\nRosas-Chavoya, M., Gallardo-Salazar, J. L., López-Serrano, P. M., Alcántara-Concepción, P. C., & León-Miranda, A. K. (2022). QGIS a constantly growing free and open-source geospatial software contributing to scientific development. Cuadernos de Investigación Geográfica, 48(1), 197-213.\n\n\nToms, S. (2015). ArcPy and ArcGIS–geospatial analysis with Python. Packt Publishing Ltd.",
    "crumbs": [
      "Instalación y Entornos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción a Entornos de Desarrollo SIG</span>"
    ]
  },
  {
    "objectID": "02-guia_instalacion_A_docker.html",
    "href": "02-guia_instalacion_A_docker.html",
    "title": "2  Guía de Instalación. Opción A: Contenedor Docker (Python, R, Julia)",
    "section": "",
    "text": "2.1 Introducción al Entorno de Trabajo\nEsta guía establece un entorno de Reproducibilidad Científica. Utilizaremos una arquitectura híbrida: VSCode como editor local (Microsoft Corporation, 2026) y Docker como laboratorio de ejecución (Inc., 2025). Esta aproximación garantiza que todos los estudiantes operen bajo las mismas versiones de motores geoespaciales (GDAL, GEOS, PROJ), eliminando el problema de “en mi computador no funciona”.",
    "crumbs": [
      "Instalación y Entornos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Guía de Instalación. Opción A: Contenedor Docker (Python, R, Julia)</span>"
    ]
  },
  {
    "objectID": "02-guia_instalacion_A_docker.html#introducción-al-entorno-de-trabajo",
    "href": "02-guia_instalacion_A_docker.html#introducción-al-entorno-de-trabajo",
    "title": "2  Guía de Instalación. Opción A: Contenedor Docker (Python, R, Julia)",
    "section": "",
    "text": "Preparación de Herramientas en Windows\nPara preparar su equipo de trabajo, instale las siguientes herramientas básicas:\n\nVSCode IDE: Su interfaz principal para editar archivos .qmd y gestionar código (Microsoft Corporation, 2026). En el anexo de referencia técnica encontrará las principales extensiones (Sección E.2) necesarias a instalar en VSCode.\nDocker Desktop: Motor de virtualización que ejecutará nuestro laboratorio SIG (Inc., 2025). Durante la instalación, asegúrese de activar la opción “Use WSL 2 instead of Hyper-V”.\n\nSiguiendo los pasos detallados a continuación para instalar dos contenedores Docker, en resumen, ellos contendrán (no es necesario instalarlos manualmente):\n\nPython, R y Julia con los principales paquetes/librerías para geoprocesamiento.\nQuarto.\nTinyTeX: Motor ligero de LaTeX necesario para compilar reportes profesionales (ej. en Quarto) en formato PDF (Xie, 2019). Si desea instalar TinyTeX para generar PDF por fuera del entorno Docker, desde la terminal de VSCode use el comando (opcional: fuera de clase):\n\n  quarto install tinytex\n\nPostgreSQL + PostGIS\n\n\n\nEnlaces de Descarga e Instalación\nDescargue e instale las versiones oficiales desde los siguientes enlaces:\n\nVSCode IDE:\n\nURL: https://code.visualstudio.com/\nInstalación: Seleccione el instalador .exe más reciente para Windows.\n\nDocker Desktop:\n\nURL: https://www.docker.com/products/docker-desktop/\nInstalación: Ejecute el instalador y asegúrese de aceptar la actualización del kernel de WSL 2 si el sistema lo solicita, o previamente usar en el terminal wsl --update.",
    "crumbs": [
      "Instalación y Entornos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Guía de Instalación. Opción A: Contenedor Docker (Python, R, Julia)</span>"
    ]
  },
  {
    "objectID": "02-guia_instalacion_A_docker.html#sec-infraestructura",
    "href": "02-guia_instalacion_A_docker.html#sec-infraestructura",
    "title": "2  Guía de Instalación. Opción A: Contenedor Docker (Python, R, Julia)",
    "section": "2.2 Infraestructura a instalar",
    "text": "2.2 Infraestructura a instalar\nPara garantizar un entorno de análisis SIG reproducible y políglota, utilizaremos la orquestación de contenedores. Este enfoque permite ejecutar, de forma aislada y coordinada, tanto el motor de procesamiento como el servidor de datos.\n\nEl Manifiesto Técnico: Dockerfile y docker-compose.yml\n\n\n\n\n\n\nOrganización del Proyecto\n\n\n\nPara automatizar el despliegue de los dos contenedores del curso (analisis-geo y db-postgis), utilizaremos la orquestación de Docker. Mientras que el entorno de análisis se construye a medida sobre la imagen base ghcr.io/osgeo/gdal:ubuntu-full-latest, el servicio de base de datos utiliza la imagen especializada kartoza/postgis.\nPara este proceso, utilizaremos dos archivos clave: docker-compose.yml y Dockerfile.\n\n\n\nCree una carpeta utilizando su ID de usuario de correo institucional como nombre (el identificador que aparece antes del @unal.edu.co). Por ejemplo, si su correo es juperez@unal.edu.co, la carpeta deberá llamarse juperez. En adelante llamaremos a esa carpeta su_carpeta o la carpeta ID UNAL.\nDentro de ella, guarde los archivos que se presentan a continuación.\n\n\nArchivo docker-compose.yml (Orquestación)\nEste archivo es el manifiesto técnico que automatiza la construcción y coordinación de los servicios del curso. Su propósito es definir las reglas de convivencia entre los contenedores, configurando los siguientes pilares:\n\nImágenes: Versiones exactas de software (GDAL/Ubuntu para análisis y PostGIS para datos).\nPuertos: Mapeos específicos para acceder a las herramientas desde Windows sin conflictos (8889 para Jupyter, 8788 para el visor de R y 5434 para la base de datos).\nVolúmenes: Garantizan la persistencia de datos, sincronizando su carpeta local en tiempo real con el entorno interno del contenedor.\n\nA continuación, se describen los dos servicios integrados en este manifiesto:\n\nServicio de Análisis (analisis-geo): Identificado en el archivo como analisis-geo, este servicio se construye a medida (etiqueta build: .) utilizando las instrucciones del Dockerfile. Es el motor políglota encargado de procesar R, Python y Julia sobre una base robusta de GDAL. Incluye una configuración de LD_PRELOAD para la estabilidad de las librerías dinámicas y una integración profunda que permite usar el visor httpgd de R como terminal gráfica unificada para todos los lenguajes. Crea el contenedor contenedor_sig_unal.\nServicio PostGIS (db-postgis): Identificado como db-postgis, este servicio descarga automáticamente la imagen especializada de Kartoza. Levanta el servidor de base de datos sig_db_unal, configurado para recibir conexiones espaciales desde sus scripts o herramientas externas como QGIS o ArcGIS a través del puerto 5434.\n\nservices:\n  # ============================================================\n  # SERVICIO PRINCIPAL\n  # Entorno de análisis geoespacial y científico\n  # Integra R, Python, Julia, GDAL, Quarto y Jupyter\n  # ============================================================\n  analisis-geo:\n    build: .\n    image: image_sig_unal                 # Nombre de la imagen Docker que se construye localmente\n    container_name: contenedor_sig_unal   # Nombre del contenedor (más fácil de usar en docker exec)\n    \n    # Permite sesiones interactivas (terminal, REPLs, etc.)\n    tty: true\n    stdin_open: true\n\n    # Carpeta compartida:\n    # Todo lo que esté en el proyecto (host) aparece dentro del contenedor\n    volumes:\n      - .:/home/rstudio/work\n\n    # ------------------------------------------------------------\n    # VARIABLES DE ENTORNO\n    # Aseguran que R, Python, Julia y Quarto usen versiones correctas\n    # ------------------------------------------------------------\n    environment:\n      - RETICULATE_PYTHON=/usr/bin/python3   # Python que usará R (reticulate)\n      - QUARTO_PYTHON=/usr/bin/python3       # Python que usará Quarto\n      - JULIA_HOME=/opt/julia/bin             # Ruta base de Julia\n\n      # \"Cirugía\" necesaria para evitar conflictos entre Julia y GDAL\n      # (muy común en entornos científicos mixtos)\n      - LD_PRELOAD=/usr/lib/x86_64-linux-gnu/libcurl.so.4:/usr/lib/x86_64-linux-gnu/libstdc++.so.6\n\n      # Backend gráfico de Julia (evita errores al graficar en contenedores)\n      - GKSwstype=100\n\n    # ------------------------------------------------------------\n    # PUERTOS\n    # izquierda = computador del estudiante (acceso externo con localhost)\n    # derecha   = contenedor (acceso interno - EXPOSE)\n    # ------------------------------------------------------------\n    ports:\n      # Jupyter Notebook / JupyterLab\n      # Se accede desde el navegador en: http://localhost:8889\n      - \"127.0.0.1:8889:8888\"\n\n      # Visor de gráficos de R (httpgd)\n      # Permite ver gráficos interactivos fuera de RStudio\n      - \"127.0.0.1:8788:8787\"\n\n    # Este servicio solo se inicia cuando la base de datos esté lista\n    depends_on:\n      - db-postgis\n\n  # ============================================================\n  # SERVICIO DE BASE DE DATOS\n  # PostgreSQL + PostGIS para datos espaciales\n  # ============================================================\n  db-postgis:\n    image: kartoza/postgis:latest\n    container_name: contenedor_postgis_unal\n\n    # Credenciales y base de datos inicial\n    environment:\n      - POSTGRES_USER=profe_unal\n      - POSTGRES_PASS=geomatica2025\n      - POSTGRES_DB=sig_db_unal\n\n    # Puerto para conectarse desde QGIS, DBeaver, PgAdmin, etc.\n    ports:\n      - \"127.0.0.1:5434:5432\"\n\n    # Volumen persistente:\n    # Los datos NO se pierden aunque el contenedor se borre\n    volumes:\n      - postgis_data_unal:/var/lib/postgresql\n\n# ============================================================\n# VOLUMENES DOCKER\n# Espacio en disco administrado por Docker\n# ============================================================\nvolumes:\n  postgis_data_unal:\n\n\n\nArchivo Dockerfile (Construcción del Entorno)\nEste archivo constituye la receta de construcción del entorno de análisis. Su función es “congelar” un sistema operativo Ubuntu Noble optimizado, garantizando que todos los estudiantes trabajen exactamente con las mismas versiones de librerías, compiladores y paquetes.\nLos pilares técnicos de este archivo son:\n\nImagen Base Profesional: Utiliza la distribución oficial de OSGeo/GDAL, que provee el stack más estable de librerías geoespaciales (PROJ, GEOS, GDAL) a nivel de sistema.\nPila Políglota Integrada: Automatiza la instalación y configuración de R, Python 3 y Julia 1.10.4, resolviendo dependencias cruzadas que suelen ser difíciles de configurar manualmente.\nMotor de Reportes Científicos: Instala Quarto y TinyTeX, permitiendo la generación automática de informes en PDF y HTML con calidad editorial.\nPuente de Comunicación Maestro: Configura el archivo Rprofile.site, el cual actúa como el “cerebro” que permite a R ejecutar código de Julia y capturar gráficos de Python de forma transparente.\n\n# ============================================================\n# Imagen base\n# ------------------------------------------------------------\n# Imagen oficial de OSGeo con GDAL completo, PROJ, GEOS y soporte\n# raster/vector profesional. Base estándar en SIG reproducible.\n# ============================================================\nFROM ghcr.io/osgeo/gdal:ubuntu-full-latest\n\n\n# ============================================================\n# 1. Base, Locales y Pandoc\n# ------------------------------------------------------------\n# Configuración UTF-8 para evitar problemas con acentos,\n# R, Python, Julia, LaTeX y generación de documentos.\n# ============================================================\nENV LANG=en_US.UTF-8\nENV LC_ALL=en_US.UTF-8\n\n# Herramientas base del sistema:\n# - compiladores y toolchain (C/C++)\n# - git / curl / wget para descargas\n# - pandoc como motor universal de documentos\nRUN apt-get update && apt-get install -y locales git curl wget ca-certificates \\\n    build-essential cmake libtool automake pkg-config software-properties-common \\\n    pandoc && \\\n    locale-gen en_US.UTF-8\n\n\n# ============================================================\n# Librerías criptográficas y de red\n# ------------------------------------------------------------\n# Necesarias para:\n# - conexiones HTTPS\n# - Julia\n# - GDAL\n# - acceso a APIs externas\n# ============================================================\nRUN apt-get update && apt-get install -y --no-install-recommends \\\n    libmbedtls-dev \\\n    libnng-dev \\\n    libssl-dev \\\n    libxml2-dev \\\n    libcurl4-openssl-dev \\\n    git \\\n    cmake\n\n\n# ============================================================\n# 2. R, Python y dependencias de sistema\n# ------------------------------------------------------------\n# Incluye soporte para:\n# - SIG (GDAL / GEOS / PROJ)\n# - NetCDF / HDF5\n# - NASA / Copernicus\n# - WhiteboxTools\n# ============================================================\nRUN apt-get update && apt-get install -y --no-install-recommends \\\n    r-base r-base-dev python3-pip python3-dev \\\n    psmisc lsof net-tools ffmpeg \\\n    libpng-dev libcairo2-dev libsystemd-dev \\\n    libfontconfig1-dev libfreetype6-dev \\\n    libharfbuzz-dev libfribidi-dev \\\n    libcurl4-openssl-dev libsqlite3-dev libxml2-dev libssl-dev \\\n    libgeos-dev libproj-dev libgdal-dev libudunits2-dev \\\n    libgit2-dev libssh2-1-dev libxt-dev libglpk-dev libmount-dev \\\n    libmagick++-dev libpcre2-dev libnetcdf-dev libhdf5-dev \\\n    libxt6 libxrender1 libxext6 default-jdk \\\n    # Elimina la restricción de pip en Debian/Ubuntu modernos\n    && rm /usr/lib/python3.12/EXTERNALLY-MANAGED || true && \\\n    rm -rf /var/lib/apt/lists/*\n\n\n# ============================================================\n# 3. Quarto CLI y TinyTeX\n# ------------------------------------------------------------\n# Quarto: documentos reproducibles (HTML, PDF, slides)\n# TinyTeX: LaTeX liviano para generación de PDF\n# ============================================================\nRUN curl -LO https://github.com/quarto-dev/quarto-cli/releases/download/v1.4.550/quarto-1.4.550-linux-amd64.deb \\\n    && dpkg -i quarto-1.4.550-linux-amd64.deb && rm quarto-1.4.550-linux-amd64.deb \\\n    && quarto install tinytex --no-prompt\n\n\n# ============================================================\n# 4. Python Stack\n# ------------------------------------------------------------\n# Librerías SIG, ciencia de datos, notebooks y visualización\n# ============================================================\nRUN pip3 install --upgrade --ignore-installed --break-system-packages \\\n    # Ya estaban:\n    shapely matplotlib numpy geopandas fiona pyyaml nbformat nbclient ipykernel \\\n    # Nuevos agregados:\n    pandas rasterio rasterstats scipy psycopg2 pysal earthaccess cdsapi leafmap \\\n    geemap segment-geospatial geoai-py lidar pygis whitebox whiteboxgui streamlit \\\n    ghp-import jupyter-book jupyterlab jupytext mystmd notebook\n\n\n# ============================================================\n# 5. R Stack\n# ------------------------------------------------------------\n# Instalación desde CRAN optimizado de Posit para Linux\n# Incluye SIG, visualización, modelado y ML espacial\n# ============================================================\nRUN R -e \"options(timeout = 1000, Ncpus = parallel::detectCores(), repos = c(CRAN = 'https://packagemanager.posit.co/cran/__linux__/noble/latest')); \\\n    install.packages(c('ggplot2', 'patchwork', 'dplyr', 'remotes', 'languageserver', \\\n    'rmarkdown', 'units', 's2', 'sf', 'terra', 'stars', 'reticulate', 'IRkernel', \\\n    'unigd', 'cpp11', 'systemfonts', 'AsioHeaders', 'png', 'grid', 'JuliaCall', 'JuliaConnectoR', \\\n    # Nuevos CRAN:\n    'tidyverse', 'tmap', 'leaflet', 'googleway', 'ggspatial', 'mapview', 'plotly', \\\n    'rasterVis', 'cartogram', 'geogrid', 'geofacet', 'linemap', 'tanaka', 'rayshader', \\\n    'lwgeom', 'gstat', 'spdep', 'spatialreg', 'stplanr', 'sfnetworks', 'spatstat', \\\n    'stpp', 'magrittr', 'giscoR', 'caret', 'tidymodels', 'spatialsample', 'CAST', \\\n    'mlr3spatial', 'mlr3spatiotempcv', 'ncdf4', 'whitebox'))\"\n\n\n# ============================================================\n# Starsdata y repositorios específicos\n# ------------------------------------------------------------\n# Se compila desde código fuente y se usan repos especiales\n# ============================================================\nRUN R -e \"options(timeout = 30000, Ncpus = parallel::detectCores()); \\\n    install.packages('starsdata', repos='https://cran.uni-muenster.de/pebesma/', type='source')\" && \\\n    R -e \"options(timeout = 2000, Ncpus = parallel::detectCores()); \\\n    install.packages(c('mlr3cmprsk', 'survdistr'), repos=c('https://mlr3learners.r-universe.dev', 'https://cloud.r-project.org')); \\\n    install.packages('geocompkg', repos=c('https://geocompr.r-universe.dev', 'https://cloud.r-project.org'), dependencies=TRUE); \\\n    whitebox::install_whitebox(); IRkernel::installspec(user = FALSE)\"\n\n\n# ============================================================\n# httpgd estable\n# ------------------------------------------------------------\n# Dispositivo gráfico moderno para R (gráficos en navegador)\n# ============================================================\nRUN wget https://cran.r-project.org/src/contrib/Archive/httpgd/httpgd_2.0.3.tar.gz && \\\n    R CMD INSTALL httpgd_2.0.3.tar.gz && rm httpgd_2.0.3.tar.gz\n\n# ============================================================\n# 6. Puente Python ↔ R (Backend de Matplotlib para reticulate)\n# ------------------------------------------------------------\n# Permite que gráficos de matplotlib generados desde Python\n# puedan ser capturados y mostrados correctamente desde R\n# usando reticulate (especialmente en notebooks y httpgd).\n# ============================================================\n\n# Creamos la estructura esperada por reticulate\nRUN mkdir -p /usr/local/lib/python3.12/dist-packages/reticulate/matplotlib && \\\n    touch /usr/local/lib/python3.12/dist-packages/reticulate/__init__.py\n\n# Definimos una función que R puede interceptar\n# para recibir el path de la imagen generada por Python\nRUN printf 'def r_graphic_command(path):\\n    import os\\n    if os.path.exists(path): print(f\"r_graphic_command: {path}\")\\n' &gt; /usr/local/lib/python3.12/dist-packages/reticulate/__init__.py\n\n# Backend custom de matplotlib:\n# - Renderiza con Agg\n# - Guarda el gráfico como PNG temporal\n# - Notifica a R para que lo muestre\nRUN printf 'import matplotlib\\nfrom matplotlib.backends.backend_agg import FigureCanvasAgg\\nfrom matplotlib.backend_bases import FigureManagerBase\\n\\ndef show(*args, **kwargs):\\n    import os, tempfile, reticulate\\n    fd, path = tempfile.mkstemp(suffix=\".png\")\\n    os.close(fd)\\n    matplotlib.pyplot.savefig(path)\\n    if hasattr(reticulate, \"r_graphic_command\"):\\n        reticulate.r_graphic_command(path)\\n\\nclass FigureManager(FigureManagerBase):\\n    def show(self):\\n        show()\\n\\ndef new_figure_manager(num, *args, **kwargs):\\n    FigureClass = kwargs.pop(\"FigureClass\", matplotlib.figure.Figure)\\n    thisFig = FigureClass(*args, **kwargs)\\n    return new_figure_manager_given_figure(num, thisFig)\\n\\ndef new_figure_manager_given_figure(num, figure):\\n    canvas = FigureCanvasAgg(figure)\\n    manager = FigureManager(canvas, num)\\n    return manager\\n\\nFigureCanvas = FigureCanvasAgg\\n' &gt; /usr/local/lib/python3.12/dist-packages/reticulate/matplotlib/backend.py\n\n\n# ============================================================\n# 7. Julia: Instalación y Wrapper de Seguridad\n# ------------------------------------------------------------\n# Se instala Julia binaria oficial y se fuerza el uso de\n# librerías del sistema para evitar conflictos con GDAL/OpenSSL\n# ============================================================\n\n# Versión fija de Julia (reproducibilidad total)\nENV JULIA_VERSION=1.10.4\n\n# Descarga e instalación manual de Julia\nRUN wget https://julialang-s3.julialang.org/bin/linux/x64/1.10/julia-${JULIA_VERSION}-linux-x86_64.tar.gz \\\n    && tar -xvzf julia-${JULIA_VERSION}-linux-x86_64.tar.gz && mv julia-1.10.4 /opt/julia\n\n# Wrapper de Julia:\n# - Fuerza LD_PRELOAD\n# - Evita conflictos de libcurl / libstdc++\n# - Garantiza compatibilidad con GDAL\nRUN printf '#!/bin/bash\\nexport LD_PRELOAD=/usr/lib/x86_64-linux-gnu/libcurl.so.4:/usr/lib/x86_64-linux-gnu/libstdc++.so.6\\nexport JULIA_PKG_USE_CLI_GIT=true\\n/opt/julia/bin/julia \"$@\"\\n' &gt; /usr/local/bin/julia && chmod +x /usr/local/bin/julia\n    \n\n# ============================================================\n# 8. Julia: Configuración de librerías nativas\n# ------------------------------------------------------------\n# Se fijan explícitamente las rutas del sistema para:\n# - GDAL\n# - GEOS\n# evitando que Julia use binarios incompatibles\n# ============================================================\nRUN mkdir -p /root/.julia/environments/v1.10 && \\\n    printf \"[LocalPreferences]\\nGDAL_jll = { libgdal_path = \\\"/usr/lib/libgdal.so\\\" }\\nGEOS_jll = { libgeos_path = \\\"/usr/lib/x86_64-linux-gnu/libgeos_c.so\\\" }\\n\" &gt; /root/.julia/environments/v1.10/LocalPreferences.toml\n\n\n# ============================================================\n# 9. Julia: Instalación de paquetes\n# ------------------------------------------------------------\n# Stack SIG completo:\n# - Rasters, ArchGDAL, GeoStats, Makie\n# - Conectores DB, CSV, NetCDF\n# - Visualización y notebooks (IJulia)\n# ============================================================\nRUN julia -e 'using Pkg; Pkg.add([\"Preferences\", \"Suppressor\", \"RCall\", \"LibGEOS\", \"Tables\", \"DataFrames\", \"Plots\", \\\n    \"Statistics\", \"ArchGDAL\", \"LibPQ\", \"GeoDataFrames\", \"IJulia\", \"CSV\", \"CairoMakie\", \"AlgebraOfGraphics\", \\\n    \"DimensionalData\", \"FlexiJoins\", \"GeoFormatTypes\", \"GeoInterface\", \"GeoJSON\", \"GeoMakie\", \"GeometryOps\", \\\n    \"Makie\", \"MakieCore\", \"NaturalEarth\", \"Proj\", \"Rasters\", \"StatsBase\", \"Tyler\", \"GeoStats\", \"Graphs\", \\\n    \"NCDatasets\", \"MetaGraphsNext\"])'\n\n\n# ============================================================\n# Cirugía de librerías (OpenSSL)\n# ------------------------------------------------------------\n# Fuerza a Julia a usar OpenSSL del sistema (Ubuntu Noble)\n# Evita errores de TLS y descargas de paquetes\n# ============================================================\nRUN find /root/.julia/artifacts -name \"libssl.so*\" -exec ln -sf /usr/lib/x86_64-linux-gnu/libssl.so.3 {} \\; && \\\n    find /root/.julia/artifacts -name \"libcrypto.so*\" -exec ln -sf /usr/lib/x86_64-linux-gnu/libcrypto.so.3 {} \\;\n\n\n# ============================================================\n# Precompilación total de Julia\n# ------------------------------------------------------------\n# Garantiza arranque instantáneo en:\n# - VSCode\n# - Jupyter\n# - IJulia\n# ============================================================\nRUN julia -e 'using Pkg; Pkg.precompile()'\n\n\n# ============================================================\n# Configuración de paralelismo\n# ------------------------------------------------------------\n# Julia usará automáticamente todos los núcleos disponibles\n# ============================================================\nENV JULIA_NUM_THREADS=auto\n\n# ============================================================\n# 10. CONFIGURACIÓN MAESTRA Rprofile.site\n# ------------------------------------------------------------\n# Este archivo se ejecuta automáticamente cada vez que inicia R.\n# Centraliza la integración R ↔ Julia ↔ Python ↔ VSCode.\n#\n# Build 47.42:\n# - Control de DPI, tamaño y fuentes\n# - Ejecución segura de Julia desde R\n# - Renderizado consistente de gráficos\n# - Hook para Matplotlib vía reticulate\n# ============================================================\n\nRUN cat &lt;&lt; 'EOF' &gt; /usr/lib/R/etc/Rprofile.site\n# ============================================================\n# --- 1. AJUSTES DE SISTEMA ---\n# ------------------------------------------------------------\n# Variables globales para que R sepa dónde encontrar:\n# - Julia\n# - Python usado por Quarto\n# ============================================================\nSys.setenv(JULIA_BINDIR = \"/opt/julia/bin\")\nSys.setenv(QUARTO_PYTHON = \"/usr/bin/python3\")\n\n# ============================================================\n# Código Julia embebido (auto-sanable)\n# ------------------------------------------------------------\n# Se define como string para:\n# - Inyectarse dinámicamente en Julia\n# - Evitar errores si el kernel se reinicia\n# - Garantizar reproducibilidad en notebooks\n# ============================================================\n.unal_julia_code &lt;- '\nusing Suppressor, Plots, Statistics\n\n# Ejecutor central de código Julia desde R\n# - Evalúa múltiples expresiones\n# - Captura stdout\n# - Maneja gráficos y texto\nfunction _unal_core_executor(code, is_plot, filename, dpi, w, h, fs)\n    @capture_out begin\n        if is_plot\n            # Parámetros gráficos homogéneos (DPI, tamaño, fuentes)\n            default(dpi=dpi, size=(w, h), titlefontsize=fs+2, \n                    guidefontsize=fs, tickfontsize=fs-2, legendfontsize=fs-1)\n        end\n        pos = 1\n        while pos &lt;= lastindex(code)\n            start_idx = pos\n            try\n                ex, pos = Meta.parse(code, pos)\n                cmd_part = strip(code[start_idx:prevind(code, pos)])\n                if !isempty(cmd_part)\n                    println(\"julia&gt; \", cmd_part)\n                    res = eval(ex)\n                    if res !== nothing && !(res isa Plots.Plot)\n                        show(stdout, MIME(\"text/plain\"), res)\n                        println()\n                    end\n                    println() \n                end\n            catch e\n                println(\"julia&gt; Error: \", e)\n                break\n            end\n        end\n        # Guardado del gráfico si aplica\n        if is_plot && current() !== nothing; savefig(current(), filename); end\n    end\nend\n'\n\n# ============================================================\n# Inicialización segura de Julia\n# ------------------------------------------------------------\n# - Verifica que JuliaConnectoR esté disponible\n# - Inyecta el ejecutor solo una vez por sesión\n# ============================================================\n.ensure_julia_ready &lt;- function() {\n  if (!requireNamespace(\"JuliaConnectoR\", quietly = TRUE)) stop(\"JuliaConnectoR missing\")\n  if (!JuliaConnectoR::juliaEval('isdefined(Main, :_unal_core_executor)')) {\n    JuliaConnectoR::juliaEval(.unal_julia_code)\n  }\n}\n\n# ============================================================\n# j_eval(): ejecutar código Julia (solo texto)\n# ------------------------------------------------------------\n# Uso típico:\n# j_eval(\"1 + 1\")\n# ============================================================\nj_eval &lt;- function(cmd) {\n  .ensure_julia_ready()\n  cat(JuliaConnectoR::juliaCall(\"_unal_core_executor\", cmd, FALSE, \"\", 72, 800, 500, 12))\n}\n\n# ============================================================\n# j_plot(): ejecutar código Julia con gráficos\n# ------------------------------------------------------------\n# - Guarda el gráfico en PNG\n# - Lo renderiza directamente en R\n# ============================================================\nj_plot &lt;- function(cmd, n = \"tmp_plot.png\", dpi = 300, w = 800, h = NULL, ratio = 1.6, fontsize = 12) {\n  .ensure_julia_ready()\n  if (is.null(h)) h &lt;- round(w / ratio)\n  log_out &lt;- JuliaConnectoR::juliaCall(\"_unal_core_executor\", cmd, TRUE, n, dpi, as.integer(w), as.integer(h), as.integer(fontsize))\n  if (nchar(log_out) &gt; 0) cat(log_out)\n  if (file.exists(n)) {\n    img &lt;- png::readPNG(n)\n    grid::grid.newpage()\n    grid::grid.raster(img)\n  }\n}\n\n# ============================================================\n# --- 2. CARGA DE LIBRERÍAS Y DISPOSITIVOS ---\n# ------------------------------------------------------------\n# Librerías base para renderizar imágenes\n# ============================================================\nlibrary(png)\nlibrary(grid)\n\nif (interactive()) {\n\n  # ==========================================================\n  # Visor gráfico httpgd (VSCode / navegador)\n  # ----------------------------------------------------------\n  # Permite gráficos interactivos persistentes\n  # ==========================================================\n  if (requireNamespace(\"httpgd\", quietly = TRUE)) {\n    options(device = \"httpgd\", httpgd.host = \"0.0.0.0\", httpgd.port = 8787, httpgd.token = FALSE)\n  }\n  \n  # ==========================================================\n  # Hook Python → R (Matplotlib)\n  # ----------------------------------------------------------\n  # Captura gráficos de matplotlib y los muestra en R\n  # usando el backend custom definido en Docker\n  # ==========================================================\n  setHook(packageEvent(\"reticulate\", \"onLoad\"), function(...) {\n    try({\n      ret_py &lt;- reticulate::import(\"reticulate\", delay_load = TRUE)\n      reticulate::py_set_attr(ret_py, \"r_graphic_command\", function(path) {\n        if (file.exists(path)) {\n          img &lt;- png::readPNG(path)\n          grid::grid.newpage()\n          grid::grid.raster(img)\n        }\n      })\n      reticulate::py_run_string(\"import matplotlib; matplotlib.use('module://reticulate.matplotlib.backend')\")\n    }, silent = TRUE)\n  })\n}\nEOF\n\n\n# ============================================================\n# Compatibilidad multi-R (opcional)\n# ------------------------------------------------------------\n# Permite que R instalado en rutas alternativas use\n# exactamente la misma configuración\n# ============================================================\n#RUN cp /usr/lib/R/etc/Rprofile.site /etc/R/Rprofile.site\n\n\n# ============================================================\n# 10. Finalización del contenedor\n# ------------------------------------------------------------\n# Directorio de trabajo compartido\n# Permisos amplios para docencia\n# ============================================================\nWORKDIR /home/rstudio/work\nRUN chmod -R 777 /home/rstudio/work\n\n# Puertos:\n# 8888 → JupyterLab\n# 8787 → httpgd / RStudio-like viewer\nEXPOSE 8888\nEXPOSE 8787\n\n# Arranque por defecto: JupyterLab\nCMD [\"jupyter\", \"lab\", \"--ip=0.0.0.0\", \"--port=8888\", \"--no-browser\", \"--allow-root\", \"--NotebookApp.token='geomatica2025'\"]\n\n\nStack de Python\nPara el análisis geoespacial avanzado, es necesario instalar un conjunto de librerías especializadas. El núcleo de este entorno es geopandas, cuya instalación gestiona automáticamente dependencias críticas como numpy (cálculo numérico), pandas (manipulación de datos) y shapely (operaciones geométricas). Complementariamente, instalaremos rasterio para la gestión profesional de datos ráster y rasterstats para la extracción de estadísticas zonales.\n\n\n\nTabla 2.1: Paquetes principales de Python\n\n\n\n\n\nPaquete\nFuncionalidad\nSitio web\n\n\n\n\nnumpy\nArreglos\nhttps://numpy.org/\n\n\npandas\nTablas\nhttps://pandas.pydata.org/\n\n\nshapely\nGeometrías vectoriales\nhttps://shapely.readthedocs.io/\n\n\ngeopandas\nCapas vectoriales\nhttps://geopandas.org/\n\n\nrasterio\nRáster\nhttps://rasterio.readthedocs.io/\n\n\nrasterstats\nEstadísticas zonales\nhttps://github.com/perrygeo/python-rasterstats\n\n\npsycopg2\nInterfaz a PostgreSQL\nhttps://www.psycopg.org/docs/\n\n\n\n\n\n\nComo veremos, estos paquetes dependen unos de otros. Las dependencias principales se muestran en la Figura 2.1:\n\n\n\n\n\n\nFigura 2.1: Principales dependencias entre los paquetes de Python que vamos a estudiar. Adaptado de Dorman (2025).\n\n\n\n\ngeopandas: Capa superior que integra a pandas, shapely, fiona y pyproj. Permite realizar consultas espaciales complejas y gestionar GeoDataFrames con una sintaxis simplificada.\nrasterio: Basada en la librería GDAL, es el estándar para la lectura, escritura y manipulación de formatos ráster (como GeoTIFF), permitiendo gestionar metadatos y arreglos de píxeles con alta eficiencia.\nscipy: Proporciona algoritmos avanzados de optimización, álgebra lineal y estadística necesarios para procesos de interpolación y análisis de superficies.\nrasterstats: Herramienta específica para extraer estadísticas (medias, sumas) a partir de capas ráster basadas en geometrías vectoriales.\nshapely: Motor geométrico basado en el estándar Simple Features y puente hacia la librería GEOS. Se encarga de la lógica matemática de las geometrías (áreas, intersecciones, buffers y validación topográfica).\npyproj: Interfaz para la librería PROJ. Gestiona proyecciones cartográficas, sistemas de referencia (CRS) y transformaciones de datums.\nfiona / pyogrio: Motores de acceso a datos vectoriales (SHP, GPKG) que actúan como interfaces hacia la librería GDAL/OGR.\nxyzservices: Repositorio de metadatos para conectar con servicios de mapas base dinámicos (como OpenStreetMap).\n\nLa siguiente tabla vincula las librerías de Python con los motores de cálculo de bajo nivel (C/C++) integrados en el contenedor Docker:\n\n\n\n\n\n\n\n\nLibrería Python\nMotor de Sistema (C/C++)\nFunción Principal en Geomática\n\n\n\n\npyproj\nPROJ\nGestión de Proyecciones y Sistemas de Referencia (CRS).\n\n\nshapely\nGEOS\nÁlgebra topológica (Intersecciones, Buffers, Áreas).\n\n\nfiona / pyogrio\nGDAL/OGR\nLectura y escritura de formatos vectoriales.\n\n\nrasterio\nGDAL\nManejo de datos ráster y metadatos de imágenes.\n\n\ngeopandas\n(Integra los 3 motores)\nGestión integral de GeoDataFrames espaciales.\n\n\n\n\n\nStack de R\nPara el análisis geoespacial en R, utilizaremos un ecosistema robusto basado en el estándar Simple Features y motores de alto rendimiento para datos ráster (rejilla - cuadrículas).\n\n\n\nTabla 2.2: Paquetes principales del stack espacial en R\n\n\n\n\n\nPaquete\nFuncionalidad\nSitio web\n\n\n\n\nsf\nGeometrías vectoriales (Simple Features)\nhttps://r-spatial.github.io/sf/\n\n\nterra\nAnálisis de datos espaciales (Ráster/Vector)\nhttps://rspatial.github.io/terra/\n\n\nstars\nArreglos ordenados espacio-temporales (DataCubes)\nhttps://r-spatial.github.io/stars/\n\n\ntidyverse\nMetapaquete para ciencia de datos\nhttps://www.tidyverse.org/\n\n\ntidyterra\nMétodos de tidyverse para terra\nhttps://dieghernan.github.io/tidyterra/\n\n\n\n\n\n\n\nsf (Simple Features): Es el estándar moderno para el manejo de datos vectoriales. Representa las geometrías como una columna especial en un data frame, permitiendo aplicar toda la potencia de manipulación de tablas a objetos espaciales.\nterra: Motor de alta eficiencia que reemplaza al antiguo paquete raster. Está optimizado para el manejo de grandes volúmenes de datos mediante objetos SpatRaster y SpatVector, permitiendo operaciones de álgebra de mapas y análisis local de manera veloz.\nstars (Spatiotemporal Arrays): Especializada en el manejo de “cubos de datos” (rejillas con dimensiones de espacio, tiempo y múltiples atributos). Es la herramienta ideal para procesar series temporales de imágenes satelitales o modelos climáticos multidimensionales.\ntidyterra: Extiende la gramática de ggplot2 y tidyverse hacia los objetos de terra. Permite visualizar mapas ráster de forma elegante y realizar tuberías (pipes) de datos manteniendo la integridad espacial.\n\n\n\nStack de Julia\nJulia ofrece un rendimiento de nivel C++ con sintaxis simplificada. Debido a que utilizaremos librerías espaciales modernas instaladas vía Mamba, debemos sincronizar el entorno para que el Kernel de Jupyter pueda localizar los controladores actualizados sin colapsar.\n\n\n\nTabla 2.3: Paquetes principales del stack en Julia\n\n\n\n\n\nPaquete\nFuncionalidad\nSitio web\n\n\n\n\nLibPQ.jl\nControlador PostgreSQL/PostGIS\nhttps://juliadatabases.org/LibPQ.jl/dev/\n\n\nArchGDAL.jl\nInterfaz de alto nivel para GDAL\nhttps://yeesian.com/ArchGDAL.jl/\n\n\nLibGEOS.jl\nInterfaz del motor geométrico (GEOS)\nhttps://github.com/JuliaGeo/LibGEOS.jl\n\n\nPlots.jl\nVisualización y generación de gráficos\nhttps://docs.juliaplots.org/\n\n\nDataFrames.jl\nManipulación de datos en memoria\nhttps://dataframes.juliadata.org/\n\n\n\n\n\n\n\nLibPQ.jl: Conector de bajo nivel para PostgreSQL. Es la herramienta que permitirá a los estudiantes realizar ingesta y consulta de datos desde el servidor PostGIS.\nArchGDAL.jl: Proporciona una abstracción de alto nivel para el motor GDAL. Es excelente para transformar formatos y manejar proyecciones.\nLibGEOS.jl: La interfaz directa al motor de geometrías (GEOS). Se utiliza para operaciones topológicas puras como validación de polígonos, intersecciones y cálculos de buffers.\nDataFrames.jl: El estándar para el manejo de datos tabulares en Julia, permitiendo integrar los resultados de las consultas espaciales en estructuras fáciles de analizar.",
    "crumbs": [
      "Instalación y Entornos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Guía de Instalación. Opción A: Contenedor Docker (Python, R, Julia)</span>"
    ]
  },
  {
    "objectID": "02-guia_instalacion_A_docker.html#puesta-en-marcha-y-acceso-al-contenedor-terminal-vscode-jupyterlab",
    "href": "02-guia_instalacion_A_docker.html#puesta-en-marcha-y-acceso-al-contenedor-terminal-vscode-jupyterlab",
    "title": "2  Guía de Instalación. Opción A: Contenedor Docker (Python, R, Julia)",
    "section": "2.3 Puesta en Marcha y Acceso al Contenedor (Terminal, VSCode, JupyterLab)",
    "text": "2.3 Puesta en Marcha y Acceso al Contenedor (Terminal, VSCode, JupyterLab)\nSiga este procedimiento para iniciar su laboratorio por primera vez:\n\nIniciar Docker Desktop: Asegúrese de que el icono de la ballena está en la barra de tareas.\n\n\nConfiguración de Almacenamiento: Debido a que la imagen políglota y la base de datos requieren un espacio considerable, asegúrese de que el disco de destino tenga al menos 30 GB de espacio libre.\nProcedimiento para cambiar la ubicación de las imágenes (archivos con extensión .vhdx): Si su disco principal (C:) está sin espacio, mueva Docker a otro disco:\n\nDiríjase a Settings (engranaje) -&gt; Resources -&gt; Advanced.\nLocalice Disk image location.\nHaga clic en Browse y seleccione una carpeta en un disco con mayor capacidad.\nHaga clic en Apply & restart.\n\nOptimización de Memoria Swap {#swap-ref}: Para procesar datos raster de gran tamaño sin interrupciones en R o Julia, es fundamental ampliar el archivo de intercambio (Swap). Puede consultar más detalles en la Sección 2.7 sobre cómo esto impacta el rendimiento.\nProcedimiento para aumentar Swap en Windows (Host): Ajuste la memoria virtual del sistema operativo para evitar cierres por falta de RAM:\n\nEn el buscador de Windows, escriba y seleccione “Ver la configuración avanzada del sistema”.\nEn la pestaña Opciones avanzadas, sección Rendimiento, haga clic en el botón Configuración.\nDiríjase a Opciones avanzadas -&gt; Memoria Virtual y haga clic en Cambiar.\nDesmarque “Administrar automáticamente”, seleccione el disco principal, elija Tamaño personalizado y asigne estos valores sugeridos, que dependen del espacio disponible en el disco (verifíquelo): Inicial 16384 MB / Máximo 32768 MB.\nHaga clic en Establecer y luego en Aceptar (requerirá reiniciar el equipo).\n\nConfiguración de Swap en el Contenedor (WSL2): Dado que Docker opera sobre el subsistema Linux, debe configurar el archivo de intercambio global de WSL2:\n\nAbra el explorador de archivos y diríjase a su carpeta de usuario (escriba %USERPROFILE% en la barra de direcciones).\nCree un archivo nuevo llamado .wslconfig (asegúrese de que no tenga extensión .txt al final).\nPegue el siguiente contenido para definir la RAM y asegurar 32 GB de swap para sus procesos espaciales (sugerido, depende de su espacio en disco):\n\n\n[wsl2]\nmemory=12GB # RAM máxima física asignada a Linux\nswap=32GB   # Memoria de intercambio para evitar el cierre de contenedores\n\n\n\n\n\n\nImportante\n\n\n\nSi desea verificar si estos cambios surtieron efecto dentro de su laboratorio, puede ejecutar el comando free -h en la terminal de Jupyter o VSCode. Esto le mostrará la memoria total y el espacio de Swap disponible tal como se configuró en el Anexo de Referencia Técnica.\n\n\n\nOrganización de Archivos: Copie los archivos docker-compose.yml y Dockerfile dentro de su carpeta de trabajo (nombrada con su ID de correo UNAL).\nConfiguración de Terminal: Abra PowerShell y ejecute el siguiente comando para visualizar correctamente caracteres especiales y logs:\n\n# Forzar UTF8 en el PowerShell\n[Console]::OutputEncoding = [System.Text.Encoding]::UTF8\n\nConstrucción del Entorno (Build): Este comando se ejecuta solo la primera vez. Desde la terminal, ubicado en su carpeta de ID (su_carpeta), ejecute:\n\ndocker compose build --no-cache 2&gt;&1 | tee build_sig_unal.log\n\nArrancar Contenedores: El comando build una vez se termina satisfactoriamente, no necesita volver a ejecutarse. El principal comando para subir el servicio de las imágenes instaladas se muestra a continuación. Use este comando siempre antes de iniciar a trabajar con los contenedores instalados:\n\ndocker compose up -d\n\nVerificación de Logs: Si desea ver el progreso o verificar errores, revise el archivo .log generado o ejecute el siguiente comando, sin embargo la url de acceso a JupyterLab mostrada después de ejecutar este comando puede estar errónea. Para acceder a JupyterLab vea la siguiente instrucción (Ingreso a JupyterLab)\n\ndocker logs contenedor_sig_unal\n\nIngreso a JupyterLab: Una vez el contenedor esté corriendo, abra su navegador y pegue la siguiente URL (note que usamos el puerto 8889 definido en nuestro manifiesto):\n\nhttp://127.0.0.1:8889/lab?token=geomatica2025\n\nLocalización de Archivos y Persistencia: En el contenedor, su carpeta de Windows se encuentra vinculada a la ruta /home/rstudio/work.\n\nCualquier archivo guardado en esa ruta dentro de Jupyter aparecerá en su carpeta de Windows.\nSe recomienda organizar su trabajo en las subcarpetas: notebooks, scripts, y data.\nLa carpeta imagenes (sin tílde y provista para las guías Quarto) debe residir también en esta ruta para un renderizado correcto.\n\nAcceso y Configuración en VSCode:\nPara una experiencia de desarrollo profesional, conecte VSCode directamente al contenedor:\n\nEjecute Ctrl + Shift + P y seleccione Dev Containers: Attach to Running Container….\nSeleccione el contenedor contenedor_sig_unal.\nExtensiones: Una vez conectado “dentro” del contenedor, debe habilitar/instalar las extensiones (‘Install in Container’) de R (REditorSupport), R Debugger, R Extension Pack (Yuki Ueda), Julia, Python, Quarto, PostgreSQL (Chris Kolman), psql (doublefint), GitHub Repositories, Container Tools, Python (Microsoft), Jupyter (Microsoft). Para un listado completo ver Sección E.2.\nInicialización del Visor Gráfico (Solo la primera vez por sesión)\n\nPara que los gráficos de R (y los puentes de Python/Julia) se visualicen correctamente en VSCode, debe inicializar el dispositivo gráfico. En su terminal de R, ejecute:\n# Lanza el servidor de gráficos httpgd\nhttpgd::hgd()\n\nAcceso al Visor: VSCode debería abrir automáticamente una pestaña con el visor. Si esto no sucede o prefiere usar su navegador externo (Chrome/Edge), acceda a la dirección: http://127.0.0.1:8788.\nNota sobre Puertos: Aunque el comando en R pueda imprimir una URL interna con el puerto 8787 o un token aleatorio, ignore esa dirección. Gracias a nuestro archivo docker-compose.yml, el puerto 8788 de su Windows está “cableado” permanentemente al visor, eliminando la necesidad de buscar tokens o puertos dinámicos.\n\nApagar los servicios:\n\ndocker compose down\n\nResumen de la infraestructura instalada\n\n\n\n\n\n\n\n\nComponente\nVersión / Estado\nDetalles Técnicos\n\n\n\n\nR Engine\n4.3.3 (Angel Food Cake)\nPuente JuliaConnectoR y visor httpgd configurados.\n\n\nJulia Stack\nv1.10.x\nArchGDAL 3.12.1 operativo mediante enlaces simbólicos.\n\n\nPython Stack\n3.12.x\nGeoPandas, PyTorch y drivers psycopg2 listos.\n\n\nBase de Datos\nPostGIS (Noble)\nHost interno db-postgis con extensión espacial activa.\n\n\nVisualización\nDual Mode\nPuertos 8788 (R/Julia Plots) y 8889 (Jupyter Lab).\n\n\nPersistencia\nVolúmenes Docker\nMapeo bidireccional en /home/rstudio/work confirmado.\n\n\nCirugía SSL\n✅ Aplicada\nCompatibilidad OpenSSL 3.0 (Sistema) vs 3.3 (Julia).",
    "crumbs": [
      "Instalación y Entornos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Guía de Instalación. Opción A: Contenedor Docker (Python, R, Julia)</span>"
    ]
  },
  {
    "objectID": "02-guia_instalacion_A_docker.html#mapeo-de-capacidades-sig",
    "href": "02-guia_instalacion_A_docker.html#mapeo-de-capacidades-sig",
    "title": "2  Guía de Instalación. Opción A: Contenedor Docker (Python, R, Julia)",
    "section": "2.4 Mapeo de Capacidades SIG",
    "text": "2.4 Mapeo de Capacidades SIG\nEs vital entender que, aunque usemos lenguajes distintos, todos “beben” de las mismas librerías de bajo nivel instaladas en nuestra imagen base de OSGeo:\n\n\n\n\n\n\n\n\n\n\nOperación\nR (sf / terra)\nPython (GeoPandas)\nJulia (ArchGDAL)\nMotor de Sistema\n\n\n\n\nLectura de Datos\nst_read() / rast()\nread_file() / open()\nArchGDAL.read()\nGDAL\n\n\nBuffers / Geometría\nst_buffer()\n.buffer()\nLibGEOS.buffer()\nGEOS\n\n\nReproyección\nst_transform()\n.to_crs()\nArchGDAL.reproject()\nPROJ",
    "crumbs": [
      "Instalación y Entornos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Guía de Instalación. Opción A: Contenedor Docker (Python, R, Julia)</span>"
    ]
  },
  {
    "objectID": "02-guia_instalacion_A_docker.html#guía-visual-de-jupyterlab",
    "href": "02-guia_instalacion_A_docker.html#guía-visual-de-jupyterlab",
    "title": "2  Guía de Instalación. Opción A: Contenedor Docker (Python, R, Julia)",
    "section": "2.5 Guía Visual de JupyterLab",
    "text": "2.5 Guía Visual de JupyterLab\nAl ingresar, se encontrará con el centro de mando de sus kernels, donde podrá elegir entre R, Python o Julia para sus Notebooks:\n\n\n\n\n\n\nFigura 2.2: Interfaz de JupyterLab configurada para el laboratorio.\n\n\n\n\nLa Carpeta ‘work’ y el Espejo de Datos\nEn el panel izquierdo de la Figura 2.2, la carpeta /home/rstudio/work/ es el espejo de su directorio local en Windows. Gracias a la configuración de volúmenes en el archivo docker-compose.yml, existe un puente directo: todo cambio realizado en Jupyter se refleja en su disco duro y viceversa, garantizando que su trabajo no se pierda al apagar el contenedor.",
    "crumbs": [
      "Instalación y Entornos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Guía de Instalación. Opción A: Contenedor Docker (Python, R, Julia)</span>"
    ]
  },
  {
    "objectID": "02-guia_instalacion_A_docker.html#sec-compilacion",
    "href": "02-guia_instalacion_A_docker.html#sec-compilacion",
    "title": "2  Guía de Instalación. Opción A: Contenedor Docker (Python, R, Julia)",
    "section": "2.6 Compilación de la guía completa o documentos individuales",
    "text": "2.6 Compilación de la guía completa o documentos individuales\nLa guía del curso está organizada a partir de un archivo orquestador _quarto.yml, el cual contiene una referencia explícita a cada uno de los archivos Quarto (.qmd) que definen los capítulos, las presentaciones, los talleres y los anexos. Este archivo centraliza la organización y el formato de la guía tanto en PDF como en HTML.\n\nCompilación del proyecto completo\nSi desea compilar la guía completa del curso y generar todos los formatos, simplemente ejecute el comando quarto render en la carpeta raíz (donde se encuentra el archivo _quarto.yml):\n# Desde la carpeta raíz donde reside el archivo '_quarto.yml'\nquarto render\n\n\nCompilación de archivos individuales\nEn ocasiones, querrá trabajar en un solo capítulo sin procesar el libro entero. Para compilar un archivo específico (ej. archivo.qmd) de manera independiente y evitar que Quarto aplique las reglas de numeración y referencias del proyecto global, siga estos pasos:\n\nRenombrar temporalmente el orquestador: Cambie el nombre de _quarto.yml a _quarto.yml.back. Esto hace que Quarto trate al archivo como un documento “solitario”.\nEjecutar el renderizado específico:\n\n\nGenerar todos los formatos (HTML y PDF):\n\nquarto render archivo.qmd --to all\n\nGenerar solo formato HTML:\n\nquarto render archivo.qmd --to html\n\nGenerar solo formato PDF:\n\nquarto render archivo.qmd --to pdf\n\n\nNotas de estudio y personalización\n\n\n\n\n\n\n¡Personaliza tu aprendizaje!\n\n\n\nEn Quarto, puedes agregar tus propias notas de estudio usando la sintaxis de “callouts”. Recuerda que este documento está en proceso de construcción y sufrirá cambios permanentes hasta terminar el curso.\nPuedes buscar ayuda en Internet para personalizar la apariencia de tus notas. La sintaxis básica es:\n::: {.callout-tip icon=\"true\"}\n### ¡Escribe tu nota aquí!\nEste es un espacio para tus observaciones personales y recordatorios.\n:::",
    "crumbs": [
      "Instalación y Entornos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Guía de Instalación. Opción A: Contenedor Docker (Python, R, Julia)</span>"
    ]
  },
  {
    "objectID": "02-guia_instalacion_A_docker.html#sec-limpieza",
    "href": "02-guia_instalacion_A_docker.html#sec-limpieza",
    "title": "2  Guía de Instalación. Opción A: Contenedor Docker (Python, R, Julia)",
    "section": "2.7 Mantenimiento y Limpieza del Entorno",
    "text": "2.7 Mantenimiento y Limpieza del Entorno\nEl entorno políglota de este curso es robusto y, por lo tanto, pesado. Tras realizar actualizaciones o varias pruebas de construcción, es posible que el espacio en disco se agote rápidamente.\n\nComandos de Rescate de Espacio\nSi recibe errores de “Disk Full” o desea limpiar su sistema, ejecute los siguientes comandos en su terminal de Windows (PowerShell):\n# 1. Eliminar contenedores detenidos y redes en desuso\ndocker system prune -f\n\n# 2. Limpiar caché de construcción (libera mucho espacio tras errores de build)\ndocker builder prune -f\n\n# 3. (Uso extremo) Eliminar TODAS las imágenes que no estén siendo usadas\n# docker image prune -a -f\n\n\n\n\n\n\nSeguridad de sus Datos\n\n\n\nNo tema realizar limpiezas periódicas. Gracias a la configuración de volúmenes en nuestro archivo docker-compose.yml, todo su código, scripts y datos espaciales están físicamente en su disco local (en la carpeta de su ID UNAL).\nAl apagar o borrar el contenedor, lo que está dentro de /home/rstudio/work/ siempre estará a salvo en su carpeta de Windows. El contenedor es solo el “motor”, sus archivos son el “combustible” que usted posee.",
    "crumbs": [
      "Instalación y Entornos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Guía de Instalación. Opción A: Contenedor Docker (Python, R, Julia)</span>"
    ]
  },
  {
    "objectID": "02-guia_instalacion_A_docker.html#verificación-de-conectividad-multilenguaje",
    "href": "02-guia_instalacion_A_docker.html#verificación-de-conectividad-multilenguaje",
    "title": "2  Guía de Instalación. Opción A: Contenedor Docker (Python, R, Julia)",
    "section": "2.8 Verificación de Conectividad Multilenguaje",
    "text": "2.8 Verificación de Conectividad Multilenguaje\nNota técnica: Dentro de la red de Docker, el host es db-postgis.\n\nPythonRJulia\n\n\n\nimport psycopg2\nimport geopandas as gpd\nimport fiona\nimport matplotlib.pyplot as plt\nfrom shapely.geometry import Point\n\nprint(\"--- Inicio de Verificación de Python SIG ---\")\n\n--- Inicio de Verificación de Python SIG ---\n\n# 1. Prueba de conexión a la base de datos PostGIS\ntry:\n    conn = psycopg2.connect(\n        host=\"db-postgis\", \n        dbname=\"sig_db_unal\", \n        user=\"profe_unal\", \n        password=\"geomatica2025\"\n    )\n    print(\"✅ Conexión a PostGIS: Exitosa\")\n    conn.close()\nexcept Exception as e:\n    print(f\"❌ Error de conexión a PostGIS: {e}\")\n\n✅ Conexión a PostGIS: Exitosa\n\n# 2. Prueba de Fiona y drivers GDAL\ntry:\n    drivers = len(fiona.supported_drivers)\n    print(f\"✅ Fiona operativo: {drivers} drivers GDAL detectados\")\nexcept Exception as e:\n    print(f\"❌ Error en Fiona/GDAL: {e}\")\n\n✅ Fiona operativo: 17 drivers GDAL detectados\n\n# 3. Prueba de GeoPandas, Motores GEOS y Visualización\ntry:\n    # Creamos un punto y su buffer (GEOS)\n    punto = Point(0, 0)\n    buffer_geom = punto.buffer(1.0)\n    \n    # Creamos GeoDataFrames para graficar\n    gdf_buffer = gpd.GeoDataFrame({'geometry': [buffer_geom]}, crs=\"EPSG:4326\")\n    gdf_punto = gpd.GeoDataFrame({'geometry': [punto]}, crs=\"EPSG:4326\")\n    \n    print(f\"✅ GeoPandas {gpd.__version__}: Operativo\")\n    print(f\"✅ Motores GEOS/Shapely: Verificados\")\n\n    # Generación del Plot Espacial con Ejes y Cuadrícula\n    fig, ax = plt.subplots(figsize=(6, 6))\n    \n    # Graficamos el buffer\n    gdf_buffer.plot(ax=ax, color='lightgreen', edgecolor='green', alpha=0.4, label='Buffer')\n    \n    # Graficamos el punto original (en rojo)\n    gdf_punto.plot(ax=ax, color='red', markersize=50, zorder=5, label='Centro')\n    \n    # Configuración de estilo consistente (Ejes y Grilla)\n    ax.set_title(\"Validación Python SIG: Buffer GEOS\")\n    ax.set_xlabel(\"Longitud\")\n    ax.set_ylabel(\"Latitud\")\n    ax.grid(True, linestyle='--', alpha=0.7) # Cuadrícula activada\n    ax.set_aspect('equal') # Proporción 1:1 para evitar deformación\n    \n    plt.show()\n    print(\"✅ Visualización GeoPandas: Mapa generado con éxito\")\n\nexcept Exception as e:\n    print(f\"❌ Error en el stack espacial de Python: {e}\")\n\n\n\n\n\n\n\nprint(\"--- Verificación Finalizada ---\")\n\n--- Verificación Finalizada ---\n\n\n\n\n\nlibrary(DBI)\nlibrary(RPostgres)\nlibrary(sf)\n\nLinking to GEOS 3.12.1, GDAL 3.8.4, PROJ 9.4.0; sf_use_s2() is TRUE\n\nlibrary(terra)\n\nterra 1.8.93\n\n\n\nAttaching package: 'terra'\n\n\nThe following object is masked from 'package:grid':\n\n    depth\n\ncat(\"--- Inicio de Verificación de R-Spatial ---\\n\")\n\n--- Inicio de Verificación de R-Spatial ---\n\n# 1. Prueba de conexión a la base de datos PostGIS\ntryCatch({\n  con &lt;- dbConnect(\n    RPostgres::Postgres(), \n    host = \"db-postgis\", \n    dbname = \"sig_db_unal\", \n    user = \"profe_unal\", \n    password = \"geomatica2025\"\n  )\n  cat(\"✅ Conexión a PostGIS: Exitosa\\n\")\n  dbDisconnect(con)\n}, error = function(e) {\n  cat(\"❌ Error de conexión a PostGIS:\", conditionMessage(e), \"\\n\")\n})\n\n✅ Conexión a PostGIS: Exitosa\n\n# 2. Prueba de Motores de Sistema y Visualización (sf)\ntryCatch({\n  conf &lt;- sf_extSoftVersion()\n  cat(paste0(\"✅ sf operativo. Motores detectados:\\n\",\n             \"   - GDAL: \", conf[\"GDAL\"], \"\\n\",\n             \"   - GEOS: \", conf[\"GEOS\"], \"\\n\",\n             \"   - PROJ: \", conf[\"PROJ\"], \"\\n\"))\n  \n  # Creamos el punto y el buffer\n  punto &lt;- st_point(c(0, 0))\n  buffer_geom &lt;- st_buffer(punto, dist = 1)\n  cat(\"✅ Prueba geométrica (GEOS): Buffer creado correctamente\\n\")\n\n  # Generación del Plot Espacial\n  # Usamos st_geometry para graficar solo la forma\n  plot(st_geometry(buffer_geom), \n       col = 'lightblue', \n       border = 'blue', \n       main = \"Validación R-Spatial: Buffer GEOS\",\n       axes = TRUE,\n       graticule = TRUE)\n  \n  # Añadimos el punto original para referencia\n  plot(st_geometry(punto), add = TRUE, col = 'red', pch = 20)\n  \n  cat(\"✅ Visualización sf: Mapa generado con éxito\\n\")\n  \n}, error = function(e) {\n  cat(\"❌ Error en el stack sf/GEOS:\", conditionMessage(e), \"\\n\")\n})\n\n✅ sf operativo. Motores detectados:\n   - GDAL: 3.8.4\n   - GEOS: 3.12.1\n   - PROJ: 9.4.0\n✅ Prueba geométrica (GEOS): Buffer creado correctamente\n\n\n\n\n\n\n\n\n\n✅ Visualización sf: Mapa generado con éxito\n\n# 3. Prueba de Raster (terra)\ntryCatch({\n  r &lt;- rast(ncols=10, nrows=10)\n  values(r) &lt;- 1:ncell(r)\n  cat(\"✅ Paquete 'terra' operativo: Objetos Raster verificados\\n\")\n}, error = function(e) {\n  cat(\"❌ Error en el stack terra:\", conditionMessage(e), \"\\n\")\n})\n\n✅ Paquete 'terra' operativo: Objetos Raster verificados\n\ncat(\"--- Verificación Finalizada ---\\n\")\n\n--- Verificación Finalizada ---\n\n\n\n\n\n# #| eval: false\nj_plot('\nusing LibPQ\nusing LibGEOS\nusing ArchGDAL\nusing Plots\n\nprintln(\"--- Inicio de Verificación de Julia SIG ---\")\n\n# 1. Prueba de conexión a la base de datos PostGIS\ntry\n    conn = LibPQ.Connection(\"host=db-postgis dbname=sig_db_unal user=profe_unal password=geomatica2025\")\n    println(\"✅ Conexión a PostGIS: Exitosa\")\n    close(conn)\ncatch e\n    println(\"❌ Error de conexión a PostGIS: \", e)\nend\n\n# 2. Verificación de LibGEOS y Visualización de Geometría\ntry\n    # Creamos un punto y le aplicamos un buffer de 1.0 unidades\n    # Esto valida la integración de Julia con la librería GEOS del sistema\n    punto = LibGEOS.readgeom(\"POINT (0 0)\")\n    buffer_geom = LibGEOS.buffer(punto, 1.0)\n    \n    println(\"✅ LibGEOS operativo: Motores geométricos verificados\")\n    \n    # Graficamos el objeto del buffer\n    # fillcolor y alpha ayudan a ver que es un polígono real\n    plt = plot(buffer_geom, \n               title=\"Validación Julia SIG: Buffer GEOS\", \n               fillcolor=:blue, \n               fillalpha=0.3, \n               aspect_ratio=:equal, \n               legend=false)\n    \n    # display() es OBLIGATORIO para mostrar gráficos dentro de bloques try/catch\n    display(plt) \n    \ncatch e\n    println(\"❌ Error en LibGEOS o Visualización: \", e)\nend\n\n# 3. Verificación de ArchGDAL (Usando llamada de bajo nivel)\ntry\n    # Accedemos directamente al motor de C para evitar errores de exportación\n    gdal_ver = ArchGDAL.GDAL.gdalversioninfo(\"--version\")\n    println(\"✅ ArchGDAL operativo (Versión GDAL: $gdal_ver)\")\ncatch e\n    println(\"❌ Error en ArchGDAL: \", e)\nend\n\nprintln(\"--- Verificación Finalizada ---\")\n')\n\nStarting Julia ...\n\n\njulia&gt; using LibPQ\n\njulia&gt; using LibGEOS\n\njulia&gt; using ArchGDAL\n\njulia&gt; using Plots\n\njulia&gt; println(\"--- Inicio de Verificación de Julia SIG ---\")\n\n# 1. Prueba de conexión a la base de datos PostGIS\n--- Inicio de Verificación de Julia SIG ---\n\njulia&gt; try\n    conn = LibPQ.Connection(\"host=db-postgis dbname=sig_db_unal user=profe_unal password=geomatica2025\")\n    println(\"✅ Conexión a PostGIS: Exitosa\")\n    close(conn)\ncatch e\n    println(\"❌ Error de conexión a PostGIS: \", e)\nend\n\n# 2. Verificación de LibGEOS y Visualización de Geometría\n✅ Conexión a PostGIS: Exitosa\n\njulia&gt; try\n    # Creamos un punto y le aplicamos un buffer de 1.0 unidades\n    # Esto valida la integración de Julia con la librería GEOS del sistema\n    punto = LibGEOS.readgeom(\"POINT (0 0)\")\n    buffer_geom = LibGEOS.buffer(punto, 1.0)\n    \n    println(\"✅ LibGEOS operativo: Motores geométricos verificados\")\n    \n    # Graficamos el objeto del buffer\n    # fillcolor y alpha ayudan a ver que es un polígono real\n    plt = plot(buffer_geom, \n               title=\"Validación Julia SIG: Buffer GEOS\", \n               fillcolor=:blue, \n               fillalpha=0.3, \n               aspect_ratio=:equal, \n               legend=false)\n    \n    # display() es OBLIGATORIO para mostrar gráficos dentro de bloques try/catch\n    display(plt) \n    \ncatch e\n    println(\"❌ Error en LibGEOS o Visualización: \", e)\nend\n\n# 3. Verificación de ArchGDAL (Usando llamada de bajo nivel)\n✅ LibGEOS operativo: Motores geométricos verificados\n\njulia&gt; try\n    # Accedemos directamente al motor de C para evitar errores de exportación\n    gdal_ver = ArchGDAL.GDAL.gdalversioninfo(\"--version\")\n    println(\"✅ ArchGDAL operativo (Versión GDAL: $gdal_ver)\")\ncatch e\n    println(\"❌ Error en ArchGDAL: \", e)\nend\n✅ ArchGDAL operativo (Versión GDAL: GDAL 3.12.1 \"Chicoutimi\", released 2025/12/12)\n\njulia&gt; println(\"--- Verificación Finalizada ---\")\n--- Verificación Finalizada ---\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDorman, M. (2025). Spatial Data Programming with Python. Ben-Gurion University of the Negev. https://geobgu.xyz/py-2025/\n\n\nInc., D. (2025). Docker Desktop Documentation. https://docs.docker.com\n\n\nMicrosoft Corporation. (2026). Visual Studio Code. https://code.visualstudio.com/\n\n\nXie, Y. (2019). TinyTeX: A lightweight, cross-platform, and easy-to-maintain LaTeX distribution based on TeX Live. TUGboat, 40(1), 30-32.",
    "crumbs": [
      "Instalación y Entornos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Guía de Instalación. Opción A: Contenedor Docker (Python, R, Julia)</span>"
    ]
  },
  {
    "objectID": "02.a-guia_instalacion_A_docker.html",
    "href": "02.a-guia_instalacion_A_docker.html",
    "title": "3  Guía de Instalación. Opción A: Instalación vía Paquete Preconfigurado (Docker)",
    "section": "",
    "text": "3.1 1. Introducción al Entorno de Trabajo\nEsta guía establece un entorno de Reproducibilidad Científica. Utilizaremos una arquitectura híbrida: VSCode como editor local y Docker como laboratorio de ejecución. Esta aproximación garantiza que todos los estudiantes operen bajo las mismas versiones de motores geoespaciales (GDAL, GEOS, PROJ), eliminando el problema de “en mi computador no funciona”.\nEl paquete que utilizaremos ya contiene preinstalado: 1. Motores de análisis: Python, R y Julia con librerías geoespaciales. 2. Reportes: Quarto y TinyTeX (LaTeX). 3. Base de datos: PostGIS (PostgreSQL con extensiones espaciales).",
    "crumbs": [
      "Instalación y Entornos",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Guía de Instalación. Opción A: Instalación vía Paquete Preconfigurado (Docker)</span>"
    ]
  },
  {
    "objectID": "02.a-guia_instalacion_A_docker.html#preparación-de-herramientas-en-windows-host",
    "href": "02.a-guia_instalacion_A_docker.html#preparación-de-herramientas-en-windows-host",
    "title": "3  Guía de Instalación. Opción A: Instalación vía Paquete Preconfigurado (Docker)",
    "section": "3.2 2. Preparación de Herramientas en Windows (Host)",
    "text": "3.2 2. Preparación de Herramientas en Windows (Host)\nAntes de manipular el paquete del curso, instale las siguientes herramientas básicas:\n\nVSCode IDE: Interfaz principal para editar archivos .qmd y gestionar código.\nDocker Desktop: Motor de virtualización. Durante la instalación, asegúrese de activar la opción “Use WSL 2 instead of Hyper-V”.\n\n\n⚠️ Optimización Crítica de Memoria (WSL2)\nLos procesos de Sistemas de Información Geográfica (SIG) consumen mucha RAM. Para evitar que Docker se cierre, configure los límites de memoria de Linux: 1. Presione Win + R, escriba %USERPROFILE% y acepte. 2. Busque o cree un archivo llamado .wslconfig (asegúrese de que no tenga extensión .txt). 3. Pegue el siguiente contenido y guarde:\n[wsl2]\nmemory=12GB # RAM máxima física asignada al laboratorio\nswap=32GB   # Memoria de intercambio para procesos pesados\nReinicie Docker Desktop después de este cambio.",
    "crumbs": [
      "Instalación y Entornos",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Guía de Instalación. Opción A: Instalación vía Paquete Preconfigurado (Docker)</span>"
    ]
  },
  {
    "objectID": "02.a-guia_instalacion_A_docker.html#despliegue-del-laboratorio-sig",
    "href": "02.a-guia_instalacion_A_docker.html#despliegue-del-laboratorio-sig",
    "title": "3  Guía de Instalación. Opción A: Instalación vía Paquete Preconfigurado (Docker)",
    "section": "3.3 3. Despliegue del Laboratorio SIG",
    "text": "3.3 3. Despliegue del Laboratorio SIG\nSiga estos pasos para instalar el entorno a partir del archivo sig_unal_completo.zip:\n\nPaso A: Preparación de la Carpeta\n\nCree una carpeta en su disco local con su ID institucional (ej. D:\\SIG_UNAL_2025\\juperez).\nExtraiga el contenido del archivo sig_unal_completo.zip en esa carpeta.\nVerifique que existan los siguientes archivos:\n\nsig_unal_completo.tar (La imagen del sistema).\ndocker-compose.yml (El manifiesto de configuración).\n\n\n\n\nPaso B: Carga de la Imagen en Docker\nAbra una terminal de PowerShell dentro de la carpeta donde extrajo los archivos y ejecute:\ndocker load -i sig_unal_completo.tar\nEste proceso puede tardar unos minutos. Verifique que al finalizar aparezca el mensaje “Loaded image” para image_sig_unal:final y postgis_unal:final.\n\n\nPaso C: Lanzamiento del Laboratorio\nEn la misma terminal, ejecute:\ndocker compose up -d\nEsto activará los dos contenedores: uno para análisis geoespacial y otro para la base de datos.",
    "crumbs": [
      "Instalación y Entornos",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Guía de Instalación. Opción A: Instalación vía Paquete Preconfigurado (Docker)</span>"
    ]
  },
  {
    "objectID": "02.a-guia_instalacion_A_docker.html#acceso-y-uso-del-entorno",
    "href": "02.a-guia_instalacion_A_docker.html#acceso-y-uso-del-entorno",
    "title": "3  Guía de Instalación. Opción A: Instalación vía Paquete Preconfigurado (Docker)",
    "section": "3.4 4. Acceso y Uso del Entorno",
    "text": "3.4 4. Acceso y Uso del Entorno\n\n📓 JupyterLab (Análisis Políglota)\nAbra su navegador y acceda a: http://localhost:8889 * Contraseña/Token: (Si se solicita) geomatica2025 * Persistencia: Todo archivo guardado en la carpeta /home/rstudio/work aparecerá automáticamente en su carpeta de Windows. No guarde nada fuera de esa ruta, o se perderá al cerrar el contenedor.\n\n\n🐘 Base de Datos PostGIS\nPara conectar herramientas como QGIS o DBeaver, use los siguientes parámetros: * Host: localhost * Puerto: 5434 * Usuario: profe_unal * Contraseña: geomatica2025 * Base de Datos: sig_db_unal",
    "crumbs": [
      "Instalación y Entornos",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Guía de Instalación. Opción A: Instalación vía Paquete Preconfigurado (Docker)</span>"
    ]
  },
  {
    "objectID": "02.a-guia_instalacion_A_docker.html#verificación-de-la-instalación",
    "href": "02.a-guia_instalacion_A_docker.html#verificación-de-la-instalación",
    "title": "3  Guía de Instalación. Opción A: Instalación vía Paquete Preconfigurado (Docker)",
    "section": "3.5 5. Verificación de la Instalación",
    "text": "3.5 5. Verificación de la Instalación\nPara confirmar que la “cirugía” de librerías y la conectividad son correctas, cree un nuevo Notebook de Julia en JupyterLab y ejecute el siguiente bloque:\n# Validación de Motores SIG y Conectividad\nusing LibPQ, LibGEOS, ArchGDAL, Plots\n\n# 1. Prueba de conexión a PostGIS\ntry\n    conn = LibPQ.Connection(\"host=db-postgis dbname=sig_db_unal user=profe_unal password=geomatica2025\")\n    println(\"✅ Conexión a PostGIS: Exitosa\")\n    close(conn)\ncatch e\n    println(\"❌ Error de conexión: \", e)\nend\n\n# 2. Prueba de Motores Geométricos (GEOS)\ntry\n    punto = LibGEOS.readgeom(\"POINT (0 0)\")\n    buffer_geom = LibGEOS.buffer(punto, 1.0)\n    println(\"✅ Motores geométricos operativos (GEOS)\")\n    \n    # Visualización del Buffer\n    plt = plot(buffer_geom, title=\"Validación SIG: Buffer GEOS\", \n               fillcolor=:blue, fillalpha=0.3, aspect_ratio=:equal)\n    display(plt)\ncatch e\n    println(\"❌ Error en motores geométricos o gráficos: \", e)\nend",
    "crumbs": [
      "Instalación y Entornos",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Guía de Instalación. Opción A: Instalación vía Paquete Preconfigurado (Docker)</span>"
    ]
  },
  {
    "objectID": "02.a-guia_instalacion_A_docker.html#mantenimiento-y-apagado",
    "href": "02.a-guia_instalacion_A_docker.html#mantenimiento-y-apagado",
    "title": "3  Guía de Instalación. Opción A: Instalación vía Paquete Preconfigurado (Docker)",
    "section": "3.6 6. Mantenimiento y Apagado",
    "text": "3.6 6. Mantenimiento y Apagado\n\nPara apagar el laboratorio sin borrar datos: docker compose stop.\nPara reiniciar el laboratorio: docker compose start.\nSi necesita borrar todo para reinstalar (los datos de la DB se mantienen en el volumen): docker compose down.",
    "crumbs": [
      "Instalación y Entornos",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Guía de Instalación. Opción A: Instalación vía Paquete Preconfigurado (Docker)</span>"
    ]
  },
  {
    "objectID": "03-guia_instalacion_B_qgis.html",
    "href": "03-guia_instalacion_B_qgis.html",
    "title": "4  Guía de Instalación. Opción B: QGIS y PyQGIS",
    "section": "",
    "text": "4.1 Opción B.1 - OSGeo4W\nOSGeo4W es un entorno para Windows que agrupa y facilita la gestión de software geoespacial de código abierto como QGIS (Rosas-Chavoya et al., 2022), GDAL/OGR (Mitchell, 2015), GRASS (Neteler et al., 2012) y SAGA (Passy & Théry, 2018).\nEn este escenario, Python (Python Software Foundation, 2025) es el motor fundamental, permitiendo la automatización directa de tareas sobre el software de escritorio (Lawhead, 2017). Para mantener la estabilidad del sistema, en este entorno nativo no intentaremos vincular R (R Core Team, 2025) o Julia (Bezanson et al., 2017); para dicho propósito políglota utilizaremos exclusivamente la Opción A (Docker) (Inc., 2025).",
    "crumbs": [
      "Instalación y Entornos",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Guía de Instalación. Opción B: QGIS y PyQGIS</span>"
    ]
  },
  {
    "objectID": "03-guia_instalacion_B_qgis.html#sec-osgeo4w",
    "href": "03-guia_instalacion_B_qgis.html#sec-osgeo4w",
    "title": "4  Guía de Instalación. Opción B: QGIS y PyQGIS",
    "section": "",
    "text": "Instrucciones de Instalación\n\nDescargue el Network Installer de QGIS.\nEjecute y seleccione Advanced Install.\nMantenga las rutas por defecto (C:\\OSGeo4W).\nEn el paso de Select Packages, busque los elementos de la tabla y marque únicamente la casilla Bin (Binarios).\n\n\n\nLista de Paquetes Seleccionados\n\n\n\n\n\n\n\n\n\nGrupo\nPaquete\nMódulo\nPropósito / Uso en Clase\n\n\n\n\nEntorno Core\nqgis-ltr / qgis-ltr-full\nTodo\nSoftware base y metapaquete de dependencias.\n\n\nBases de Datos\npgmodeler\n5\nDiseño visual de modelos para PostGIS.\n\n\nBases de Datos\nlibspatialite\n5\nMotor de base de datos espacial liviano para verificación en shell.\n\n\nBases de Datos\npython3-psycopg2\n5\nAdaptador de Python para PostgreSQL/PostGIS.\n\n\nGeoprocesamiento\ngrass\n6\nMotor para análisis topológico e hidrología.\n\n\nGeoprocesamiento\nsaga\n7\nAlgoritmos de terreno y geomorfometría.\n\n\nGeoprocesamiento\ngdal\n6\nLectura/escritura de formatos raster y vector.\n\n\nCiencia de Datos\npython3-numpy\n2\nManejo de estructuras Arrays y Matrices.\n\n\nCiencia de Datos\npython3-pandas\n3\nAnálisis exploratorio de datos (EDA).\n\n\nCiencia de Datos\npython3-geopandas\n3\nExtensión espacial para GeoDataFrames.\n\n\nVisualización\npython3-matplotlib\n3\nGráficos básicos y mapas estáticos.\n\n\nVisualización\npython3-seaborn\n3\nGráficos estadísticos avanzados.\n\n\nDesarrollo\npython3-pip\n1\nGestor para instalar librerías adicionales.\n\n\nDesarrollo\npython3-jupyterlab\nTodo\nEntorno interactivo para prototipado rápido (Wijayaningrum et al., 2022).\n\n\nMotores SIG\nproj / geos\n6\nCálculos de proyecciones y geometría.\n\n\nMachine Learning\npython3-scikit-learn\n6\nModelado predictivo espacial.\n\n\n\n\n\n\n\n\n\nAceptación de Dependencias Adicionales\n\n\n\nAl avanzar, el instalador mostrará la ventana “Unmet Dependencies”. Es obligatorio aceptar todos los paquetes sugeridos para contar con los controladores de formatos .ecw y .sid requeridos por la cartografía oficial nacional. Para que el comando spatialite funcione en la shell, asegúrese de marcar el paquete libspatialite en la sección Libs.\n\n\n\n\nVerificación de la Instalación\nAbra la OSGeo4W Shell y ejecute los comandos para verificar la correcta integración de Python y los motores SIG:\npython3 --version\ngdalinfo --version\nspatialite --version\n\nCorrección de Errores al Lanzar QGIS\nSi al iniciar QGIS aparece un error crítico indicando ModuleNotFoundError: No module named 'gdal', se debe a una sintaxis de importación obsoleta en ciertos complementos (Rosas-Chavoya et al., 2022).\nError identificado: File \".../agknow_utils.py\", line 29, in &lt;module&gt; import gdal, osr\nSolución: Debe modificar el archivo del plugin para usar el espacio de nombres de OSGeo:\n\nLocalice el archivo en: %AppData%\\QGIS\\QGIS3\\profiles\\default\\python\\plugins\\agknow_qgis\\agknow_utils.py.\nReemplace la línea 29:\n\nIncorrecto: import gdal, osr\nCorrecto: from osgeo import gdal, osr\n\n\n\n\n\n\n\n\nNota sobre R y Julia\n\n\n\nPara el uso intensivo de R y Julia, se recomienda la Opción A (Docker) (Inc., 2025) ya que viene con las librerías espaciales pre-configuradas, evitando errores de vinculación de DLLs comunes en instalaciones nativas de Windows.",
    "crumbs": [
      "Instalación y Entornos",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Guía de Instalación. Opción B: QGIS y PyQGIS</span>"
    ]
  },
  {
    "objectID": "03-guia_instalacion_B_qgis.html#sec-qgis-gee-pixi",
    "href": "03-guia_instalacion_B_qgis.html#sec-qgis-gee-pixi",
    "title": "4  Guía de Instalación. Opción B: QGIS y PyQGIS",
    "section": "4.2 Opción B.2: QGIS + GEE usando Pixi",
    "text": "4.2 Opción B.2: QGIS + GEE usando Pixi\nAntes de comenzar, es indispensable contar con una cuenta de Google Cloud habilitada para Google Earth Engine (GEE). Puede dar de alta su cuenta en earthengine.google.com.\n\n\n\n\n\n\nRequisito de Google Cloud\n\n\n\nAsegúrese de haber creado un proyecto en la consola de Google Cloud y de tener activadas las APIs for Earth Engine para dicho proyecto; de lo contrario, el proceso de autenticación fallará.\n\n\nVideo gúia de creación y registro en GEE\n\n\nInstalación de Pixi\nPixi es un gestor de paquetes extremadamente rápido basado en el ecosistema de Conda, pero mucho más ligero. Permite crear entornos aislados sin romper las librerías de su sistema operativo.\n\nEn Linux / macOS (bash/zsh)\nEjecute el siguiente comando en su terminal:\ncurl -fsSL https://pixi.sh/install.sh | sh\nNota: Cierre y vuelva a abrir su terminal para que pixi se añada a su PATH. Confirme la instalación con:\npixi --version\n\n\nEn Windows (PowerShell)\nAbra PowerShell (no requiere permisos de Administrador) y ejecute:\npowershell -ExecutionPolicy Bypass -c \"irm -useb https://pixi.sh/install.ps1 | iex\"\nReinicie PowerShell y confirme la versión:\npixi --version\n\n\n\n\nCreación del Proyecto\nNavegue hasta la carpeta (diferente a todas las utilizadas hasta el momento) donde desea guardar sus trabajos y cree un nuevo proyecto llamado geocd:\npixi init geocd\ncd geocd\n\n\n\nConfiguración del Entorno Geográfico\nInstalaremos un stack potente que incluye QGIS y las herramientas necesarias para trabajar con Google Earth Engine y datos ráster/vectoriales en Python.\nDesde la carpeta geocd, ejecute:\npixi add qgis geemap geopandas xee rioxarray\n\n\n\n\n\n\n¿Qué estamos instalando?\n\n\n\n\nQGIS: El software SIG profesional de uso libre mas popular.\ngeemap: Librería para visualización interactiva de GEE.\ngeopandas: Gestión de datos vectoriales.\nxee & rioxarray: Motores para leer cubos de datos y archivos ráster.\n\n\n\n\n\n\nAutenticación de Earth Engine\nFinalmente, debe vincular su entorno local con su cuenta de Google Cloud. Este comando abrirá una ventana en su navegador para autorizar el acceso:\npixi run earthengine authenticate\nSiga las instrucciones en pantalla, seleccione su proyecto de Google Cloud y copie el código de verificación si el sistema se lo solicita. ¡Ya está listo para procesar datos satelitales a escala global!\n\n\nTrabajar GEE dentro de QGIS\nUna vez que el entorno está configurado y autenticado, el siguiente paso es integrar Google Earth Engine directamente en la interfaz de QGIS. Para esto, utilizaremos el complemento desarrollado por el equipo de OpenGeos: El Plugin: GEE Data Catalog. Este complemento permite navegar por los miles de datasets de Earth Engine (Sentinel, Landsat, MODIS, etc.) y cargarlos en el lienzo de QGIS con un solo clic, utilizando el motor de procesamiento en la nube.\n\n\nRecursos Adicionales\n\nRepositorio oficial: opengeos/qgis-gee-data-catalogs-plugin\nVideo Guía Earth Engine Data Catalogs Plugin for QGIS: aquí\nVideo Guía Time Series Satellite Images in Seconds: aquí",
    "crumbs": [
      "Instalación y Entornos",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Guía de Instalación. Opción B: QGIS y PyQGIS</span>"
    ]
  },
  {
    "objectID": "03-guia_instalacion_B_qgis.html#otras-referencias-importantes",
    "href": "03-guia_instalacion_B_qgis.html#otras-referencias-importantes",
    "title": "4  Guía de Instalación. Opción B: QGIS y PyQGIS",
    "section": "4.3 Otras referencias importantes",
    "text": "4.3 Otras referencias importantes\n\nPyQGIS cookbook en markdown y Jupyter notebook formats (Wu, 2023a)\nQGIS Notebook Plugin: Integrate Jupyter Notebooks into QGIS (Wu, 2023b)\n\n\n\n\n\nBezanson, J., Edelman, A., Karpinski, S., & Shah, V. B. (2017). Julia: A fresh approach to numerical computing. SIAM review, 59(1), 65-98.\n\n\nInc., D. (2025). Docker Desktop Documentation. https://docs.docker.com\n\n\nLawhead, J. (2017). QGIS python programming cookbook. Packt Publishing Ltd.\n\n\nMitchell, T. (2015). An Introduction to Open Source Geospatial Tools.\n\n\nNeteler, M., Bowman, M. H., Landa, M., & Metz, M. (2012). GRASS GIS: A multi-purpose open source GIS. Environmental Modelling & Software, 31, 124-130.\n\n\nPassy, P., & Théry, S. (2018). The use of SAGA GIS modules in QGIS. QGIS and generic tools, 1, 107-149.\n\n\nPython Software Foundation. (2025). Python 3 Documentation. https://docs.python.org/3/\n\n\nR Core Team. (2025). R: A Language and Environment for Statistical Computing. R Foundation for Statistical Computing. https://www.R-project.org/\n\n\nRosas-Chavoya, M., Gallardo-Salazar, J. L., López-Serrano, P. M., Alcántara-Concepción, P. C., & León-Miranda, A. K. (2022). QGIS a constantly growing free and open-source geospatial software contributing to scientific development. Cuadernos de Investigación Geográfica, 48(1), 197-213.\n\n\nWijayaningrum, V. N., Lestari, V. A., et al. (2022). Jupyter lab platform-based interactive learning. 2022 International Conference on Electrical and Information Technology (IEIT), 295-301.\n\n\nWu, Q. (2023a). PyQGIS cookbook in markdown and Jupyter notebook formats. En GitHub repository. https://github.com/opengeos/pyqgis-cookbook; GitHub.\n\n\nWu, Q. (2023b). QGIS Notebook Plugin: Integrate Jupyter Notebooks into QGIS. En GitHub repository [Software]. https://github.com/opengeos/qgis-notebook-plugin; GitHub.",
    "crumbs": [
      "Instalación y Entornos",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Guía de Instalación. Opción B: QGIS y PyQGIS</span>"
    ]
  },
  {
    "objectID": "04-guia_instalacion_C_ArcGIS.html",
    "href": "04-guia_instalacion_C_ArcGIS.html",
    "title": "5  Guía de Instalación. Opción C: ArcGIS Pro y ArcPy",
    "section": "",
    "text": "5.1 ..",
    "crumbs": [
      "Instalación y Entornos",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Guía de Instalación. Opción C: ArcGIS Pro y ArcPy</span>"
    ]
  },
  {
    "objectID": "05-introduccion_python_r_julia.html",
    "href": "05-introduccion_python_r_julia.html",
    "title": "6  Introducción a Python, R y Julia",
    "section": "",
    "text": "6.1 Introducción\nEste capítulo presenta una introducción práctica y comparativa a los lenguajes Python, R y Julia, enfocada en el uso de comandos básicos y en la lectura e interpretación de resultados en consola. El objetivo no es profundizar en programación avanzada, sino ofrecer una puerta de entrada común para estudiantes que se inician en el uso de herramientas computacionales para geocomputación.",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Introducción</span>"
    ]
  },
  {
    "objectID": "05-introduccion_python_r_julia.html#introducción",
    "href": "05-introduccion_python_r_julia.html#introducción",
    "title": "6  Introducción a Python, R y Julia",
    "section": "",
    "text": "Ejecución de código en cada lenguaje\n\nPython y R se ejecutan de forma nativa mediante code chunks estándar.\nJulia, en este curso, no se ejecuta directamente. Todo el código Julia se evalúa desde R utilizando funciones auxiliares:\n\nj_eval() para ejecutar instrucciones generales\nj_plot() para generar gráficos\n\n\nPor esta razón, en el documento encontrarás dos tipos de bloques relacionados con Julia: - Bloques con código Julia puro, que sirven como referencia y pueden copiarse y reutilizarse. - Bloques en R que llaman a j_eval() o j_plot(), que son los que realmente ejecutan el código.\n\n\nSobre los bloques de código\n\nTodos los bloques de código tienen un label, lo que permite su correcta identificación y reutilización.\nAlgunos bloques están pensados exclusivamente para HTML y no se ejecutan. Su función es permitir que el estudiante copie y pegue el código directamente en su entorno de trabajo.\nCuando un bloque no se ejecuta, esto se indica explícitamente en sus opciones.\n\n\n\nAlcance del capítulo\nEn este capítulo aprenderás a: - Acceder a la ayuda y documentación básica en cada lenguaje - Ejecutar comandos simples y entender su salida - Reconocer tipos de objetos y estructuras básicas - Comparar cómo Python, R y Julia resuelven tareas similares\nEste contenido servirá como base para los capítulos posteriores, donde se utilizarán estos lenguajes para la creación de mapas, análisis de datos espaciales y visualización geográfica.",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Introducción</span>"
    ]
  },
  {
    "objectID": "05-introduccion_python_r_julia.html#función-j_eval-y-j_plot-en-r",
    "href": "05-introduccion_python_r_julia.html#función-j_eval-y-j_plot-en-r",
    "title": "6  Introducción a Python, R y Julia",
    "section": "6.2 Función j_eval y j_plot en R",
    "text": "6.2 Función j_eval y j_plot en R\nUsada para ejecutar código Julia en R. j_eval ejecuta comandos que no tengan salidas gráficas, y j_plot es necesaria cuándo el código Julia produce salidas gráficas.\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\n# Código en R\nj_eval &lt;- function(cmd) {\n  .ensure_julia_ready()\n  lineas &lt;- strsplit(cmd, \"\\n\")[[1]]\n  buffer &lt;- \"\"; en_bloque &lt;- 0; en_comillas &lt;- 0; resultado_final &lt;- NULL\n\n  for (l in lineas) {\n    if (trimws(l) == \"\") next\n    buffer &lt;- paste0(buffer, l, \"\\n\")\n    \n    # --- Tu lógica estable de detección ---\n    en_comillas &lt;- (en_comillas + lengths(regmatches(l, gregexpr('\"', l, fixed = TRUE)))) %% 2 \n    if (en_comillas == 0) {\n      abrir &lt;- grepl(\"\\\\b(do|function|for|if|begin|let|while)\\\\b\", l) + \n               lengths(regmatches(l, gregexpr(\"(\", l, fixed = TRUE))) + \n               lengths(regmatches(l, gregexpr(\"[\", l, fixed = TRUE)))\n      cerrar &lt;- grepl(\"\\\\bend\\\\b\", l) + \n                lengths(regmatches(l, gregexpr(\")\", l, fixed = TRUE))) + \n                lengths(regmatches(l, gregexpr(\"]\", l, fixed = TRUE)))\n      en_bloque &lt;- en_bloque + abrir - cerrar\n    }\n    \n    if (en_bloque &lt;= 0 && en_comillas == 0) {\n      res_raw &lt;- JuliaConnectoR::juliaCall(\"_unal_core_executor\", buffer, FALSE, \"\", 72, 800, 500, 12)\n      \n      # --- AJUSTE DE SALIDA: Forzar nueva línea ---\n      res_l &lt;- gsub(\"\\033\\\\[[0-9;]*m\", \"\", res_raw) # Limpiar ANSI\n      \n      # Separamos por líneas para procesar el prompt\n      partes &lt;- strsplit(res_l, \"\\n\")[[1]]\n      for (p in partes) {\n        if (grepl(\"^julia&gt; \", p)) {\n          # Si el comando y el resultado están pegados (separados por 2+ espacios), los dividimos\n          p_div &lt;- gsub(\"^(julia&gt; .*?)\\\\s{2,}(?=\\\\S)\", \"\\\\1\\n\", p, perl = TRUE)\n          cat(p_div, \"\\n\")\n        } else {\n          cat(p, \"\\n\")\n        }\n      }\n      # ---------------------------------------------\n      \n      lineas_res &lt;- strsplit(res_raw, \"\\n\")[[1]]\n      lineas_res &lt;- trimws(lineas_res[lineas_res != \"\"])\n      temp_res &lt;- tail(lineas_res[!grepl(\"^julia&gt;\", lineas_res)], 1)\n      if (length(temp_res) &gt; 0) resultado_final &lt;- temp_res\n      buffer &lt;- \"\"; en_bloque &lt;- 0; en_comillas &lt;- 0\n    }\n  }\n  if (is.null(resultado_final)) return(invisible(NULL))\n  val_limpio &lt;- gsub('\"', '', resultado_final)\n  num_val &lt;- suppressWarnings(as.numeric(val_limpio))\n  return(if (!is.na(num_val)) num_val else val_limpio)\n}\n\nj_plot &lt;- function(cmd, n = \"tmp_plot.png\", dpi = 300, w = 800, h = NULL, ratio = 1.6, fontsize = 12) {\n  .ensure_julia_ready()\n  if (is.null(h)) h &lt;- round(w / ratio)\n  lineas &lt;- strsplit(cmd, \"\\n\")[[1]]\n  buffer &lt;- \"\"; en_bloque &lt;- 0; en_comillas &lt;- 0\n  \n  for (i in 1:length(lineas)) {\n    l &lt;- lineas[i]\n    if (trimws(l) == \"\") next\n    buffer &lt;- paste0(buffer, l, \"\\n\")\n    en_comillas &lt;- (en_comillas + lengths(regmatches(l, gregexpr('\"', l, fixed = TRUE)))) %% 2 \n    \n    if (en_comillas == 0) {\n      abrir &lt;- grepl(\"\\\\b(do|function|for|if|begin|let|while)\\\\b\", l) + \n               lengths(regmatches(l, gregexpr(\"(\", l, fixed = TRUE))) + \n               lengths(regmatches(l, gregexpr(\"[\", l, fixed = TRUE)))\n      cerrar &lt;- grepl(\"\\\\bend\\\\b\", l) + \n                lengths(regmatches(l, gregexpr(\")\", l, fixed = TRUE))) + \n                lengths(regmatches(l, gregexpr(\"]\", l, fixed = TRUE)))\n      en_bloque &lt;- en_bloque + abrir - cerrar\n    }\n    \n    if (en_bloque &lt;= 0 && en_comillas == 0) {\n      es_ultimo &lt;- (i == length(lineas))\n      log_out &lt;- JuliaConnectoR::juliaCall(\"_unal_core_executor\", buffer, es_ultimo, n, dpi, as.integer(w), as.integer(h), as.integer(fontsize))\n      \n      # Mismo ajuste de salida para j_plot\n      log_l &lt;- gsub(\"\\033\\\\[[0-9;]*m\", \"\", log_out)\n      partes_log &lt;- strsplit(log_l, \"\\n\")[[1]]\n      for (p in partes_log) {\n        if (grepl(\"^julia&gt; \", p)) {\n          cat(gsub(\"^(julia&gt; .*?)\\\\s{2,}(?=\\\\S)\", \"\\\\1\\n\", p, perl = TRUE), \"\\n\")\n        } else {\n          cat(p, \"\\n\")\n        }\n      }\n      buffer &lt;- \"\"; en_bloque &lt;- 0; en_comillas &lt;- 0\n    }\n  }\n  if (file.exists(n)) {\n    img &lt;- png::readPNG(n)\n    grid::grid.newpage()\n    grid::grid.raster(img)\n  }\n}\n\n\n\n\n\nFlujo de ejecución de texto con j_eval\nPara entender por qué los resultados aparecen con colores y cómo se gestionan los bloques de código, observe el siguiente flujo de ejecución de la función j_eval:\n\n\n\n\n\n\nsequenceDiagram\n    participant R as Usuario (R Console)\n    participant F as Función j_eval\n    participant JC as JuliaConnectoR\n    participant J as Motor Julia (Core)\n\n    R-&gt;&gt;F: Envía código (cmd)\n    loop Por cada línea\n        F-&gt;&gt;F: Detecta bloques (if, for, do)\n        Note over F: Acumula en buffer hasta cerrar bloque\n    end\n    F-&gt;&gt;JC: Pasa bloque completo\n    JC-&gt;&gt;J: Ejecuta en entorno Julia\n    J--&gt;&gt;JC: Devuelve texto (raw string)\n    JC--&gt;&gt;F: Retorna resultado a R\n    F-&gt;&gt;R: Imprime con resaltado (```julia)\n    F-&gt;&gt;R: Retorna valor final (Numeric/String)\n\n\n\n\nFigura 6.1: Arquitectura de ejecución de la función puente j_eval.\n\n\n\n\n\n\n\n\n\n\n\nNota\n\n\n\nComo se ilustra en la Figura 6.1, la función no solo “pasa” el texto, sino que actúa como un supervisor que espera a que los bloques de programación estén completos antes de despertar al motor de Julia. Esto garantiza la estabilidad del sistema.\n\n\n\n\nFlujo de generación gráfica con j_plot\nA diferencia de la ejecución de texto, j_plot requiere una coordinación adicional para gestionar archivos físicos. Observe el proceso:\n\n\n\n\n\n\nsequenceDiagram\n    participant R as R (j_plot)\n    participant J as Motor Julia\n    participant D as Disco (PNG)\n    participant V as Visor (R Graphics)\n\n    R-&gt;&gt;J: Envía bloques de código\n    Note over J: Procesa lógica espacial/gráfica\n    J--&gt;&gt;R: Retorna logs/mensajes\n    R-&gt;&gt;R: Imprime logs con color\n    \n    rect rgb(240, 240, 240)\n    Note right of J: En el último bloque:\n    J-&gt;&gt;D: Guarda imagen (tmp_plot.png)\n    end\n    \n    D--&gt;&gt;R: Confirma existencia de archivo\n    R-&gt;&gt;D: Lee matriz de píxeles (readPNG)\n    R-&gt;&gt;V: Dibuja en pantalla (grid.raster)\n    Note over V: ¡Gráfico visible en el libro!\n\n\n\n\nFigura 6.2: Arquitectura de generación y renderizado de gráficos Julia-R.\n\n\n\n\n\n\n\n\n\n\n\nEl rol del disco duro\n\n\n\nComo muestra la Figura 6.2, el secreto de j_plot es que utiliza un archivo temporal como “puente” visual. Por eso, si usted tiene el archivo tmp_plot.png abierto en otro programa, j_plot podría fallar al intentar sobrescribirlo.\n\n\n\n\nInterpretación de errores y consola\nAl trabajar con la interoperabilidad entre lenguajes (usando las funciones j_eval y j_plot definidas arriba, la consola de VSCode nos devolverá mensajes que debemos aprender a interpretar.\n\nEl error de conexión TCP\nSi al usar Julia recibe un mensaje de error que menciona TCP connection, usualmente significa que el motor de Julia se ha cerrado o ha entrado en conflicto de memoria. * Solución: Ejecute .ensure_julia_ready() en su consola de R para reiniciar el puente de comunicación.\n\n\nInterpretación del Stacktrace en Julia\nCuando Julia detecta un error, genera un rastro de llamadas o Stacktrace. No intente leer cada línea; busque siempre la primera (que define el tipo de error) y la última línea de código escrita por usted.\n# Ejemplo de error por índice fuera de rango\nERROR: BoundsError: attempt to access 5-element Vector{Int64} at index [6]\n\n\nResaltado de sintaxis en la salida\nGracias a la configuración de results: asis en los bloques de código, la salida de nuestras funciones aparecerá con el prompt julia&gt; coloreado, facilitando la distinción entre lo que es un mensaje informativo y un resultado del cálculo.",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Introducción</span>"
    ]
  },
  {
    "objectID": "05-introduccion_python_r_julia.html#ayuda-y-documentación",
    "href": "05-introduccion_python_r_julia.html#ayuda-y-documentación",
    "title": "6  Introducción a Python, R y Julia",
    "section": "6.3 Ayuda y documentación",
    "text": "6.3 Ayuda y documentación\n\n\n\n\n\n\n\n\n\n\nTarea\nDescripción\nPython\nR\nJulia\n\n\n\n\nVer ayuda general\nAbre la documentación interactiva\nhelp()\nhelp.start()\n? en REPL\n\n\nAyuda de función\nDocumentación de un comando\nhelp(sum)\n?mean\n?sum\n\n\nVer ejemplos\nCódigo de ejemplo de una función\nDocstrings\nexample(\"lapply\")\nDocstrings\n\n\nVignettes / guías\nTutoriales extendidos\nobj.__doc__\nbrowseVignettes()\n?Modulo\n\n\nDemo\nEjecutar ejemplos\nlibreria.ejemplos()*\ndemo()\ninclude(\"test\")*\n\n\n\nNota sobre los Docstrings: En Python y Julia, la documentación y los ejemplos de uso residen directamente dentro del código fuente en bloques llamados Docstrings. Al ejecutar los comandos de ayuda (help() o @doc), el intérprete extrae estos comentarios y los muestra en la terminal, permitiendo que el usuario vea ejemplos reales de implementación de inmediato sin necesidad de manuales externos.\nNota sobre los Demos (*): A diferencia de R, Python y Julia no tienen un comando universal demo(). El asterisco indica que el acceso a ejemplos depende de la librería. En Python, se suele explorar la propiedad __doc__ o módulos de datasets. En Julia, se acostumbra a inspeccionar la carpeta de instalación mediante pathof(Modulo) para encontrar archivos de prueba o ejemplos.\n\nPythonRJulia\n\n\n\n# help() busca y muestra el \"Docstring\" de la función\nhelp(sum)\n\n# Ayuda sobre un módulo completo para ver sus funciones disponibles\nimport math\nhelp(math)\n\n# dir() lista todos los métodos y atributos (la \"anatomía\" del objeto)\nimport pandas as pd\ndir(pd.DataFrame)\n\n# pydoc renderiza la documentación técnica en la terminal\nimport pydoc\nprint(pydoc.render_doc(\"math\")) \n\n# Ejemplo de \"Demo\" en Python (vía datasets de una librería SIG)\nimport geopandas as gpd\n# Listamos los mapas de ejemplo que vienen con la librería\nprint(gpd.datasets.available)\n\n\n\n\n# Inicia el servidor de ayuda local en formato HTML\nhelp.start()\n\n# Acceso rápido a la documentación de una función específica\n?mean\nhelp(\"plot\")\n\n# Ejecuta automáticamente el código de ejemplo del manual\nexample(\"lapply\")\n\n# --- Vignettes y Demos ---\n\n# Abre el índice de tutoriales detallados (vignettes)\nbrowseVignettes()\n\n# Listar guías del paquete 'stars' (análisis de cubos de datos)\n# Nota: presione \"q\" al final de la lista para liberar la consola\nvignette(package = \"stars\")\n\n# Visualizar una vignette específica por su nombre\nvignette(\"stars1\", package = \"stars\")\n\n# Importante: requiere dispositivo gráfico (ej. httpgd::hgd())\n# presione \"q\" al final de la lista para salir\ndemo()\n\n# Demos específicos de librerías de Geomática\nlibrary(sf)\ndemo(\"nc\", package = \"sf\")\ndemo(\"ggplot\", package = \"sf\")\n\n\n\n\n# Este comando (?) solo funciona dentro del REPL interactivo\n# ?sum\n\n# En Quarto usamos la macro @doc para acceder al Docstring\n@doc sum\n@doc println\n\n# Julia usa docstrings con ejemplos y ayuda integrados, similar a Python\n# Para encontrar \"Demos\", localizamos la carpeta del paquete en el disco\nusing DataFrames\nprintln(\"Ubicación del código: \", pathof(DataFrames))",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Introducción</span>"
    ]
  },
  {
    "objectID": "05-introduccion_python_r_julia.html#instalación-y-carga-de-paquetes",
    "href": "05-introduccion_python_r_julia.html#instalación-y-carga-de-paquetes",
    "title": "6  Introducción a Python, R y Julia",
    "section": "6.4 Instalación y carga de paquetes",
    "text": "6.4 Instalación y carga de paquetes\n\n\n\n\n\n\n\n\n\n\nTarea\nDescripción\nPython\nR\nJulia\n\n\n\n\nInstalar paquete\nAgregar librerías externas\npip3 install ...\ninstall.packages()\nPkg.add()\n\n\nCargar paquete\nHabilitar funciones del paquete\nimport ...\nlibrary()\nusing ...\n\n\n\n\nPythonRJulia\n\n\n\n# #| eval: false\n\n# En terminal usamos pip3 \n# para asegurar la versión de Python 3.x\n# pip3 install colorama\n\n# Dentro de python usamos el prefijo \"!\"\n# !pip3 install colorama\n\n# Cargamos solo lo necesario para manejar colores en consola\nfrom colorama import Fore, Style\n\nprint(\"Librería cargada en Python\")\n\nLibrería cargada en Python\n\n# Aparecerán caracteres especiales al inicio del texto\n# porque el HTML no entiende la instrucción colorear en rojo\n# Fore.RED aplica el color; Style.RESET_ALL evita que el color \"manche\" las siguientes líneas\nprint(Fore.RED + \"Librería cargada en Python\" + Style.RESET_ALL)\n\n\u001b[31mLibrería cargada en Python\u001b[0m\n\n\n\n\n\n# #| eval: false\n\n# Este comando carga el paquete con require() o lo instala\n# si no existe\nif (!require(\"crayon\", character.only = TRUE)) {\n  install.packages(\"crayon\", dependencies = TRUE, repos = \"https://cran.rstudio.com/\")\n}\n\nLoading required package: crayon\n\n# Activamos el paquete para la sesión actual de R\nlibrary(crayon)\n\n# cat() interpreta los códigos de escape ANSI que generan los colores\ncat(red(\"Librería cargada en R\"))\n\nLibrería cargada en R\n\n\n\n\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\n# Cargamos el gestor de paquetes de Julia\nusing Pkg\n# Instalamos la librería Crayons\nPkg.add(\"Crayons\")\n\n# Cargamos la librería para habilitar sus funciones\nusing Crayons\n\nprintln(\"Librería cargada en Julia\")\n\n# Aparecerán caracteres especiales al inicio del texto\n# porque el HTML no entiende la instrucción colorear en rojo\n# println con Crayon permite aplicar estilos directamente\nprintln(Crayon(foreground=:red), \"Librería cargada en Julia\")\n\n\n\n\n# #| eval: false\nj_eval('\nusing Pkg\n# Verificamos si \"Crayons\" ya está en el proyecto; si no, lo instalamos\nif !haskey(Pkg.dependencies(), Base.UUID(\"a83e43d3-9d41-5979-9952-4e448995a975\"))\n    Pkg.add(\"Crayons\")\nend\nusing Crayons\nprintln(\"Librería cargada en Julia\")\n\n# Aparecerán caracteres especiales al inicio del texto\n# porque el HTML no entiende la instrucción colorear en rojo\nprintln(Crayon(foreground=:red), \"Librería cargada en Julia\")\n')\nStarting Julia ...\njulia&gt; using Pkg\njulia&gt; # Verificamos si “Crayons” ya está en el proyecto; si no, lo instalamos\njulia&gt; if !haskey(Pkg.dependencies(), Base.UUID(“a83e43d3-9d41-5979-9952-4e448995a975”)) Pkg.add(“Crayons”) end\njulia&gt; using Crayons\njulia&gt; println(“Librería cargada en Julia”) Librería cargada en Julia\njulia&gt; # Aparecerán caracteres especiales al inicio del texto\njulia&gt; # porque el HTML no entiende la instrucción colorear en rojo\njulia&gt; println(Crayon(foreground=:red), “Librería cargada en Julia”) Librería cargada en Julia\n[1] “\\033[31mLibrería cargada en Julia”",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Introducción</span>"
    ]
  },
  {
    "objectID": "05-introduccion_python_r_julia.html#objetos-básicos-y-estructuras-de-datos",
    "href": "05-introduccion_python_r_julia.html#objetos-básicos-y-estructuras-de-datos",
    "title": "6  Introducción a Python, R y Julia",
    "section": "6.5 Objetos básicos y estructuras de datos",
    "text": "6.5 Objetos básicos y estructuras de datos\nEl manejo eficiente de vectores y matrices es el corazón del procesamiento ráster. A continuación, se presenta una comparativa de cómo se declaran y manipulan los objetos básicos.\n\n\n\nTabla 6.1: Comparativa de estructuras de datos\n\n\n\n\n\n\n\n\n\n\n\n\nEstructura\nDescripción\nPython\nR\nJulia\n\n\n\n\nVector\nColección lineal ordenada\nv = np.array([1, 2, 3])\nv &lt;- c(1, 2, 3)\nv = [1, 2, 3]\n\n\nMatriz\nArreglo bidimensional (Ráster)\nm = np.zeros((3,3)) o np.array([[...]])\nm &lt;- matrix(0, 3, 3)\nm = zeros(3, 3) o [... ; ...]\n\n\nDiccionario\nPares clave-valor (Metadatos)\n{key: val} ej. {\"id\": 1}\nlist(k=v) ej. list(id = 1)\nDict(k=&gt;v) ej. Dict(\"id\"=&gt;1)\n\n\nData Frame\nEstructura tabular (Atributos)\npd.DataFrame()\ndata.frame()\nDataFrame(...)\n\n\nIndexación\nPosición del primer elemento\nInicia en 0\nInicia en 1\nInicia en 1\n\n\n\n\n\n\n\nRelación entre estructuras y componentes SIG\nPara entender por qué usamos diferentes estructuras de datos, es útil ver cómo se mapean con los componentes de un Sistema de Información Geográfica:\n\n\n\n\n\n\n%%{init: {'theme': 'base', 'themeVariables': { 'clusterBkg': '#f8f9fa', 'clusterBorder': '#dee2e6' }}}%%\ngraph TD\n    subgraph E [Estructuras en R/Python/Julia]\n        M[Matriz / Array]\n        D[DataFrame / Tabla]\n        K[Diccionario / Dict]\n    end\n\n    subgraph C [Componentes del Dato SIG]\n        R(Ráster / Rejilla de Celdas)\n        A(Atributos / Datos Alfanuméricos)\n        T(Metadatos / Información de Cabecera)\n    end\n\n    M ==&gt;|Representa| R\n    D ==&gt;|Almacena| A\n    K ==&gt;|Define| T\n\n    R -.-&gt;|Se vincula a| A\n    T -.-&gt;|Describe a| R\n    \n    %% Estilos de los nodos\n    style M fill:#e1f5fe,stroke:#01579b,stroke-width:2px\n    style D fill:#e8f5e9,stroke:#1b5e20,stroke-width:2px\n    style K fill:#fff3e0,stroke:#e65100,stroke-width:2px\n    style R fill:#ffffff,stroke:#4a148c\n    style A fill:#ffffff,stroke:#4a148c\n    style T fill:#ffffff,stroke:#4a148c\n    \n    %% ESTILO DE LOS CUADROS DE FONDO (Gris Claro)\n    style E fill:#f2f2f2,stroke:#cccccc,stroke-dasharray: 5 5\n    style C fill:#f2f2f2,stroke:#cccccc,stroke-dasharray: 5 5\n\n\n\n\nFigura 6.3: Mapeo de estructuras de programación a componentes de datos espaciales.\n\n\n\n\n\n\n\n\n\n\n\nNota\n\n\n\nComo se observa en la Figura 6.3, la Matriz es la estructura reina para el análisis ráster, mientras que los DataFrames son los que nos permiten realizar consultas sobre las bases de datos de predios o coberturas.\n\n\n\n\n\n\n\n\nEl peligro de la indexación espacial\n\n\n\nEsta es la fuente más frecuente de errores. Mientras que en Python el primer píxel de una banda satelital es el [0,0], en R y Julia es el [1,1]. Un error de este tipo desplazará todos sus resultados una celda, invalidando análisis de precisión o cambios de cobertura.\n\n\nNota sobre estructuras: En Geomática, los vectores suelen representar coordenadas o valores de píxeles, mientras que los diccionarios son fundamentales para manejar atributos (como en formato JSON o GeoJSON). Las tablas (DataFrames) son el estándar para bases de datos alfanuméricas de predios, municipios o estaciones climáticas.\n\nPythonRJulia\n\n\n\n# #| eval: false\n# 1. Listas: colecciones mutables de elementos\n# Ejemplo: Códigos DANE de departamentos (Antioquia, Cundinamarca, Valle)\ncodigos = [5, 25, 76]\ntype(codigos)\n\n&lt;class 'list'&gt;\n\n# 2. Diccionarios: Estructuras de clave-valor\n# Ideal para representar metadatos de un departamento\nmetadatos = {\n    \"departamento\": [\"Antioquia\", \"Cundinamarca\", \"Valle\"],\n    \"area_km2\": [63612, 22623, 22140],\n    \"capital\": [\"Medellín\", \"Bogotá\", \"Cali\"]\n}\ntype(metadatos)\n\n&lt;class 'dict'&gt;\n\n# 3. DataFrames: Para manejar tablas de atributos SIG\nimport pandas as pd\ndf_colombia = pd.DataFrame(metadatos)\ntype(df_colombia)\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\n\n# Visualizamos el resumen técnico de la tabla\nprint(df_colombia.info())\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 3 entries, 0 to 2\nData columns (total 3 columns):\n #   Column        Non-Null Count  Dtype \n---  ------        --------------  ----- \n 0   departamento  3 non-null      object\n 1   area_km2      3 non-null      int64 \n 2   capital       3 non-null      object\ndtypes: int64(1), object(2)\nmemory usage: 204.0+ bytes\nNone\n\n\n\n\n\n# #| eval: false\n# 1. Vectores: La unidad básica en R (todos los elementos del mismo tipo)\n# Códigos DANE de departamentos\ncodigos &lt;- c(5, 25, 76)\nclass(codigos)\n\n[1] \"numeric\"\n\n# 2. Listas: Pueden contener objetos de diferentes tipos y tamaños\n# En R, las listas con nombres funcionan como los diccionarios\nmetadatos &lt;- list(\n  departamento = c(\"Antioquia\", \"Cundinamarca\", \"Valle\"),\n  area_km2 = c(63612, 22623, 22140),\n  capital = c(\"Medellín\", \"Bogotá\", \"Cali\")\n)\nclass(metadatos)\n\n[1] \"list\"\n\n# 3. Data Frame: La estructura tabular nativa por excelencia\ndf_colombia &lt;- data.frame(metadatos)\nclass(df_colombia)\n\n[1] \"data.frame\"\n\n# str() muestra la estructura interna del objeto (equivalente a info() en Python)\nstr(df_colombia)\n\n'data.frame':   3 obs. of  3 variables:\n $ departamento: chr  \"Antioquia\" \"Cundinamarca\" \"Valle\"\n $ area_km2    : num  63612 22623 22140\n $ capital     : chr  \"Medellín\" \"Bogotá\" \"Cali\"\n\n\n\n\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\n# 1. Vectores: Se definen con corchetes (similar a Python)\ncodigos = [5, 25, 76]\ntypeof(codigos)\n\n# 2. Diccionarios: Se usa el operador =&gt; para asociar clave y valor\nmetadatos = Dict(\n    \"departamento\" =&gt; [\"Antioquia\", \"Cundinamarca\", \"Valle\"],\n    \"area_km2\" =&gt; [63612, 22623, 22140]\n)\ntypeof(metadatos)\n\n# 3. Tablas: En Julia Base se pueden usar vectores de Tuplas Nombradas,\n# pero en Geomática siempre usaremos la librería DataFrames\nusing DataFrames\ndf_colombia = DataFrame(\n    departamento = [\"Antioquia\", \"Cundinamarca\", \"Valle\"],\n    area_km2 = [63612, 22623, 22140],\n    capital = [\"Medellín\", \"Bogotá\", \"Cali\"]\n)\ntypeof(df_colombia)\n\n# describe() da un resumen estadístico de la tabla\nprintln(describe(df_colombia))\n\n\n\n\n# #| eval: false\nj_eval('\n# 1. Vectores: Se definen con corchetes (similar a Python)\ncodigos = [5, 25, 76]\n\ntypeof(codigos)\n\n# 2. Diccionarios: Se usa el operador =&gt; para asociar clave y valor\nmetadatos = Dict(\n    \"departamento\" =&gt; [\"Antioquia\", \"Cundinamarca\", \"Valle\"],\n    \"area_km2\" =&gt; [63612, 22623, 22140]\n)\n\ntypeof(metadatos)\n\n# 3. Tablas: En Julia Base se pueden usar vectores de Tuplas Nombradas,\n# pero en Geomática siempre usaremos la librería DataFrames\nusing DataFrames\ndf_colombia = DataFrame(\n    departamento = [\"Antioquia\", \"Cundinamarca\", \"Valle\"],\n    area_km2 = [63612, 22623, 22140],\n    capital = [\"Medellín\", \"Bogotá\", \"Cali\"]\n)\n\ntypeof(df_colombia)\n\n# describe() da un resumen estadístico de la tabla\nprintln(describe(df_colombia))\n')\njulia&gt; # 1. Vectores: Se definen con corchetes (similar a Python)\njulia&gt; codigos = [5, 25, 76] 3-element Vector{Int64}: 5 25 76\njulia&gt; typeof(codigos) Vector{Int64} (alias for Array{Int64, 1})\njulia&gt; # 2. Diccionarios: Se usa el operador =&gt; para asociar clave y valor\njulia&gt; metadatos = Dict( “departamento” =&gt; [“Antioquia”, “Cundinamarca”, “Valle”], “area_km2” =&gt; [63612, 22623, 22140] ) Dict{String, Vector} with 2 entries: “departamento” =&gt; [“Antioquia”, “Cundinamarca”, “Valle”] “area_km2” =&gt; [63612, 22623, 22140]\njulia&gt; typeof(metadatos) Dict{String, Vector}\njulia&gt; # 3. Tablas: En Julia Base se pueden usar vectores de Tuplas Nombradas,\njulia&gt; # pero en Geomática siempre usaremos la librería DataFrames\njulia&gt; using DataFrames\njulia&gt; df_colombia = DataFrame( departamento = [“Antioquia”, “Cundinamarca”, “Valle”], area_km2 = [63612, 22623, 22140], capital = [“Medellín”, “Bogotá”, “Cali”] ) 3×3 DataFrame Row │ departamento area_km2 capital │ String Int64 String ─────┼────────────────────────────────── 1 │ Antioquia 63612 Medellín 2 │ Cundinamarca 22623 Bogotá 3 │ Valle 22140 Cali\njulia&gt; typeof(df_colombia) DataFrame\njulia&gt; # describe() da un resumen estadístico de la tabla\njulia&gt; println(describe(df_colombia)) 3×7 DataFrame Row │ variable mean min median max nmissing eltype │ Symbol Union… Any Union… Any Int64 DataType ─────┼───────────────────────────────────────────────────────────────────────── 1 │ departamento Antioquia Valle 0 String 2 │ area_km2 36125.0 22140 22623.0 63612 0 Int64 3 │ capital Bogotá Medellín 0 String\n[1] “3 │ capital Bogotá Medellín 0 String”",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Introducción</span>"
    ]
  },
  {
    "objectID": "05-introduccion_python_r_julia.html#comandos-básicos-y-manipulación-de-tablas",
    "href": "05-introduccion_python_r_julia.html#comandos-básicos-y-manipulación-de-tablas",
    "title": "6  Introducción a Python, R y Julia",
    "section": "6.6 4. Comandos básicos y manipulación de tablas",
    "text": "6.6 4. Comandos básicos y manipulación de tablas\n\n\n\n\n\n\n\n\n\n\nTarea\nDescripción\nPython\nR\nJulia\n\n\n\n\nDirectorio\nRuta de trabajo actual\nos.getcwd()\ngetwd()\npwd()\n\n\nTipo / clase\nTipo de estructura\ntype()\nclass()\ntypeof()\n\n\nEstructura\nResumen técnico\ndf.info()\nstr()\ndescribe(df)\n\n\nDimensiones\nFilas y columnas\ndf.shape\ndim()\nsize()\n\n\nPrimeras filas\nVista rápida inicial\ndf.head(n)\nhead(df, n)\nfirst(df, n)\n\n\nFrecuencias\nConteo de categorías\nvalue_counts()\ntable()\ncountmap()\n\n\nUnir filas\nConcatenar vertical\npd.concat(..., axis=0)\nrbind()\nvcat()\n\n\nOmitir NA\nLimpiar datos faltantes\ndropna()\nna.omit()\ndropmissing()\n\n\nOrdenar\nOrganizar por columna\nsort_values()\norder() / arrange()\nsort()\n\n\n\n\nPythonRJulia\n\n\n\n# #| eval: false\nimport os\nimport numpy as np\nimport pandas as pd\n\n# 1. Gestión del entorno de trabajo\nprint(f\"Ruta actual: {os.getcwd()}\")\n\nRuta actual: /home/rstudio/work/01_prog_sig\n\n# 2. Creación de datos: Departamentos de Colombia (Población en millones, Área en km2)\ndata = {\n    \"depto\": [\"Antioquia\", \"Cundinamarca\", \"Valle\", \"Bolívar\", \"Atlántico\"],\n    \"pob_2023\": [6.8, 3.2, 4.6, 2.2, 2.8],\n    \"area_km2\": [63612, 22623, 22140, 25978, 3388],\n    \"region\": [\"Andina\", \"Andina\", \"Pacífica\", \"Caribe\", \"Caribe\"]\n}\ndf = pd.DataFrame(data)\n\n# 3. Inspección de la tabla\nprint(df.info())           # Resumen de tipos de datos y memoria\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 5 entries, 0 to 4\nData columns (total 4 columns):\n #   Column    Non-Null Count  Dtype  \n---  ------    --------------  -----  \n 0   depto     5 non-null      object \n 1   pob_2023  5 non-null      float64\n 2   area_km2  5 non-null      int64  \n 3   region    5 non-null      object \ndtypes: float64(1), int64(1), object(2)\nmemory usage: 292.0+ bytes\nNone\n\nprint(f\"Forma: {df.shape}\") # (filas, columnas)\n\nForma: (5, 4)\n\nprint(df.head(3))          # Ver los primeros 3 registros\n\n          depto  pob_2023  area_km2    region\n0     Antioquia       6.8     63612    Andina\n1  Cundinamarca       3.2     22623    Andina\n2         Valle       4.6     22140  Pacífica\n\n# 4. Análisis de frecuencias (¿Cuántos deptos por región?)\nprint(df[\"region\"].value_counts())\n\nregion\nAndina      2\nCaribe      2\nPacífica    1\nName: count, dtype: int64\n\n# 5. Operaciones de unión\n# Crear un nuevo registro para un depto faltante\nnuevo_depto = pd.DataFrame({\"depto\":[\"Chocó\"], \"pob_2023\":[0.5], \"area_km2\":[46530], \"region\":[\"Pacífica\"]})\n# Concatenar verticalmente (axis=0 es por filas)\ndf_extendido = pd.concat([df, nuevo_depto], axis=0, ignore_index=True)\n\n# 6. Ordenamiento\n# Ordenar por población de mayor a menor\ndf_sorted = df_extendido.sort_values(by=\"pob_2023\", ascending=False)\nprint(df_sorted)\n\n          depto  pob_2023  area_km2    region\n0     Antioquia       6.8     63612    Andina\n2         Valle       4.6     22140  Pacífica\n1  Cundinamarca       3.2     22623    Andina\n4     Atlántico       2.8      3388    Caribe\n3       Bolívar       2.2     25978    Caribe\n5         Chocó       0.5     46530  Pacífica\n\n# 7. Localización por condición (¿Dónde la población es &gt; 4M?)\nindices = np.where(df_extendido[\"pob_2023\"] &gt; 4.0)\nprint(f\"Índices detectados: {indices}\")\n\nÍndices detectados: (array([0, 2]),)\n\n\n\n\n\n# #| eval: false\n# 1. Gestión del entorno\ngetwd()\n\n[1] \"/home/rstudio/work/01_prog_sig\"\n\n# 2. Datos de ejemplo (Departamentos de Colombia)\ndf &lt;- data.frame(\n  depto = c(\"Antioquia\", \"Cundinamarca\", \"Valle\", \"Bolívar\", \"Atlántico\"),\n  pob_2023 = c(6.8, 3.2, 4.6, 2.2, 2.8),\n  area_km2 = c(63612, 22623, 22140, 25978, 3388),\n  region = c(\"Andina\", \"Andina\", \"Pacífica\", \"Caribe\", \"Caribe\")\n)\n\n# 3. Inspección básica\nstr(df)          # Estructura del objeto\n\n'data.frame':   5 obs. of  4 variables:\n $ depto   : chr  \"Antioquia\" \"Cundinamarca\" \"Valle\" \"Bolívar\" ...\n $ pob_2023: num  6.8 3.2 4.6 2.2 2.8\n $ area_km2: num  63612 22623 22140 25978 3388\n $ region  : chr  \"Andina\" \"Andina\" \"Pacífica\" \"Caribe\" ...\n\ndim(df)          # Dimensiones (filas y columnas)\n\n[1] 5 4\n\nhead(df, 3)      # Primeras 3 filas\n\n         depto pob_2023 area_km2   region\n1    Antioquia      6.8    63612   Andina\n2 Cundinamarca      3.2    22623   Andina\n3        Valle      4.6    22140 Pacífica\n\n# 4. Frecuencias (Equivalente a value_counts)\ntable(df$region)\n\n\n  Andina   Caribe Pacífica \n       2        2        1 \n\n# 5. Uniones verticales\n# Creamos el registro adicional\nnuevo &lt;- data.frame(depto=\"Chocó\", pob_2023=0.5, area_km2=46530, region=\"Pacífica\")\n# rbind une por filas (necesita que las columnas se llamen igual)\ndf_extendido &lt;- rbind(df, nuevo)\n\n# 6. Ordenamiento\n# order() devuelve los índices; los usamos para reindexar el dataframe\ndf_sorted &lt;- df_extendido[order(-df_extendido$pob_2023), ]\nprint(df_sorted)\n\n         depto pob_2023 area_km2   region\n1    Antioquia      6.8    63612   Andina\n3        Valle      4.6    22140 Pacífica\n2 Cundinamarca      3.2    22623   Andina\n5    Atlántico      2.8     3388   Caribe\n4      Bolívar      2.2    25978   Caribe\n6        Chocó      0.5    46530 Pacífica\n\n# 7. Alternativa con dplyr (El estándar de \"Tidyverse\" para manipular tablas)\nlibrary(dplyr)\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\n# --- Opción A: Paso a paso con variables intermedias ---\n# Útil para depurar y entender qué sucede en cada etapa\n\n# Paso 1: Ordenar la tabla de departamentos por población de forma descendente\ndf_ordenado &lt;- arrange(df_extendido, desc(pob_2023))\nprint(df_ordenado)\n\n         depto pob_2023 area_km2   region\n1    Antioquia      6.8    63612   Andina\n2        Valle      4.6    22140 Pacífica\n3 Cundinamarca      3.2    22623   Andina\n4    Atlántico      2.8     3388   Caribe\n5      Bolívar      2.2    25978   Caribe\n6        Chocó      0.5    46530 Pacífica\n\n# Paso 2: Filtrar los resultados para quedarnos solo con los mayores a 4M\ndf_final &lt;- filter(df_ordenado, pob_2023 &gt; 4.0)\nprint(df_final)\n\n      depto pob_2023 area_km2   region\n1 Antioquia      6.8    63612   Andina\n2     Valle      4.6    22140 Pacífica\n\n# --- Opción B: Uso de Operadores Pipe (Flujo continuo) ---\n# El pipe permite \"pasar\" el resultado de una función a la siguiente sin crear variables nuevas.\n\n# 1. Pipe de la librería dplyr (el clásico: %&gt;%)\n# Se lee como: \"Toma df_extendido, ENTONCES ordena, ENTONCES filtra\"\ndf_extendido %&gt;% \n  arrange(desc(pob_2023)) %&gt;% \n  filter(pob_2023 &gt; 4.0)\n\n      depto pob_2023 area_km2   region\n1 Antioquia      6.8    63612   Andina\n2     Valle      4.6    22140 Pacífica\n\n# 2. Pipe nativo de R (disponible desde la versión 4.1: |&gt;)\n# Es más eficiente en memoria y no depende de cargar librerías extra\ndf_extendido |&gt; \n  arrange(desc(pob_2023)) |&gt; \n  filter(pob_2023 &gt; 4.0)\n\n      depto pob_2023 area_km2   region\n1 Antioquia      6.8    63612   Andina\n2     Valle      4.6    22140 Pacífica\n\n\n\n\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\nusing DataFrames, Statistics\n\n# 1. Directorio actual\npwd()\n\n# 2. Definición de la tabla de departamentos\ndf = DataFrame(\n    depto = [\"Antioquia\", \"Cundinamarca\", \"Valle\", \"Bolívar\", \"Atlántico\"],\n    pob_2023 = [6.8, 3.2, 4.6, 2.2, 2.8],\n    area_km2 = [63612, 22623, 22140, 25978, 3388],\n    region = [\"Andina\", \"Andina\", \"Pacífica\", \"Caribe\", \"Caribe\"]\n)\n\n# 3. Inspección técnica\ndescribe(df)     # Resumen estadístico y de tipos\nnrow(df)         # Número de filas\nfirst(df, 3)     # Primeros 3 registros\n\n# 4. Uniones\nnuevo = DataFrame(depto=[\"Chocó\"], pob_2023=[0.5], area_km2=[46530], region=[\"Pacífica\"])\n# vcat es concatenación vertical\ndf_ext = vcat(df, nuevo)\n\n# 5. Ordenamiento (rev=true para descendente)\ndf_sorted = sort(df_ext, :pob_2023, rev=true)\nprintln(df_sorted)\n\n\n\n\n# #| eval: false\nj_eval('\nusing DataFrames\n\n# Recreamos la tabla en el entorno de Julia\ndf = DataFrame(\n    depto = [\"Antioquia\", \"Cundinamarca\", \"Valle\", \"Bolívar\", \"Atlántico\"],\n    pob_2023 = [6.8, 3.2, 4.6, 2.2, 2.8],\n    area_km2 = [63612, 22623, 22140, 25978, 3388],\n    region = [\"Andina\", \"Andina\", \"Pacífica\", \"Caribe\", \"Caribe\"]\n)\n\n# Ejecutamos inspección y unión\nnuevo = DataFrame(depto=[\"Chocó\"], pob_2023=[0.5], area_km2=[46530], region=[\"Pacífica\"])\ndf_ext = vcat(df, nuevo)\n\n# Ordenar por población y mostrar\nprintln(sort(df_ext, :pob_2023, rev=true))\n')\njulia&gt; using DataFrames\njulia&gt; # Recreamos la tabla en el entorno de Julia\njulia&gt; df = DataFrame( depto = [“Antioquia”, “Cundinamarca”, “Valle”, “Bolívar”, “Atlántico”], pob_2023 = [6.8, 3.2, 4.6, 2.2, 2.8], area_km2 = [63612, 22623, 22140, 25978, 3388], region = [“Andina”, “Andina”, “Pacífica”, “Caribe”, “Caribe”] ) 5×4 DataFrame Row │ depto pob_2023 area_km2 region │ String Float64 Int64 String ─────┼──────────────────────────────────────────── 1 │ Antioquia 6.8 63612 Andina 2 │ Cundinamarca 3.2 22623 Andina 3 │ Valle 4.6 22140 Pacífica 4 │ Bolívar 2.2 25978 Caribe 5 │ Atlántico 2.8 3388 Caribe\njulia&gt; # Ejecutamos inspección y unión\njulia&gt; nuevo = DataFrame(depto=[“Chocó”], pob_2023=[0.5], area_km2=[46530], region=[“Pacífica”]) 1×4 DataFrame Row │ depto pob_2023 area_km2 region │ String Float64 Int64 String ─────┼────────────────────────────────────── 1 │ Chocó 0.5 46530 Pacífica\njulia&gt; df_ext = vcat(df, nuevo) 6×4 DataFrame Row │ depto pob_2023 area_km2 region │ String Float64 Int64 String ─────┼──────────────────────────────────────────── 1 │ Antioquia 6.8 63612 Andina 2 │ Cundinamarca 3.2 22623 Andina 3 │ Valle 4.6 22140 Pacífica 4 │ Bolívar 2.2 25978 Caribe 5 │ Atlántico 2.8 3388 Caribe 6 │ Chocó 0.5 46530 Pacífica\njulia&gt; # Ordenar por población y mostrar\njulia&gt; println(sort(df_ext, :pob_2023, rev=true)) 6×4 DataFrame Row │ depto pob_2023 area_km2 region │ String Float64 Int64 String ─────┼──────────────────────────────────────────── 1 │ Antioquia 6.8 63612 Andina 2 │ Valle 4.6 22140 Pacífica 3 │ Cundinamarca 3.2 22623 Andina 4 │ Atlántico 2.8 3388 Caribe 5 │ Bolívar 2.2 25978 Caribe 6 │ Chocó 0.5 46530 Pacífica\n[1] “6 │ Chocó 0.5 46530 Pacífica”\n\n\n\n\nOperaciones numéricas y matemáticas básicas\nEn el análisis espacial, estas operaciones son la base para calcular distancias, transformar coordenadas o procesar índices de vegetación (NDVI). A continuación, comparamos la sintaxis para las funciones matemáticas más comunes.\n\n\n\n\n\n\n\n\n\n\nTarea\nDescripción\nPython\nR\nJulia\n\n\n\n\nDivisión entera\nCociente sin decimales\n//\n%/%\ndiv()\n\n\nMódulo\nResiduo de la división\n%\n%%\n%\n\n\nRaíz cuadrada\nCálculo de \\(x^{1/2}\\)\nmath.sqrt()\nsqrt()\nsqrt()\n\n\nLogaritmo\nLogaritmo natural (\\(ln\\))\nmath.log()\nlog()\nlog()\n\n\nConstantes\nValores de \\(\\pi\\) y \\(e\\)\nmath.pi, math.e\npi, exp(1)\npi, exp(1)\n\n\n\n\nPythonRJulia\n\n\n\n# #| eval: false\nimport math\n\n# 1. Aritmética entera (Útil para indexación de matrices)\nprint(f\"División entera (5 // 2): {5 // 2}\")\n\nDivisión entera (5 // 2): 2\n\nprint(f\"Residuo/Módulo (5 % 2): {5 % 2}\")\n\nResiduo/Módulo (5 % 2): 1\n\n# 2. Constantes matemáticas universales\nprint(f\"Número e: {math.e}\")\n\nNúmero e: 2.718281828459045\n\nprint(f\"Número pi: {math.pi}\")\n\nNúmero pi: 3.141592653589793\n\n# 3. Funciones matemáticas (Requieren el módulo math)\nprint(f\"Raíz cuadrada de 2: {math.sqrt(2)}\")\n\nRaíz cuadrada de 2: 1.4142135623730951\n\nprint(f\"Logaritmo natural de 3: {math.log(3)}\")\n\nLogaritmo natural de 3: 1.0986122886681098\n\nprint(f\"Logaritmo base 10 de 3: {math.log(3, 10)}\")\n\nLogaritmo base 10 de 3: 0.47712125471966244\n\n# 4. Valor absoluto (Distancia sin dirección)\nprint(f\"Absoluto de -3.4: {abs(-3.4)}\")\n\nAbsoluto de -3.4: 3.4\n\n\n\n\n\n# #| eval: false\n\n# 1. Aritmética entera\ncat(\"División entera (5 %/% 2):\", 5 %/% 2, \"\\n\")\n\nDivisión entera (5 %/% 2): 2 \n\ncat(\"Residuo/Módulo (5 %% 2):\", 5 %% 2, \"\\n\")\n\nResiduo/Módulo (5 %% 2): 1 \n\n# 2. Constantes (pi es nativo, e se obtiene con exp)\ncat(\"Número e (exp(1)):\", exp(1), \"\\n\")\n\nNúmero e (exp(1)): 2.718282 \n\ncat(\"Número pi:\", pi, \"\\n\")\n\nNúmero pi: 3.141593 \n\n# 3. Funciones matemáticas (Nativas en Base R)\ncat(\"Raíz cuadrada de 2:\", sqrt(2), \"\\n\")\n\nRaíz cuadrada de 2: 1.414214 \n\ncat(\"Logaritmo natural de 3:\", log(3), \"\\n\")\n\nLogaritmo natural de 3: 1.098612 \n\ncat(\"Logaritmo base 10 de 3:\", log(3, 10), \"\\n\")\n\nLogaritmo base 10 de 3: 0.4771213 \n\n# 4. Valor absoluto\ncat(\"Absoluto de -3.4:\", abs(-3.4), \"\\n\")\n\nAbsoluto de -3.4: 3.4 \n\n\n\n\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\n# 1. Aritmética entera\nprintln(\"División entera: \", div(5, 2))\nprintln(\"Residuo: \", 5 % 2)\n\n# 2. Constantes y funciones (Nativas en Julia)\nprintln(\"Número e: \", exp(1))\nprintln(\"Número pi: \", pi)\n\n# 3. Funciones matemáticas\nprintln(\"Raíz cuadrada: \", sqrt(2))\nprintln(\"Logaritmo natural: \", log(3))\nprintln(\"Logaritmo base 10: \", log(10, 3)) # Nota: En Julia log(base, x)\n\n# 4. Valor absoluto\nprintln(\"Absoluto: \", abs(-3.4))\n\n\n\n\n# #| eval: false\nj_eval('\n# Ejecución de operaciones matemáticas vía j_eval\nprintln(\"División entera Julia: \", div(5, 2))\nprintln(\"Residuo Julia: \", 5 % 2)\nprintln(\"Raíz de 2: \", sqrt(2))\nprintln(\"Log natural 3: \", log(3))\nprintln(\"Log base 10: \", log(10, 3)) # Inversión de argumentos frente a R/Python\nprintln(\"Absoluto: \", abs(-3.4))\nprintln(\"Pi: \", pi)\n')\njulia&gt; # Ejecución de operaciones matemáticas vía j_eval\njulia&gt; println(“División entera Julia:”, div(5, 2)) División entera Julia: 2\njulia&gt; println(“Residuo Julia:”, 5 % 2) Residuo Julia: 1\njulia&gt; println(“Raíz de 2:”, sqrt(2)) Raíz de 2: 1.4142135623730951\njulia&gt; println(“Log natural 3:”, log(3)) Log natural 3: 1.0986122886681098\njulia&gt; println(“Log base 10:”, log(10, 3)) # Inversión de argumentos frente a R/Python Log base 10: 0.47712125471966244\njulia&gt; println(“Absoluto:”, abs(-3.4)) Absoluto: 3.4\njulia&gt; println(“Pi:”, pi) Pi: π\n[1] “Pi: π”",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Introducción</span>"
    ]
  },
  {
    "objectID": "05-introduccion_python_r_julia.html#lectura-y-escritura-de-datos",
    "href": "05-introduccion_python_r_julia.html#lectura-y-escritura-de-datos",
    "title": "6  Introducción a Python, R y Julia",
    "section": "6.7 5. Lectura y escritura de datos",
    "text": "6.7 5. Lectura y escritura de datos\n\n\n\n\n\n\n\n\n\n\nTarea\nDescripción\nPython\nR\nJulia\n\n\n\n\nLeer CSV\nCargar tabla desde texto/archivo\npd.read_csv()\nread.csv()\nCSV.read()\n\n\nEscribir CSV\nGuardar tabla en disco\ndf.to_csv()\nwrite.csv()\nCSV.write()\n\n\n\nPara este ejercicio, utilizaremos una técnica de simulación de archivos en memoria. Esto es extremadamente útil en programación SIG para procesar datos que vienen de servicios web (APIs) antes de guardarlos físicamente.\n\nPythonRJulia\n\n\n\n# #| eval: false\nimport pandas as pd\nfrom io import StringIO\n\n# Simulamos el contenido de un archivo CSV con municipios y altitudes (msnm)\ncsv_data = \"\"\"municipio,altitud\nBogota,2625\nMedellin,1495\nCali,1018\nQuibdo,43\n\"\"\"\n\n# StringIO convierte un texto en un \"objeto de archivo\" que pandas puede leer\ndf = pd.read_csv(StringIO(csv_data))\n\n# Mostramos el resultado cargado\nprint(df)\n\n  municipio  altitud\n0    Bogota     2625\n1  Medellin     1495\n2      Cali     1018\n3    Quibdo       43\n\n\n# Guardamos en el disco (index=False evita que se guarde la columna de índices)\ndf.to_csv(\"municipios_altitud.csv\", index=False)\n\n\n\n\n# #| eval: false\n# Contenido simulado\ncsv_data &lt;- \"municipio,altitud\\nBogota,2625\\nMedellin,1495\\nCali,1018\\nQuibdo,43\"\n\n# textConnection crea un flujo de lectura a partir de la cadena de texto\ncon &lt;- textConnection(csv_data)\ndf &lt;- read.csv(con)\n\n# Es buena práctica cerrar la conexión después de usarla\nclose(con)\n\n# Visualizamos la tabla\nprint(df)\n\n  municipio altitud\n1    Bogota    2625\n2  Medellin    1495\n3      Cali    1018\n4    Quibdo      43\n\n# Escribimos en el disco (row.names=FALSE para evitar la columna adicional de números)\nwrite.csv(df, \"municipios_altitud.csv\", row.names = FALSE)\n\n\n\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\nusing CSV\nusing DataFrames\n\n# Contenido simulado\ncsv_data = \"municipio,altitud\\nBogota,2625\\nMedellin,1495\\nCali,1018\\nQuibdo,43\"\n\n# IOBuffer permite a Julia tratar un String como un archivo abierto\ndf = CSV.read(IOBuffer(csv_data), DataFrame)\n\n# Visualizamos\nprintln(df)\n\n# Guardar datos en el disco\nCSV.write(\"municipios_altitud.csv\", df)\n\n\n\n\n# #| eval: false\nj_eval('\nusing CSV\nusing DataFrames\n\ncsv_data = \"municipio,altitud\\nBogota,2625\\nMedellin,1495\\nCali,1018\\nQuibdo,43\"\n\n# Cargamos el string como DataFrame usando el buffer de memoria\ndf = CSV.read(IOBuffer(csv_data), DataFrame)\n\nprintln(\"Tabla cargada en Julia:\")\nprintln(df)\n\n# Escritura física\nCSV.write(\"municipios_altitud.csv\", df)\n')\njulia&gt; using CSV\njulia&gt; using DataFrames\njulia&gt; csv_data = “municipio,altitud Bogota,2625 Medellin,1495 Cali,1018 Quibdo,43” “municipio,altitud,2625,1495,1018,43”\njulia&gt; # Cargamos el string como DataFrame usando el buffer de memoria\njulia&gt; df = CSV.read(IOBuffer(csv_data), DataFrame) 4×2 DataFrame Row │ municipio altitud │ String15 Int64 ─────┼──────────────────── 1 │ Bogota 2625 2 │ Medellin 1495 3 │ Cali 1018 4 │ Quibdo 43\njulia&gt; println(“Tabla cargada en Julia:”) Tabla cargada en Julia:\njulia&gt; println(df) 4×2 DataFrame Row │ municipio altitud │ String15 Int64 ─────┼──────────────────── 1 │ Bogota 2625 2 │ Medellin 1495 3 │ Cali 1018 4 │ Quibdo 43\njulia&gt; # Escritura física\njulia&gt; CSV.write(“municipios_altitud.csv”, df) “municipios_altitud.csv”\n[1] “municipios_altitud.csv”",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Introducción</span>"
    ]
  },
  {
    "objectID": "05-introduccion_python_r_julia.html#indexación-y-filtrado",
    "href": "05-introduccion_python_r_julia.html#indexación-y-filtrado",
    "title": "6  Introducción a Python, R y Julia",
    "section": "6.8 6. Indexación y filtrado",
    "text": "6.8 6. Indexación y filtrado\nEn esta sección aprenderemos a extraer subconjuntos de datos. En Geomática, esto es vital para aislar, por ejemplo, municipios que superen una altitud crítica o departamentos que pertenecen a una región específica.\n\n\n\n\n\n\n\n\n\n\nTarea\nDescripción\nPython\nR\nJulia\n\n\n\n\nSeleccionar filas\nElegir registros por posición\ndf.iloc[0:2]\ndf[1:2, ]\ndf[1:2, :]\n\n\nFiltrar por condición\nSubset basado en reglas\ndf[df[\"altitud\"] &gt; 1000]\ndf[df$altitud &gt; 1000, ]\nfilter(row -&gt; ...)\n\n\n\n\nPythonRJulia\n\n\n\n# #| eval: false\nimport pandas as pd\n\n# Datos de municipios colombianos con su altitud (msnm)\ndf = pd.DataFrame({\n    \"municipio\": [\"Bogotá\", \"Medellín\", \"Cali\", \"Quibdó\", \"Barranquilla\"],\n    \"altitud\": [2625, 1495, 1018, 43, 18],\n    \"departamento\": [\"Cundinamarca\", \"Antioquia\", \"Valle\", \"Chocó\", \"Atlántico\"]\n})\n\n# 1. Seleccionar filas por posición (índices 0 y 1)\n# iloc permite acceso puramente posicional\nprimeros_dos = df.iloc[0:2]\nprint(\"Primeros dos municipios:\\n\", primeros_dos)\n\nPrimeros dos municipios:\n   municipio  altitud  departamento\n0    Bogotá     2625  Cundinamarca\n1  Medellín     1495     Antioquia\n\n# 2. Filtrar por condición (Municipios de \"Tierras Altas\" &gt; 1500 msnm)\ntierras_altas = df[df[\"altitud\"] &gt; 1500]\nprint(\"\\nMunicipios en tierras altas:\\n\", tierras_altas)\n\n\nMunicipios en tierras altas:\n   municipio  altitud  departamento\n0    Bogotá     2625  Cundinamarca\n\n\n# 3. Filtrado con múltiples condiciones (Andinos y con altitud &gt; 1000)\n# Usamos & para 'y' lógico\nandinos_altos = df[(df[\"altitud\"] &gt; 1000) & (df[\"departamento\"] != \"Chocó\")]\n\n\n\n\n# #| eval: false\ndf &lt;- data.frame(\n  municipio = c(\"Bogotá\", \"Medellín\", \"Cali\", \"Quibdó\", \"Barranquilla\"),\n  altitud = c(2625, 1495, 1018, 43, 18),\n  departamento = c(\"Cundinamarca\", \"Antioquia\", \"Valle\", \"Chocó\", \"Atlántico\")\n)\n\n# 1. Seleccionar filas por posición (En R los índices inician en 1)\nprimeros_dos &lt;- df[1:2, ]\nprint(primeros_dos)\n\n  municipio altitud departamento\n1    Bogotá    2625 Cundinamarca\n2  Medellín    1495    Antioquia\n\n# 2. Filtrar por condición lógica\ntierras_altas &lt;- df[df$altitud &gt; 1500, ]\nprint(tierras_altas)\n\n  municipio altitud departamento\n1    Bogotá    2625 Cundinamarca\n\n# 3. Filtrado usando subset() - más legible en Base R\nandinos_altos &lt;- subset(df, altitud &gt; 1000 & departamento != \"Chocó\")\nprint(andinos_altos)\n\n  municipio altitud departamento\n1    Bogotá    2625 Cundinamarca\n2  Medellín    1495    Antioquia\n3      Cali    1018        Valle\n\n\n\n\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\nusing DataFrames\n\ndf = DataFrame(\n    municipio = [\"Bogotá\", \"Medellín\", \"Cali\", \"Quibdó\", \"Barranquilla\"],\n    altitud = [2625, 1495, 1018, 43, 18],\n    departamento = [\"Cundinamarca\", \"Antioquia\", \"Valle\", \"Chocó\", \"Atlántico\"]\n)\n\n# 1. Selección por posición (similar a R, inicia en 1)\nprimeros_dos = df[1:2, :]\n\n# 2. Filtrado usando la función filter()\n# El operador -&gt; crea una función anónima para evaluar cada fila\ntierras_altas = filter(row -&gt; row.altitud &gt; 1500, df)\n\n# 3. Filtrado abreviado (Sintaxis de Julia 1.7+)\nandinos_altos = df[(df.altitud .&gt; 1000) .& (df.departamento .!= \"Chocó\"), :]\n\n\n\n\n# #| eval: false\nj_eval('\nusing DataFrames\n\ndf = DataFrame(\n    municipio = [\"Bogotá\", \"Medellín\", \"Cali\", \"Quibdó\", \"Barranquilla\"],\n    altitud = [2625, 1495, 1018, 43, 18],\n    departamento = [\"Cundinamarca\", \"Antioquia\", \"Valle\", \"Chocó\", \"Atlántico\"]\n)\n\n# Ejecutamos un filtro y mostramos el resultado\nprintln(\"Municipios con altitud &gt; 1000 msnm:\")\nprintln(filter(row -&gt; row.altitud &gt; 1000, df))\n')\njulia&gt; using DataFrames\njulia&gt; df = DataFrame( municipio = [“Bogotá”, “Medellín”, “Cali”, “Quibdó”, “Barranquilla”], altitud = [2625, 1495, 1018, 43, 18], departamento = [“Cundinamarca”, “Antioquia”, “Valle”, “Chocó”, “Atlántico”] ) 5×3 DataFrame Row │ municipio altitud departamento │ String Int64 String ─────┼───────────────────────────────────── 1 │ Bogotá 2625 Cundinamarca 2 │ Medellín 1495 Antioquia 3 │ Cali 1018 Valle 4 │ Quibdó 43 Chocó 5 │ Barranquilla 18 Atlántico\njulia&gt; # Ejecutamos un filtro y mostramos el resultado\njulia&gt; println(“Municipios con altitud &gt; 1000 msnm:”) Municipios con altitud &gt; 1000 msnm:\njulia&gt; println(filter(row -&gt; row.altitud &gt; 1000, df)) 3×3 DataFrame Row │ municipio altitud departamento │ String Int64 String ─────┼────────────────────────────────── 1 │ Bogotá 2625 Cundinamarca 2 │ Medellín 1495 Antioquia 3 │ Cali 1018 Valle\n[1] “3 │ Cali 1018 Valle”",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Introducción</span>"
    ]
  },
  {
    "objectID": "05-introduccion_python_r_julia.html#estadística-descriptiva-básica",
    "href": "05-introduccion_python_r_julia.html#estadística-descriptiva-básica",
    "title": "6  Introducción a Python, R y Julia",
    "section": "6.9 7. Estadística descriptiva básica",
    "text": "6.9 7. Estadística descriptiva básica\nEl análisis estadístico permite entender la distribución de variables geográficas, como la precipitación acumulada o la densidad de población.\n\n\n\n\n\n\n\n\n\n\nTarea\nDescripción\nPython\nR\nJulia\n\n\n\n\nMedia\nPromedio aritmético\nnp.mean()\nmean()\nmean()\n\n\nDesviación\nMedida de dispersión\nnp.std()\nsd()\nstd()\n\n\nResumen\nEstadísticos básicos\ndf.describe()\nsummary()\ndescribe()\n\n\n\n\nPythonRJulia\n\n\n\n# #| eval: false\nimport numpy as np\nimport pandas as pd\n\n# Altitudes de una muestra de estaciones climáticas en los Andes colombianos\naltitudes = np.array([2625, 1495, 1018, 2150, 1850])\n\n# 1. Estadísticos individuales con Numpy\nprint(f\"Altitud Media: {np.mean(altitudes)} msnm\")\n\nAltitud Media: 1827.6 msnm\n\nprint(f\"Desviación Estándar: {np.std(altitudes):.2f}\")\n\nDesviación Estándar: 548.88\n\n# 2. Resumen completo con Pandas\ndf_alt = pd.DataFrame(altitudes, columns=[\"msnm\"])\nprint(\"\\nResumen Descriptivo:\")\n\n\nResumen Descriptivo:\n\nprint(df_alt.describe())\n\n              msnm\ncount     5.000000\nmean   1827.600000\nstd     613.670351\nmin    1018.000000\n25%    1495.000000\n50%    1850.000000\n75%    2150.000000\nmax    2625.000000\n\n\n\n\n\n# #| eval: false\n# Vector de altitudes msnm\naltitudes &lt;- c(2625, 1495, 1018, 2150, 1850)\n\n# 1. Estadísticos descriptivos básicos\ncat(\"Media:\", mean(altitudes), \"\\n\")\n\nMedia: 1827.6 \n\ncat(\"Desviación Estándar:\", sd(altitudes), \"\\n\")\n\nDesviación Estándar: 613.6704 \n\n# 2. Resumen completo (Min, 1st Qu, Median, Mean, 3rd Qu, Max)\nsummary(altitudes)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   1018    1495    1850    1828    2150    2625 \n\n\n\n\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\nusing Statistics\nusing DataFrames\n\naltitudes = [2625, 1495, 1018, 2150, 1850]\n\n# 1. Las funciones de estadística requieren el paquete 'Statistics'\nprintln(\"Media: \", mean(altitudes))\nprintln(\"Desviación: \", std(altitudes))\n\n# 2. Resumen descriptivo para DataFrames\ndf = DataFrame(msnm = altitudes)\nprintln(describe(df))\n\n\n\n\n# #| eval: false\nj_eval('\nusing Statistics\nusing DataFrames\n\naltitudes = [2625, 1495, 1018, 2150, 1850]\n\nprintln(\"Media aritmética en Julia: \", mean(altitudes))\nprintln(\"Desviación estándar: \", std(altitudes))\n\n# Mostramos el resumen tabular\ndf = DataFrame(msnm = altitudes)\nprintln(describe(df))\n')\njulia&gt; using Statistics\njulia&gt; using DataFrames\njulia&gt; altitudes = [2625, 1495, 1018, 2150, 1850] 5-element Vector{Int64}: 2625 1495 1018 2150 1850\njulia&gt; println(“Media aritmética en Julia:”, mean(altitudes)) Media aritmética en Julia: 1827.6\njulia&gt; println(“Desviación estándar:”, std(altitudes)) Desviación estándar: 613.6703512473125\njulia&gt; # Mostramos el resumen tabular\njulia&gt; df = DataFrame(msnm = altitudes) 5×1 DataFrame Row │ msnm │ Int64 ─────┼─────── 1 │ 2625 2 │ 1495 3 │ 1018 4 │ 2150 5 │ 1850\njulia&gt; println(describe(df)) 1×7 DataFrame Row │ variable mean min median max nmissing eltype │ Symbol Float64 Int64 Float64 Int64 Int64 DataType ─────┼────────────────────────────────────────────────────────────── 1 │ msnm 1827.6 1018 1850.0 2625 0 Int64\n[1] “1 │ msnm 1827.6 1018 1850.0 2625 0 Int64”",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Introducción</span>"
    ]
  },
  {
    "objectID": "05-introduccion_python_r_julia.html#gráficos-básicos",
    "href": "05-introduccion_python_r_julia.html#gráficos-básicos",
    "title": "6  Introducción a Python, R y Julia",
    "section": "6.10 8. Gráficos básicos",
    "text": "6.10 8. Gráficos básicos\nLa visualización es el primer paso del análisis exploratorio de datos (EDA). En SIG, usamos barras para comparar atributos entre regiones y los histogramas para entender la distribución de variables como la elevación o la precipitación.\n\n\n\n\n\n\n\n\n\n\nTarea\nDescripción\nPython\nR\nJulia\n\n\n\n\nBarras\nComparar categorías\nplt.bar()\nbarplot()\nbar()\n\n\nHistograma\nDistribución de frecuencias\nplt.hist()\nhist()\nhistogram()\n\n\n\n\nPythonRJulia\n\n\n\n# #| eval: false\nimport matplotlib.pyplot as plt\n\n# 1. Gráfico de Barras: Altitud de ciudades principales\nciudades = [\"Bogotá\", \"Medellín\", \"Cali\", \"Quibdó\"]\naltitudes = [2625, 1495, 1018, 43]\n\nplt.bar(ciudades, altitudes, color='skyblue', edgecolor='navy')\nplt.xlabel(\"Ciudad\")\nplt.ylabel(\"Altitud (msnm)\")\nplt.title(\"Comparativa de Altitud - Municipios de Colombia\")\nplt.show()\n\n\n\n\n\n\n\n# 2. Histograma: Distribución de una muestra de altitudes\n# Simulamos 50 estaciones climáticas en diferentes pisos térmicos\nimport numpy as np\nmuestra_altitudes = [2625, 1495, 1018, 43, 18, 2527, 959, 467, 2150, 1850] * 5\n\nplt.hist(muestra_altitudes, bins=5, color='orange', alpha=0.7)\nplt.xlabel(\"Rango de Altitud (msnm)\")\nplt.ylabel(\"Frecuencia (N° Estaciones)\")\nplt.title(\"Distribución de Estaciones por Altitud\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n# #| eval: false\n# 1. Gráfico de Barras\nciudades &lt;- c(\"Bogotá\", \"Medellín\", \"Cali\", \"Quibdó\")\naltitudes &lt;- c(2625, 1495, 1018, 43)\n\n# En R base, barplot es simple y potente\nbarplot(altitudes, \n        names.arg = ciudades, \n        col = \"skyblue\", \n        border = \"navy\",\n        xlab = \"Ciudad\", \n        ylab = \"Altitud (msnm)\",\n        main = \"Altitud de Municipios\")\n\n\n\n\n\n\n\n# 2. Histograma\nmuestra_altitudes &lt;- c(2625, 1495, 1018, 43, 18, 2527, 959, 467, 2150, 1850)\nhist(muestra_altitudes, \n     breaks = 5, \n     col = \"orange\", \n     xlab = \"Altitud (msnm)\", \n     main = \"Distribución de la Muestra\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\nusing Plots\n\n# 1. Gráfico de Barras\nciudades = [\"Bogotá\", \"Medellín\", \"Cali\", \"Quibdó\"]\naltitudes = [2625, 1495, 1018, 43]\n\n# Plots.jl usa una sintaxis muy limpia para etiquetas\nbar(ciudades, altitudes, \n    color=:skyblue, \n    xlabel=\"Ciudad\", \n    ylabel=\"Altitud (msnm)\", \n    title=\"Altitud de Municipios\",\n    legend=false)\n\n# 2. Histograma\nmuestra_altitudes = [2625, 1495, 1018, 43, 18, 2527, 959, 467, 2150, 1850]\nhistogram(muestra_altitudes, \n          bins=5, \n          color=:orange, \n          title=\"Frecuencia de Altitudes\")\n\n\n\n\n# #| eval: false\nj_plot('\nusing Plots\n\n# Datos de Colombia\nciudades = [\"Bogotá\", \"Medellín\", \"Cali\", \"Quibdó\"]\naltitudes = [2625, 1495, 1018, 43]\n\n# En j_plot, el gráfico se genera en el dispositivo configurado\np1 = bar(ciudades, altitudes, title=\"Altitud Municipios\", legend=false)\ndisplay(p1)\n\nmuestra = [2625, 1495, 1018, 43, 18, 2527, 959, 467, 2150, 1850]\np2 = histogram(muestra, bins=5, title=\"Histograma Altitudes\")\ndisplay(p2)\n')\njulia&gt; using Plots\njulia&gt; # Datos de Colombia\njulia&gt; ciudades = [“Bogotá”, “Medellín”, “Cali”, “Quibdó”] 4-element Vector{String}: “Bogotá” “Medellín” “Cali” “Quibdó”\njulia&gt; altitudes = [2625, 1495, 1018, 43] 4-element Vector{Int64}: 2625 1495 1018 43\njulia&gt; # En j_plot, el gráfico se genera en el dispositivo configurado\njulia&gt; p1 = bar(ciudades, altitudes, title=“Altitud Municipios”, legend=false)\njulia&gt; display(p1)\njulia&gt; muestra = [2625, 1495, 1018, 43, 18, 2527, 959, 467, 2150, 1850] 10-element Vector{Int64}: 2625 1495 1018 43 18 2527 959 467 2150 1850\njulia&gt; p2 = histogram(muestra, bins=5, title=“Histograma Altitudes”)\njulia&gt; display(p2)",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Introducción</span>"
    ]
  },
  {
    "objectID": "05-introduccion_python_r_julia.html#transformación-de-datos",
    "href": "05-introduccion_python_r_julia.html#transformación-de-datos",
    "title": "6  Introducción a Python, R y Julia",
    "section": "6.11 9. Transformación de datos",
    "text": "6.11 9. Transformación de datos\nEn el análisis de datos espaciales, frecuentemente necesitamos derivar nuevas variables a partir de las existentes, como convertir unidades de medida (metros a pies) o categorizar valores (crear rangos climáticos).\n\n\n\n\n\n\n\n\n\n\nTarea\nDescripción\nPython\nR\nJulia\n\n\n\n\nCrear columna\nNueva variable calculada\ndf[\"nueva\"] = ...\ndf$nueva &lt;- ...\ndf.nueva = ...\n\n\n\n\nPythonRJulia\n\n\n\n# #| eval: false\nimport pandas as pd\n\n# Definimos un DataFrame con municipios y su altitud en metros (msnm)\ndf = pd.DataFrame({\n    \"municipio\": [\"Bogotá\", \"Medellín\", \"Cali\"],\n    \"altitud_m\": [2625, 1495, 1018]\n})\n\n# 1. Creación de una columna mediante una operación aritmética simple\n# Convertimos metros a pies (aprox. 3.28 pies por metro)\ndf[\"altitud_ft\"] = df[\"altitud_m\"] * 3.28\n\n# 2. Creación de una columna con lógica condicional (Clasificación climática)\n# Usamos una función lambda para evaluar cada fila\ndf[\"clima\"] = df[\"altitud_m\"].apply(lambda x: \"Frío\" if x &gt; 2000 else \"Templado\")\n\nprint(df)\n\n  municipio  altitud_m  altitud_ft     clima\n0    Bogotá       2625     8610.00      Frío\n1  Medellín       1495     4903.60  Templado\n2      Cali       1018     3339.04  Templado\n\n\n\n\n\n# #| eval: false\n# Creamos el data frame base\ndf &lt;- data.frame(\n  municipio = c(\"Bogotá\", \"Medellín\", \"Cali\"),\n  altitud_m = c(2625, 1495, 1018)\n)\n\n# 1. Creación de columna usando el operador de asignación $\n# La operación se aplica de forma vectorizada a toda la columna\ndf$altitud_ft &lt;- df$altitud_m * 3.28\n\n# 2. Creación de columna con lógica condicional usando ifelse()\ndf$clima &lt;- ifelse(df$altitud_m &gt; 2000, \"Frío\", \"Templado\")\n\nprint(df)\n\n  municipio altitud_m altitud_ft    clima\n1    Bogotá      2625    8610.00     Frío\n2  Medellín      1495    4903.60 Templado\n3      Cali      1018    3339.04 Templado\n\n\n\n\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\nusing DataFrames\n\n# Definimos el DataFrame con datos de Colombia\ndf = DataFrame(\n    municipio = [\"Bogotá\", \"Medellín\", \"Cali\"],\n    altitud_m = [2625, 1495, 1018]\n)\n\n# 1. Creación de columna: El punto (.) indica que la operación es vectorizada (broadcast)\n# Es fundamental en Julia para operar sobre todos los elementos de la columna\ndf.altitud_ft = df.altitud_m .* 3.28\n\n# 2. Creación con lógica condicional usando una comprensión de lista\ndf.clima = [x &gt; 2000 ? \"Frío\" : \"Templado\" for x in df.altitud_m]\n\nprintln(df)\n\n\n\n\n# #| eval: false\nj_eval('\nusing DataFrames\n\n# Recreamos el DataFrame en el entorno de Julia\ndf = DataFrame(\n    municipio = [\"Bogotá\", \"Medellín\", \"Cali\"],\n    altitud_m = [2625, 1495, 1018]\n)\n\n# Aplicamos las transformaciones\ndf.altitud_ft = df.altitud_m .* 3.28\ndf.clima = [x &gt; 2000 ? \"Frío\" : \"Templado\" for x in df.altitud_m]\n\n# Mostramos el resultado final\nprintln(df)\n')\njulia&gt; using DataFrames\njulia&gt; # Recreamos el DataFrame en el entorno de Julia\njulia&gt; df = DataFrame( municipio = [“Bogotá”, “Medellín”, “Cali”], altitud_m = [2625, 1495, 1018] ) 3×2 DataFrame Row │ municipio altitud_m │ String Int64 ─────┼────────────────────── 1 │ Bogotá 2625 2 │ Medellín 1495 3 │ Cali 1018\njulia&gt; # Aplicamos las transformaciones\njulia&gt; df.altitud_ft = df.altitud_m .* 3.28 3-element Vector{Float64}: 8610.0 4903.599999999999 3339.04\n[1] 3339.04",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Introducción</span>"
    ]
  },
  {
    "objectID": "05-introduccion_python_r_julia.html#resumen-comparativo-cheat-sheet",
    "href": "05-introduccion_python_r_julia.html#resumen-comparativo-cheat-sheet",
    "title": "6  Introducción a Python, R y Julia",
    "section": "6.12 10. Resumen comparativo (cheat sheet)",
    "text": "6.12 10. Resumen comparativo (cheat sheet)\nEsta tabla sirve como guía de referencia rápida para transitar entre los tres lenguajes durante el desarrollo de proyectos de análisis espacial.\n\n\n\n\n\n\n\n\n\n\nCategoría\nTarea\nPython\nR\nJulia\n\n\n\n\nEcosistema\nAyuda de función\nhelp(f)\n?f\n?f\n\n\n\nInstalar paquete\npip3 install x\ninstall.packages(\"x\")\nPkg.add(\"x\")\n\n\nEstructuras\nVector / Lista\n[1, 2, 3]\nc(1, 2, 3)\n[1, 2, 3]\n\n\n\nDiccionario / Mapa\n{\"k\": v}\nlist(k = v)\nDict(k =&gt; v)\n\n\n\nData Frame\npd.DataFrame(d)\ndata.frame(d)\nDataFrame(d)\n\n\nI/O\nLeer CSV\npd.read_csv(\"f.csv\")\nread.csv(\"f.csv\")\nCSV.read(\"f.csv\", DF)\n\n\nManipulación\nVer estructura\ndf.info()\nstr(df)\ndescribe(df)\n\n\n\nFiltrar filas\ndf[df.col &gt; x]\ndf[df$col &gt; x, ]\nfilter(r -&gt; r.col &gt; x, df)\n\n\n\nCrear columna\ndf[\"n\"] = x * 2\ndf$n &lt;- x * 2\ndf.n = x .* 2\n\n\nAnálisis\nMedia\nnp.mean(x)\nmean(x)\nmean(x)\n\n\n\nDimensiones\ndf.shape\ndim(df)\nsize(df)\n\n\nVisualización\nBarras\nplt.bar(x, y)\nbarplot(y, names=x)\nbar(x, y)\n\n\n\n\n\nObservaciones finales\nPara evitar errores comunes en el procesamiento de datos geoespaciales, tenga siempre en cuenta estos tres pilares de la programación moderna:\n\n1. Índices de arreglos (posicionamiento)\nLa forma en que los lenguajes cuentan las posiciones es la causa principal de errores en la extracción de coordenadas o píxeles:\n\nPython: Utiliza indexación base-0 (el primer elemento está en la posición 0).\nR: Utiliza indexación base-1 (el primer elemento está en la posición 1).\nJulia: Al igual que R, utiliza indexación base-1.\n\n\n\n2. Vectorización y broadcasting (eficiencia)\nLa capacidad de operar sobre columnas completas sin usar bucles manuales (que son lentos) varía en su sintaxis y naturaleza:\n\nPython: La vectorización no es nativa de las listas base. Depende totalmente de librerías como numpy o pandas. Si intenta multiplicar una lista estándar por 2 ([1, 2] * 2), Python duplicará los elementos de la lista en lugar de realizar el cálculo matemático.\nR: La vectorización es nativa y automática. Casi todas las funciones de R están diseñadas para recibir un vector y devolver otro. Al hacer vector * 2, R entiende por defecto que debe multiplicarse cada elemento.\nJulia: Utiliza el concepto de Broadcasting. Es el más explícito: requiere añadir un punto antes del operador (.*, ./, .^) o de la función. Este punto le indica al compilador de Julia que “esparza” la operación sobre todos los elementos del vector con una eficiencia comparable al lenguaje C.\n\n\n\n3. El flujo de datos: el pipe (., %&gt;%, |&gt;)\nEl “Pipe” permite escribir código que se lee de izquierda a derecha (como una receta), evitando el anidamiento excesivo de paréntesis.\n\nPython (pandas): Utiliza el encadenamiento de métodos mediante el punto (.). Cada operación devuelve un nuevo objeto sobre el cual se aplica la siguiente: df.filter(...).sort(...).\nR (dplyr / Nativo): El pipe clásico de Tidyverse (%&gt;%) o el nativo (|&gt;) pasa el objeto automáticamente como primer argumento de la siguiente función: df %&gt;% filter(...).\nJulia (|&gt; / Chain.jl): El pipe nativo (|&gt;) es un operador de tubería simple. Para flujos de datos complejos y legibles, la comunidad de Julia prefiere la macro @chain del paquete Chain.jl.\n\n\n\n\n\nLibrerías de referencia (caja de herramientas)\nPara que su entorno de trabajo esté completo, asegúrese de tener instaladas y cargadas estas librerías base:\n\nPython: pandas (tablas de atributos), numpy (álgebra de mapas), matplotlib (salidas gráficas).\nR: base y dplyr (manipulación), graphics (visualización rápida).\nJulia: DataFrames (tablas), CSV (lectura), Statistics y Plots.\n\n\nNota sobre el rendimiento: Ninguno de los comandos vistos en este capítulo ejecuta procesamiento en paralelo (uso de múltiples núcleos). La vectorización y el pipe son herramientas de eficiencia lógica y computacional en un solo núcleo. El procesamiento multihilo se reservará para el análisis de grandes volúmenes de datos en capítulos posteriores.",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Introducción</span>"
    ]
  },
  {
    "objectID": "06-estructuras_datos_geo.html",
    "href": "06-estructuras_datos_geo.html",
    "title": "7  Estructuras de Datos Geoespaciales",
    "section": "",
    "text": "7.1 El Estándar Simple Features (ISO 19125)\nLa mayoría de las librerías modernas de programación SIG (Geopandas en Python, sf en R y LibGEOS/ArchGDAL en Julia) implementan el estándar Simple Features Access de la OGC. Este estándar define un modelo común para almacenar y acceder a geometrías en 2D.\nLas geometrías fundamentales que utilizaremos son:",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Estructuras de Datos Geoespaciales</span>"
    ]
  },
  {
    "objectID": "06-estructuras_datos_geo.html#el-estándar-simple-features-iso-19125",
    "href": "06-estructuras_datos_geo.html#el-estándar-simple-features-iso-19125",
    "title": "7  Estructuras de Datos Geoespaciales",
    "section": "",
    "text": "Point (Punto): Un par de coordenadas \\((x, y)\\).\nLineString (Línea): Una secuencia de puntos conectados.\nPolygon (Polígono): Un anillo cerrado que puede contener “huecos” (anillos interiores).",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Estructuras de Datos Geoespaciales</span>"
    ]
  },
  {
    "objectID": "06-estructuras_datos_geo.html#creación-de-geometrías-básicas",
    "href": "06-estructuras_datos_geo.html#creación-de-geometrías-básicas",
    "title": "7  Estructuras de Datos Geoespaciales",
    "section": "7.2 Creación de Geometrías Básicas",
    "text": "7.2 Creación de Geometrías Básicas\nA continuación, definiremos la ubicación de la Plaza de Bolívar en Bogotá (aprox. \\(-74.076, 4.598\\)) usando los tres lenguajes.\n\nPython (Shapely)R (sf)Julia (LibGEOS)\n\n\n\n# #| eval: false\nfrom shapely.geometry import Point, LineString\n\n# Crear punto (Longitud, Latitud)\nplaza_bolivar = Point(-74.076, 4.598)\n\n# Crear una línea (un segmento de la Séptima)\ncalle_septima = LineString([(-74.076, 4.598), (-74.075, 4.605)])\n\nprint(f\"Tipo: {plaza_bolivar.geom_type}\")\n\nTipo: Point\n\nprint(f\"WKT: {plaza_bolivar.wkt}\")\n\nWKT: POINT (-74.076 4.598)\n\n\n\n\n\n# #| eval: false\nlibrary(sf)\n\nLinking to GEOS 3.12.1, GDAL 3.8.4, PROJ 9.4.0; sf_use_s2() is TRUE\n\n# Crear punto\nplaza_bolivar &lt;- st_point(c(-74.076, 4.598))\n\n# Crear línea\ncalle_septima &lt;- st_linestring(rbind(c(-74.076, 4.598), c(-74.075, 4.605)))\n\nprint(plaza_bolivar)\n\nPOINT (-74.076 4.598)\n\n\n\n\n\n# #| eval: false\nj_eval('\n  using LibGEOS\n\n  # Crear punto desde formato WKT\n  plaza_bolivar = LibGEOS.readgeom(\"POINT (-74.076 4.598)\")\n\n  println(\"Tipo: \", typeof(plaza_bolivar))\n')\n\nStarting Julia ...\n\n\njulia&gt; using LibGEOS\n\n  # Crear punto desde formato WKT\n\njulia&gt; plaza_bolivar = LibGEOS.readgeom(\"POINT (-74.076 4.598)\")\nPoint(Ptr{Nothing} @0x00000000174a1e50, LibGEOS.GEOSContext(Ptr{Nothing} @0x0000000017b11410))\n\njulia&gt; println(\"Tipo: \", typeof(plaza_bolivar))\nTipo: Point",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Estructuras de Datos Geoespaciales</span>"
    ]
  },
  {
    "objectID": "06-estructuras_datos_geo.html#atributos-y-tablas-espaciales",
    "href": "06-estructuras_datos_geo.html#atributos-y-tablas-espaciales",
    "title": "7  Estructuras de Datos Geoespaciales",
    "section": "7.3 Atributos y Tablas Espaciales",
    "text": "7.3 Atributos y Tablas Espaciales\nUn SIG es la unión de geometría + atributos. Cada lenguaje tiene una estructura principal para manejar estas tablas:\n\n\n\nConcepto\nPython\nR\nJulia\n\n\n\n\nLibrería\ngeopandas\nsf\nGeoTables.jl\n\n\nEstructura\nGeoDataFrame\nsf (data.frame)\nGeoTable\n\n\n\n\nEjemplo: Ciudades Principales de Colombia\n\nPython (GeoPandas)R (sf)Julia (GeoTables)\n\n\n\n# #| eval: false\nimport geopandas as gpd\nimport pandas as pd\nfrom shapely.geometry import Point\n\n# Datos alfanuméricos\ndf = pd.DataFrame({\n    'Ciudad': ['Bogotá', 'Medellín', 'Cali'],\n    'Pob': [7.9, 2.5, 2.2]\n})\n\n# Geometrías\ngeoms = [Point(-74.08, 4.60), Point(-75.56, 6.25), Point(-76.52, 3.42)]\n\n# Unión en GeoDataFrame\ngdf = gpd.GeoDataFrame(df, geometry=geoms, crs=\"EPSG:4326\")\nprint(gdf)\n\n     Ciudad  Pob             geometry\n0    Bogotá  7.9   POINT (-74.08 4.6)\n1  Medellín  2.5  POINT (-75.56 6.25)\n2      Cali  2.2  POINT (-76.52 3.42)\n\n\n\n\n\n# #| eval: false\nlibrary(sf)\n\nciudades &lt;- data.frame(\n  Ciudad = c(\"Bogotá\", \"Medellín\", \"Cali\"),\n  Pob = c(7.9, 2.5, 2.2),\n  lon = c(-74.08, -75.56, -76.52),\n  lat = c(4.60, 6.25, 3.42)\n)\n\ngdf &lt;- st_as_sf(ciudades, coords = c(\"lon\", \"lat\"), crs = 4326)\nprint(gdf)\n\nSimple feature collection with 3 features and 2 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: -76.52 ymin: 3.42 xmax: -74.08 ymax: 6.25\nGeodetic CRS:  WGS 84\n    Ciudad Pob            geometry\n1   Bogotá 7.9  POINT (-74.08 4.6)\n2 Medellín 2.5 POINT (-75.56 6.25)\n3     Cali 2.2 POINT (-76.52 3.42)\n\n\n\n\n\n# #| eval: false\nj_eval('\n  using GeoTables, GeometryBasics, DataFrames\n\n  df = DataFrame(Ciudad = [\"Bogotá\", \"Medellín\", \"Cali\"], Pob = [7.9, 2.5, 2.2])\n  puntos = [Point2f(-74.08, 4.60), Point2f(-75.56, 6.25), Point2f(-76.52, 3.42)]\n\n  gt = GeoTable(df, geometry = puntos)\n  println(gt)\n')\n\njulia&gt; using GeoTables, GeometryBasics, DataFrames\njulia&gt; Error: ArgumentError(\"Package GeoTables not found in current path.\\n- Run `import Pkg; Pkg.add(\\\"GeoTables\\\")` to install the GeoTables package.\")",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Estructuras de Datos Geoespaciales</span>"
    ]
  },
  {
    "objectID": "06-estructuras_datos_geo.html#sistemas-de-referencia-de-coordenadas-crs",
    "href": "06-estructuras_datos_geo.html#sistemas-de-referencia-de-coordenadas-crs",
    "title": "7  Estructuras de Datos Geoespaciales",
    "section": "7.4 Sistemas de Referencia de Coordenadas (CRS)",
    "text": "7.4 Sistemas de Referencia de Coordenadas (CRS)\nEn Colombia, trabajamos principalmente con:\n\nWGS84 (EPSG:4326): Grados decimales.\nMAGNA-SIRGAS / Origen Nacional (EPSG:9377): Metros.\n\n\n\n\n\n\n\nImportante\n\n\n\nNunca realice cálculos de área o distancia usando coordenadas en grados (EPSG:4326). Siempre proyecte a EPSG:9377 para obtener resultados en metros.",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Estructuras de Datos Geoespaciales</span>"
    ]
  },
  {
    "objectID": "41-practica_1_benchmark_raster.html",
    "href": "41-practica_1_benchmark_raster.html",
    "title": "8  Evaluación Comparativa de Procesamiento Geoespacial",
    "section": "",
    "text": "8.1 Introducción",
    "crumbs": [
      "Prácticas",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Evaluación Comparativa de Procesamiento Geoespacial</span>"
    ]
  },
  {
    "objectID": "41-practica_1_benchmark_raster.html#introducción",
    "href": "41-practica_1_benchmark_raster.html#introducción",
    "title": "8  Evaluación Comparativa de Procesamiento Geoespacial",
    "section": "",
    "text": "Materia: Programación SIG: Python, R, Julia\nPráctica 1: Sentinel-2 (1GB) - R (terra) vs R (stars) vs Python (rasterio) vs Julia (ArchGDAL + Raster.jl)\nAutores: Alexys Rodríguez-Avellaneda Ph.D. & herramientas IA",
    "crumbs": [
      "Prácticas",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Evaluación Comparativa de Procesamiento Geoespacial</span>"
    ]
  },
  {
    "objectID": "41-practica_1_benchmark_raster.html#función-j_eval-y-j_plot-en-r",
    "href": "41-practica_1_benchmark_raster.html#función-j_eval-y-j_plot-en-r",
    "title": "8  Evaluación Comparativa de Procesamiento Geoespacial",
    "section": "8.2 Función j_eval y j_plot en R",
    "text": "8.2 Función j_eval y j_plot en R\nUsada para ejecutar código Julia en R. j_eval ejecuta comandos que no tengan salidas gráficas, y j_plot es necesaria cuándo el código Julia produce salidas gráficas.\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\n# Código en R \nj_eval &lt;- function(cmd) {\n  .ensure_julia_ready()\n  lineas &lt;- strsplit(cmd, \"\\n\")[[1]]\n  buffer_bloque &lt;- \"\"; en_bloque &lt;- 0; resultado_final &lt;- NULL\n\n  for (l in lineas) {\n    if (trimws(l) == \"\") next\n    buffer_bloque &lt;- paste0(buffer_bloque, l, \"\\n\")\n    abrir &lt;- grepl(\"\\\\b(do|function|for|if|begin|let|while)\\\\b\", l) & !grepl(\"\\\\bend\\\\b\", l)\n    cerrar &lt;- grepl(\"\\\\bend\\\\b\", l)\n    en_bloque &lt;- en_bloque + abrir - cerrar\n    \n    if (en_bloque &lt;= 0) {\n      res_raw &lt;- JuliaConnectoR::juliaCall(\"_unal_core_executor\", buffer_bloque, FALSE, \"\", 72, 800, 500, 12)\n      cat(res_raw)\n      lineas_res &lt;- strsplit(res_raw, \"\\n\")[[1]]\n      lineas_res &lt;- trimws(lineas_res[lineas_res != \"\"])\n      # Capturamos solo si hay contenido real\n      temp_res &lt;- tail(lineas_res[!grepl(\"^julia&gt;\", lineas_res)], 1)\n      if (length(temp_res) &gt; 0) resultado_final &lt;- temp_res\n      buffer_bloque &lt;- \"\"; en_bloque &lt;- 0\n    }\n  }\n  if (is.null(resultado_final)) return(NULL) # Evita el error de length zero\n  val_limpio &lt;- gsub('\"', '', resultado_final)\n  num_val &lt;- suppressWarnings(as.numeric(val_limpio))\n  return(if (!is.na(num_val)) num_val else val_limpio)\n}\n\nj_plot &lt;- function(cmd, n = \"tmp_plot.png\", dpi = 300, w = 800, h = NULL, ratio = 1.6, fontsize = 12) {\n  .ensure_julia_ready()\n  if (is.null(h)) h &lt;- round(w / ratio)\n  \n  lineas &lt;- strsplit(cmd, \"\\n\")[[1]]\n  buffer_bloque &lt;- \"\"; en_bloque &lt;- 0\n  \n  for (i in 1:length(lineas)) {\n    l &lt;- lineas[i]\n    if (trimws(l) == \"\") next\n    buffer_bloque &lt;- paste0(buffer_bloque, l, \"\\n\")\n    \n    # Lógica de detección de bloques (do, function, for, etc.)\n    abrir &lt;- grepl(\"\\\\b(do|function|for|if|begin|let|while)\\\\b\", l) & !grepl(\"\\\\bend\\\\b\", l)\n    cerrar &lt;- grepl(\"\\\\bend\\\\b\", l)\n    en_bloque &lt;- en_bloque + abrir - cerrar\n    \n    # Solo ejecutamos si el bloque está cerrado\n    if (en_bloque &lt;= 0) {\n      # ¿Es el último bloque? Si sí, activamos el guardado de imagen (TRUE)\n      es_ultimo &lt;- (i == length(lineas))\n      \n      log_out &lt;- JuliaConnectoR::juliaCall(\n        \"_unal_core_executor\", \n        buffer_bloque, \n        es_ultimo, # Solo la última ejecución guarda el PNG\n        n, dpi, as.integer(w), as.integer(h), as.integer(fontsize)\n      )\n      \n      if (nchar(log_out) &gt; 0) cat(log_out)\n      buffer_bloque &lt;- \"\"; en_bloque &lt;- 0\n    }\n  }\n  \n  # Renderizado de la imagen en R (solo si se creó el archivo)\n  if (file.exists(n)) {\n    img &lt;- png::readPNG(n)\n    grid::grid.newpage()\n    grid::grid.raster(img)\n    # Opcional: borrar el temporal después de leerlo para no dejar basura\n    # unlink(n) \n  }\n}",
    "crumbs": [
      "Prácticas",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Evaluación Comparativa de Procesamiento Geoespacial</span>"
    ]
  },
  {
    "objectID": "41-practica_1_benchmark_raster.html#preparación-de-los-datos-sentinel-2a",
    "href": "41-practica_1_benchmark_raster.html#preparación-de-los-datos-sentinel-2a",
    "title": "8  Evaluación Comparativa de Procesamiento Geoespacial",
    "section": "8.3 Preparación de los Datos: Sentinel-2A",
    "text": "8.3 Preparación de los Datos: Sentinel-2A\nEn este ejercicio procesamos una escena de Sentinel-2A en formato .zip. En lugar de extraer el archivo (lo cual duplicaría el espacio en disco a casi 2GB), usamos el driver VSI (Virtual Systems Interface) de GDAL.\n\nAnatomía de la Imagen\nLa imagen Sentinel-2 se organiza por bandas. Para este benchmark usaremos la Banda 4 (Red), fundamental para el cálculo de índices de vegetación como el NDVI.\n\n\n\nBanda\nResolución\nLongitud de Onda\nUso\n\n\n\n\nB02 (Blue)\n10m\n490 nm\nMapeo de aguas, suelos\n\n\nB03 (Green)\n10m\n560 nm\nVigor de vegetación\n\n\nB04 (Red)\n10m\n665 nm\nAbsorción de clorofila\n\n\nB08 (NIR)\n10m\n842 nm\nBiomasa, salud foliar\n\n\n\n\nDescubrir la Ruta de la Imagen Sentinel-2\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\n# Código en R\n\nlibrary(starsdata)\nlibrary(terra)\nlibrary(stars)\nlibrary(reticulate)\n\n# 1. Localización del ZIP dentro del paquete starsdata\nf &lt;- \"sentinel/S2A_MSIL1C_20180220T105051_N0206_R051_T32ULE_20180221T134037.zip\"\ngranule &lt;- system.file(file = f, package = \"starsdata\")\ngranule\n\n# 2. Construcción de la ruta Virtual de GDAL (/vsizip/)\n# Rompemos la cadena en varias líneas para que LaTeX pueda procesarla\nbase_name &lt;- strsplit(basename(granule), \".zip\")[[1]]\nbase_name\n\n\n# Esta ruta permite leer directamente el XML de metadatos dentro del ZIP sin descomprimir.\n#s2_path &lt;- paste0(\"SENTINEL2_L1C:/vsizip/\", granule, \"/\", base_name, \".SAFE/MTD_MSIL1C.xml:10m:EPSG_32632\")\ns2_path &lt;- paste0(\n  \"SENTINEL2_L1C:/vsizip/\", \n  granule, \n  \"/\", \n  base_name, \n  \".SAFE/MTD_MSIL1C.xml:10m:EPSG_32632\"\n)\n#s2_path\n\n# Mostramos el resultado sin comillas ni índices [1] para el libro\ncat(\"Ruta generada:\", s2_path, fill = TRUE)\n\n# Guardamos la ruta en un archivo compartido para que Python y Julia la lean\nwriteLines(s2_path, \"s2_shared_path.txt\")\n\n\n\n\n\n\nCódigo\nlibrary(starsdata)\nlibrary(terra)\n\n\nterra 1.8.93\n\n\n\nAttaching package: 'terra'\n\n\nThe following object is masked from 'package:grid':\n\n    depth\n\n\nCódigo\nlibrary(stars)\n\n\nLoading required package: abind\n\n\nLoading required package: sf\n\n\nLinking to GEOS 3.12.1, GDAL 3.8.4, PROJ 9.4.0; sf_use_s2() is TRUE\n\n\nCódigo\nlibrary(reticulate)\n\n# 1. Localización del ZIP dentro del paquete starsdata\nf &lt;- \"sentinel/S2A_MSIL1C_20180220T105051_N0206_R051_T32ULE_20180221T134037.zip\"\ngranule &lt;- system.file(file = f, package = \"starsdata\")\ngranule\n\n\n[1] \"/usr/local/lib/R/site-library/starsdata/sentinel/S2A_MSIL1C_20180220T105051_N0206_R051_T32ULE_20180221T134037.zip\"\n\n\nCódigo\nbase_name &lt;- strsplit(basename(granule), \".zip\")[[1]]\nbase_name\n\n\n[1] \"S2A_MSIL1C_20180220T105051_N0206_R051_T32ULE_20180221T134037\"\n\n\nCódigo\n# 2. Construcción de la ruta Virtual de GDAL (/vsizip/)\n# Esta ruta permite leer directamente el XML de metadatos dentro del ZIP sin descomprimir.\ns2_path &lt;- paste0(\"SENTINEL2_L1C:/vsizip/\", granule, \"/\", base_name, \".SAFE/MTD_MSIL1C.xml:10m:EPSG_32632\")\ns2_path\n\n\n[1] \"SENTINEL2_L1C:/vsizip//usr/local/lib/R/site-library/starsdata/sentinel/S2A_MSIL1C_20180220T105051_N0206_R051_T32ULE_20180221T134037.zip/S2A_MSIL1C_20180220T105051_N0206_R051_T32ULE_20180221T134037.SAFE/MTD_MSIL1C.xml:10m:EPSG_32632\"\n\n\nCódigo\n# Guardamos la ruta en un archivo compartido para que Python y Julia la lean\nwriteLines(s2_path, \"s2_shared_path.txt\")",
    "crumbs": [
      "Prácticas",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Evaluación Comparativa de Procesamiento Geoespacial</span>"
    ]
  },
  {
    "objectID": "41-practica_1_benchmark_raster.html#metodología-de-la-evaluación-comparativa-benchmarking",
    "href": "41-practica_1_benchmark_raster.html#metodología-de-la-evaluación-comparativa-benchmarking",
    "title": "8  Evaluación Comparativa de Procesamiento Geoespacial",
    "section": "8.4 Metodología de la evaluación comparativa (benchmarking)",
    "text": "8.4 Metodología de la evaluación comparativa (benchmarking)\nEste experimento evalúa el rendimiento de cuatro motores geoespaciales ampliamente utilizados —terra (R), stars (R), rasterio (Python) y Rasters.jl (Julia)— frente a una operación numéricamente simple pero computacionalmente exigente sobre datos raster de gran tamaño.\nEl flujo de trabajo consiste en:\n\nApertura del archivo raster Sentinel-2.\nSelección de una sola banda (B4).\nAplicación de una operación aritmética escalar.\nCálculo de la media global (mean), que fuerza la evaluación completa del raster.\n\nA diferencia de benchmarks centrados en materialización explícita, este experimento utiliza la operación mean() como operación común de evaluación, permitiendo que cada motor ejecute el cálculo conforme a su propio modelo interno de ejecución (lazy vs eager).\n\n\nDimensión del problema\nUna banda Sentinel-2 a 10 m de resolución contiene:\n\\[10.980 \\times 10.980 = 120.560.400 \\text{ píxeles}\\]\nAsumiendo datos en punto flotante de 32 bits (4 bytes), el volumen teórico mínimo es:\n\\[120.560.400 \\times 4 \\approx 482{,}24 \\text{ MB}\\]\nEste tamaño excede ampliamente la caché de CPU, por lo que el experimento está dominado por I/O, acceso a memoria y eficiencia de recorrido, no por complejidad algorítmica.\n\n\n\nExclusiones deliberadas\n\nLa generación de gráficos (plotting) se ejecuta fuera del bloque cronometrado.\nEl tiempo de renderizado y escritura en disco no refleja la velocidad de procesamiento numérico.\nEn Julia, se realiza una ejecución previa (warm-up) para excluir el costo de compilación Just-In-Time (JIT) del tiempo reportado.\nEn Python y R, el código numérico crítico se ejecuta en librerías ya compiladas (GDAL, NumPy, C/C++), por lo que no existe un costo de compilación comparable. Cualquier efecto de “calentamiento” en estos casos se limita a inicialización de librerías y caché de disco, y no altera de forma significativa los tiempos medidos.\n\n\n\n\nEtapas del proceso evaluado\n\n\n\n\n\n\n\n\nEtapa\nDescripción técnica\nImplementación por motor\n\n\n\n\n1. Apertura del dataset\nLectura de metadatos y establecimiento de conexión al raster (sin carga completa a RAM)\nR / terra: rast()  R / stars: read_stars(proxy = TRUE)  Python / rasterio: rasterio.open()  Julia / ArchGDAL + Rasters.jl: ArchGDAL.read()\n\n\n2. Selección de banda B4\nReferencia a la banda espectral sin materializar todos los píxeles\nR / terra: r[[1]]  R / stars: s[,,,1]  Python / rasterio: src.read(1)  Julia / Rasters.jl: Raster(ds)[Band(1)]\n\n\n3. Operación aritmética escalar\nMultiplicación de cada píxel por un factor constante (1.5)\nR / terra: b4 * 1.5  R / stars: b4 * 1.5  Python / NumPy: b4 * 1.5  Julia / Rasters.jl: r .* 1.5\n\n\n4. Reducción global (mean)\nCálculo de la media global, forzando el recorrido completo del raster\nR / terra: global(res_terra, \"mean\", na.rm = TRUE)[1, 1] (streaming)  R / stars: mean(as.vector(res_mem[[1]]), na.rm = TRUE) (tras materialización explícita)  Python / NumPy: res.mean() (array ya en RAM)  Julia / Rasters.jl: mean(res) (streaming lazy)\n\n\n\n\n\n\nInterpretación clave del paso de reducción (mean)\nEl cálculo de la media es fundamental porque:\n\nObliga a recorrer todos los píxeles del raster.\nGarantiza que la operación aritmética fue realmente ejecutada.\nPermite forzar la evaluación completa del flujo de cálculo sin introducir operaciones adicionales.\n\nNo obstante, cada motor implementa este paso de forma distinta: algunos realizan la reducción en streaming sin materializar el raster completo, mientras que otros requieren una materialización explícita en memoria. Estas diferencias responden a decisiones de diseño propias de cada librería y constituyen una limitación inevitable de la comparación.\n\n\n\nDiferencias estructurales entre motores\nCada motor está optimizado para un tipo distinto de análisis. terra y rasterio están especialmente afinados para cálculos numéricos simples sobre grandes volúmenes de datos, mientras que stars y Rasters.jl priorizan flexibilidad y modelos de datos más generales, lo cual puede afectar el rendimiento en operaciones simples como una media global.\n\n\n\n\n\n\n\n\nMotor\n¿Cómo trabaja internamente?\n¿Qué implica en este benchmark?\n\n\n\n\nterra (R)\nUsa archivos raster “por referencia” y hace los cálculos en C++\nRecorre el raster una sola vez de forma muy eficiente\n\n\nstars (R)\nManeja los datos como cubos multidimensionales con mucha información espacial\nEs más flexible, pero la media global es más lenta por el manejo de metadatos\n\n\nrasterio (Python)\nCarga la banda completa en un arreglo NumPy\nLos datos quedan contiguos en memoria y se procesan muy rápido\n\n\nRasters.jl (Julia)\nEvalúa las operaciones paso a paso y por bloques\nEs muy general, pero en este caso introduce más sobrecarga\n\n\n\n\n\n\nLimitaciones inevitables del benchmarking\nEste benchmark no mide qué lenguaje es “más rápido”, sino cómo funciona todo el conjunto de herramientas que usa cada uno (librerías, forma de leer datos y manera de calcular).\nEn particular:\n\nPython (rasterio) es muy rápido porque lee la banda completa en memoria y usa arreglos NumPy optimizados.\nterra (R) está muy bien optimizado para hacer operaciones matemáticas sobre rasters usando código en C++.\nstars (R) se enfoca en manejar bien la información espacial y los metadatos, lo que hace más lenta una media global.\nJulia (Rasters.jl) está pensado para análisis espaciales más generales y flexibles, no para un único cálculo masivo como en NumPy.\n\nPor eso, estos resultados deben interpretarse así:\n\nMiden el rendimiento para una tarea específica (leer un raster y calcular una media),\nNo un ranking general de lenguajes de programación.\n\n\n\nInterpretación del benchmark\nEste benchmark representa un caso extremo y muy simplificado:\n\nSe utiliza una sola banda raster.\nSe aplica una operación matemática trivial (multiplicación escalar).\nSe calcula una única media global.\n\nPor lo tanto, no evalúa:\n\nAnálisis con múltiples bandas.\nOperaciones espaciales complejas (vecindarios, máscaras, reproyecciones).\nFlujos de trabajo largos, iterativos o modelos estadísticos.\n\nEl objetivo no es declarar un “lenguaje ganador”, sino entender los costos reales de: - leer los datos, - manejar las abstracciones, - y calcular una estadística global.\n\n¿Qué significa “manejar las abstracciones”?\nLas abstracciones son capas de software que facilitan el trabajo del usuario.\nEstas capas se encargan de:\n\nLeer los datos de forma segura.\nMantener la información espacial (coordenadas, resolución, extensión).\nCoordinar las operaciones sin que el usuario controle cada paso.\n\nAunque hacen el código más claro y seguro, introducen un costo adicional, que se vuelve visible en operaciones simples y masivas, como una reducción global (mean).\n\n\nNivel de abstracción por motor\n\n\n\n\n\n\n\n\nMotor / librería\nNivel de abstracción\nForma de trabajar (idea intuitiva)\n\n\n\n\nPython / rasterio + NumPy\nBaja\n“Aquí tienes un arreglo de números en memoria, hagamos cuentas rápido”\n\n\nR / terra\nMedia\n“Yo manejo el raster y optimizo las operaciones por ti”\n\n\nR / stars\nAlta\n“Además de los valores, manejo dimensiones, tiempo, atributos y geometría”\n\n\nJulia / Rasters.jl\nFlexible\n“Construyo un flujo de operaciones que se evalúa cuando es necesario”\n\n\n\nIdea clave:\n&gt; A mayor nivel de abstracción, mayor comodidad y expresividad para el usuario,\n&gt; pero también mayor costo computacional en operaciones simples como una media global.",
    "crumbs": [
      "Prácticas",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Evaluación Comparativa de Procesamiento Geoespacial</span>"
    ]
  },
  {
    "objectID": "41-practica_1_benchmark_raster.html#análisis-de-rendimiento-y-paralelismo",
    "href": "41-practica_1_benchmark_raster.html#análisis-de-rendimiento-y-paralelismo",
    "title": "8  Evaluación Comparativa de Procesamiento Geoespacial",
    "section": "8.5 Análisis de Rendimiento y Paralelismo",
    "text": "8.5 Análisis de Rendimiento y Paralelismo\n\nBenchmark en Python vs. Julia\n\n🐍 Python (Rasterio)⚡ Julia (Rasters.jl)\n\n\nrasterio es la navaja suiza de Python para rasters. Al combinarse con NumPy, utiliza instrucciones SIMD que paralelizan el cálculo a nivel de procesador (vectorización), aunque la lectura de GDAL sigue siendo monohilo.\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\n# Código en Python\nimport rasterio\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport time\nimport gc\n\n# ------------------------------------------------\n# 1. Leer ruta compartida\n# ------------------------------------------------\nwith open(\"s2_shared_path.txt\", \"r\") as f:\n    s2_path = f.read().strip()\n\n# ------------------------------------------------\n# 2. WARM-UP (compila + cachea)\n# ------------------------------------------------\nwith rasterio.open(s2_path) as src:\n    _ = (src.read(1) * 1.5).mean()\n\ngc.collect()\n\n# ------------------------------------------------\n# 3. BENCHMARK REAL\n# ------------------------------------------------\nt0 = time.perf_counter()\n\nwith rasterio.open(s2_path) as src:\n    b4 = src.read(1)          # lectura banda 4\n    res = b4 * 1.5            # operación\n    m_py = res.mean()         # FORZADO REAL\n\nt_python = time.perf_counter() - t0\n\nprint(f\"🐍 Python: {t_python:.3f} seg | mean = {m_py:.6f}\")\n\n# ------------------------------------------------\n# 4. Plot (FUERA DEL BENCHMARK)\n# ------------------------------------------------\nplt.imshow(res, cmap=\"terrain\")\nplt.title(\"Python: Banda 4 × 1.5\")\nplt.axis(\"off\")\nplt.show()\n\n# ------------------------------------------------\n# 5. Limpieza\n# ------------------------------------------------\ndel b4, res\n#gc.collect()\n\n\n\n\n\n\nCódigo\nimport rasterio\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport time\nimport gc\n\n# ------------------------------------------------\n# 1. Leer ruta compartida\n# ------------------------------------------------\nwith open(\"s2_shared_path.txt\", \"r\") as f:\n    s2_path = f.read().strip()\n\n# ------------------------------------------------\n# 2. WARM-UP (compila + cachea)\n# ------------------------------------------------\nwith rasterio.open(s2_path) as src:\n    _ = (src.read(1) * 1.5).mean()\n\ngc.collect()\n\n\n480\n\n\nCódigo\n# ------------------------------------------------\n# 3. BENCHMARK REAL\n# ------------------------------------------------\nt0 = time.perf_counter()\n\nwith rasterio.open(s2_path) as src:\n    b4 = src.read(1)          # lectura banda 4\n    res = b4 * 1.5            # operación\n    m_py = res.mean()         # FORZADO REAL\n\nt_python = time.perf_counter() - t0\n\nprint(f\"🐍 Python: {t_python:.3f} seg | mean = {m_py:.6f}\")\n\n\n🐍 Python: 2.896 seg | mean = 3766.624630\n\n\nCódigo\n# ------------------------------------------------\n# 4. Plot (FUERA DEL BENCHMARK)\n# ------------------------------------------------\nplt.imshow(res, cmap=\"terrain\")\n\n\n&lt;matplotlib.image.AxesImage object at 0x7f0fdfc81a30&gt;\n\n\nCódigo\nplt.title(\"Python: Banda 4 × 1.5\")\n\n\nText(0.5, 1.0, 'Python: Banda 4 × 1.5')\n\n\nCódigo\nplt.axis(\"off\")\n\n\n(np.float64(-0.5), np.float64(10979.5), np.float64(10979.5), np.float64(-0.5))\n\n\nCódigo\nplt.show()\n\n\n\n\n\n\n\n\n\nCódigo\n\n# ------------------------------------------------\n# 5. Limpieza\n# ------------------------------------------------\ndel b4, res\n#gc.collect()\n\n\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\n# Código en R\n# Aquí es donde creamos t_python para R de la variable t_python en Python. Lo necesitamos en R para la tabla final.\n# Extraemos el valor desde el objeto 'py'\nt_python &lt;- py$t_python\n#t_python &lt;- 0\n\ncat(\"🐍 Tiempo capturado de Python:\", round(t_python, 3), \"seg.\")\n\n\n\n\n\n\nCódigo\n# Aquí es donde creamos t_python para R de la variable t_python en Python. Lo necesitamos en R para la tabla final.\n# Extraemos el valor desde el objeto 'py'\nt_python &lt;- py$t_python\n#t_python &lt;- 0\n\ncat(\"🐍 Tiempo capturado de Python:\", round(t_python, 3), \"seg.\")\n\n\n🐍 Tiempo capturado de Python: 2.896 seg.\n\n\n\n\nJulia es el único de los cuatro motores evaluados que puede explotar paralelismo multihilo en esta operación específica, sin recurrir a librerías externas adicionales, aprovechando los núcleos asignados al contenedor.\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\n# Código en Julia\nusing Rasters, ArchGDAL, Statistics, Plots\n\n# Evita restricciones artificiales de memoria\nRasters.checkmem!(false)\n\n# ------------------------------------------------\n# 1. Leer ruta compartida\n# ------------------------------------------------\npath = strip(read(\"s2_shared_path.txt\", String))\n\n# ------------------------------------------------\n# 2. FUNCIÓN DE BENCHMARK (proxy + mean)\n# ------------------------------------------------\nfunction process_band_mean(path)\n    ArchGDAL.read(path) do ds\n        r   = Raster(ds)[Band(1)]   # proxy, solo banda 4\n        res = r .* 1.5              # operación lazy\n        return mean(res)            # FORZADO REAL (streaming)\n    end\nend\n\n# ------------------------------------------------\n# 3. WARM-UP (compilación)\n# ------------------------------------------------\nprocess_band_mean(path)\nGC.gc()\n\n# ------------------------------------------------\n# 4. BENCHMARK REAL\n# ------------------------------------------------\nt0 = time_ns()\nm_julia = process_band_mean(path)\nt1 = time_ns()\n\nt_julia = (t1 - t0) / 1e9\n\nprintln(\"🟣 Julia: \", round(t_julia, digits=3), \" seg | mean = \", round(m_julia, digits=6))\n\n\n# ------------------------------------------------\n# 5. Plot (FUERA DEL BENCHMARK, proxy)\n# ------------------------------------------------\nArchGDAL.read(path) do ds\n    r   = Raster(ds)[Band(1)]\n    res = r .* 1.5\n    p = plot(res, colormap = :terrain,\n         title = \"Julia: Banda 4 × 1.5\")\n    savefig(p, \"julia_plot.png\")\nend\n\n# Debe ser la última para que j_eval en R capture solo el número\nt_julia\n\n\n\n\n\n\nCódigo\n# 1. Desde R, llamamos a julia con j_eval (la función al inicio de este archivo o en el Rprofile)\n# Ejecutamos dos veces: \n#   la primera compila \"costo de arranque\" (JIT), \n#   la segunda mide el tiempo\n\nt_julia &lt;- j_eval('\nusing Rasters, ArchGDAL, Statistics, Plots\n\n# Evita restricciones artificiales de memoria\nRasters.checkmem!(false)\n\n# ------------------------------------------------\n# 1. Leer ruta compartida\n# ------------------------------------------------\npath = strip(read(\"s2_shared_path.txt\", String))\n\n# ------------------------------------------------\n# 2. FUNCIÓN DE BENCHMARK (proxy + mean)\n# ------------------------------------------------\nfunction process_band_mean(path)\n    ArchGDAL.read(path) do ds\n        r   = Raster(ds)[Band(1)]   # proxy, solo banda 4\n        res = r .* 1.5              # operación lazy\n        return mean(res)            # FORZADO REAL (streaming)\n    end\nend\n\n# ------------------------------------------------\n# 3. WARM-UP (compilación)\n# ------------------------------------------------\nprocess_band_mean(path)\nGC.gc()\n\n# ------------------------------------------------\n# 4. BENCHMARK REAL\n# ------------------------------------------------\nt0 = time_ns()\nm_julia = process_band_mean(path)\nt1 = time_ns()\n\nt_julia = (t1 - t0) / 1e9\n\nprintln(\"🟣 Julia: \", round(t_julia, digits=3), \" seg | mean = \", round(m_julia, digits=6))\n\n\n# ------------------------------------------------\n# 5. Plot (FUERA DEL BENCHMARK, proxy)\n# ------------------------------------------------\nArchGDAL.read(path) do ds\n    r   = Raster(ds)[Band(1)]\n    res = r .* 1.5\n    p = plot(res, colormap = :terrain,\n         title = \"Julia: Banda 4 × 1.5\")\n    savefig(p, \"julia_plot.png\")\nend\n\n# Debe ser la última para que j_eval en R capture solo el número\nt_julia\n')\n\n\nStarting Julia ...\n\n\njulia&gt; using Rasters, ArchGDAL, Statistics, Plots\n\njulia&gt; # Evita restricciones artificiales de memoria\n\njulia&gt; Rasters.checkmem!(false)\nfalse\n\njulia&gt; # ------------------------------------------------\n\njulia&gt; # 1. Leer ruta compartida\n\njulia&gt; # ------------------------------------------------\n\njulia&gt; path = strip(read(\"s2_shared_path.txt\", String))\n\"SENTINEL2_L1C:/vsizip//usr/local/lib/R/site-library/starsdata/sentinel/S2A_MSIL1C_20180220T105051_N0206_R051_T32ULE_20180221T134037.zip/S2A_MSIL1C_20180220T105051_N0206_R051_T32ULE_20180221T134037.SAFE/MTD_MSIL1C.xml:10m:EPSG_32632\"\n\njulia&gt; # ------------------------------------------------\n\njulia&gt; # 2. FUNCIÓN DE BENCHMARK (proxy + mean)\n\njulia&gt; # ------------------------------------------------\n\njulia&gt; function process_band_mean(path)\n    ArchGDAL.read(path) do ds\n        r   = Raster(ds)[Band(1)]   # proxy, solo banda 4\n        res = r .* 1.5              # operación lazy\n        return mean(res)            # FORZADO REAL (streaming)\n    end\nend\nprocess_band_mean (generic function with 1 method)\n\njulia&gt; # ------------------------------------------------\n\njulia&gt; # 3. WARM-UP (compilación)\n\njulia&gt; # ------------------------------------------------\n\njulia&gt; process_band_mean(path)\n3766.6246303263756\n\njulia&gt; GC.gc()\n\njulia&gt; # ------------------------------------------------\n\njulia&gt; # 4. BENCHMARK REAL\n\njulia&gt; # ------------------------------------------------\n\njulia&gt; t0 = time_ns()\n0x00000c52a25e33cd\n\njulia&gt; m_julia = process_band_mean(path)\n3766.6246303263756\n\njulia&gt; t1 = time_ns()\n0x00000c5577962cf8\n\njulia&gt; t_julia = (t1 - t0) / 1e9\n12.167149867\n\njulia&gt; println(\"🟣 Julia: \", round(t_julia, digits=3), \" seg | mean = \", round(m_julia, digits=6))\n🟣 Julia: 12.167 seg | mean = 3766.62463\n\njulia&gt; # ------------------------------------------------\n\njulia&gt; # 5. Plot (FUERA DEL BENCHMARK, proxy)\n\njulia&gt; # ------------------------------------------------\n\njulia&gt; ArchGDAL.read(path) do ds\n    r   = Raster(ds)[Band(1)]\n    res = r .* 1.5\n    p = plot(res, colormap = :terrain,\n         title = \"Julia: Banda 4 × 1.5\")\n    savefig(p, \"julia_plot.png\")\nend\n\"/home/rstudio/work/01_prog_sig/julia_plot.png\"\n\njulia&gt; # Debe ser la última para que j_eval en R capture solo el número\n\njulia&gt; t_julia\n12.167149867\n\n\nCódigo\n# 2. R muestra la imagen guardada por Julia en el HTML\nknitr::include_graphics(\"julia_plot.png\")\n\n\n\n\n\nProcesamiento de alta resolución en Julia\n\n\n\n\nCódigo\n# 3. Impresión desde R\nprint(paste(\"⚡ Tiempo capturado en R:\", t_julia, \" seg.\"))\n\n\n[1] \"⚡ Tiempo capturado en R: 12.167149867  seg.\"\n\n\n\n\n\n\n\nBenchmark en R: Terra vs Stars\n\n🏁 R: terra🌟 R: stars\n\n\nterra está desarrollado sobre C++. Su fortaleza es la velocidad de lectura y el manejo de memoria mediante punteros externos. Paralelismo: Para esta tarea (operación escalar), terra trabaja de forma secuencial (monohilo), confiando en la optimización de sus bucles en C++.\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\n# Código en R\nlibrary(terra)\n# ------------------------------------------------\n# 0. Inicio del cronómetro\n# ------------------------------------------------\nt0 &lt;- Sys.time()\n\n# ------------------------------------------------\n# 1. Abrir raster en modo proxy (NO RAM)\n# ------------------------------------------------\nr &lt;- rast(s2_path)\n\n# ------------------------------------------------\n# 2. Seleccionar solo la banda 4 (sigue siendo proxy)\n# ------------------------------------------------\nb4 &lt;- r[[1]]\n\n# ------------------------------------------------\n# 3. Operación aritmética (lazy)\n# ------------------------------------------------\nres_terra &lt;- b4 * 1.5\n\n# ------------------------------------------------\n# 4. FORZADO REAL (streaming, sin materializar)\n# ------------------------------------------------\nm_terra &lt;- global(res_terra, \"mean\", na.rm = TRUE)[1, 1]\n\n# ------------------------------------------------\n# 5. Tiempo total\n# ------------------------------------------------\nt_terra &lt;- as.numeric(Sys.time() - t0)\n\ncat(\"🟤 Terra:\",\n    round(t_terra, 3), \"seg |\",\n    \"mean =\", round(m_terra, 6), \"\\n\")\n\n# ------------------------------------------------\n# 6. Plot (FUERA DEL BENCHMARK, proxy)\n# ------------------------------------------------\nplot(res_terra, col = terrain.colors(100),\n     main = \"Terra: Banda 4 × 1.5\")\n\n# ------------------------------------------------\n# 7. Limpieza\n# ------------------------------------------------\nrm(r, b4, res_terra)\ngc()\n\n\n\n\n\n\nCódigo\n# library(terra)\n# ------------------------------------------------\n# 0. Inicio del cronómetro\n# ------------------------------------------------\nt0 &lt;- Sys.time()\n\n# ------------------------------------------------\n# 1. Abrir raster en modo proxy (NO RAM)\n# ------------------------------------------------\nr &lt;- rast(s2_path)\n\n# ------------------------------------------------\n# 2. Seleccionar solo la banda 4 (sigue siendo proxy)\n# ------------------------------------------------\nb4 &lt;- r[[1]]\n\n# ------------------------------------------------\n# 3. Operación aritmética (lazy)\n# ------------------------------------------------\nres_terra &lt;- b4 * 1.5\n\n# ------------------------------------------------\n# 4. FORZADO REAL (streaming, sin materializar)\n# ------------------------------------------------\nm_terra &lt;- global(res_terra, \"mean\", na.rm = TRUE)[1, 1]\n\n# ------------------------------------------------\n# 5. Tiempo total\n# ------------------------------------------------\nt_terra &lt;- as.numeric(Sys.time() - t0)\n\ncat(\"🟤 Terra:\",\n    round(t_terra, 3), \"seg |\",\n    \"mean =\", round(m_terra, 6), \"\\n\")\n\n\n🟤 Terra: 5.523 seg | mean = 3766.625 \n\n\nCódigo\n# ------------------------------------------------\n# 6. Plot (FUERA DEL BENCHMARK, proxy)\n# ------------------------------------------------\nplot(res_terra, col = terrain.colors(100),\n     main = \"Terra: Banda 4 × 1.5\")\n\n\n\n\n\n\n\n\n\nCódigo\n# ------------------------------------------------\n# 7. Limpieza\n# ------------------------------------------------\nrm(r, b4, res_terra)\ngc()\n\n\n          used  (Mb) gc trigger  (Mb) max used  (Mb)\nNcells 2611241 139.5    4975398 265.8  4975398 265.8\nVcells 5098098  38.9   10146329  77.5  8324011  63.6\n\n\n\n\nEl paquete stars está especialmente diseñado para trabajar con cubos de datos multidimensionales, como múltiples bandas, series temporales y atributos espaciales complejos. Esta capacidad lo hace muy expresivo y adecuado para análisis espaciales avanzados.\nSin embargo, cuando se utiliza proxy = FALSE, los datos se materializan completamente en la memoria de R. En rasters de gran tamaño, esto puede introducir un mayor costo computacional asociado a:\n\nLectura completa de los datos desde disco.\nCopia de grandes matrices a la memoria de R.\nGestión de metadatos espaciales y dimensionales.\n\nParalelismo: En operaciones aritméticas simples —como una multiplicación escalar seguida de una media global— ni stars ni terra garantizan paralelismo explícito por defecto. En estos casos, el procesamiento suele realizarse de forma: - Secuencial, o\n- Por bloques, dependiendo de la configuración interna del paquete y del backend utilizado (por ejemplo, GDAL).\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\n# Código en R\nlibrary(stars)\n\n# ------------------------------------------------\n# 0. Inicio del cronómetro\n# ------------------------------------------------\nt0 &lt;- Sys.time()\n\n# ------------------------------------------------\n# 1. Leer raster como proxy (NO RAM)\n# ------------------------------------------------\ns &lt;- read_stars(s2_path, proxy = TRUE)\n\n# ------------------------------------------------\n# 2. Seleccionar solo la banda 4 (proxy)\n# ------------------------------------------------\nb4 &lt;- s[,,,1]\n\n# ------------------------------------------------\n# 3. Operación aritmética (lazy)\n# ------------------------------------------------\nres_stars &lt;- b4 * 1.5\n\n# ------------------------------------------------\n# 4. FORZADO REAL (materializa la banda resultante)\n# ------------------------------------------------\nres_mem &lt;- st_as_stars(res_stars)\n\n# ------------------------------------------------\n# 5. Media escalar (ya numérica)\n# ------------------------------------------------\nm_stars &lt;- mean(as.vector(res_mem[[1]]), na.rm = TRUE)\n\n# ------------------------------------------------\n# 6. Tiempo total\n# ------------------------------------------------\nt_stars &lt;- as.numeric(Sys.time() - t0)\n\ncat(\"🌟 Stars:\",\n    round(t_stars, 3), \"seg |\",\n    \"mean =\", round(m_stars, 6), \"\\n\")\n\n# ------------------------------------------------\n# 7. Plot (FUERA DEL BENCHMARK, proxy)\n# ------------------------------------------------\nplot(res_stars, col = terrain.colors(100),\n     main = \"Stars: Banda 4 × 1.5\")\n\n# ------------------------------------------------\n# 8. Limpieza\n# ------------------------------------------------\nrm(s, b4, res_stars)\ngc()\n\n\n\n\n\n\nCódigo\n# library(stars)\n\n# ------------------------------------------------\n# 0. Inicio del cronómetro\n# ------------------------------------------------\nt0 &lt;- Sys.time()\n\n# ------------------------------------------------\n# 1. Leer raster como proxy (NO RAM)\n# ------------------------------------------------\ns &lt;- read_stars(s2_path, proxy = TRUE)\n\n# ------------------------------------------------\n# 2. Seleccionar solo la banda 4 (proxy)\n# ------------------------------------------------\nb4 &lt;- s[,,,1]\n\n# ------------------------------------------------\n# 3. Operación aritmética (lazy)\n# ------------------------------------------------\nres_stars &lt;- b4 * 1.5\n\n# ------------------------------------------------\n# 4. FORZADO REAL (materializa la banda resultante)\n# ------------------------------------------------\nres_mem &lt;- st_as_stars(res_stars)\n\n# ------------------------------------------------\n# 5. Media escalar (ya numérica)\n# ------------------------------------------------\nm_stars &lt;- mean(as.vector(res_mem[[1]]), na.rm = TRUE)\n\n# ------------------------------------------------\n# 6. Tiempo total\n# ------------------------------------------------\nt_stars &lt;- as.numeric(Sys.time() - t0)\n\ncat(\"🌟 Stars:\",\n    round(t_stars, 3), \"seg |\",\n    \"mean =\", round(m_stars, 6), \"\\n\")\n\n\n🌟 Stars: 9.227 seg | mean = 3766.625 \n\n\nCódigo\n# ------------------------------------------------\n# 7. Plot (FUERA DEL BENCHMARK, proxy)\n# ------------------------------------------------\nplot(res_stars, col = terrain.colors(100),\n     main = \"Stars: Banda 4 × 1.5\")\n\n\ndownsample set to 8\n\n\n\n\n\n\n\n\n\nCódigo\n# ------------------------------------------------\n# 8. Limpieza\n# ------------------------------------------------\nrm(s, b4, res_stars)\ngc()\n\n\n            used  (Mb) gc trigger   (Mb)  max used   (Mb)\nNcells   2662787 142.3    4975398  265.8   4975398  265.8\nVcells 127749787 974.7  562388515 4290.7 702623134 5360.6",
    "crumbs": [
      "Prácticas",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Evaluación Comparativa de Procesamiento Geoespacial</span>"
    ]
  },
  {
    "objectID": "41-practica_1_benchmark_raster.html#resultados-finales",
    "href": "41-practica_1_benchmark_raster.html#resultados-finales",
    "title": "8  Evaluación Comparativa de Procesamiento Geoespacial",
    "section": "8.6 Resultados finales",
    "text": "8.6 Resultados finales\nA continuación, se presenta la comparativa de rendimiento para procesar la Banda 4 (Red) de 10m desde el archivo comprimido original.\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\n# Código en R\nlibrary(knitr)\nlibrary(kableExtra)\n\n# Creamos el dataframe con los datos capturados\nresultados &lt;- data.frame(\n  Motor = c(\"R: terra\", \"R: stars\", \"Python: rasterio\", \"Julia: Rasters.jl\"),\n  Lenguaje = c(\"R (C++)\", \"R\", \"Python (C++/NumPy)\", \"Julia (Nativo)\"),\n  Paralelismo = c(\"Monohilo\", \"Monohilo\", \"SIMD (Vectorizado)\", \"Multihilo (12 hilos)\"),\n  Tiempo_Seg = c(t_terra, t_stars, t_python, t_julia)\n)\nresultados\n# Cálculo de eficiencia: ¿Cuántas veces es más rápido que el más lento?\nmax_t &lt;- max(resultados$Tiempo_Seg, na.rm = TRUE)\nresultados$X_mas_rapido &lt;- round(max_t / resultados$Tiempo_Seg, 2)\n\n# Formateo elegante para el HTML\nkable(resultados, \n      digits = 3, \n      caption = \"Duelo de Titanes: Procesamiento de 1GB Sentinel-2\",\n      col.names = c(\"Motor\", \"Lenguaje\", \"Paralelismo\", \"Tiempo (s)\", \"Eficiencia (X)\")) %&gt;%\n  kable_styling(bootstrap_options = c(\"striped\", \"hover\", \"condensed\"), \n                full_width = F) %&gt;%\n  row_spec(which.min(resultados$Tiempo_Seg), bold = T, color = \"white\", background = \"#2c3e50\")\n\n\n\n\n\n\n              Motor           Lenguaje          Paralelismo Tiempo_Seg\n1          R: terra            R (C++)             Monohilo   5.523022\n2          R: stars                  R             Monohilo   9.227233\n3  Python: rasterio Python (C++/NumPy)   SIMD (Vectorizado)   2.896271\n4 Julia: Rasters.jl     Julia (Nativo) Multihilo (12 hilos)  12.167150\n\n\n\n\nDuelo de Titanes: Procesamiento de 1GB Sentinel-2\n\n\nMotor\nLenguaje\nParalelismo\nTiempo (s)\nEficiencia (X)\n\n\n\n\nR: terra\nR (C++)\nMonohilo\n5.523\n2.20\n\n\nR: stars\nR\nMonohilo\n9.227\n1.32\n\n\nPython: rasterio\nPython (C++/NumPy)\nSIMD (Vectorizado)\n2.896\n4.20\n\n\nJulia: Rasters.jl\nJulia (Nativo)\nMultihilo (12 hilos)\n12.167\n1.00\n\n\n\n\n\n\n\n\nLos tiempos no deben compararse fuera del contexto de este patrón de acceso (lectura secuencial + reducción global).\n\nEl benchmark favorece motores optimizados para recorridos contiguos de memoria y reducciones monolíticas, en particular NumPy (vía rasterio en Python) y el motor C++ interno de terra en R, los cuales pueden ejecutar la operación aritmética y el cálculo estadístico en una única pasada sobre un bloque contiguo de datos en memoria.\n\nEn contraste, motores basados en evaluaciones diferidas (lazy evaluation) y procesamiento por bloques con mayor carga de metadatos, como stars en R y Rasters.jl en Julia, incurren en mayor overhead de abstracción y llamadas intermedias, lo que afecta su desempeño relativo en este escenario específico.\n\nEficiencia de Memoria: terra es el ganador aquí, ya que su gestión de objetos fuera de la RAM de R le permite manejar archivos gigantes sin colapsar.\nParalelismo Real: Solo Julia aprovecha los hilos de ejecución de la CPU para la operación matemática de forma nativa. Python usa optimización de hardware (SIMD) vía NumPy, mientras que R se mantiene secuencial pero optimizado en sus librerías de C++.\nGDAL VSI: Todos los lenguajes demostraron que el driver /vsizip/ es la forma más eficiente de interactuar con datos Sentinel-2 sin el costo de descompresión.\n\n\nJulia: paralelismo y pipelines composables\nEl potencial de paralelismo multihilo no siempre se traduce en mejores tiempos en benchmarks simples como el presente. Esto se debe a que Julia, a través de Rasters.jl, utiliza un modelo basado en pipelines composables.\nUn pipeline composable significa que las operaciones no se ejecutan inmediatamente. En su lugar, Julia construye un flujo de operaciones (lectura → selección de banda → operación aritmética → reducción) que se evalúa solo cuando se solicita un resultado final, como la media global.\nEste enfoque tiene ventajas claras en análisis complejos y encadenados, pero introduce un costo adicional de planificación y abstracción que se vuelve visible en tareas muy simples y masivas, como una única multiplicación seguida de una reducción global.\nEn otras palabras, Julia está optimizada para flujos de trabajo complejos, no para reducciones monolíticas de una sola pasada al estilo NumPy.\n\n\n\n\n\n\n\n\nHerramienta / librería\n¿Pipeline composable?\nEjemplo típico\n\n\n\n\nJulia (Rasters.jl)\n✅ Sí\nmean(r .* 1.5) → se evalúa al final\n\n\nR (dplyr + dbplyr)\n✅ Sí*\nCadena de transformaciones luego collect()\n\n\nPython (xarray + Dask)\n✅ Sí\nresult = data.mean() luego compute()\n\n\nApache Spark\n✅ Sí\nPlan de ejecución (DAG) antes de correr\n\n\nPython (rasterio + NumPy)\n❌ No\nLee y calcula todo inmediatamente\n\n\nR (terra)\n⚠️ Parcial\nOptimiza en C++ pero no expone pipeline diferido\n\n\nR (stars)\n❌ No\nproxy limitado, sin DAG composable completo\n\n\n\n* Nota sobre R (dplyr + dbplyr):\nNo es una solución espacial por sí misma. El pipeline composable existe, pero requiere un backend espacial (por ejemplo: PostGIS, DuckDB + spatial, Spark, BigQuery GIS). Sin ese backend, no aplica directamente a raster/cubos geoespaciales.\nNota sobre stars:\nAunque puede trabajar con proxy = TRUE, stars no implementa un pipeline composable tipo tidyverse, ni un DAG diferido completo. Las operaciones tienden a materializar datos relativamente pronto y no se integran con dplyr/dbplyr para optimización global del flujo.",
    "crumbs": [
      "Prácticas",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Evaluación Comparativa de Procesamiento Geoespacial</span>"
    ]
  },
  {
    "objectID": "41-practica_1_benchmark_raster.html#más-allá-del-benchmarking-optimización-y-virtualización-de-datos-geoespaciales",
    "href": "41-practica_1_benchmark_raster.html#más-allá-del-benchmarking-optimización-y-virtualización-de-datos-geoespaciales",
    "title": "8  Evaluación Comparativa de Procesamiento Geoespacial",
    "section": "8.7 Más allá del benchmarking: optimización y virtualización de datos geoespaciales",
    "text": "8.7 Más allá del benchmarking: optimización y virtualización de datos geoespaciales\nEste benchmark evalúa un caso simple y controlado, pero los proyectos reales con grandes volúmenes de datos geoespaciales rara vez dependen de un solo archivo raster leído de forma local. Hoy en día existen múltiples estrategias para optimizar el rendimiento, muchas de las cuales se basan en virtualización del acceso a datos y formatos eficientes.\nAlgunas de las principales alternativas que deben considerarse en proyectos de gran escala son:\n\nFormatos optimizados para alto volumen\n\nCloud Optimized GeoTIFF (COG)\nPermite leer solo las partes necesarias del raster mediante acceso por bloques y overviews, sin descargar el archivo completo.\nZarr / GeoZarr\nFormato orientado a datos multidimensionales y computación distribuida. Muy eficiente para acceso parcial, paralelismo y almacenamiento en la nube.\nGeoParquet\nFormato columnar optimizado para datos vectoriales masivos. Ideal para análisis a gran escala, consultas selectivas y procesamiento distribuido.\n\n\n\nVirtualización y acceso remoto\n\nGDAL VFS (/vsicurl/, /vsis3/, /vsiaz/)\nPermite trabajar con datos remotos como si fueran archivos locales, leyendo solo los bloques necesarios.\nSTAC (SpatioTemporal Asset Catalog)\nFacilita la búsqueda y acceso estructurado a grandes catálogos de datos espaciales distribuidos.\n\n\n\nParalelismo y ejecución distribuida\n\nProcesamiento por bloques y multihilo (GDAL, terra, rasterio)\nFrameworks distribuidos como Dask, Spark o Ray, especialmente combinados con Zarr o Parquet.\nAceleración en la nube mediante almacenamiento objeto y cómputo escalable.\n\n\n\nMensaje clave\nEste ejercicio muestra los costos mínimos inevitables de leer, abstraer y reducir datos raster. Sin embargo, la verdadera optimización en proyectos reales no suele venir de cambiar de lenguaje, sino de:\n\nElegir formatos de datos adecuados.\nMinimizar movimientos innecesarios de datos.\nAprovechar acceso parcial, paralelismo y virtualización.\nDiseñar flujos de trabajo pensados desde el inicio para grandes volúmenes.\n\nEn resumen:\n&gt; Cuando los datos crecen, la arquitectura y el formato importan tanto o más que el lenguaje.",
    "crumbs": [
      "Prácticas",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Evaluación Comparativa de Procesamiento Geoespacial</span>"
    ]
  },
  {
    "objectID": "41-practica_1_benchmark_raster.html#desafío-de-laboratorio-primer-día",
    "href": "41-practica_1_benchmark_raster.html#desafío-de-laboratorio-primer-día",
    "title": "8  Evaluación Comparativa de Procesamiento Geoespacial",
    "section": "8.8 🏁 Desafío de laboratorio: primer día",
    "text": "8.8 🏁 Desafío de laboratorio: primer día\nPara cerrar esta sesión del “Duelo de Titanes”, deberán resolver el siguiente desafío práctico.\nPueden apoyarse en herramientas de IA para investigar, pero recuerden:\n\nBuscamos precisión y evidencia, no “carreta”.\n\nEste laboratorio incluye ejecución real de código en distintos entornos.\n\n\n🛠️ Instrucciones de entrega\n\nCreen un nuevo repositorio en su GitHub personal llamado taller1-sig.\nTodas las respuestas escritas deben estar en un archivo respuestas.qmd.\nRendericen respuestas.qmd a HTML y PDF.\nSuban al repositorio:\n\nrespuestas.qmd\nrespuestas.html\nrespuestas.pdf\nLos notebooks y scripts solicitados (ver abajo).\n\n\n\n\n\n⚙️ Parte A — Ejecución en JupyterLab (notebooks)\nEjecuten los cuatro procesos del benchmark desde JupyterLab, usando el kernel adecuado para cada lenguaje.\n\n📒 Notebooks obligatorios\nCreen los siguientes notebooks:\n\n01_benchmark_terra.ipynb\n\n02_benchmark_stars.ipynb\n\n03_benchmark_rasterio.ipynb\n\n04_benchmark_rasters_julia.ipynb\n\nCada notebook debe:\n\nLeer el raster\nAplicar la operación matemática (× 1.5)\nCalcular la media global\nImprimir el tiempo total de ejecución\n\n📌 Entrega: - Suban los cuatro notebooks al repositorio. - En respuestas.qmd, incluyan: - El tiempo reportado por cada motor - Una breve observación (1–2 líneas) por notebook\n\n\n\n\n🖥️ Parte B — Ejecución desde VSCode (terminal integrada)\nAhora repitan el benchmark fuera de Jupyter, usando la terminal integrada de VSCode.\n\n📄 Scripts obligatorios\nCreen los siguientes archivos:\n\nbenchmark_terra.R\nbenchmark_stars.R\nbenchmark_rasterio.py\nbenchmark_rasters.jl\n\nCada script debe:\n\nLeer el raster\nEjecutar la operación\nCalcular la media global\nImprimir:\n\nEl tiempo total\nEl valor de la media\n\n\n\n\n▶️ Ejecución esperada\nDesde la terminal de VSCode:\nRscript benchmark_terra.R\nRscript benchmark_stars.R\npython3 benchmark_rasterio.py\njulia benchmark_rasters.jl\n📌 Entrega: - Suban los cuatro scripts al repositorio. - Reporten los tiempos obtenidos en respuestas.qmd.\n\n\n\n\n🪟 Parte C — Ejecución desde el Termina de Windows (PowerShell)\nFinalmente, ejecuten los procesos sin usar VSCode ni Jupyter, directamente desde Windows Terminal (PowerShell), trabajando con Docker.\nPueden usar una o ambas opciones.\n\n\nOpción 1️⃣ — Entrando al intérprete\nEjemplos:\ndocker exec -it contenedor_sig_unal R\ndocker exec -it contenedor_sig_unal python3\ndocker exec -it contenedor_sig_unal julia\nY luego ejecutar el script correspondiente dentro del intérprete.\n\n\n\nOpción 2️⃣ — Ejecución directa\nEjemplos:\ndocker exec contenedor_sig_unal Rscript benchmark_terra.R\ndocker exec contenedor_sig_unal Rscript benchmark_stars.R\ndocker exec contenedor_sig_unal python3 benchmark_rasterio.py\ndocker exec contenedor_sig_unal julia benchmark_rasters.jl\n📌 Entrega: - Indiquen en respuestas.qmd: - Qué opción usaron - Los tiempos obtenidos - Si notaron diferencias frente a JupyterLab o VSCode\n\n\n\n\n❓ Preguntas de análisis\n\n1. 📍 Entorno de ejecución\n¿Notaron diferencias de tiempo entre:\n\nJupyterLab\n\nVSCode (terminal integrada)\n\nWindows Terminal (PowerShell)\n\nDen una razón técnica posible (overhead del kernel, entorno, proceso, etc.).\n\n\n\n2. 🧱 Abstracción en la práctica\n¿En qué motor creen que el costo de las abstracciones es más visible?\nRelacionen su respuesta con los tiempos observados.\n\n\n3. 🔥 Julia y el costo de compilación (Warm-up)\n¿El efecto del warm-up de Julia se notó más en algún entorno específico?\nExpliquen brevemente por qué.\n\n\n\n4. 🧠 Elección informada\nDespués de ejecutar el benchmark en tres entornos distintos,\n¿cambiarían su elección del “Titán” para una emergencia ambiental real?\nJustifiquen en máximo 5 líneas.\n\n\n💡 Nota para el éxito\nEste laboratorio no busca que memoricen comandos,\nsino que entiendan que el rendimiento depende del stack completo: lenguaje, librerías, entorno y forma de ejecución.",
    "crumbs": [
      "Prácticas",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Evaluación Comparativa de Procesamiento Geoespacial</span>"
    ]
  },
  {
    "objectID": "41-practica_1_benchmark_raster.html#limpieza-de-recursos",
    "href": "41-practica_1_benchmark_raster.html#limpieza-de-recursos",
    "title": "8  Evaluación Comparativa de Procesamiento Geoespacial",
    "section": "8.9 Limpieza de recursos",
    "text": "8.9 Limpieza de recursos\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\n# Código en R\n# Eliminar variables\n#rm(res_terra, res_stars, r, s)\n\n# Liberar memoria RAM\ngc()\n\n# Borrar archivo con la ruta\nif(file.exists(\"s2_shared_path.txt\")) file.remove(\"s2_shared_path.txt\")",
    "crumbs": [
      "Prácticas",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Evaluación Comparativa de Procesamiento Geoespacial</span>"
    ]
  },
  {
    "objectID": "61-presentacion_1_clase1.html",
    "href": "61-presentacion_1_clase1.html",
    "title": "9  Temas por Charlar",
    "section": "",
    "text": "9.1 Clase 1: Instalación y uso básico del software",
    "crumbs": [
      "Presentaciones",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Temas por Charlar</span>"
    ]
  },
  {
    "objectID": "61-presentacion_1_clase1.html#clase-1-instalación-y-uso-básico-del-software",
    "href": "61-presentacion_1_clase1.html#clase-1-instalación-y-uso-básico-del-software",
    "title": "9  Temas por Charlar",
    "section": "",
    "text": "Docker Desktop\n\n\nInstalar nuestros contenedores\n\n\nVSCode + Extensiones (dentro del nuestros contenerores)\n\n\nGit + GitHub\n\n\nAcceso a Jupyter Lab\n\n\nCreación de archivos Quarto (*.qmd): HTML & PDF\n\n\nOSGeo4W (QGIS) - QGIS + GEE (Pixi)\n\n\nChequeo ArcGIS Pro",
    "crumbs": [
      "Presentaciones",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Temas por Charlar</span>"
    ]
  },
  {
    "objectID": "61-presentacion_1_clase1.html#syllabus-anterior---contenido",
    "href": "61-presentacion_1_clase1.html#syllabus-anterior---contenido",
    "title": "9  Temas por Charlar",
    "section": "9.2 Syllabus anterior - Contenido",
    "text": "9.2 Syllabus anterior - Contenido\n\n\nPrincipios de Programación.\n\n\nFundamentos de Python.\n\n\nMarcos de Datos.\n\n\nProgramación Orientada a Objetos.\n\n\nPython y PostgreSQL.\n\n\nLibrerías Geoespaciales.\n\n\nArcGIS.\n\n\n👉 Necesitamos modificarlo.",
    "crumbs": [
      "Presentaciones",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Temas por Charlar</span>"
    ]
  },
  {
    "objectID": "61-presentacion_1_clase1.html#syllabus-anterior---estructura",
    "href": "61-presentacion_1_clase1.html#syllabus-anterior---estructura",
    "title": "9  Temas por Charlar",
    "section": "9.3 Syllabus anterior - Estructura",
    "text": "9.3 Syllabus anterior - Estructura\n\n\nExposiciones del Profesor.\n\n\nTeoría.\nPráctica.\n\n\nTrabajos en Grupo.\n\n\nExposiciones de los Estudiantes.\n\n\nLecturas.\n\n\nPrácticas.\n\n\nTrabajo Final.\n\n\n👉 Necesitamos concretarlo y asignar porcentajes.",
    "crumbs": [
      "Presentaciones",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Temas por Charlar</span>"
    ]
  },
  {
    "objectID": "61-presentacion_1_clase1.html#propuestas-de-estudiantes-para-el-curso",
    "href": "61-presentacion_1_clase1.html#propuestas-de-estudiantes-para-el-curso",
    "title": "9  Temas por Charlar",
    "section": "9.4 Propuestas de Estudiantes para el Curso",
    "text": "9.4 Propuestas de Estudiantes para el Curso\n🎯 Tienes la palabra.",
    "crumbs": [
      "Presentaciones",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Temas por Charlar</span>"
    ]
  },
  {
    "objectID": "61-presentacion_1_clase1.html#curso-enfoque-open-science",
    "href": "61-presentacion_1_clase1.html#curso-enfoque-open-science",
    "title": "9  Temas por Charlar",
    "section": "9.5 Curso: Enfoque Open Science",
    "text": "9.5 Curso: Enfoque Open Science\n\nMaterial presentado por profesor\n\nDiapositivas\nCódigo\nTeoría\nArchivos de configuración\n\nMaterial de los estudiantes\nHTML, PDF\nGitHub",
    "crumbs": [
      "Presentaciones",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Temas por Charlar</span>"
    ]
  },
  {
    "objectID": "61-presentacion_1_clase1.html#seminario-latingeo",
    "href": "61-presentacion_1_clase1.html#seminario-latingeo",
    "title": "9  Temas por Charlar",
    "section": "9.6 Seminario LatinGeo",
    "text": "9.6 Seminario LatinGeo\n\nOrganizado por GeoCorp y UNAL.\nPresentar trabajos finales.\nPresentar temas específicos.\nAbierto al público (en línea).\nFormato Open Science.\nPuede contribuir a la nota final.\nPodemos traer invitados.\n\n🎯 LatinGeo: Python, R y Julia",
    "crumbs": [
      "Presentaciones",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Temas por Charlar</span>"
    ]
  },
  {
    "objectID": "61-presentacion_1_clase1.html#temas-para-proyecto-final",
    "href": "61-presentacion_1_clase1.html#temas-para-proyecto-final",
    "title": "9  Temas por Charlar",
    "section": "9.7 Temas para Proyecto Final",
    "text": "9.7 Temas para Proyecto Final\n\n\nGeocomputación en la Nube.\n\n\nVirtualización.\n\n\nLibrerías Geo: Pipelines Composables.\n\n\nCreación de Paquetes (R, Python, Julia).\n\n\nCreación de Extensiones.\n\n\nGitHub Actions.\n\n\nDuckDB\n\n\nGEE - GEEMAP\n\n\nTemas aplicados\n\n\n…",
    "crumbs": [
      "Presentaciones",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Temas por Charlar</span>"
    ]
  },
  {
    "objectID": "62-presentacion_2_benchmark.html",
    "href": "62-presentacion_2_benchmark.html",
    "title": "10  Benchmark geoespacial: cómo leer los resultados",
    "section": "",
    "text": "10.1 ¿Qué estamos comparando?\nEste ejercicio no compara lenguajes de programación.\nEvalúa el rendimiento del stack completo:\n👉 El lenguaje es solo una parte del sistema.",
    "crumbs": [
      "Presentaciones",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Benchmark geoespacial: cómo leer los resultados</span>"
    ]
  },
  {
    "objectID": "62-presentacion_2_benchmark.html#qué-estamos-comparando",
    "href": "62-presentacion_2_benchmark.html#qué-estamos-comparando",
    "title": "10  Benchmark geoespacial: cómo leer los resultados",
    "section": "",
    "text": "GDAL (Geospatial Data Abstraction Library): raster (GDAL) + vector (OGR: OpenGIS Simple Features Reference Implementation)\nLibrerías raster\nModelo de ejecución\nNivel de abstracción",
    "crumbs": [
      "Presentaciones",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Benchmark geoespacial: cómo leer los resultados</span>"
    ]
  },
  {
    "objectID": "62-presentacion_2_benchmark.html#qué-hace-exactamente-el-benchmark",
    "href": "62-presentacion_2_benchmark.html#qué-hace-exactamente-el-benchmark",
    "title": "10  Benchmark geoespacial: cómo leer los resultados",
    "section": "10.2 ¿Qué hace exactamente el benchmark?",
    "text": "10.2 ¿Qué hace exactamente el benchmark?\nEl benchmark ejecuta un caso extremo y muy simplificado:\n\nUsa una sola banda raster\nAplica una operación matemática simple (× 1.5)\nCalcula una media global\n\n🎯 Diseñado para forzar la lectura completa de los datos.",
    "crumbs": [
      "Presentaciones",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Benchmark geoespacial: cómo leer los resultados</span>"
    ]
  },
  {
    "objectID": "62-presentacion_2_benchmark.html#qué-no-evalúa",
    "href": "62-presentacion_2_benchmark.html#qué-no-evalúa",
    "title": "10  Benchmark geoespacial: cómo leer los resultados",
    "section": "10.3 ¿Qué NO evalúa?",
    "text": "10.3 ¿Qué NO evalúa?\nEste benchmark no evalúa:\n\nAnálisis multibanda\nOperaciones espaciales complejas\nVecindarios, máscaras o reproyecciones\nFlujos iterativos o modelos estadísticos\n\n🚫 No representa un flujo SIG real completo.",
    "crumbs": [
      "Presentaciones",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Benchmark geoespacial: cómo leer los resultados</span>"
    ]
  },
  {
    "objectID": "62-presentacion_2_benchmark.html#por-qué-usamos-mean",
    "href": "62-presentacion_2_benchmark.html#por-qué-usamos-mean",
    "title": "10  Benchmark geoespacial: cómo leer los resultados",
    "section": "10.4 ¿Por qué usamos mean()?",
    "text": "10.4 ¿Por qué usamos mean()?\nEl cálculo de la media es clave porque:\n\nObliga a recorrer todos los píxeles\nGarantiza que la operación aritmética fue ejecutada\nFuerza la evaluación completa del raster\n\n⚠️ Cada motor implementa este paso de forma distinta.",
    "crumbs": [
      "Presentaciones",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Benchmark geoespacial: cómo leer los resultados</span>"
    ]
  },
  {
    "objectID": "62-presentacion_2_benchmark.html#modelos-de-ejecución-comparados",
    "href": "62-presentacion_2_benchmark.html#modelos-de-ejecución-comparados",
    "title": "10  Benchmark geoespacial: cómo leer los resultados",
    "section": "10.5 Modelos de ejecución comparados",
    "text": "10.5 Modelos de ejecución comparados\nCada stack sigue una filosofía diferente:\n\nPython / rasterio + NumPy\nLectura completa a memoria + ejecución inmediata\nR / terra\nÁlgebra de ráster optimizado en C++ y procesamiento por bloques, pero sin exponer un pipeline diferido composable\nR / stars\nManejo de cubos de datos multidimensionales y metadatos ricos; el modo proxy difiere la lectura, pero no construye un DAG composable completo\nJulia / Rasters.jl\nFlujos lazy y pipelines composables, evaluados al final como un plan coherente",
    "crumbs": [
      "Presentaciones",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Benchmark geoespacial: cómo leer los resultados</span>"
    ]
  },
  {
    "objectID": "62-presentacion_2_benchmark.html#qué-favorece-este-benchmark",
    "href": "62-presentacion_2_benchmark.html#qué-favorece-este-benchmark",
    "title": "10  Benchmark geoespacial: cómo leer los resultados",
    "section": "10.6 ¿Qué favorece este benchmark?",
    "text": "10.6 ¿Qué favorece este benchmark?\nEste escenario favorece motores optimizados para:\n\nRecorridos contiguos de memoria\nOperaciones simples en una sola pasada\nReducciones globales monolíticas\n\n👉 No todos los motores están diseñados para este patrón.",
    "crumbs": [
      "Presentaciones",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Benchmark geoespacial: cómo leer los resultados</span>"
    ]
  },
  {
    "objectID": "62-presentacion_2_benchmark.html#abstracción-vs-rendimiento",
    "href": "62-presentacion_2_benchmark.html#abstracción-vs-rendimiento",
    "title": "10  Benchmark geoespacial: cómo leer los resultados",
    "section": "10.7 Abstracción vs rendimiento",
    "text": "10.7 Abstracción vs rendimiento\nMás abstracción implica:\n\nMás metadatos\nMás coordinación interna\nMás costo administrativo\n\nPero también ofrece:\n\nCódigo más claro\nMenos errores\nMayor expresividad analítica\n\n⚖️ Es un intercambio inevitable.",
    "crumbs": [
      "Presentaciones",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Benchmark geoespacial: cómo leer los resultados</span>"
    ]
  },
  {
    "objectID": "62-presentacion_2_benchmark.html#niveles-de-abstracción-por-motor",
    "href": "62-presentacion_2_benchmark.html#niveles-de-abstracción-por-motor",
    "title": "10  Benchmark geoespacial: cómo leer los resultados",
    "section": "10.8 Niveles de abstracción por motor",
    "text": "10.8 Niveles de abstracción por motor\n\n\n\n\n\n\n\n\nMotor\nNivel de abstracción\nForma de trabajar\n\n\n\n\nNumPy / rasterio\nBaja\n“Aquí tienes un arreglo, calcula ahora”\n\n\nterra (R)\nMedia\n“Yo optimizo internamente en C++”\n\n\nstars (R)\nAlta\n“Gestiono dimensiones, tiempo y metadatos”\n\n\nRasters.jl (Julia)\nFlexible\n“Defino un pipeline que se evalúa al final”\n\n\n\n📌 Más abstracción = más expresividad, pero más costo administrativo.",
    "crumbs": [
      "Presentaciones",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Benchmark geoespacial: cómo leer los resultados</span>"
    ]
  },
  {
    "objectID": "62-presentacion_2_benchmark.html#paralelismo-y-pipelines-composables",
    "href": "62-presentacion_2_benchmark.html#paralelismo-y-pipelines-composables",
    "title": "10  Benchmark geoespacial: cómo leer los resultados",
    "section": "10.9 Paralelismo y pipelines composables",
    "text": "10.9 Paralelismo y pipelines composables\nSolo algunos stacks permiten componer operaciones y ejecutarlas al final:\n\nJulia (Rasters.jl)\nPipelines composables + paralelismo multihilo nativo,\nsin librerías externas adicionales\nPython (xarray + Dask)\nPipelines lazy con ejecución distribuida explícita\nR (dplyr + dbplyr)\nLenguaje de pipelines, no espacial por sí mismo;\nrequiere backends como PostGIS, DuckDB o Spark\n\n📌 Optimización interna no equivale a pipeline composable.",
    "crumbs": [
      "Presentaciones",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Benchmark geoespacial: cómo leer los resultados</span>"
    ]
  },
  {
    "objectID": "62-presentacion_2_benchmark.html#no-hay-un-ganador-universal",
    "href": "62-presentacion_2_benchmark.html#no-hay-un-ganador-universal",
    "title": "10  Benchmark geoespacial: cómo leer los resultados",
    "section": "10.10 No hay un ganador universal",
    "text": "10.10 No hay un ganador universal\nEste benchmark mide:\n\nRendimiento bajo un patrón específico de acceso y reducción global\n\nNo mide:\n\nCalidad general del lenguaje\nFlexibilidad analítica\nEscalabilidad en flujos SIG complejos\n\n📍 Los resultados deben interpretarse con contexto.",
    "crumbs": [
      "Presentaciones",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Benchmark geoespacial: cómo leer los resultados</span>"
    ]
  },
  {
    "objectID": "62-presentacion_2_benchmark.html#escalando-a-datos-realmente-grandes",
    "href": "62-presentacion_2_benchmark.html#escalando-a-datos-realmente-grandes",
    "title": "10  Benchmark geoespacial: cómo leer los resultados",
    "section": "10.11 Escalando a datos realmente grandes",
    "text": "10.11 Escalando a datos realmente grandes\nEn proyectos reales con grandes volúmenes de datos se consideran:\n\nCloud Optimized GeoTIFF (COG)\nZarr\nGeoParquet\nProcesamiento por bloques\nInfraestructura virtualizada - cloud / HPC - High-Performance Computing (AWS - GCP - Azure)\n\n👉 La arquitectura de datos suele importar más que el lenguaje.",
    "crumbs": [
      "Presentaciones",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Benchmark geoespacial: cómo leer los resultados</span>"
    ]
  },
  {
    "objectID": "62-presentacion_2_benchmark.html#mensaje-final-del-benchmark",
    "href": "62-presentacion_2_benchmark.html#mensaje-final-del-benchmark",
    "title": "10  Benchmark geoespacial: cómo leer los resultados",
    "section": "10.12 Mensaje final del Benchmark",
    "text": "10.12 Mensaje final del Benchmark\nEste ejercicio sirve para:\n\nEntender costos reales de lectura y abstracción\nLeer benchmarks de forma crítica\nElegir herramientas según el problema\n\n🎯 No existe el “lenguaje más rápido”\nexiste el stack adecuado para cada tarea.",
    "crumbs": [
      "Presentaciones",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Benchmark geoespacial: cómo leer los resultados</span>"
    ]
  },
  {
    "objectID": "62-presentacion_2_benchmark.html#qué-es-lo-importante-hoy-y-qué-no",
    "href": "62-presentacion_2_benchmark.html#qué-es-lo-importante-hoy-y-qué-no",
    "title": "10  Benchmark geoespacial: cómo leer los resultados",
    "section": "10.13 ¿Qué es lo importante hoy (y qué no)?",
    "text": "10.13 ¿Qué es lo importante hoy (y qué no)?\nEn este punto del curso:\n❌ No es importante entender cada línea de código\n❌ No es importante memorizar sintaxis\n❌ No es importante “ser rápido programando”\n✅ Sí es importante:\n\nVer el panorama completo de la programación SIG actual\n\nEntender que existen múltiples stacks y enfoques\nReconocer que el rendimiento depende de arquitectura, no solo del lenguaje\n\n👉 El código lo aprenderemos paso a paso.",
    "crumbs": [
      "Presentaciones",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Benchmark geoespacial: cómo leer los resultados</span>"
    ]
  },
  {
    "objectID": "62-presentacion_2_benchmark.html#qué-estamos-aprendiendo-realmente",
    "href": "62-presentacion_2_benchmark.html#qué-estamos-aprendiendo-realmente",
    "title": "10  Benchmark geoespacial: cómo leer los resultados",
    "section": "10.14 ¿Qué estamos aprendiendo realmente?",
    "text": "10.14 ¿Qué estamos aprendiendo realmente?\nMás allá del benchmark, este laboratorio busca que ustedes aprendan a:\n\nUsar GitHub como bitácora de trabajo\nDocumentar con Quarto\nEjecutar análisis en Jupyter Lab\nTrabajar en VSCode\nUsar la terminal (Windows / Linux)\nEjecutar entornos reproducibles con Docker\nCorrer el mismo proceso de muchas formas distintas\n\n🎯 Programar SIG hoy es saber orquestar herramientas, no solo escribir código.",
    "crumbs": [
      "Presentaciones",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Benchmark geoespacial: cómo leer los resultados</span>"
    ]
  },
  {
    "objectID": "62-presentacion_2_benchmark.html#el-límite-lo-ponen-ustedes",
    "href": "62-presentacion_2_benchmark.html#el-límite-lo-ponen-ustedes",
    "title": "10  Benchmark geoespacial: cómo leer los resultados",
    "section": "10.15 El límite lo ponen ustedes",
    "text": "10.15 El límite lo ponen ustedes\nEn clase aprenderemos:\n\nLos conceptos fundamentales\nLas herramientas base\nLos patrones comunes de trabajo\n\nPero el verdadero aprendizaje vendrá de:\n\nSus proyectos\nSu trabajo individual\nLo que decidan explorar más allá del aula\n\n🚀 En programación SIG,\nel límite no lo pone el lenguaje, lo pone la curiosidad y el problema que quieran resolver.",
    "crumbs": [
      "Presentaciones",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Benchmark geoespacial: cómo leer los resultados</span>"
    ]
  },
  {
    "objectID": "81-infraestructura_instalada.html",
    "href": "81-infraestructura_instalada.html",
    "title": "Apéndice A — Infraestructura Instalada",
    "section": "",
    "text": "A.1 Configuración inicial del entorno (Pre-flight)\nPara automatizar el soporte de gráficos y capturas sin configurar cada archivo individualmente, ejecute estos comandos en la terminal del contenedor contenedor_sig_unal inmediatamente después de iniciar los servicios con docker compose up -d:",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Infraestructura Instalada</span>"
    ]
  },
  {
    "objectID": "81-infraestructura_instalada.html#sec-preflight",
    "href": "81-infraestructura_instalada.html#sec-preflight",
    "title": "Apéndice A — Infraestructura Instalada",
    "section": "",
    "text": "Tabla A.1: Comandos de configuración global del contenedor\n\n\n\n\n\n\n\n\n\n\nCategoría\nComando de Configuración\nPropósito\n\n\n\n\nSoporte Base\napt-get update && apt-get install -y fonts-symbola wget\nFuentes para emojis y herramienta de descarga de paquetes externos.\n\n\nNavegador\nwget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb && apt install -y ./google-chrome-stable_current_amd64.deb\nInstala Google Chrome (Bypass de Snap). Obligatorio para capturas de mapas en Docker.\n\n\nAutomatización R\necho 'Sys.setenv(CHROMOTE_CHROME = \"/usr/bin/google-chrome\")' &gt;&gt; /usr/local/lib/R/etc/Rprofile.site\nConfigura la ruta de Chrome para todo el sistema R de forma persistente. (si falla usa /etc/R/Rprofile.site)\n\n\nSeguridad Root\necho 'options(chromote.args = c(\"--no-sandbox\", \"--disable-gpu\", \"--headless\"))' &gt;&gt; /usr/local/lib/R/etc/Rprofile.site\nHabilita el modo headless y evita bloqueos de sandbox al ejecutar como root. (si falla usa /etc/R/Rprofile.site)\n\n\nLibrerías R\nRscript -e \"install.packages('webshot2', repos='https://cloud.r-project.org/')\"\nInstala el motor de captura de widgets HTML y mapas de Leaflet.\n\n\nLibrerías Python\npip3 install selenium\nHabilita la automatización de capturas para visualizaciones dinámicas de Python.\n\n\nLibrerías Julia\njulia -e 'using Pkg; Pkg.add([\"FileIO\", \"ImageIO\"])'\nSoporte esencial para procesar y exportar gráficos en el ecosistema Julia.\n\n\n\n\n\n\n\nVentajas de esta configuración\nAl usar el archivo Rprofile.site, hemos logrado que:\n\nLimpieza: Sus archivos .qmd solo contendrán código de análisis geográfico, eliminando bloques de configuración de sistema repetitivos.\nPersistencia: Cualquier usuario o script que inicie una sesión de R dentro de este contenedor heredará automáticamente la capacidad de tomar capturas de pantalla.\nCompatibilidad: Quarto detectará webshot2 y el navegador Chrome de forma nativa al renderizar a PDF.\n\n\n\nNotas de implementación\n\n\n\n\n\n\n¿Por qué Google Chrome y no Chromium?\n\n\n\nEn distribuciones basadas en Ubuntu 22.04 o superiores, el comando apt install chromium-browser instala una versión ligada a Snap, la cual no puede ejecutarse dentro de un contenedor Docker por restricciones de seguridad del kernel. La instalación manual del paquete .deb de Google Chrome garantiza un binario funcional en /usr/bin/google-chrome.\n\n\n\n\n\n\n\n\nImportancia de ImageIO y FileIO en Julia\n\n\n\nEn Julia, estas librerías actúan como los “drivers” de imagen. Sin ellas, aunque el código genere un mapa o gráfico, Quarto no podrá convertirlo a un formato que LaTeX entienda (como PNG), resultando en bloques vacíos en el PDF final.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Infraestructura Instalada</span>"
    ]
  },
  {
    "objectID": "81-infraestructura_instalada.html#introducción-a-la-infraestructura-de-datos",
    "href": "81-infraestructura_instalada.html#introducción-a-la-infraestructura-de-datos",
    "title": "Apéndice A — Infraestructura Instalada",
    "section": "A.2 Introducción a la infraestructura de datos",
    "text": "A.2 Introducción a la infraestructura de datos\nEste anexo constituye la guía técnico para la gestión del entorno de desarrollo instalado. Es decir, información que describe y detalla los contenedores instalados (instalación opción A), su estructura y funcionamiento, así mismo como la descripción y detalles adicionales de las dos instalaciones de QGIS (Instalación Opción B)\n\nContenedores instalados (Instalación Opción A)\n\nResumen de infraestructura docker\nAntes de entrar en los detalles técnicos, es vital entender el rol de los dos archivos maestros que sostienen su laboratorio geográfico.\n\n\n\n\n\n\n\nArchivo\nRol Crítico\n\n\n\n\nDockerfile\nEl “Qué” (La Receta): Crea el entorno políglota desde cero, instala las librerías de NASA/Copernicus y aplica la “cirugía” de OpenSSL para que Julia sea estable en Ubuntu Noble.\n\n\ndocker-compose.yml\nEl “Cómo” (La Orquesta): Despliega los servicios, mapea los puertos externos (8889, 8788, 5434) y asegura que sus mapas y bases de datos no se borren gracias al volumen persistente (postgis_data_unal).\n\n\n\n\n\n\n\n\n\nPersistencia de Datos\n\n\n\nGracias al docker-compose, si su contenedor se apaga o se reinicia, los datos de su base de datos PostGIS no se pierden. El volumen nombrado actúa como un disco duro externo que sobrevive a cualquier caída del sistema.\n\n\n\n\n🧪 Batería de pruebas de integridad del docker\n\n\n\n\n\n\n\n\nID\nComando de Verificación (Docker)\nDescripción\n\n\n\n\n01\ndocker exec contenedor_sig_unal gdalinfo --version\nVerifica que el núcleo de GDAL está activo.\n\n\n02\ndocker exec contenedor_sig_unal R -e \"library(sf); st_point(c(0,0))\"\nPrueba la librería sf y el motor de geometría en R.\n\n\n03\ndocker exec contenedor_sig_unal python3 -c \"import geopandas; print(geopandas.__version__)\"\nVerifica el stack espacial de Python.\n\n\n04\ndocker exec contenedor_sig_unal R -e \"j_eval('sum([1, 2, 3])')\"\nTest Crítico: Verifica la función personalizada y el puente R -&gt; Julia.\n\n\n05\ndocker exec contenedor_sig_unal R -e \"j_plot('plot(rand(10))')\"\nPrueba la generación de gráficos Julia capturados por R.\n\n\n06\ndocker exec contenedor_sig_unal julia -e 'using ArchGDAL; println(ArchGDAL.GDAL.gdalversioninfo(\"RELEASE_NAME\"))'\nCirugía Exitosa: Confirma que Julia accede a GDAL del sistema (v3.12.1).\n\n\n07\ndocker exec contenedor_sig_unal R -e \"library(RPostgres); dbConnect(Postgres(), host='db-postgis', dbname='sig_db_unal', user='profe_unal', password='geomatica2025')\"\nPrueba la conexión R -&gt; PostGIS (Interna).\n\n\n08\ndocker exec contenedor_sig_unal python3 -c \"import psycopg2; conn = psycopg2.connect(host='db-postgis', dbname='sig_db_unal', user='profe_unal', password='geomatica2025'); print('Python PostGIS conectado ✅'); conn.close()\"\nPrueba la conexión Python -&gt; PostGIS (Interna).\n\n\n09\ndocker exec contenedor_sig_unal R -e \"cat(whitebox::wbt_version())\"\nVerifica que los binarios de WhiteboxTools están instalados y accesibles.\n\n\n10\ndocker exec contenedor_sig_unal R -e \"library(httpgd); print('Visor OK')\"\nVerifica que el motor gráfico para VSCode está listo en el puerto 8787.\n\n\n\n\n\nConfiguración de puertos y conectividad\nPara que su computadora (Host) pueda comunicarse con los servicios dentro del contenedor, hemos diseñado un sistema de “puentes” o mapeo de puertos. Esto evita conflictos si ya tiene instalados otros servidores de bases de datos o Jupyter en su PC.\n\n\n\n\n\n\n\n\n\n\nServicio\nPuerto en su PC (Host)\nPuerto en Contenedor\nPropósito\nAcceso / Conexión\n\n\n\n\nJupyter Lab\n8889\n8888\nProgramación y Notebooks\nhttp://localhost:8889\n\n\nVisor R (httpgd)\n8788\n8787\nGráficos de R y VSCode\nhttp://localhost:8788\n\n\nPostGIS (DB)\n5434\n5432\nBase de Datos Espacial\nlocalhost:5434\n\n\n\n\n\n🔑 Credenciales de la base de datos\nUtilice estos datos para configurar sus conexiones en QGIS, DBeaver o mediante código (R/Python/Julia):\n\nBase de Datos: sig_db_unal\nUsuario: profe_unal\nContraseña: geomatica2025\nHost Interno: db-postgis (Use este nombre únicamente para conexiones dentro de sus scripts).\n\n\n\nLógica de arquitectura (Dockerfile y docker-compose)\nLa configuración del entorno se ha “blindado” técnicamente para garantizar la estabilidad:\n\nEn el Dockerfile: Se usan las instrucciones EXPOSE 8888 y EXPOSE 8787. Esto le avisa a Docker que el contenedor tiene dos “puertas” abiertas internamente. Al fijar httpgd.port = 8787, nos aseguramos de que el visor de gráficos de R no pelee con Jupyter por el mismo canal.\nEn el Docker-Compose:\n\n8889:8888: Permite que este curso conviva con otras instalaciones de Jupyter (que suelen usar el 8888).\n8788:8787: Habilita la conexión independiente de VSCode al visor de gráficos de R.\n5434:5432: Evita el choque con bases de datos locales (Postgres suele usar el 5432 o 5433).\n\n\n\n\nGuía de acceso: El concepto de “lados”\nEs fundamental entender desde dónde está intentando conectar:\n\n🌐 Desde afuera (Su PC / Host)\nEs lo que usted configura en su navegador o en QGIS. Usted ve los puertos mapeados: * Jupyter/Notebooks: http://localhost:8889 (usando el token geomatica2025). * Base de Datos (QGIS/DBeaver): Host: localhost, Puerto: 5434.\n\n\n🐳 Desde adentro (El Contenedor)\nSus scripts de Python, R y Julia no saben que existe un mapeo externo. Dentro de su “casa” Docker, nada ha cambiado: * PostGIS: El código debe buscar el puerto estándar 5432 y el host db-postgis. * httpgd: El servidor de gráficos sigue escuchando en el puerto interno 8787.\n\n\n\n\n\n\n\nTip de Conexión\n\n\n\nSi intenta conectar QGIS usando el puerto 5432 y falla, recuerde que el “puente” hacia el contenedor se construyó específicamente sobre el puerto 5434.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Infraestructura Instalada</span>"
    ]
  },
  {
    "objectID": "82-quarto.html",
    "href": "82-quarto.html",
    "title": "Apéndice B — Quarto: Orquestación y Configuración",
    "section": "",
    "text": "B.1 Opciones del encabezado yml\nEjemplo 1: Solo HTML\nEjemplo 2: HTML y Python",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Quarto: Orquestación y Configuración</span>"
    ]
  },
  {
    "objectID": "82-quarto.html#opciones-del-encabezado-yml",
    "href": "82-quarto.html#opciones-del-encabezado-yml",
    "title": "Apéndice B — Quarto: Orquestación y Configuración",
    "section": "",
    "text": "---\ntitle: \"Título de la Práctica\"\nauthor: \"Nombre del Estudiante\"\ndate: last-modified\nformat:\n  html:\n    toc: true\n    toc-depth: 3\n    toc-location: left\n    number-sections: true\n    theme: lux\n---\n\n---\ntitle: \"Informe Técnico: Análisis Geoespacial\"\nauthor: \"ID Correo UNAL\"\ndate: today\nformat:\n  html:\n    toc: true\n    number-sections: true\n    theme: cosmo\n  pdf:\n    toc: true\n    toc-title: \"Contenido\"\n    number-sections: true\n    documentclass: scrreprt\n    geometry:\n      - top=25mm\n      - left=25mm\n      - right=25mm\n      - bottom=25mm\n---",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Quarto: Orquestación y Configuración</span>"
    ]
  },
  {
    "objectID": "82-quarto.html#resumen-de-comandos-quarto",
    "href": "82-quarto.html#resumen-de-comandos-quarto",
    "title": "Apéndice B — Quarto: Orquestación y Configuración",
    "section": "B.2 Resumen de comandos Quarto",
    "text": "B.2 Resumen de comandos Quarto\nquarto render guia_instalacion.qmd --to all\nquarto render guia_instalacion.qmd --to html\nquarto render guia_instalacion.qmd --to pdf",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Quarto: Orquestación y Configuración</span>"
    ]
  },
  {
    "objectID": "82-quarto.html#sec-opciones-chunks",
    "href": "82-quarto.html#sec-opciones-chunks",
    "title": "Apéndice B — Quarto: Orquestación y Configuración",
    "section": "B.3 Control de ejecución en Quarto - opciones de chunks",
    "text": "B.3 Control de ejecución en Quarto - opciones de chunks\nPara que sus informes técnicos sean profesionales, no basta con que el código funcione; es necesario controlar qué se muestra y qué se oculta al lector final. En Quarto, esto se logra mediante el uso de “opciones de chunk” utilizando la sintaxis de la tubería de comentarios (#|).\n\n\n\n\n\n\n\n\n\n\nOpción de Chunk\n¿Se ejecuta?\n¿Muestra el Código?\n¿Muestra Resultados / Plots?\nUso Ideal\n\n\n\n\n#| echo: false\n✅ SÍ\n❌ NO\n✅ SÍ\nPara Resultados Finales. Muestra el mapa/tabla sin la “receta”.\n\n\n#| include: false\n✅ SÍ\n❌ NO\n❌ NO\nPara el Setup. Corre todo en secreto, sin mensajes ni advertencias.\n\n\n#| code-fold: true\n✅ SÍ\n📂 Plegado\n✅ SÍ\nPara el Proceso. El código se oculta tras un botón “Code”.\n\n\n#| eval: false\n❌ NO\n✅ SÍ\n❌ NO\nPara Tutoriales. Solo muestra el texto del código sin procesarlo.\n\n\n#| output: false\n✅ SÍ\n✅ SÍ\n❌ NO\nPara Debugging. Ves su código pero no los resultados pesados.\n\n\n#| warning: false\n✅ SÍ\n-\n-\nOculta esos textos naranjas de advertencia de las librerías.\n\n\n#| message: false\n✅ SÍ\n-\n-\nOculta mensajes de carga (ej: “Loading terra package…”).\n\n\n\n\nRecomendaciones de uso según el contexto\nDependiendo de la parte del script en la que se encuentre, existen configuraciones que garantizan un documento más limpio y fluido:\n\n\n\n\n\n\n\n\nTipo de Chunk\nOpción recomendada\n¿Por qué?\n\n\n\n\nSetup / Librerías\n#| include: false\nEjecuta todo pero oculta el código y los mensajes de carga de R/Julia/Python.\n\n\nLimpieza de RAM\n#| include: false\nBorra objetos y vacía el cache en silencio. El lector no necesita ver la “limpieza”.\n\n\nProcesamiento\n#| code-fold: true\nMuestra el mapa pero esconde el código tras un clic. Ideal para transparencia académica.\n\n\nResultados Finales\n#| echo: false\nMuestra solo la tabla comparativa y conclusiones. Es el “veredicto” limpio y profesional.\n\n\n\n\n\n\n\n\n\nSintaxis Correcta\n\n\n\nRecuerde que las opciones deben ir al inicio del chunk, justo después de los corchetes del lenguaje:\n#| echo: false\n#| warning: false\nlibrary(terra)\n# Su código aquí...",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Quarto: Orquestación y Configuración</span>"
    ]
  },
  {
    "objectID": "82-quarto.html#instalación-de-extensiones-de-quarto",
    "href": "82-quarto.html#instalación-de-extensiones-de-quarto",
    "title": "Apéndice B — Quarto: Orquestación y Configuración",
    "section": "B.4 Instalación de Extensiones de Quarto",
    "text": "B.4 Instalación de Extensiones de Quarto\nLas extensiones permiten ampliar las funcionalidades nativas de Quarto, añadiendo nuevos formatos de salida, filtros personalizados o librerías de componentes visuales. Para que el proceso de descarga desde repositorios remotos sea exitoso y seguro, es fundamental haber completado previamente la configuración descrita en la Sección D.5.\n\nEl proceso de instalación\nPara agregar una extensión a tu proyecto, Quarto utiliza el comando add seguido del identificador del repositorio (usualmente usuario/repositorio). Este proceso descarga los archivos necesarios dentro de una carpeta local denominada _extensions/.\n\nEjemplo práctico: Librería de iconos FontAwesome\nComo caso de estudio, instalaremos la extensión oficial para el uso de iconos vectoriales. Ejecuta el siguiente comando en tu terminal:\nquarto add quarto-ext/fontawesome\n\n\n\n\n\n\nConfianza del Autor\n\n\n\nAl ejecutar el comando, el sistema solicitará confirmar si confías en los autores de la extensión. Escribe Y para permitir que Quarto gestione los archivos del filtro en tu directorio de trabajo.\n\n\n\n\n\nGestión de archivos del proyecto\nUna vez finalizada la instalación, notarás que en la raíz de tu proyecto se ha creado la siguiente estructura:\nmi-proyecto/\n├── _extensions/\n│   └── quarto-ext/\n│       └── fontawesome/\n└── tu-archivo.qmd\nEs importante no modificar manualmente los archivos dentro de la carpeta _extensions, ya que Quarto los requiere para procesar el documento final durante el renderizado.\n\n\nAplicación en el documento\nTras la instalación exitosa, puedes utilizar las nuevas funcionalidades mediante shortcodes. En el caso de nuestra extensión de ejemplo, ahora es posible insertar iconos de la siguiente manera:\nPara este análisis utilizaremos:\n\n* {{&lt; fa satellite &gt;}} Datos satelitales.\n* {{&lt; fa location-dot \"red\" &gt;}} Puntos de control terrestre.\n\n\n\n\n\n\nActualización de extensiones\n\n\n\nSi en el futuro deseas actualizar una extensión instalada a su última versión, simplemente vuelve a ejecutar el mismo comando quarto add. El sistema detectará la versión existente y te preguntará si deseas sobrescribirla.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Quarto: Orquestación y Configuración</span>"
    ]
  },
  {
    "objectID": "83-docker_desktop.html",
    "href": "83-docker_desktop.html",
    "title": "Apéndice C — Docker: Gestión de Contenedores e Imágenes",
    "section": "",
    "text": "C.1 Procedimiento incial\nAntes de trabajar con Docker debes:\nLos siguientes pasos son compilar (solo una vez), arrancar las imágenes y detener las imágenes:\nFinalmente trabajar con los contenedores dentro de VSCode:",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Docker: Gestión de Contenedores e Imágenes</span>"
    ]
  },
  {
    "objectID": "83-docker_desktop.html#procedimiento-incial",
    "href": "83-docker_desktop.html#procedimiento-incial",
    "title": "Apéndice C — Docker: Gestión de Contenedores e Imágenes",
    "section": "",
    "text": "Arrancar Docker Desktop\nUsando la terminal PowerShell de Windows ubicarte sobre la carpeta dónde se encuentran los archivos Dockerfile y docker-compose.html\n\n\n\nCompilación Limpia (Sin Cache) con Log:\n\ndocker build --no-cache -t mi_sig_env:v1 . &gt; build_details.log 2&gt;&1\n\nArrancar las imágenes:\n\ndocker compose up -d\n\nDetener las imágenes: (opcional: solo para terminar)\n\ndocker compose down\n\n\n“Ctrl + Shif + P”: “Dev Containers: Attach to Running Container…” y seleccionar container image_sig_unal (contenedor_sig_unal)",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Docker: Gestión de Contenedores e Imágenes</span>"
    ]
  },
  {
    "objectID": "83-docker_desktop.html#comandos-docker",
    "href": "83-docker_desktop.html#comandos-docker",
    "title": "Apéndice C — Docker: Gestión de Contenedores e Imágenes",
    "section": "C.2 Comandos docker",
    "text": "C.2 Comandos docker\nUse la siguiente tabla como referencia para gestionar sus contenedores desde la terminal de su sistema anfitrión (Windows/Mac/Linux).\n\n\n\n\n\n\n\n\nAcción\nComando\nPropósito\n\n\n\n\nConstrucción Inicial\ndocker-compose up --build -d\nCompila el Dockerfile y levanta los servicios (Solo una vez).\n\n\nInicio Diario\ndocker-compose up -d\nInicia los servicios de forma instantánea si ya fueron construidos.\n\n\nMonitoreo de Procesos\ndocker logs -f entorno_unal_sig\nSigue los logs en vivo (ideal para ver pre-compilaciones).\n\n\nVer logs recientes\ndocker logs --tail 20 entorno_unal_sig\nMuestra las últimas 20 líneas (ideal para buscar el token).\n\n\nApagado\ndocker-compose down\nDetiene los servicios y libera recursos del sistema.\n\n\nPrueba de R (sf)\ndocker exec entorno_unal_sig R -e \"library(sf); print('R-Spatial detectado')\"\nConfirmar que R reconoce los drivers geoespaciales del sistema.\n\n\nPrueba de Python\ndocker exec entorno_unal_sig python -c \"import shapely; import geopandas; print('Python OK')\"\nConfirmar que el stack de Python (GeoPandas/Shapely) está instalado.\n\n\nPrueba de Julia\ndocker exec entorno_unal_sig julia -e \"using LibGEOS; println('Julia OK')\"\nConfirmar que Julia tiene acceso a los binarios geoespaciales.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Docker: Gestión de Contenedores e Imágenes</span>"
    ]
  },
  {
    "objectID": "83-docker_desktop.html#compilación-avanzada",
    "href": "83-docker_desktop.html#compilación-avanzada",
    "title": "Apéndice C — Docker: Gestión de Contenedores e Imágenes",
    "section": "C.3 Compilación avanzada",
    "text": "C.3 Compilación avanzada\nPara trabajar con entornos SIG, a menudo necesitamos reconstruir imágenes sin basura previa.\n\nCompilación Limpia (Sin Cache) con Log: Para asegurar que Docker descargue todas las librerías desde cero y guarde un registro detallado de los errores: docker build --no-cache -t mi_sig_env:v1 . --progress=plain &gt; build_details.log 2&gt;&1\nSubir Imagen a Repositorio: docker tag mi_sig_env:v1 usuario_dockerhub/mi_sig_env:v1 docker push usuario_dockerhub/mi_sig_env:v1\nCargar en VSCode: Una vez el contenedor esté corriendo, use la extensión Dev Containers -&gt; Botón verde inferior izquierdo -&gt; Attach to Running Container.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Docker: Gestión de Contenedores e Imágenes</span>"
    ]
  },
  {
    "objectID": "83-docker_desktop.html#cambio-de-ruta-de-almacenamiento-windows",
    "href": "83-docker_desktop.html#cambio-de-ruta-de-almacenamiento-windows",
    "title": "Apéndice C — Docker: Gestión de Contenedores e Imágenes",
    "section": "C.4 Cambio de ruta de almacenamiento (Windows)",
    "text": "C.4 Cambio de ruta de almacenamiento (Windows)\nSi el disco C: se agota debido a las imágenes de Docker, siga estos pasos en Docker Desktop: 1. Vaya a Settings (engranaje). 2. Resources &gt; Advanced. 3. En Disk image location, cambie la ruta a un disco con mayor capacidad (ej. D:\\DockerImages). 4. Presione Apply & Restart.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Docker: Gestión de Contenedores e Imágenes</span>"
    ]
  },
  {
    "objectID": "83-docker_desktop.html#sec-optimizacion-memoria",
    "href": "83-docker_desktop.html#sec-optimizacion-memoria",
    "title": "Apéndice C — Docker: Gestión de Contenedores e Imágenes",
    "section": "C.5 Optimización de memoria RAM y swap",
    "text": "C.5 Optimización de memoria RAM y swap\nCuando procesamos datos masivos (como imágenes Sentinel-2 o rásters globales), la RAM física de 16GB suele ser insuficiente. Para evitar que el sistema aborte los procesos con el error “Killed”, debemos configurar un “pulmón” de emergencia en dos niveles.\n\n1. El “pulmón” de Windows: memoria virtual\nObligamos a Windows a usar el disco duro como si fuera RAM de reserva. Si tiene un disco sólido (SSD) secundario con mucho espacio libre (ej. Disco D:), es el lugar ideal para configurarlo.\n\nEn el buscador de Windows, escriba: “Ajustar la apariencia y rendimiento de Windows”.\nVaya a la pestaña Opciones avanzadas &gt; sección Memoria virtual &gt; clic en Cambiar.\nDesmarque la opción “Administrar automáticamente el tamaño del archivo de paginación para todas las unidades”.\nSeleccione la unidad de disco (C: o D:) y marque Tamaño personalizado.\nEstablezca los siguientes valores (recomendados para este curso):\n\nTamaño inicial: 16384 MB (16 GB).\nTamaño máximo: 32768 MB (32 GB).\n\nHaga clic en Establecer, luego en Aceptar y reinicie su computadora para aplicar los cambios.\n\n\n\n2. El “túnel” de docker: swap de WSL2\nDocker Desktop corre sobre WSL2 (Windows Subsystem for Linux), el cual tiene su propio “presupuesto” limitado. Por defecto, este túnel es estrecho (máximo 4GB de Swap). Si no ampliamos esto, el contenedor nunca podrá aprovechar realmente el espacio que le asignamos a Windows.\nCómo ampliar la tubería: 1. Presione Win + R, escriba %UserProfile% y presione Enter. 2. Busque el archivo .wslconfig. Si no existe, créelo con el Bloc de Notas. 3. Pegue el siguiente contenido:\n[wsl2]\nmemory=12GB # RAM máxima que le permitimos usar a Linux/Docker\nswap=16GB   # El nuevo tamaño de swap que verá el comando 'top' en la terminal\n\nAplicar cambios: Guarde el archivo, abra una terminal (PowerShell) y escriba wsl --shutdown. Luego, inicie Docker Desktop nuevamente.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Docker: Gestión de Contenedores e Imágenes</span>"
    ]
  },
  {
    "objectID": "83-docker_desktop.html#higiene-y-limpieza-de-choque",
    "href": "83-docker_desktop.html#higiene-y-limpieza-de-choque",
    "title": "Apéndice C — Docker: Gestión de Contenedores e Imágenes",
    "section": "C.6 Higiene y limpieza de choque",
    "text": "C.6 Higiene y limpieza de choque\nPara garantizar que un renderizado de Quarto llegue al 100% sin colapsar el contenedor, aplique estas medidas de higiene:\n\nCierre “Vampiros”: Aplicaciones como Chrome, Edge, Teams y Slack consumen RAM de forma agresiva. Ciérrelas antes de procesos pesados.\nLimpieza de disco: Use el Liberador de espacio en disco (cleanmgr) para vaciar archivos de volcado de memoria.\nLa “Escoba” en el Código: Use comandos de limpieza entre procesos de diferentes lenguajes:\n\nR: rm(obj); gc(full = TRUE)\nPython: del var; gc.collect()\nJulia: GC.gc()\n\n\n\n\n\n\n\n\nImportante para Visualización\n\n\n\nEn Julia y R, evite generar gráficos interactivos pesados dentro de bucles de procesamiento. La acumulación de objetos visuales en la memoria de VSCode es la causa número uno de colapsos en el contenedor.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Docker: Gestión de Contenedores e Imágenes</span>"
    ]
  },
  {
    "objectID": "84-git_github.html",
    "href": "84-git_github.html",
    "title": "Apéndice D — Git y GitHub: Sincronización Local-Remota",
    "section": "",
    "text": "D.1 Control de versiones - flujo de trabajo en PowerShell\nPara gestionar el repositorio de forma robusta y tener control total sobre el historial de cambios, utilice la siguiente secuencia de comandos desde la terminal del contenedor:",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Git y GitHub: Sincronización Local-Remota</span>"
    ]
  },
  {
    "objectID": "84-git_github.html#sec-git-terminal",
    "href": "84-git_github.html#sec-git-terminal",
    "title": "Apéndice D — Git y GitHub: Sincronización Local-Remota",
    "section": "",
    "text": "Tabla D.1: Comandos esenciales para la gestión de Git en terminal\n\n\n\n\n\n\n\n\n\n\nAcción\nComando\nPropósito\n\n\n\n\nVerificar estado\ngit status\nMuestra la “verdad absoluta” local: archivos modificados o listos para commit.\n\n\nSincronizar índices\ngit remote update\nConsulta el servidor para saber si hay cambios nuevos en la nube sin descargarlos aún.\n\n\nPreparar cambios\ngit add .\nAgrega todos los cambios detectados al área de preparación (Staging).\n\n\nConfirmar versión\ngit commit -m \"mensaje\"\nCrea un punto de control permanente en el historial local.\n\n\nEnviar al remoto\ngit push\nSube los commits locales al servidor (GitHub).\n\n\nActualizar local\ngit pull\nDescarga y fusiona los cambios del servidor en su entorno de trabajo.\n\n\nVer historial\ngit log --oneline\nMuestra un resumen simplificado de la línea de tiempo del proyecto.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Git y GitHub: Sincronización Local-Remota</span>"
    ]
  },
  {
    "objectID": "84-git_github.html#sec-git-diagnostico",
    "href": "84-git_github.html#sec-git-diagnostico",
    "title": "Apéndice D — Git y GitHub: Sincronización Local-Remota",
    "section": "D.2 Diagnóstico de archivos “invisibles” o errores de rastreo",
    "text": "D.2 Diagnóstico de archivos “invisibles” o errores de rastreo\nSi ha modificado un archivo pero este no aparece listado tras ejecutar git status, las causas técnicas suelen ser las siguientes:\n\nInterferencia de Repositorios Anidados: Si clonó una carpeta que ya contenía un directorio .git, el repositorio principal la tratará como un objeto opaco (submódulo) y no rastreará sus archivos internos.\n\nSolución: Verifique la presencia de carpetas ocultas con ls -a y elimine la carpeta .git interna si desea que el repositorio raíz tome el control: rm -rf nombre_carpeta/.git.\n\nFiltros en el archivo .gitignore: El archivo puede tener reglas que excluyan carpetas enteras por nombre o extensión.\n\nVerificación: Use el comando git status --ignored para listar todos los archivos que Git está omitiendo deliberadamente.\n\nEstado del sistema de archivos: Git opera sobre los datos escritos en el disco duro. Asegúrese de que el editor de texto haya guardado efectivamente los cambios en el archivo físico antes de consultar el estado.\n\n\n\n\n\n\n\nPersistencia de Credenciales\n\n\n\nSi la terminal le solicita usuario y contraseña en cada push o pull, puede configurar Git para que recuerde sus credenciales temporalmente en la memoria del contenedor con el siguiente comando: git config --global credential.helper cache",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Git y GitHub: Sincronización Local-Remota</span>"
    ]
  },
  {
    "objectID": "84-git_github.html#subír-el-contenido-carpeta-local-hacia-github",
    "href": "84-git_github.html#subír-el-contenido-carpeta-local-hacia-github",
    "title": "Apéndice D — Git y GitHub: Sincronización Local-Remota",
    "section": "D.3 Subír el contenido (carpeta local hacia GitHub)",
    "text": "D.3 Subír el contenido (carpeta local hacia GitHub)\nSi ya tiene sus archivos en Windows y quiere subirlos a un repositorio recién creado en GitHub:\n\nInstalar Git\n\n\nDescarga: Acceda a git-scm.com/download/win.\nInstalación: Ejecute el instalador manteniendo las opciones por defecto; asegúrese de que la opción “Git from the command line and also from 3rd-party software” esté activa.\nVerificación: Ejecute git --version en una terminal para confirmar la instalación.\n\n\nCrear una cuenta en GitHub\nAbrir Terminal en la carpeta local:\nIncicializar Git en la carpeta local:\n\ngit init\n\nVer el estado actual del repositorio Git:\n\ngit status\n\nArchivo .gitignore: Crear un archivo de texto .gitignore para indicarle a Git los archivos y carperas que nunca deben ser registrados con Git cuando se use el comando git add (siguiente item del procedimiento). Estos archivos que pueden estar en la raíz de la carpeta o dentro de otras sub-carpetas no se registrarán automáticamente cuando ejecute el comando git add . (ver mas adelante). Sin embargo puede forzar una carpeta o algunos tipos de archivos que estén marcados para ignorar dentro del .gitignore (ver mas adelante).\n\n.quarto/\n_freeze/\n.ipynb_checkpoints/\n__pycache__/\nnotebooks/\nscripts/\ndata/\n\nRegistrar (add) el archivo .gitignore con Git:\n\ngit add .gitignore\n\nRevise nuevamente el estátus y verifique cambios. Puede incluir el listado de los ignorados:\n\ngit status --ignored\n\nSalvar (commit) el archivo en Git (local). Note que en el comando, el texto “Archivo .gitignore” es un comentario que describe lo que está salvando:\n\ngit commit -m \"Archivo .gitignore\"\n\nCambiar al nombre de rama (branch) a principal (main). Pueden haber diferentes ramas con diferentes versiones del mismo archivo. Para cambiar a main:\n\ngit branch -M main\n\nConectar el repositorio local (Git) con nuestro repositorio en GitHub.\n\nPara conectar Git con GitHub, puede hacerlo con SSH (debe realizar el proceso de instalación de llaves Sección D.4) o con HTTPS (debe generar un PAT desde github.com que usará como clave de autenticación). En este caso usaremos HTTPS.\nCree un nuevo repositorio en GitHub y copie la url HTTP del repositorio. Es algo como: https://github.com/usuario/repositorio.git\ngit remote add origin https://github.com/usuario/repositorio.git\n\nProcedimiento para generar el PAT (Personal Access Token) en GitHub.com {#ancla-github_pat}\n\n\nEn lugar de escribir tu contraseña cuando el terminal te la pida, debes pegar un token generado en tu cuenta.\nVe a tu cuenta de GitHub.com: Settings &gt; Developer settings &gt; Personal access tokens &gt; Tokens (classic).\nGenera un nuevo token con el permiso repo activado.\nCopia el token (no lo volverás a ver).\n\n\nSubir (push) la información guardada localmente en Git a nuestro repositorio en GitHub:\n\ngit push -u origin main   \n# Cuanto solicite el password use el PAT/token generado previamente en github.com\nPuedes ver el estatus git status y realizar un procedimiento similar para registrar (add), salvar (commit) y subir (push) mas archivos. Otras opciones de Git se describen a continuación:\n\nRegistrar archivos específicos con Git (local):\n\ngit add file1 file2 ...\n\nForzar archivos y/o carpetas que están marcados para ignorar (bandera -f): el comando a continuación sincronizará con Git toda la carpeta _site/site_libs/ y su contenido, así contenga archivos o carpetas marcados para ignorar en .gitignore. {#ancla-git_add_minus_f}\n\ngit add -f _site/site_libs/\n\nRegistrar todos los archivos y carpetas disponibles y sin registrar, sin embargo todos los archivos y carpetas dentro de .gitignore no serán tenidos en cuenta {#ancla-git_add_punto}:\n\ngit add .\n\nEn resumen estos son los comandos que comúnmente usarás para mentener sincronizados tus archivos con Git y tu Git con GitHub, es decir el proceso de subir (push) archivos a la nube.\n\ngit add (agregar archivos a Git)\ngit commit (guardar archivos en Git)\ngit push (subir archivos a GitHub)\n\nLos otros comandos vistos solo se ejecutan una vez o de acuerdo con necesitades específicas:\n\ngit init (una vez)\ngit remote add origin (una vez)\ngit branch -M main (lo debes usar para cambiar a main en caso de tener múltiples ramas)",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Git y GitHub: Sincronización Local-Remota</span>"
    ]
  },
  {
    "objectID": "84-git_github.html#sec-ssh-github",
    "href": "84-git_github.html#sec-ssh-github",
    "title": "Apéndice D — Git y GitHub: Sincronización Local-Remota",
    "section": "D.4 Autenticación segura SSH - Windows",
    "text": "D.4 Autenticación segura SSH - Windows\nLa autenticación mediante SSH permite interactuar con GitHub de forma segura sin necesidad de ingresar credenciales manualmente en cada operación. Siga este procedimiento detallado para configurar su acceso.\n\nRequisito previo: creación de cuenta en GitHub\nEl correo que use para crear esta cuenta debe ser el mismo correo usado para crear las llaves SSH para conexión automática.\n\n\nRequisito previo: instalación de Git\nEs indispensable que su sistema operativo cuente con el motor de Git antes de iniciar la configuración:\n\n\nPreparación del entorno local\n\nNavegación: Diríjase mediante el Explorador de Archivos a la carpeta raíz de su proyecto (ejemplo: carpeta ID Unal).\nTerminal: Abra una ventana de PowerShell en esa ubicación (clic derecho -&gt; “Abrir en Terminal”).\nInicialización: Prepare el repositorio local mediante el comando:\n\ngit init\n\n\nGestión de llaves SSH en Windows\nSSH (Secure Shell) es un protocolo de red diseñado para el acceso, administración y transferencia de datos entre un equipo local y un servidor remoto mediante un canal cifrado. En nuestro flujo de trabajo, implementamos el algoritmo Ed25519, un estándar de vanguardia basado en criptografía de curva elíptica (EdDSA). Este método no solo ofrece un nivel de seguridad superior frente a ataques de fuerza bruta, sino que permite una autenticación transparente y sin contraseña, actuando como un “pasaporte digital” que vincula de forma única su estación de trabajo con GitHub.\n\n\n\n\n\n\n¿Por qué Ed25519?\n\n\n\nA diferencia de los estándares antiguos (como RSA), Ed25519 genera llaves más cortas, rápidas y significativamente más seguras, optimizando la latencia en cada comunicación con el repositorio.\n\n\n\nComprobación de llaves existentes: Verifique si su usuario ya posee llaves configuradas:\n\nls ~/.ssh\n* Si el directorio está vacío o solo contiene `known_hosts`, proceda a generar una nueva.\n* Si visualiza los archivos `id_ed25519` e `id_ed25519.pub`, puede saltar al paso de registro en GitHub.\n\nGeneración de llaves: Cree un par de llaves seguras utilizando el algoritmo Ed25519:\n\nEl correo que use en el siguiente paso, debe ser el correo con el que creó la cuenta de GitHub: “su_correo@domimio.com”\nssh-keygen -t ed25519 -C \"su_correo@domimio.com\"\n* **Nota**: Presione `ENTER` en todas las solicitudes para aceptar las rutas por defecto y no asignar una *passphrase*.\n\n\n\n\n\n\nSeguridad de la Identidad\n\n\n\nLa llave pública (id_ed25519.pub) es la que se entrega a GitHub, mientras que la llave privada (id_ed25519) funciona como su sello personal secreto y nunca debe salir de su equipo.\n\n\n\n\nRegistro de la identidad en GitHub\n\nCopiar la firma pública: Obtenga el contenido de su llave para registrarla:\n\ncat $env:USERPROFILE\\.ssh\\id_ed25519.pub\n*Seleccione y copie toda la cadena de texto resultante.*\n\nConfiguración en la plataforma:\n\nAcceda a su cuenta en GitHub.com.\nEntre a Settings -&gt; SSH and GPG keys.\nSeleccione New SSH key.\nAsigne el título Windows-UNAL-2025, pegue el contenido en el campo Key y presione Add SSH key.\n\n\n\n\nActivación del agente SSH del sistema\nPara que Windows gestione su identidad de forma transparente, debe habilitar el servicio correspondiente:\n\nModo Administrador: Cierre su terminal actual y abra una nueva sesión de PowerShell como Administrador.\nHabilitar Servicio: Ejecute los siguientes comandos para automatizar el arranque del agente:\n\nSet-Service ssh-agent -StartupType Automatic\nStart-Service ssh-agent\n\nCargar la llave privada: Registre su llave en el agente activo:\n\nssh-add $env:USERPROFILE\\.ssh\\id_ed25519\n\n\nVerificación de la autenticación\n\nPrueba de conexión: Compruebe que el túnel de comunicación con los servidores de GitHub funciona correctamente:\n\nssh -T git@github.com\n\nResultado esperado: Si la configuración es exitosa, recibirá un mensaje similar a: Hi usuario! You've successfully authenticated, but GitHub does not provide shell access.\n\n\n¡Túnel SSH Activo y Configurado!\nHas establecido una identidad digital segura entre tu equipo y GitHub. A partir de este momento, la comunicación para sincronizar tus repositorios será transparente y automática.\n\nIdentidad Permanente: Esta configuración se realiza una sola vez por computador; tu “firma digital” ya reside en el sistema.\nAdiós a las Interrupciones: GitHub ya no solicitará tu usuario, contraseña o tokens personales de acceso en cada operación.\nCompatibilidad Total: Esta llave es reconocida automáticamente por PowerShell, VSCode, Positron, RStudio y cualquier otra terminal científica que utilices.\nSeguridad de Grado Profesional: Tus envíos (push) viajan ahora por un canal cifrado bajo el estándar Ed25519.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Git y GitHub: Sincronización Local-Remota</span>"
    ]
  },
  {
    "objectID": "84-git_github.html#sec-ssh-linux",
    "href": "84-git_github.html#sec-ssh-linux",
    "title": "Apéndice D — Git y GitHub: Sincronización Local-Remota",
    "section": "D.5 Autenticación segura SSH - Linux (Docker)",
    "text": "D.5 Autenticación segura SSH - Linux (Docker)\nLa autenticación mediante SSH permite interactuar con GitHub de forma segura sin ingresar credenciales manualmente. En contenedores Docker, esto soluciona errores de validación SSL y facilita el uso de extensiones de Quarto.\n\nPreparación del Entorno Global\nAntes de generar las llaves, configura tu identidad de Git y verifica que el contenedor tenga salida a internet.\n\nConfigurar identidad:\n\ngit config --global user.email \"correo@dominio.com\"\ngit config --global user.name \"usuario_github\"\n\nVerificar conexión:\n\ncurl -I https://github.com\n\n\n\n\n\n\nAdvertencia\n\n\n\nSi recibes el error * “Could not resolve host”*, revisa la configuración de red de tu contenedor.\n\n\n\n\nGestión de llaves SSH (Algoritmo Ed25519)\nImplementamos Ed25519, el estándar actual por su seguridad y velocidad.\n\nComprobar llaves existentes:\n\nls -la ~/.ssh\n\nGenerar nueva llave: Ejecuta el comando y presiona ENTER en todas las solicitudes (sin contraseña).\n\nssh-keygen -t ed25519 -C \"alexyshr@gmail.com\"\n\n\n\n\n\n\nNota\n\n\n\nLa llave pública (id_ed25519.pub) se registra en GitHub; la llave privada (id_ed25519) es tu firma secreta.\n\n\n\n\nRegistro de Identidad en GitHub\n\nVisualizar y copiar la llave pública:\n\ncat ~/.ssh/id_ed25519.pub\n\nConfigurar en la web:\n\nVe a Settings -&gt; SSH and GPG keys en tu cuenta de GitHub.\nHaz clic en New SSH key.\nTítulo: Docker-RStudio-Geomatica.\nPega el contenido y guarda.\n\n\n\n\nActivación del Agente SSH\nPara que el sistema use tu llave automáticamente, inicia el agente y regístrala:\n# Iniciar agente\neval \"$(ssh-agent -s)\"\n\n# Cargar la llave privada\nssh-add ~/.ssh/id_ed25519\n\n\nVerificación Final\nComprueba que el túnel de comunicación funciona correctamente:\nssh -T git@github.com\nResultado esperado: &gt; Hi usuario_github! You've successfully authenticated, but GitHub does not provide shell access.\n\n¡Configuración Exitosa!\nTu contenedor ahora es un entorno de confianza para GitHub. Comandos como quarto add o git push funcionarán de forma transparente.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Git y GitHub: Sincronización Local-Remota</span>"
    ]
  },
  {
    "objectID": "84-git_github.html#sec-vinculacion-clase",
    "href": "84-git_github.html#sec-vinculacion-clase",
    "title": "Apéndice D — Git y GitHub: Sincronización Local-Remota",
    "section": "D.6 Descargar contenido (GitHub hacia carpeta local)",
    "text": "D.6 Descargar contenido (GitHub hacia carpeta local)\nPara explicar este procedimiento, usaremos el repositorio GitHub con el material de la clase. Los contenidos de la clase están en https://github.com/alexyshr/ProgramacionSIG2026.git (HTTPS) o git@github.com:alexyshr/ProgramacionSIG2026.git (SSH). La elección de uno de estos dos protocolos (HTTPS o SSH), depende de si ha configurado su identidad digital, ver Sección D.4.\n\n\n\n\n\n\n¡Advertencia sobre la Estructura de Carpetas!\n\n\n\nEs fundamental para el orden del curso que el repositorio con los contenidos de la clase se conecte a una carpeta independiente.\nNo sincronice estos archivos dentro de su carpeta local con los contenedores ID UNAL. Mantener directorios separados garantiza que sus ejercicios personales y los materiales de lectura del profesor no se mezclen, evitando errores de sobreescritura y conflictos de Git al realizar actualizaciones del material.\n\n\n\nOpción A: sincronizar mediante SSH (recomendado)\nUtilice este método si ya configuró sus llaves siguiendo los pasos de la Sección D.4.\n\n\n\n\n\n\nUrl SSH del Repositorio para la Clase\n\n\n\ngit@github.com:alexyshr/ProgramacionSIG2026.git\n\n\n\nVincular el repositorio remoto: Si ya inicializó su carpeta local (no la de sus contenedores Docker) con git init, ejecute el siguiente comando para establecer el origen:\n\ngit remote add origin git@github.com:alexyshr/ProgramacionSIG2026.git\n\nDescargar el contenido (Pull): Para traer los archivos del servidor a su computadora por primera vez:\n\ngit pull origin main\n\nVerificación de estado: Confirme que la carpeta local está sincronizada correctamente:\n\ngit status\n*Resultado esperado: `On branch main. Your branch is up to date. working tree clean.`*\n\n\nOpción B: sincronizar mediante HTTPS\nUtilice este método si aún no ha configurado llaves SSH o prefiere una descarga rápida. A diferencia del método anterior, este suele solicitar un Personal Access Token (PAT) (ver líneas arriba) para realizar operaciones de subida (push).\n\n\n\n\n\n\nUrl HTTPS del Repositorio para la Clase\n\n\n\nhttps://github.com/alexyshr/ProgramacionSIG2026.git\n\n\n\nOpción B-1: Descarga rápida mediante git clone\nEste comando descarga el repositorio completo y crea automáticamente una subcarpeta con el nombre del proyecto:\ngit clone https://github.com/alexyshr/ProgramacionSIG2026.git\n\n\nOpción B-2: Sincronizar repositorio GitHub a carpeta existente\nUtilice este procedimiento si usted ya creó una carpeta localmente (por ejemplo, ProgramacionSIG2026) y desea vincularla al repositorio oficial de GitHub para recibir actualizaciones sin perder sus archivos actuales.\nEjecute los siguientes comandos desde la terminal dentro de su carpeta de trabajo:\n# 1. Iniciar el repositorio localmente\ngit init\n\n# 2. Vincular la carpeta local con el servidor de GitHub\ngit remote add origin https://github.com/alexyshr/ProgramacionSIG2026.git\n\n# 3. Asegurar que la rama principal se llame 'main'\ngit branch -M main\n\n# 4. Sincronizar (traer los archivos del servidor)\n# Usamos --allow-unrelated-histories para permitir la fusión de carpetas  \n# que no \"nacieron\" del mismo commit original.\ngit pull origin main --allow-unrelated-histories\n\n\n\n\n\n\nManejo de conflictos en el primer pull\n\n\n\nAl ejecutar el git pull en una carpeta existente, es posible que Git le pida resolver conflictos si usted tiene archivos con el mismo nombre que los del repositorio (ej. un README.md genérico).\nSi desea forzar que sus archivos locales sean sobrescritos por los del repositorio oficial, puede usar: git fetch --all git reset --hard origin/main\n\n\n\n\n\n\n\n\nVerificación de la conexión\n\n\n\nPara confirmar que su carpeta quedó bien vinculada, ejecute: git remote -v\nDebería ver la URL de su repositorio tanto para fetch como para push.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Git y GitHub: Sincronización Local-Remota</span>"
    ]
  },
  {
    "objectID": "84-git_github.html#notas-de-flujo-de-trabajo",
    "href": "84-git_github.html#notas-de-flujo-de-trabajo",
    "title": "Apéndice D — Git y GitHub: Sincronización Local-Remota",
    "section": "D.7 Notas de flujo de trabajo",
    "text": "D.7 Notas de flujo de trabajo\n\nPersistencia: Una vez clonado o vinculado el repositorio, Git recordará la ruta del servidor (ya sea SSH o HTTPS). No es necesario repetir los comandos de remote add en sesiones futuras.\nSeguridad: Si opta por HTTPS, recuerde que GitHub ya no acepta contraseñas básicas por terminal; deberá generar un PAT (Personal Access Token) en la configuración de su cuenta. Por esta razón, se recomienda priorizar el uso de SSH.\n\n\n\n\n\n\n\nSiguiente Paso\n\n\n\nCon el repositorio sincronizado y el contenedor de Docker activo (como se vio en la Sección 2.2), ya puede comenzar a trabajar en sus archivos .qmd y ver los cambios reflejados en tiempo real.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Git y GitHub: Sincronización Local-Remota</span>"
    ]
  },
  {
    "objectID": "85-vscode.html",
    "href": "85-vscode.html",
    "title": "Apéndice E — Visual Studio Code: Extensiones e Interfaz",
    "section": "",
    "text": "E.1 Atajos",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>E</span>  <span class='chapter-title'>Visual Studio Code: Extensiones e Interfaz</span>"
    ]
  },
  {
    "objectID": "85-vscode.html#atajos",
    "href": "85-vscode.html#atajos",
    "title": "Apéndice E — Visual Studio Code: Extensiones e Interfaz",
    "section": "",
    "text": "La paleta de comandos VSCode\nLa mayoría de las funciones avanzadas de VSCode no tienen un botón visible. Se acceden mediante la Paleta de Comandos presionando Ctrl + Shift + P. A continuación, los comandos más utilizados en este curso:\n\n\n\n\n\n\n\n\nComando (Command Palette)\nPropósito\n¿Cuándo usarlo?\n\n\n\n\nDeveloper: Reload Window\nReinicia la interfaz de VSCode sin cerrar el contenedor.\nCuando una extensión (como la de R o Julia) deja de responder.\n\n\nDev Containers: Rebuild Container\nReconstruye la imagen desde el Dockerfile.\nCuando se realizan cambios en la configuración del entorno.\n\n\nQuarto: Preview\nAbre una ventana lateral con la previsualización del documento.\nPara ver los cambios en el .qmd en tiempo real.\n\n\nR: Create R terminal\nFuerza la apertura de una nueva consola de R vinculada.\nSi el prompt &gt; no aparece automáticamente.\n\n\nJulia: Start REPL\nInicia la consola interactiva de Julia.\nAl abrir el contenedor por primera vez para ejecutar código Julia.\n\n\nPython: Select Interpreter\nPermite elegir la versión de Python del contenedor.\nSi VSCode no detecta automáticamente /usr/bin/python3.\n\n\nPostgreSQL: New Query\nAbre un editor SQL en blanco.\nPara realizar consultas a la base de datos espacial.\n\n\nGit: Pull / Git: Push\nSincroniza cambios con GitHub.\nPara actualizar el repositorio de la clase o subir tareas.\n\n\n\n\n\n\n\n\n\nEl comando de “Primer Auxilio”\n\n\n\nSi notas que el autocompletado desaparece o que los gráficos no cargan en httpgd, el primer paso siempre es ejecutar Developer: Reload Window. Esto refresca todas las conexiones de las extensiones con el contenedor sin interrumpir los procesos que Docker está ejecutando de fondo.\n\n\n\n\nAtajos de teclado rápidos VSCode\nAdemás de la paleta, memorice estos tres para su flujo diario: * Ctrl + Shift +  (acento grave): Abre una nueva Terminal. * Ctrl + J: Mostrar la terminal/consola existente. * Ctrl + Enter: Envía la línea de código actual desde el editor al REPL (R, Julia o Python). * Ctrl + Shift + V: Previsualiza archivos Markdown (.md) de forma rápida.\n\n\nAtajos de teclado JupyterLab (notebooks)\n\n\n\nAcción\nAtajo (Esc Mode)\n\n\n\n\nEjecutar Celda\nCtrl + Enter\n\n\nEjecutar y pasar a la siguiente\nShift + Enter\n\n\nConvertir a Markdown\nM\n\n\nConvertir a Código\nY\n\n\nCrear celda arriba / abajo\nA / B",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>E</span>  <span class='chapter-title'>Visual Studio Code: Extensiones e Interfaz</span>"
    ]
  },
  {
    "objectID": "85-vscode.html#sec-extensiones-vscode",
    "href": "85-vscode.html#sec-extensiones-vscode",
    "title": "Apéndice E — Visual Studio Code: Extensiones e Interfaz",
    "section": "E.2 Instalación de extensiones en VSCode",
    "text": "E.2 Instalación de extensiones en VSCode\nPara que el entorno de desarrollo sea plenamente funcional, es necesario instalar un conjunto de extensiones específicas. Una vez que haya realizado el proceso de “Attach to Running Container”, asegúrese de que estas herramientas estén instaladas dentro del contenedor (busque el botón azul Install in Dev Container en la pestaña de extensiones).\n\n\n\nTabla E.1: Extensiones de VSCode para el entorno de Geomática y Programación SIG\n\n\n\n\n\n\n\n\n\n\n\nCategoría\nHerramienta\nPropósito\nID de la Extensión\n\n\n\n\nInfraestructura\nDev Containers\nConexión y gestión del contenedor activo\nms-vscode-remote.remote-containers\n\n\n\nDocker / Container Tools\nControl de imágenes y recursos del contenedor\nms-azuretools.vscode-docker\n\n\nEcosistema R\nR (REditorSupport)\nSoporte de sintaxis, LSP y terminal de R\nREditorSupport.r\n\n\n\nR Debugger & Tools\nDepuración de scripts y herramientas de desarrollo\nRDebugger.r-debugger\n\n\n\nR Extension Pack\nPack de utilidades (por Yuki Ueda)\nyukiueda.r-extension-pack\n\n\nEcosistema Python\nPython (Microsoft)\nIntelliSense (Pylance) y depuración avanzada\nms-python.python\n\n\n\nPython Debugger\nMotor de depuración específico para Python\nms-python.debugpy\n\n\n\nJupyter (Microsoft)\nSoporte para Notebooks e interactividad nativa\nms-toolsai.jupyter\n\n\nEcosistema Julia\nJulia\nSoporte integral para ejecución y gráficos\njulialang.language-julia\n\n\nBase de Datos\nPostgreSQL\nCliente para explorar la DB (Chris Kolkman)\nckolkman.vscode-postgres\n\n\n\npsql\nHerramienta de consulta SQL (doublefint)\ndoublefint.psql\n\n\nPublicación\nQuarto\nRenderizado y preview de archivos .qmd\nquarto.quarto\n\n\nVersión\nGitHub Repositories\nManejo de archivos remotos sin clonar todo\ngithub.remotehub\n\n\nUtilidad\nLive Server\nServidor local con recarga automática para previsualizar HTML\nritwickdey.liveserver\n\n\n\nCode Spell Checker\nCorrector ortográfico para código y comentarios\nstreetsidesoftware.code-spell-checker\n\n\n\nSpanish - Code Spell Checker\nDiccionario en español para el corrector ortográfico\nstreetsidesoftware.code-spell-checker-spanish\n\n\n\n\n\n\n\nNotas sobre herramientas específicas\n\nPostgreSQL (Chris Kolkman): Esta extensión le permitirá conectarse a la base de datos espacial del contenedor sin salir de VSCode. Podrá ejecutar queries SQL y visualizar tablas directamente.\nJupyter Ecosystem: Incluimos el Jupyter Keymap para aquellos acostumbrados a los atajos de teclado de Jupyter Notebooks. Esto facilita la transición al trabajar con kernels de Python dentro de Quarto.\nSobre psql: La herramienta de línea de comandos psql ya viene preinstalada dentro del sistema operativo del contenedor (PostgreSQL Client). No requiere instalación adicional para funcionar en la terminal del contenedor. Sin embargo, la instalación de psql y dentro de VSCode garantiza soporte adicional, ver Sección E.3 líneas abajo.\nLive Server (Ritwick Dey): Esta extensión le permite lanzar un servidor de desarrollo local con un solo clic. Es extremadamente útil para previsualizar exportaciones de mapas interactivos (Leaflet u OpenLayers) o sitios web estáticos generados por Quarto. La ventaja principal es la “recarga en vivo” (live reload): cada vez que guarde un cambio en su archivo HTML o CSS, el navegador se actualizará automáticamente sin necesidad de recargar la página manualmente.\nCode Spell Checker: Esta extensión es esencial para evitar errores tipográficos en el código y, sobre todo, en la documentación de archivos .qmd. Para que reconozca términos en nuestro idioma, se recomienda instalar también el paquete Spanish - Code Spell Checker (streetsidesoftware.code-spell-checker-spanish).\n\n\n\n\n\n\n\nInstalación Local vs. Remota\n\n\n\nRecuerde que extensiones como Dev Containers y Docker deben estar instaladas en su VSCode local (en Windows), mientras que las de análisis (R, Python, Julia, PostgreSQL) deben estar instaladas dentro de la sesión del contenedor para acceder a los compiladores y librerías de la imagen.\n\n\n\n\n\n\n\n\nSoporte del Lenguaje en R\n\n\n\nPara que el autocompletado y la documentación en tiempo real funcionen, el contenedor requiere el paquete languageserver. Aunque la imagen ya lo incluye por defecto, si nota que el resaltado de sintaxis falla, puede reinstalarlo ejecutando: install.packages(\"languageserver\") en su consola de R.\n\n\n\n\n\n\n\n\n¿Cuándo usar Live Server?\n\n\n\nÚselo cuando necesite probar cómo se comporta un mapa interactivo exportado fuera del entorno de Quarto. Simplemente haga clic derecho sobre su archivo .html en el explorador de VSCode y seleccione “Open with Live Server”. La opción de búsqueda en la página del curso (archivo _site\\index.html) solo funcionará si la ejecuta dentro de Live Server.\n\n\n\nConfiguración del corrector ortográfico\nPara habilitar corrección ortográfica en idioma español:\n\nActive el idioma: Presione Ctrl + Shift + P, escriba “Spell”, seleccione Enable Spanish Spell Checker Dictionary y finalmente seleccione User de la lista.\n\nPara que el corrector funcione simultáneamente con términos técnicos en inglés y redacción en español, puede añadir la siguiente configuración en su archivo settings.json de VSCode:\n{\n    \"cSpell.language\": \"en,es\",\n    \"cSpell.enabled\": true,\n    \"cSpell.spellCheckDelayMs\": 500,\n    \"cSpell.diagnosticLevel\": \"Information\"\n}\n\n\n\n\n\n\nDiccionario técnico\n\n\n\nA medida que trabaje con librerías como geopandas o ArchGDAL, es posible que el corrector marque estas palabras como errores. Puede agregarlas a su “Diccionario de Usuario” haciendo clic derecho sobre la palabra y seleccionando Add to User Dictionary.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>E</span>  <span class='chapter-title'>Visual Studio Code: Extensiones e Interfaz</span>"
    ]
  },
  {
    "objectID": "85-vscode.html#sec-sinergia-psql",
    "href": "85-vscode.html#sec-sinergia-psql",
    "title": "Apéndice E — Visual Studio Code: Extensiones e Interfaz",
    "section": "E.3 Sinergia de las extensiones de PostgreSQL en VSCode",
    "text": "E.3 Sinergia de las extensiones de PostgreSQL en VSCode\nContar con ambas extensiones instaladas dentro del contenedor no es redundancia, sino una estrategia para optimizar el flujo de trabajo con datos espaciales. Cada una ofrece una “capa” de interacción distinta que, al combinarse, potencia la productividad.\n\n\n\n\n\n\n\n\nExtensión\nFortaleza técnica\nUtilidad principal\n\n\n\n\nPostgreSQL (Chris Kolkman)\nExploración de objetos\nNavegar visualmente por esquemas, ver la lista de tablas y verificar columnas de PostGIS.\n\n\npsql (doublefint)\nEjecución de consultas\nEjecutar bloques de código SQL directamente desde scripts .sql con atajos de teclado rápidos.\n\n\n\n\nVentajas de la instalación dual\n\nValidación visual inmediata: Mientras escribe una consulta compleja en el editor (usando la extensión de doublefint), puede consultar el panel lateral de Chris Kolkman para verificar nombres de columnas o tipos de datos geográficos sin tener que hacer un SELECT *.\nSoporte de sintaxis robusto: La combinación garantiza que VSCode reconozca perfectamente las palabras clave de SQL y proporcione sugerencias automáticas (IntelliSense) precisas.\nResultados en pestañas independientes: Permite mantener los resultados de una consulta abiertos en una pestaña mientras se sigue editando el código en otra, algo fundamental cuando se comparan estadísticas de diferentes capas ráster o vectoriales.\n\n\n\n\n\n\n\nRecomendación de flujo\n\n\n\n\nUse el panel de Chris Kolkman para conectarse y “ver” qué hay en la base de datos.\nEscriba sus scripts de análisis espacial en archivos .sql y ejecútelos usando la extensión de doublefint para obtener una respuesta rápida en la consola.\n\n\n\n\n\n\n\n\n\nAtajo de teclado (Shortcut)\n\n\n\nPara la mayoría de estas extensiones, puede resaltar una consulta SQL y presionar Ctrl + E (o Cmd + E en Mac) para ejecutarla inmediatamente y ver los resultados en una tabla formateada.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>E</span>  <span class='chapter-title'>Visual Studio Code: Extensiones e Interfaz</span>"
    ]
  },
  {
    "objectID": "85-vscode.html#verificación-de-conectividad",
    "href": "85-vscode.html#verificación-de-conectividad",
    "title": "Apéndice E — Visual Studio Code: Extensiones e Interfaz",
    "section": "E.4 Verificación de conectividad",
    "text": "E.4 Verificación de conectividad\nUna vez instaladas las extensiones, verifique que su entorno esté correctamente configurado siguiendo estos puntos:\n\nEstado del Contenedor: En la esquina inferior izquierda de VSCode, debe aparecer un recuadro azul con el texto: Dev Container: contenedor_sig_unal.\nActivación de Kernels: Al abrir un archivo .qmd, en la esquina superior derecha debe poder seleccionar el kernel deseado (R, Python 3 o Julia).\nTerminal Unificada: Al abrir una nueva terminal (Ctrl + Shift + ), la línea de comandos debe estar identificada como rstudio@contenedor_sig_unal:/home/rstudio/work$.\n\n\n\n\n\n\n\nSincronización Automática\n\n\n\nRecuerde que cualquier cambio que realice en la configuración de estas extensiones mientras esté conectado al contenedor se guardará en su perfil local de VSCode, facilitando las conexiones futuras.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>E</span>  <span class='chapter-title'>Visual Studio Code: Extensiones e Interfaz</span>"
    ]
  },
  {
    "objectID": "86-windows.html",
    "href": "86-windows.html",
    "title": "Apéndice F — Temas técnicos sobre Windows",
    "section": "",
    "text": "F.1 Herramientas de administración",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>F</span>  <span class='chapter-title'>Temas técnicos sobre Windows</span>"
    ]
  },
  {
    "objectID": "86-windows.html#herramientas-de-administración",
    "href": "86-windows.html#herramientas-de-administración",
    "title": "Apéndice F — Temas técnicos sobre Windows",
    "section": "",
    "text": "Acceso Directo\nParámetro / Comando\nDescripción\n\n\n\n\nWindows + R\n%UserProfile%\nAbre tu carpeta personal de usuario (donde se crea el archivo .wslconfig).\n\n\nWindows + R\ncleanmgr\nAbre el Liberador de espacio en disco para purgar basura del sistema.\n\n\nWindows + R\ntaskmgr\n[Ctrl + Shift + Esc] Abre el Administrador de Tareas para ver procesos.\n\n\nWindows + R\nresmon\nAbre el Monitor de Recursos (ideal para ver el uso real de RAM y Swap).\n\n\nWindows + R\nsysdm.cpl\n[Win + Pausa] Propiedades del sistema (configuración de Memoria Virtual).\n\n\nWindows + R\n%temp%\nAbre la carpeta de Archivos temporales del usuario actual.\n\n\nWindows + R\ntemp\nAbre la carpeta de Archivos temporales del sistema (raíz).\n\n\nWindows + R\nprefetch\nCarpeta de precarga de Windows (caché que puedes vaciar para liberar espacio).\n\n\nWindows + R\ndiskmgmt.msc\nAbre la Administración de discos (para vigilar tus unidades C: y D:).\n\n\nWindows + R\nappdata\nAcceso a carpetas de configuración de aplicaciones (Roaming/Local).\n\n\nWindows + R\ncmd\n[Win + X, luego C] Abre el Símbolo del Sistema (Terminal clásica).\n\n\nWindows + R\npowershell\n[Win + X, luego A] Abre PowerShell con permisos de administrador.\n\n\nWindows + R\ncontrol\nAbre el Panel de Control clásico de Windows.\n\n\nWindows + R\nmsconfig\nConfiguración del sistema (gestión de servicios y arranque).\n\n\nWindows + R\nncpa.cpl\nPanel de Conexiones de red (configuración de adaptadores e IPs).\n\n\nNativo\nWin + E\nAbre instantáneamente el Explorador de Archivos.\n\n\nNativo\nWin + I\nAbre el panel de Configuración de Windows (Settings).\n\n\nNativo\nWin + D\nMinimiza/Restaura todo para ir al Escritorio rápidamente.\n\n\nNativo\nWin + V\nAbre el Historial del Portapapeles (muy útil para copiar varios códigos).\n\n\n\n\nProcesos de WSL2 (Windows Subsystem for Linux 2): Docker y Vmmem",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>F</span>  <span class='chapter-title'>Temas técnicos sobre Windows</span>"
    ]
  },
  {
    "objectID": "86-windows.html#comandos-powershell",
    "href": "86-windows.html#comandos-powershell",
    "title": "Apéndice F — Temas técnicos sobre Windows",
    "section": "F.2 Comandos (PowerShell)",
    "text": "F.2 Comandos (PowerShell)\n\nVer uso de RAM: Get-Process | Sort-Object WorkingSet -Descending | Select-Object -First 10\nVer estado de WSL: wsl --list --verbose\nLimpiar Cache de DNS: ipconfig /flushdns",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>F</span>  <span class='chapter-title'>Temas técnicos sobre Windows</span>"
    ]
  },
  {
    "objectID": "87-linux_ubuntu.html",
    "href": "87-linux_ubuntu.html",
    "title": "Apéndice G — Temas Técnicos sobre Linux",
    "section": "",
    "text": "G.1 Comandos adicionales antes de trabajar con los contenedores\nVer Sección A.1.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>G</span>  <span class='chapter-title'>Temas Técnicos sobre Linux</span>"
    ]
  },
  {
    "objectID": "87-linux_ubuntu.html#sec-comandos-so",
    "href": "87-linux_ubuntu.html#sec-comandos-so",
    "title": "Apéndice G — Temas Técnicos sobre Linux",
    "section": "G.2 Comandos comúnes de terminal",
    "text": "G.2 Comandos comúnes de terminal\nAl trabajar dentro de un contenedor Docker, la terminal es su línea directa con el sistema operativo (Ubuntu/Debian). Estos comandos le permitirán verificar que los motores geoespaciales y las librerías de sistema están correctamente instalados.\n\n\n\n\n\n\n\n\nComando\nPropósito\n¿Para qué sirve en el curso?\n\n\n\n\ndpkg -l \\| grep -E \"libpng\\|libgdal\\|libproj\\|libgeos\"\nLista librerías instaladas\nVerificar que los drivers de mapas (GDAL, PROJ, GEOS) están activos.\n\n\ngdalinfo --version\nVersión de GDAL\nConfirmar que el motor de traducción de datos geográficos funciona.\n\n\ndf -h\nEspacio en disco\nEvitar errores de “Disk Full” al descargar imágenes satelitales pesadas.\n\n\nhtop (o top)\nMonitor de recursos\nVer si un proceso de Julia o R está consumiendo toda la RAM o CPU.\n\n\nls -la\nListado detallado\nRevisar permisos de archivos y carpetas (clave para errores de Git).\n\n\npsql --version\nVersión de Postgres\nConfirmar que el cliente de base de datos está listo para usarse.\n\n\nwhich r / which julia\nRuta del ejecutable\nLocalizar dónde están instalados los lenguajes para configurar el Path.\n\n\nfc-list \\| grep -i \"Symbola\"\nBuscar fuentes del sistema\nLocalizar la ruta exacta de fuentes necesarias para emojis y símbolos en el PDF.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>G</span>  <span class='chapter-title'>Temas Técnicos sobre Linux</span>"
    ]
  },
  {
    "objectID": "87-linux_ubuntu.html#verificación-de-librerías-geoespaciales",
    "href": "87-linux_ubuntu.html#verificación-de-librerías-geoespaciales",
    "title": "Apéndice G — Temas Técnicos sobre Linux",
    "section": "G.3 Verificación de librerías geoespaciales",
    "text": "G.3 Verificación de librerías geoespaciales\nEl comando dpkg -l | grep -E \"libpng|libgdal|libproj|libgeos\" es su principal herramienta de diagnóstico. Si al ejecutarlo no obtiene resultados, las funciones de mapeo en R (sf), Python (geopandas) y Julia (ArchGDAL) fallarán, ya que todas dependen de estos binarios del sistema.\n\n\n\n\n\n\nTip de Productividad\n\n\n\nEn la terminal de VSCode, puede usar la tecla Tab para autocompletar nombres de archivos o comandos, y las flechas arriba/abajo para navegar por el historial de comandos ejecutados.\n\n\n\n¿Cómo leer la salida de dpkg?\nAl ejecutar el comando de verificación, verá una lista con el prefijo ii. Esto significa: * i: Desired state (Install) * i: Current state (Installed)\nSi ve algo diferente a ii, el paquete tiene problemas de instalación.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>G</span>  <span class='chapter-title'>Temas Técnicos sobre Linux</span>"
    ]
  },
  {
    "objectID": "87-linux_ubuntu.html#sec-openssl-surgery",
    "href": "87-linux_ubuntu.html#sec-openssl-surgery",
    "title": "Apéndice G — Temas Técnicos sobre Linux",
    "section": "G.4 La cirugía de librerías: el “cambiazo” de OpenSSL",
    "text": "G.4 La cirugía de librerías: el “cambiazo” de OpenSSL\nAl trabajar con contenedores de última generación, a veces nos encontramos con un choque de versiones entre lo que el sistema operativo ofrece y lo que los lenguajes de programación esperan. En nuestro caso, realizamos una “cirugía” técnica utilizando enlaces simbólicos (ln -sf).\n\nEl conflicto: ¿3.0.x o 3.3.x?\nLa respuesta corta es: Físicamente tiene instalada la versión 3.0.x, pero le mentimos al software diciéndole que es la 3.3.x.\n\nLa Realidad (Sistema): Su contenedor corre sobre Ubuntu 24.04 (Noble Numbat). Esta versión viene de fábrica con OpenSSL 3.0.x, que es la versión estable y oficial del sistema.\nLa Expectativa (Julia): Algunos paquetes potentes de Julia (como los binarios JLL de GDAL o NCDatasets) fueron compilados en entornos más recientes que ya usaban OpenSSL 3.3.x.\n\nCuando Julia intenta arrancar, busca una “etiqueta” interna llamada OPENSSL_3.3.0. Al no encontrarla en la librería de Ubuntu, el sistema lanza un error y bloquea la carga de mapas.\n\n\nLa solución: ¿qué hace exactamente ln -sf?\nImagine que Julia es un guardia de seguridad que busca una llave maestra etiquetada como “Llave 3.3”. Al revisar la caja fuerte (el sistema), solo ve la “Llave 3.0” y se niega a abrir. Lo que hicimos fue un “cambiazo” estratégico.\nEjecutamos este comando de “cirugía”:\nfind /root/.julia/artifacts -name \"libssl.so*\" -exec ln -sf /usr/lib/x86_64-linux-gnu/libssl.so.3 {} \\;\nDesglose de la operación: 1. find ... -name \"libssl.so*\": Localiza todos los archivos de librería que Julia descargó por su cuenta (sus propios binarios internos). 2. -exec ln -sf ... {}: Por cada archivo encontrado, borra el original (la -f de force) y crea un enlace simbólico (la -s de symbolic). 3. El Destino: El enlace apunta directamente a la librería real de Ubuntu (/usr/lib/.../libssl.so.3).\n\n\n¿por qué funciona si las versiones son distintas?\nFunciona gracias a que OpenSSL 3 mantiene algo llamado compatibilidad binaria entre sus versiones menores. Las funciones internas se llaman exactamente igual; lo único que cambió fue el “nombre del archivo” que Julia buscaba.\nAl redirigir el nombre, Julia utiliza la librería de Ubuntu pensando que es la suya, y como las instrucciones internas son compatibles, el sistema arranca sin errores y con total estabilidad.\n\n\n\n\n\n\nImportancia para el SIG\n\n\n\nSin esta cirugía, paquetes como ArchGDAL en Julia no podrían cargar los controladores para leer archivos .tif o conectarse a bases de datos espaciales, ya que la comunicación segura (SSL) fallaría al inicio.\n\n\n\n\nLa “factura” de la cirugía: el adiós a JuliaCall\nComo en toda operación de emergencia, el “cambiazo” de librerías tuvo un efecto secundario importante: la ruptura definitiva de la compatibilidad con JuliaCall, el puente más común entre R y Julia.\n\nEl Conflicto: JuliaCall intenta embeber a Julia directamente dentro del proceso de R (comparten la misma memoria). Al detectar que las librerías de OpenSSL han sido redirigidas mediante enlaces simbólicos, el proceso de R entra en un conflicto de seguridad y colapsa inmediatamente (Segmentation Fault), impidiendo cualquier comunicación.\nLa Solución: Para no renunciar a la integración de ambos lenguajes, cambiamos de estrategia y adoptamos JuliaConnectoR. A diferencia del método anterior, este paquete trata a Julia como un servicio independiente que se comunica mediante sockets. Esto lo hace inmune al conflicto de OpenSSL, ya que cada lenguaje corre en su propia parcela de memoria.\n\n\n\nEl nacimiento de j_eval y j_plot\nPara que este cambio de arquitectura fuera invisible para el usuario final, se desarrollaron dos funciones “envolventes” (wrappers) que automatizan la traducción entre lenguajes:\n\nj_eval(): Toma comandos escritos en R, los envía al motor de Julia de forma segura y captura el resultado (numérico o textual) para devolverlo a la consola de R. Es el cerebro detrás de nuestros benchmarks.\nj_plot(): Resuelve el problema del renderizado. Julia genera la visualización geoespacial “tras bambalinas”, y esta función captura la salida gráfica para insertarla automáticamente en el reporte de Quarto.\n\n\n\n\n\n\n\nConclusión Técnica\n\n\n\nGracias a esta combinación estratégica (Cirugía OpenSSL + JuliaConnectoR + Funciones j_), logramos lo que parecía imposible en un entorno Docker restrictivo: un ecosistema donde R, Python y Julia conviven en paz, permitiéndonos procesar datos masivos sin colapsos de memoria ni errores de librerías.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>G</span>  <span class='chapter-title'>Temas Técnicos sobre Linux</span>"
    ]
  },
  {
    "objectID": "88-python.html",
    "href": "88-python.html",
    "title": "Apéndice H — Adicionales Sobre Python",
    "section": "",
    "text": "H.1 Versiones instaladas del software\nPara verificar las versiones instaladas, puede ejecutar pip3 list en la terminal. Las versiones instaladas deben coincidir con la siguiente tabla:",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>H</span>  <span class='chapter-title'>Adicionales Sobre Python</span>"
    ]
  },
  {
    "objectID": "88-python.html#versiones-instaladas-del-software",
    "href": "88-python.html#versiones-instaladas-del-software",
    "title": "Apéndice H — Adicionales Sobre Python",
    "section": "",
    "text": "Software\nTipo\nVersión\nComando (desde terminal)\nComando (desde Python)\n\n\n\n\nPython\nLenguaje\n3.12.3\npython3 --version\nimport sys; sys.version\n\n\npip\nGestor de paquetes\n24.0\npip3 --version\nimport pip; pip.__version__\n\n\nnumpy\nPaquete\n2.4.1\npip3 show numpy\nimport numpy; numpy.__version__\n\n\npandas\nPaquete\n2.3.3\npip3 show pandas\nimport pandas; pandas.__version__\n\n\ngeopandas\nPaquete\n1.1.2\npip3 show geopandas\nimport geopandas; geopandas.__version__\n\n\nshapely\nPaquete\n2.1.2\npip3 show shapely\nimport shapely; shapely.__version__\n\n\npyproj\nPaquete\n3.7.2\npip3 show pyproj\nimport pyproj; pyproj.__version__\n\n\nfiona\nPaquete\n1.10.1\npip3 show fiona\nimport fiona; fiona.__version__\n\n\nrasterio\nPaquete\n1.5.0\npip3 show rasterio\nimport rasterio; rasterio.__version__",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>H</span>  <span class='chapter-title'>Adicionales Sobre Python</span>"
    ]
  },
  {
    "objectID": "89-r.html",
    "href": "89-r.html",
    "title": "Apéndice I — Adicionales Sobre R",
    "section": "",
    "text": "I.1 Versiones instaladas del software\nVersiones que deben quedar instaladas en el sistema R:",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>I</span>  <span class='chapter-title'>Adicionales Sobre R</span>"
    ]
  },
  {
    "objectID": "89-r.html#versiones-instaladas-del-software",
    "href": "89-r.html#versiones-instaladas-del-software",
    "title": "Apéndice I — Adicionales Sobre R",
    "section": "",
    "text": "Software\nTipo\nVersión\nComando (desde terminal)\nComando (desde R)\n\n\n\n\nR\nLenguaje\n4.5.2\nR --version\nR.version.string\n\n\nGEOS\nLibrería sistema\n3.12.1\ngeos-config --version\nsf::sf_extSoftVersion()[\"GEOS\"]\n\n\nGDAL\nLibrería sistema\n3.8.4\ngdalinfo --version\nsf::sf_extSoftVersion()[\"GDAL\"]\n\n\nPROJ\nLibrería sistema\n9.4.0\n(no aplica / no disponible)\nsf::sf_extSoftVersion()[\"PROJ\"]\n\n\nsf\nPaquete\n1.0.23\nR -q -e \"packageVersion('sf')\"\npackageVersion(\"sf\")\n\n\nterra\nPaquete\n1.8.86\nR -q -e \"packageVersion('terra')\"\npackageVersion(\"terra\")\n\n\nstars\nPaquete\n0.7.0\nR -q -e \"packageVersion('stars')\"\npackageVersion(\"stars\")",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>I</span>  <span class='chapter-title'>Adicionales Sobre R</span>"
    ]
  },
  {
    "objectID": "89-r.html#sec-httpgd-config",
    "href": "89-r.html#sec-httpgd-config",
    "title": "Apéndice I — Adicionales Sobre R",
    "section": "I.2 Visualización interactiva con httpgd",
    "text": "I.2 Visualización interactiva con httpgd\nDado que nuestro entorno Docker es “headless” (sin monitor propio), utilizamos httpgd como un servidor gráfico intermedio. Este paquete captura las señales de dibujo de R y las sirve a través de una URL que VSCode puede renderizar.\n\nInicio del servidor gráfico\nCada vez que inicie una nueva sesión de R, debe despertar al servidor manualmente:\n# Inicia el motor gráfico\nhttpgd::hgd()\n\n# Verifica el estado y el puerto asignado\nhttpgd::hgd_details()\n\n\nResolución de conflictos (el “fix” del puerto)\nEn nuestro contenedor, el puerto estándar para gráficos está mapeado al 8787. Si al ejecutar hgd_details() nota que el sistema asignó un puerto aleatorio o si el visor aparece en blanco, fuerce la conexión con la siguiente “receta”:\n# Forzar host y puerto para compatibilidad con Docker\nhttpgd::hgd(host = \"0.0.0.0\", port = 8787, token = FALSE)\n\n\nFormas de ver sus gráficos\nUna vez el servidor está corriendo, tiene dos caminos para visualizar sus mapas:\n\n\n\n\n\n\n\n\nMétodo\nComando / Acción\nVentaja\n\n\n\n\nVisor Interno\nCtrl + Shift + P -&gt; Open httpgd viewer\nMantiene todo dentro de una pestaña de VSCode.\n\n\nNavegador Externo\nhttpgd::hgd_browse()\nIdeal si trabaja con dos monitores para ver mapas en pantalla completa.\n\n\n\n\n\n\n\n\n\n¿Por qué token = FALSE?\n\n\n\nDentro del entorno seguro del contenedor, desactivamos el token para facilitar la conexión inmediata entre el servidor de R y el visor de VSCode sin que el firewall interno bloquee la petición por falta de credenciales.\n\n\n\n\nVerificación de salud\nSi después de iniciar el servidor intenta graficar algo (ej: plot(1:10)) y no ve nada, ejecute httpgd::hgd_details(). Asegúrese de que: 1. URL: Apunte a http://0.0.0.0:8787. 2. Status: Indique que está escuchando (listening).\n\n\nEl Entorno interactivo (REPL) y motores gráficos\nEn el desarrollo científico, el REPL (Read-Eval-Print Loop) es la consola interactiva que permite la “programación exploratoria”. Es el ciclo donde el sistema lee su instrucción, la evalúa mediante el motor correspondiente, imprime el resultado y queda en un bucle a la espera del siguiente comando.\nEn nuestro laboratorio políglota, la identidad visual del REPL es su brújula para saber en qué lenguaje está operando:\n\n\n\n\n\n\n\n\nLenguaje\n¿Cómo se ve el REPL?\nCaracterísticas en este curso\n\n\n\n\nR\n&gt;\nConsola estándar para procesos geoespaciales con sf o terra.\n\n\nJulia\njulia&gt;\nEntorno de alto rendimiento con modos de ayuda (?) y terminal (;).\n\n\nPython\n&gt;&gt;&gt;\nConsola básica; se recomienda el uso de IPython para interactividad.\n\n\n\nLa experiencia interactiva y el soporte gráfico dentro de VSCode dependen de la combinación entre el motor de ejecución y el dispositivo gráfico configurado en el contenedor:\n\n\n\n\n\n\n\n\n\n\nLenguaje\nAcceso / Contexto\nMotor de Ejecución\nDispositivo Gráfico\nSoporte Inline\n\n\n\n\nR\nNativo (Estático)\nR Extension\nVSCode Plots (Pane)\n✅\n\n\nR\nNativo (Interactivo)\nR Extension\nhttpgd\n✅\n\n\nJulia\nNativo (REPL)\nVSCodeServer\nVSCode Plots (Pane)\n✅\n\n\nJulia\nInterop (R-Bridge)\nJuliaConnectoR\nhttpgd (vía R)\n✅\n\n\nPython\nInterop (R-Bridge)\nreticulate\nR Device (httpgd)\n❌ / ⚠️\n\n\nPython\nNativo (Jupyter)\nJupyter kernel\nJupyter Viewer\n✅\n\n\n\n\n\nEl rol crítico de httpgd en R\nPara R, no basta con tener la extensión instalada. El paquete httpgd actúa como un servidor web interno que captura los gráficos generados en el contenedor y los “proyecta” en VSCode.\n\n¿Por qué lo usamos? Los dispositivos gráficos tradicionales (como X11 o windows()) no funcionan dentro de un contenedor Docker (headless). httpgd soluciona esto convirtiendo cada mapa en un elemento interactivo SVG/HTML renderizable.\nActivación: Siempre debe iniciar su sesión de R ejecutando httpgd::hgd() para abrir este canal de comunicación.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>I</span>  <span class='chapter-title'>Adicionales Sobre R</span>"
    ]
  },
  {
    "objectID": "89-r.html#sec-interoperabilidad",
    "href": "89-r.html#sec-interoperabilidad",
    "title": "Apéndice I — Adicionales Sobre R",
    "section": "I.3 Paquetes para comunicación con Julia y Python",
    "text": "I.3 Paquetes para comunicación con Julia y Python\nPara que este ecosistema funcione, R actúa como el “director de orquesta” utilizando un motor de ejecución y una serie de puentes que permiten la comunicación fluida de datos entre lenguajes.\n\n\n\n\n\n\n\n\n\nLenguaje / Función\nPaquete en R\nMotor / Propósito\nEstado\n\n\n\n\nRenderizado\nknitr\nMotor maestro que orquesta la ejecución de celdas en el documento\n✅\n\n\nJulia\nJuliaConnectoR\nComunicación funcional estable con el kernel de Julia\n✅\n\n\nPython\nreticulate\nInteroperabilidad de objetos y ejecución de Python\n✅\n\n\nLSP (Soporte)\nlanguageserver\nAutocompletado, IntelliSense y ayuda en tiempo real\n✅\n\n\n\n\nEl rol de knitr\nMientras que los paquetes actúan como puentes técnicos, knitr es el encargado de leer el archivo .qmd, enviar las instrucciones a los motores respectivos y capturar los resultados (tablas, mapas, gráficos) para integrarlos en el documento final. Sin knitr, la integración políglota de Quarto no sería posible.\n\n\nTransición técnica: De JuliaCall a JuliaConnectoR\nEn el diseño de este entorno, se tomó la decisión técnica de descartar el paquete JuliaCall en favor de JuliaConnectoR:\n\nEl Problema: JuliaCall presentaba inestabilidades al gestionar dependencias dinámicas compartidas (como libcurl o libstdc++) dentro del contenedor, causando cierres inesperados (crashes) de la sesión de R.\nLa Sustitución: Se seleccionó JuliaConnectoR por su arquitectura más limpia, que no interfiere con el entorno de Julia ya configurado en el sistema operativo.\nLa Solución: La integración se resolvió mediante una “inyección” de código en el archivo Rprofile.site, configurando automáticamente la ruta del ejecutable en $Sys.BINDIR$ y definiendo las funciones maestras j_eval() y j_plot().\n\n\n\n\n\n\n\n🧠 Regla de Oro del Curso\n\n\n\n\nJulia y R: Se operan de manera totalmente interactiva en VSCode (envío de líneas con Ctrl+Enter).\nPython vía reticulate: Se utiliza primordialmente para el renderizado (vía knitr) de informes finales. Para una programación interactiva pura en Python, se recomienda el uso de los Jupyter kernels.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>I</span>  <span class='chapter-title'>Adicionales Sobre R</span>"
    ]
  },
  {
    "objectID": "90-julia.html",
    "href": "90-julia.html",
    "title": "Apéndice J — Adicionales Sobre Julia",
    "section": "",
    "text": "J.1 Versiones instaladas del software\nVersiones de paquetes Julia en el sistema:",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>J</span>  <span class='chapter-title'>Adicionales Sobre Julia</span>"
    ]
  },
  {
    "objectID": "90-julia.html#versiones-instaladas-del-software",
    "href": "90-julia.html#versiones-instaladas-del-software",
    "title": "Apéndice J — Adicionales Sobre Julia",
    "section": "",
    "text": "Software\nTipo\nVersión\nComando (desde terminal)\nComando (desde Julia)\n\n\n\n\nJulia\nLenguaje\n1.10.4\njulia --version\nVERSION\n\n\nLibPQ\nPaquete\n1.18.0\njulia -e \"using LibPQ; println(pkgversion(LibPQ))\"\nusing LibPQ; pkgversion(LibPQ)\n\n\nArchGDAL\nPaquete\n0.10.11\njulia -e \"using ArchGDAL; println(pkgversion(ArchGDAL))\"\nusing ArchGDAL; pkgversion(ArchGDAL)\n\n\nLibGEOS\nPaquete\n0.9.7\njulia -e \"using LibGEOS; println(pkgversion(LibGEOS))\"\nusing LibGEOS; pkgversion(LibGEOS)\n\n\nPlots\nPaquete\n1.41.4\njulia -e \"using Plots; println(pkgversion(Plots))\"\nusing Plots; pkgversion(Plots)\n\n\nDataFrames\nPaquete\n1.8.1\njulia -e \"using DataFrames; println(pkgversion(DataFrames))\"\nusing DataFrames; pkgversion(DataFrames)",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>J</span>  <span class='chapter-title'>Adicionales Sobre Julia</span>"
    ]
  },
  {
    "objectID": "98-errata.html",
    "href": "98-errata.html",
    "title": "Apéndice K — Errata",
    "section": "",
    "text": "Esta es la errata",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>K</span>  <span class='chapter-title'>Errata</span>"
    ]
  },
  {
    "objectID": "99-referencias.html",
    "href": "99-referencias.html",
    "title": "Referencias Bibliográficas",
    "section": "",
    "text": "Bezanson, J., Edelman, A., Karpinski, S., & Shah, V. B. (2017).\nJulia: A fresh approach to numerical computing. SIAM Review,\n59(1), 65–98.\n\n\nDorman, M. (2025). Spatial data programming with python.\nBen-Gurion University of the Negev. https://geobgu.xyz/py-2025/\n\n\nInc., D. (2025). Docker desktop documentation. https://docs.docker.com\n\n\nLaw, M., & Collins, A. (2019). Getting to know ArcGIS PRO. (No\nTitle).\n\n\nLawhead, J. (2017). QGIS python programming cookbook. Packt\nPublishing Ltd.\n\n\nMicrosoft Corporation. (2026). Visual studio code. https://code.visualstudio.com/\n\n\nMitchell, T. (2015). An introduction to open source geospatial\ntools.\n\n\nNeteler, M., Bowman, M. H., Landa, M., & Metz, M. (2012). GRASS GIS:\nA multi-purpose open source GIS. Environmental Modelling &\nSoftware, 31, 124–130.\n\n\nPassy, P., & Théry, S. (2018). The use of SAGA GIS modules in QGIS.\nQGIS and Generic Tools, 1, 107–149.\n\n\nPebesma, E., & Bivand, R. (2023). Spatial data science: With\napplications in R. Chapman; Hall/CRC. https://doi.org/10.1201/9780429459016\n\n\nPebesma, E., & Bivand, R. (2025). Spatial data science: With\napplications in R and Python. https://r-spatial.org/python/\n\n\nPython Software Foundation. (2025). Python 3 documentation. https://docs.python.org/3/\n\n\nPython, W. (2021). Python. Python Releases for Windows,\n24. http://static.softwaresuggest.com.s3.amazonaws.com/ssguides/1604480172_Python_read%20(1).pdf\n\n\nR Core Team. (2025). R: A language and environment for statistical\ncomputing. R Foundation for Statistical Computing. https://www.R-project.org/\n\n\nRosas-Chavoya, M., Gallardo-Salazar, J. L., López-Serrano, P. M.,\nAlcántara-Concepción, P. C., & León-Miranda, A. K. (2022). QGIS a\nconstantly growing free and open-source geospatial software contributing\nto scientific development. Cuadernos de Investigación\nGeográfica, 48(1), 197–213.\n\n\nToms, S. (2015). ArcPy and ArcGIS–geospatial analysis with\npython. Packt Publishing Ltd.\n\n\nWijayaningrum, V. N., Lestari, V. A., et al. (2022). Jupyter lab\nplatform-based interactive learning. 2022 International Conference\non Electrical and Information Technology (IEIT), 295–301.\n\n\nWu, Q. (2023a). PyQGIS cookbook in markdown and jupyter notebook\nformats. In GitHub repository. https://github.com/opengeos/pyqgis-cookbook; GitHub.\n\n\nWu, Q. (2023b). QGIS notebook plugin: Integrate jupyter notebooks into\nQGIS. In GitHub repository [Computer software]. https://github.com/opengeos/qgis-notebook-plugin;\nGitHub.\n\n\nXie, Y. (2019). TinyTeX: A lightweight, cross-platform, and\neasy-to-maintain LaTeX distribution based on TeX live. TUGboat,\n40(1), 30–32.",
    "crumbs": [
      "Apéndices",
      "Referencias Bibliográficas"
    ]
  }
]