[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Programación SIG: Python, R y Julia",
    "section": "",
    "text": "Bienvenida\nBienvenido a la documentación del curso Programación en SIG de la Maestría en Geomática de la Universidad Nacional de Colombia.\nEste recurso ha sido diseñado como una guía teórico-práctica para el análisis y procesamiento de datos geográficos utilizando los tres lenguajes más potentes en la ciencia de datos actual: Python, R y Julia.",
    "crumbs": [
      "Bienvenida"
    ]
  },
  {
    "objectID": "index.html#objetivos-del-curso",
    "href": "index.html#objetivos-del-curso",
    "title": "Programación SIG: Python, R y Julia",
    "section": "Objetivos del curso",
    "text": "Objetivos del curso\nEl objetivo principal es que el estudiante desarrolle habilidades para automatizar procesos geoespaciales y construir flujos de trabajo reproducibles.\n\nPython: Lenguaje principal de enfoque.\nR: Comparativa para análisis estadístico espacial.\nJulia: Alternativa de alto rendimiento para computación científica.",
    "crumbs": [
      "Bienvenida"
    ]
  },
  {
    "objectID": "index.html#cómo-usar-este-libro",
    "href": "index.html#cómo-usar-este-libro",
    "title": "Programación SIG: Python, R y Julia",
    "section": "Cómo usar este libro",
    "text": "Cómo usar este libro\nA lo largo de los capítulos, encontrarás ejemplos de código organizados en pestañas (tabs). Aunque el énfasis de las explicaciones está en Python, puedes alternar entre lenguajes para ver cómo se implementa la misma lógica en los otros entornos:\n\n\n\n\n\n\nNota\n\n\n\nUtiliza las pestañas superiores en los bloques de código para cambiar entre Python, R y Julia.",
    "crumbs": [
      "Bienvenida"
    ]
  },
  {
    "objectID": "index.html#requisitos-previos",
    "href": "index.html#requisitos-previos",
    "title": "Programación SIG: Python, R y Julia",
    "section": "Requisitos previos",
    "text": "Requisitos previos\nPara seguir este curso, se proveen guías de instalación de: - Docker Desktop (para el entorno unificado). - Editor de código VSCode. - QGIS - ArcGIS Pro - Conocimientos básicos de Sistemas de Información Geográfica (SIG) y manejo de datos vectoriales/raster.",
    "crumbs": [
      "Bienvenida"
    ]
  },
  {
    "objectID": "index.html#sec-licencia",
    "href": "index.html#sec-licencia",
    "title": "Programación SIG: Python, R y Julia",
    "section": "Licencia y citación del material",
    "text": "Licencia y citación del material\n\nLicencia de uso\nEste material de curso se distribuye bajo una licencia Creative Commons Atribución-NoComercial 4.0 Internacional (CC BY-NC 4.0).\n\n\n\n\n\n\nLo que esto significa para el estudiante:\n\n\n\nBajo los principios de Open Science, usted es libre de: 1. Compartir: Copiar y redistribuir el material en cualquier medio o formato. 2. Adaptar: Remezclar, transformar y construir sobre el material para fines académicos e investigativos.\nBajo las siguientes condiciones: * Atribución: Debe dar crédito de manera adecuada, brindar un enlace a la licencia e indicar si se han realizado cambios. * No comercial: No puede hacer uso del material con fines comerciales o de lucro.\n\n\n\n\n\nCómo citar este material\nSi utiliza este código, las guías o los datos en sus propios proyectos o investigaciones, por favor incluya las siguientes referencias:\n\nReferencia en formato APA (7ma edición)\n\nRodríguez-Avellaneda, A. H. (2026). Programación en SIG: R, Python y Julia [Material de curso]. Maestría en Geomática, Universidad Nacional de Colombia. Recuperado de https://github.com/alexyshr/ProgramacionSIG2026\n\n\n\nReferencia en formato BibTeX (Para LaTeX/Zotero)\n@misc{rodriguez2026sig,\n  author = {Rodriguez-Avellaneda, Alexys H.},\n  title = {Programación en SIG: R, Python y Julia},\n  year = {2026},\n  howpublished = {Material de curso, Maestría en Geomática},\n  publisher = {Universidad Nacional de Colombia},\n  url = {[https://github.com/alexyshr/ProgramacionSIG2026](https://github.com/alexyshr/ProgramacionSIG2026)},\n  note = {Licencia CC BY-NC 4.0}\n}",
    "crumbs": [
      "Bienvenida"
    ]
  },
  {
    "objectID": "index.html#sec-contacto",
    "href": "index.html#sec-contacto",
    "title": "Programación SIG: Python, R y Julia",
    "section": "Contacto y colaboración",
    "text": "Contacto y colaboración\nEste documento es una obra en construcción permanente en el marco de la ciencia abierta. Si encuentra errores, omisiones o desea proponer mejoras técnicas en los flujos de R, Python o Julia, puede colaborar de las siguientes formas:\n\nAbrir un Issue: Para reportar errores en el código o en la redacción.\nEnviar un Pull Request: Si desea proponer una corrección directa o una nueva funcionalidad.\n\n\n\n\n\n\n\nReconocimiento a herramientas de IA\n\n\n\nGran parte de la orquestación técnica de este entorno (especialmente la resolución de conflictos de librerías en Docker y la creación de funciones puente como j_eval) ha sido refinada con el apoyo de herramientas de Inteligencia Artificial, bajo la supervisión y validación del autor principal.",
    "crumbs": [
      "Bienvenida"
    ]
  },
  {
    "objectID": "00-prefacio.html",
    "href": "00-prefacio.html",
    "title": "Prefacio",
    "section": "",
    "text": "Filosofía del curso: El enfoque “Políglota”\nA diferencia de los cursos tradicionales centrados exclusivamente en un software o un solo lenguaje, este curso adopta una visión inspirada en el trabajo de Edzer Pebesma y Roger Bivand en Spatial Data Science (Pebesma & Bivand, 2023, 2025).\nNuestro enfoque es Python-céntrico, reconociendo su dominio en la industria y la inteligencia artificial, pero integramos R y Julia como aliados estratégicos:",
    "crumbs": [
      "Prefacio"
    ]
  },
  {
    "objectID": "00-prefacio.html#filosofía-del-curso-el-enfoque-políglota",
    "href": "00-prefacio.html#filosofía-del-curso-el-enfoque-políglota",
    "title": "Prefacio",
    "section": "",
    "text": "Python: Nuestra base para la automatización, desarrollo de scripts y flujos de trabajo en la nube.\nR: Para cuando el análisis requiere un rigor estadístico espacial profundo y una visualización cartográfica de alta calidad.\nJulia: Para computación científica de alto rendimiento donde la velocidad de ejecución es crítica.",
    "crumbs": [
      "Prefacio"
    ]
  },
  {
    "objectID": "00-prefacio.html#por-qué-tres-lenguajes",
    "href": "00-prefacio.html#por-qué-tres-lenguajes",
    "title": "Prefacio",
    "section": "¿Por qué tres lenguajes?",
    "text": "¿Por qué tres lenguajes?\nEl objetivo no es que el estudiante sea un experto programador en los tres, sino que comprenda que los motores geoespaciales subyacentes (como GDAL, GEOS y PROJ) son los mismos. Al aprender a interactuar con ellos desde diferentes sintaxis, el estudiante desarrolla una flexibilidad mental que le permitirá adaptarse a cualquier tecnología futura.",
    "crumbs": [
      "Prefacio"
    ]
  },
  {
    "objectID": "00-prefacio.html#datos-de-colombia-como-eje-central",
    "href": "00-prefacio.html#datos-de-colombia-como-eje-central",
    "title": "Prefacio",
    "section": "Datos de Colombia como eje central",
    "text": "Datos de Colombia como eje central\nLa teoría es universal, pero la práctica es local. Todos los ejemplos y ejercicios de este curso están diseñados utilizando datos reales del contexto colombiano:\n\nCapas vectoriales del IGAC y límites administrativos del DANE.\nModelos Digitales de Elevación y productos satelitales sobre la geografía nacional.\nSistemas de Referencia de Coordenadas basados en MAGNA-SIRGAS.",
    "crumbs": [
      "Prefacio"
    ]
  },
  {
    "objectID": "00-prefacio.html#estructura-de-la-documentación",
    "href": "00-prefacio.html#estructura-de-la-documentación",
    "title": "Prefacio",
    "section": "Estructura de la documentación",
    "text": "Estructura de la documentación\nPara facilitar el aprendizaje comparado, esta guía utiliza un sistema de pestañas. En la mayoría de los capítulos, verás bloques de código organizados así:\n\nPython (principal)R (alternativa)Julia (alto rendimiento)\n\n\nExplicación de la implementación en Python usando librerías como geopandas, rasterio o shapely.\n\n\nEquivalente funcional utilizando sf, terra o stars.\n\n\nImplementación moderna usando ArchGDAL.jl, GeomStats.jl o Rasters.jl.",
    "crumbs": [
      "Prefacio"
    ]
  },
  {
    "objectID": "00-prefacio.html#reproducibilidad",
    "href": "00-prefacio.html#reproducibilidad",
    "title": "Prefacio",
    "section": "Reproducibilidad",
    "text": "Reproducibilidad\nSiguiendo los estándares de la ciencia abierta, todo el entorno de este curso está preconfigurado en contenedores Docker. Esto garantiza que el código que funciona en el computador del profesor funcionará exactamente igual en el del estudiante, eliminando el “infierno de las dependencias” de instalación.\n\n\n\n\nPebesma, E., & Bivand, R. (2023). Spatial Data Science: With Applications in R. Chapman; Hall/CRC. https://doi.org/10.1201/9780429459016\n\n\nPebesma, E., & Bivand, R. (2025). Spatial Data Science: With Applications in R and Python. https://r-spatial.org/python/",
    "crumbs": [
      "Prefacio"
    ]
  },
  {
    "objectID": "01-introduccion-entornos.html",
    "href": "01-introduccion-entornos.html",
    "title": "1  Introducción a Entornos de Desarrollo SIG",
    "section": "",
    "text": "1.1 Estrategia de Trabajo: Arquitectura Híbrida\nPara el desarrollo del curso, utilizaremos tres enfoques que permiten equilibrar la potencia del software de escritorio (comercial y libre) con el rigor de la ciencia de datos reproducible. Esta estructura garantiza que el estudiante adquiera competencias tanto en la automatización de software SIG tradicional como en el análisis de datos geoespaciales moderno.",
    "crumbs": [
      "Instalación y Entornos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción a Entornos de Desarrollo SIG</span>"
    ]
  },
  {
    "objectID": "01-introduccion-entornos.html#estrategia-de-trabajo-arquitectura-híbrida",
    "href": "01-introduccion-entornos.html#estrategia-de-trabajo-arquitectura-híbrida",
    "title": "1  Introducción a Entornos de Desarrollo SIG",
    "section": "",
    "text": "Comparativa de Entornos\n\n\n\n\n\n\n\n\n\nCriterio\nOpción A: Contenedor (Docker)\nOpción B: Nativo (OSGeo4W)\nOpción C: Nativo (ArcGIS Pro)\n\n\n\n\nTecnología\nDocker (Inc., 2025) Compose (JupyterLab).\nOSGeo4W - QGIS (Rosas-Chavoya et al., 2022) LTR.\nArcGIS Pro (Law & Collins, 2019) (Conda Environment).\n\n\nUso Principal\nAnálisis masivo y Ciencia de Datos.\nAutomatización SIG con PyQGIS (Lawhead, 2017).\nGeoprocesamiento y ArcPy (Toms, 2015).\n\n\nVentaja\nEntorno idéntico y reproducible.\nAcceso a drivers locales y QGIS.\nHerramientas comerciales avanzadas.\n\n\nLenguajes\nPython (Python, 2021), R (R Core Team, 2025) y Julia (Bezanson et al., 2017) (Preconfigurados).\nPython (PyQGIS).\nPython (ArcPy).\n\n\n\n\n\nSecuencia Didáctica y Uso de Entornos\nEl curso seguirá una progresión lógica desde la abstracción de datos y bases de datos hacia la automatización en software especializado:\n\n\n\n\n\n\n\n\n\nEtapa\nEntorno Sugerido\nContenido Temático\nRazón\n\n\n\n\nFase 1: Fundamentos y DB (Semanas 1-7)\nOpción A: Docker\nPrincipios de programación, estructuras básicas, Ciencia de Datos políglota y PostGIS.\nEntorno controlado para aprender lógica de programación y gestión de bases de datos sin conflictos de instalación.\n\n\nFase 2: Extensibilidad Libre (Semanas 8-11)\nOpción B: OSGeo4W\nDesarrollo de scripts, complementos y automatización dentro de QGIS.\nUso de Python (PyQGIS) para extender las capacidades del software libre más relevante.\n\n\nFase 3: Extensibilidad Comercial (Semanas 12-15)\nOpción C: ArcGIS\nScripts de geoprocesamiento, Toolbox y flujos de trabajo en ArcGIS Pro.\nUso de Python (ArcPy) para automatizar procesos en el entorno comercial líder.\n\n\n\n\n\nPropósito según el Escenario\n\n\n\n\n\n\n\n\n\nEscenario\nUsa la Opción A (Docker/PostGIS)\nUsa la Opción B (QGIS/Python)\nUsa la Opción C (ArcGIS/Python)\n\n\n\n\nPrácticas de clase\nPara aprender Python y consultas SQL espaciales.\nPara automatizar tareas repetitivas en QGIS.\nPara crear herramientas dentro de ArcGIS Pro.\n\n\nAutomatización\nPara flujos de análisis de datos masivos.\nPara interactuar con la API de QGIS (PyQGIS).\nPara interactuar con la API de ArcGIS (ArcPy).\n\n\nEcosistema\nIndependiente del Sistema Operativo.\nEcosistema de Código Abierto (OSGeo).\nEcosistema Comercial (ESRI).",
    "crumbs": [
      "Instalación y Entornos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción a Entornos de Desarrollo SIG</span>"
    ]
  },
  {
    "objectID": "01-introduccion-entornos.html#decisiones-de-diseño-del-entorno",
    "href": "01-introduccion-entornos.html#decisiones-de-diseño-del-entorno",
    "title": "1  Introducción a Entornos de Desarrollo SIG",
    "section": "1.2 Decisiones de Diseño del Entorno",
    "text": "1.2 Decisiones de Diseño del Entorno\nLa Opción A constituye el núcleo de la Ciencia de Datos Espaciales del curso. Al integrar PostGIS en este entorno, se garantiza que los estudiantes practiquen la persistencia de datos y el análisis SQL desde la primera fase.\nLas Opciones B y C tienen como propósito específico el dominio de Python dentro de los entornos de software SIG de mayor relevancia, permitiendo al estudiante tener acceso a todas las funcionalidades, motores de renderizado y herramientas de geoprocesamiento nativas de QGIS y ArcGIS respectivamente.\n\n\n\n\nBezanson, J., Edelman, A., Karpinski, S., & Shah, V. B. (2017). Julia: A fresh approach to numerical computing. SIAM review, 59(1), 65-98.\n\n\nInc., D. (2025). Docker Desktop Documentation. https://docs.docker.com\n\n\nLaw, M., & Collins, A. (2019). Getting to know ArcGIS PRO. (No Title).\n\n\nLawhead, J. (2017). QGIS python programming cookbook. Packt Publishing Ltd.\n\n\nPython, W. (2021). Python. Python releases for windows, 24. http://static.softwaresuggest.com.s3.amazonaws.com/ssguides/1604480172_Python_read%20(1).pdf\n\n\nR Core Team. (2025). R: A Language and Environment for Statistical Computing. R Foundation for Statistical Computing. https://www.R-project.org/\n\n\nRosas-Chavoya, M., Gallardo-Salazar, J. L., López-Serrano, P. M., Alcántara-Concepción, P. C., & León-Miranda, A. K. (2022). QGIS a constantly growing free and open-source geospatial software contributing to scientific development. Cuadernos de Investigación Geográfica, 48(1), 197-213.\n\n\nToms, S. (2015). ArcPy and ArcGIS–geospatial analysis with Python. Packt Publishing Ltd.",
    "crumbs": [
      "Instalación y Entornos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción a Entornos de Desarrollo SIG</span>"
    ]
  },
  {
    "objectID": "02-guia_instalacion_A_docker.html",
    "href": "02-guia_instalacion_A_docker.html",
    "title": "2  Guía de Instalación. Opción A: Docker (Python, R, Julia)",
    "section": "",
    "text": "2.1 Introducción\nPara garantizar un entorno de análisis SIG reproducible y políglota, utilizaremos la orquestación de contenedores con Docker (Inc., 2025). Este enfoque permite ejecutar, de forma aislada y coordinada, tanto el motor de procesamiento como el servidor de datos.\nEsta guía establece un entorno de reproducibilidad científica. Utilizaremos una arquitectura híbrida: VSCode como editor local (Microsoft Corporation, 2026) y Docker como laboratorio de ejecución (Inc., 2025). Esta aproximación garantiza que todos los estudiantes operen bajo las mismas versiones de motores geoespaciales (GDAL, GEOS, PROJ), eliminando el problema de “en mi computador no funciona”.\nEste documento detalla el procedimiento actualizado para la instalación de las herramientas Docker del curso utilizando un método offline. Este método es ideal para entornos con conexión limitada y garantiza la homogeneidad del software.",
    "crumbs": [
      "Instalación y Entornos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Guía de Instalación. Opción A: Docker (Python, R, Julia)</span>"
    ]
  },
  {
    "objectID": "02-guia_instalacion_A_docker.html#preparación-de-herramientas-en-equipo-local",
    "href": "02-guia_instalacion_A_docker.html#preparación-de-herramientas-en-equipo-local",
    "title": "2  Guía de Instalación. Opción A: Docker (Python, R, Julia)",
    "section": "2.2 Preparación de herramientas en equipo local",
    "text": "2.2 Preparación de herramientas en equipo local\nPara preparar su equipo de trabajo, instale las siguientes herramientas básicas:\n\nVSCode IDE: En Apéndice F encontrará el proceso de instalación y las principales extensiones (Sección F.6) necesarias a instalar en VSCode.\nDocker Desktop: En Apéndice D encontrará la guía de instalación y el proceso de configuración previo (Sección D.2) para garantizar un funcionamiento óptimo.\n\n\nImportante: Antes de la instalación, siga el procedimiento descrito en Sección D.2.",
    "crumbs": [
      "Instalación y Entornos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Guía de Instalación. Opción A: Docker (Python, R, Julia)</span>"
    ]
  },
  {
    "objectID": "02-guia_instalacion_A_docker.html#limpieza-del-entorno-opcional-pero-recomendado",
    "href": "02-guia_instalacion_A_docker.html#limpieza-del-entorno-opcional-pero-recomendado",
    "title": "2  Guía de Instalación. Opción A: Docker (Python, R, Julia)",
    "section": "2.3 Limpieza del entorno (opcional pero recomendado)",
    "text": "2.3 Limpieza del entorno (opcional pero recomendado)\nVer Sección D.3.",
    "crumbs": [
      "Instalación y Entornos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Guía de Instalación. Opción A: Docker (Python, R, Julia)</span>"
    ]
  },
  {
    "objectID": "02-guia_instalacion_A_docker.html#descarga-y-preparación-de-archivos",
    "href": "02-guia_instalacion_A_docker.html#descarga-y-preparación-de-archivos",
    "title": "2  Guía de Instalación. Opción A: Docker (Python, R, Julia)",
    "section": "2.4 Descarga y preparación de archivos",
    "text": "2.4 Descarga y preparación de archivos\nVer Sección D.4.",
    "crumbs": [
      "Instalación y Entornos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Guía de Instalación. Opción A: Docker (Python, R, Julia)</span>"
    ]
  },
  {
    "objectID": "02-guia_instalacion_A_docker.html#instalación-de-las-imágenes-maquinas-virtuales",
    "href": "02-guia_instalacion_A_docker.html#instalación-de-las-imágenes-maquinas-virtuales",
    "title": "2  Guía de Instalación. Opción A: Docker (Python, R, Julia)",
    "section": "2.5 Instalación de las imágenes (maquinas virtuales)",
    "text": "2.5 Instalación de las imágenes (maquinas virtuales)\nUbique los archivos en una carpeta local que cumpla con los siguientes requisitos:\n\nNo estar dentro de carpetas sincronizadas (OneDrive, Dropbox, etc.).\nQue la ruta (path) no contenga espacios, tildes ni caracteres especiales.\nQue sea preferiblemente una ruta corta.\nEvite carpetas temporales o de sistema como Descargas o Temp.\n\nDentro de la carpeta deben existir los archivos descargados en el paso anterior: - sig_unal_completo.tar (El archivo de la imagen). - docker-compose.yml (El archivo de orquestación contenido en la descarga).\nEste procedimiento instalará dos imágenes (una con la base de datos espacial y otra con Python, R y Julia) y configurará una red interna para comunicar su máquina anfitriona (Windows) con las dos máquinas virtuales Linux.\nDesde una terminal situada en dicha carpeta, ejecute:\ndocker load -i sig_unal_completo.tar\n\nNota: El terminal quedará en modo de espera sin enviar mensajes hasta que termine. El proceso suele tardar unos 20 minutos, pero puede extenderse a más de una hora según su hardware. No interrumpa el proceso.\n\n\nPaciencia: El comando de carga es pesado. Si el proceso falla, el sistema enviará un mensaje de error; de lo contrario, simplemente espere a que la terminal le devuelva el control. No olvide limpiar el entorno para intentar nuevamente en caso de fallos en el proceso.",
    "crumbs": [
      "Instalación y Entornos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Guía de Instalación. Opción A: Docker (Python, R, Julia)</span>"
    ]
  },
  {
    "objectID": "02-guia_instalacion_A_docker.html#puesta-en-marcha",
    "href": "02-guia_instalacion_A_docker.html#puesta-en-marcha",
    "title": "2  Guía de Instalación. Opción A: Docker (Python, R, Julia)",
    "section": "2.6 Puesta en marcha",
    "text": "2.6 Puesta en marcha\nUna vez terminada la carga (load), inicie los servicios desde la misma carpeta con:\ndocker compose up -d\nSi la ejecución es exitosa, verá un mensaje confirmando el inicio de: - Red: final_default - Contenedor: contenedor_postgis_unal (basado en la imagen postgis_unal:final) - Contenedor: contenedor_sig_unal (basado en la imagen image_sig_unal:final)",
    "crumbs": [
      "Instalación y Entornos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Guía de Instalación. Opción A: Docker (Python, R, Julia)</span>"
    ]
  },
  {
    "objectID": "02-guia_instalacion_A_docker.html#iniciar-contenedores",
    "href": "02-guia_instalacion_A_docker.html#iniciar-contenedores",
    "title": "2  Guía de Instalación. Opción A: Docker (Python, R, Julia)",
    "section": "2.7 Iniciar contenedores",
    "text": "2.7 Iniciar contenedores\nVer Sección D.7",
    "crumbs": [
      "Instalación y Entornos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Guía de Instalación. Opción A: Docker (Python, R, Julia)</span>"
    ]
  },
  {
    "objectID": "02-guia_instalacion_A_docker.html#cargar-contenedores-en-vscode",
    "href": "02-guia_instalacion_A_docker.html#cargar-contenedores-en-vscode",
    "title": "2  Guía de Instalación. Opción A: Docker (Python, R, Julia)",
    "section": "2.8 Cargar contenedores en VSCode",
    "text": "2.8 Cargar contenedores en VSCode\nVer Sección B.4.",
    "crumbs": [
      "Instalación y Entornos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Guía de Instalación. Opción A: Docker (Python, R, Julia)</span>"
    ]
  },
  {
    "objectID": "02-guia_instalacion_A_docker.html#apagar-los-contenedores",
    "href": "02-guia_instalacion_A_docker.html#apagar-los-contenedores",
    "title": "2  Guía de Instalación. Opción A: Docker (Python, R, Julia)",
    "section": "2.9 Apagar los contenedores",
    "text": "2.9 Apagar los contenedores\nVer Sección D.7.",
    "crumbs": [
      "Instalación y Entornos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Guía de Instalación. Opción A: Docker (Python, R, Julia)</span>"
    ]
  },
  {
    "objectID": "02-guia_instalacion_A_docker.html#contenido-de-los-contenedores",
    "href": "02-guia_instalacion_A_docker.html#contenido-de-los-contenedores",
    "title": "2  Guía de Instalación. Opción A: Docker (Python, R, Julia)",
    "section": "2.10 Contenido de los contenedores",
    "text": "2.10 Contenido de los contenedores\nVer Sección B.2.1.\n\n\n\n\nInc., D. (2025). Docker Desktop Documentation. https://docs.docker.com\n\n\nMicrosoft Corporation. (2026). Visual Studio Code. https://code.visualstudio.com/",
    "crumbs": [
      "Instalación y Entornos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Guía de Instalación. Opción A: Docker (Python, R, Julia)</span>"
    ]
  },
  {
    "objectID": "03-guia_instalacion_B_qgis.html",
    "href": "03-guia_instalacion_B_qgis.html",
    "title": "3  Guía de Instalación. Opción B: QGIS y PyQGIS",
    "section": "",
    "text": "3.1 Opción B.1 - OSGeo4W\nOSGeo4W es un entorno para Windows que agrupa y facilita la gestión de software geoespacial de código abierto como QGIS (Rosas-Chavoya et al., 2022), GDAL/OGR (Mitchell, 2015), GRASS (Neteler et al., 2012) y SAGA (Passy & Théry, 2018).\nEn este escenario, Python (Python Software Foundation, 2025) es el motor fundamental, permitiendo la automatización directa de tareas sobre el software de escritorio (Lawhead, 2017). Para mantener la estabilidad del sistema, en este entorno nativo no intentaremos vincular R (R Core Team, 2025) o Julia (Bezanson et al., 2017); para dicho propósito políglota utilizaremos exclusivamente la Opción A (Docker) (Inc., 2025).",
    "crumbs": [
      "Instalación y Entornos",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Guía de Instalación. Opción B: QGIS y PyQGIS</span>"
    ]
  },
  {
    "objectID": "03-guia_instalacion_B_qgis.html#sec-osgeo4w",
    "href": "03-guia_instalacion_B_qgis.html#sec-osgeo4w",
    "title": "3  Guía de Instalación. Opción B: QGIS y PyQGIS",
    "section": "",
    "text": "Instrucciones de Instalación\n\nDescargue el Network Installer de QGIS.\nEjecute y seleccione Advanced Install.\nMantenga las rutas por defecto (C:\\OSGeo4W).\nEn el paso de Select Packages, busque los elementos de la tabla y marque únicamente la casilla Bin (Binarios).\n\n\n\nLista de Paquetes Seleccionados\n\n\n\n\n\n\n\n\n\nGrupo\nPaquete\nMódulo\nPropósito / Uso en Clase\n\n\n\n\nEntorno Core\nqgis-ltr / qgis-ltr-full\nTodo\nSoftware base y metapaquete de dependencias.\n\n\nBases de Datos\npgmodeler\n5\nDiseño visual de modelos para PostGIS.\n\n\nBases de Datos\nlibspatialite\n5\nMotor de base de datos espacial liviano para verificación en shell.\n\n\nBases de Datos\npython3-psycopg2\n5\nAdaptador de Python para PostgreSQL/PostGIS.\n\n\nGeoprocesamiento\ngrass\n6\nMotor para análisis topológico e hidrología.\n\n\nGeoprocesamiento\nsaga\n7\nAlgoritmos de terreno y geomorfometría.\n\n\nGeoprocesamiento\ngdal\n6\nLectura/escritura de formatos raster y vector.\n\n\nCiencia de Datos\npython3-numpy\n2\nManejo de estructuras Arrays y Matrices.\n\n\nCiencia de Datos\npython3-pandas\n3\nAnálisis exploratorio de datos (EDA).\n\n\nCiencia de Datos\npython3-geopandas\n3\nExtensión espacial para GeoDataFrames.\n\n\nVisualización\npython3-matplotlib\n3\nGráficos básicos y mapas estáticos.\n\n\nVisualización\npython3-seaborn\n3\nGráficos estadísticos avanzados.\n\n\nDesarrollo\npython3-pip\n1\nGestor para instalar librerías adicionales.\n\n\nDesarrollo\npython3-jupyterlab\nTodo\nEntorno interactivo para prototipado rápido (Wijayaningrum et al., 2022).\n\n\nMotores SIG\nproj / geos\n6\nCálculos de proyecciones y geometría.\n\n\nMachine Learning\npython3-scikit-learn\n6\nModelado predictivo espacial.\n\n\n\n\n\n\n\n\n\nAceptación de Dependencias Adicionales\n\n\n\nAl avanzar, el instalador mostrará la ventana “Unmet Dependencies”. Es obligatorio aceptar todos los paquetes sugeridos para contar con los controladores de formatos .ecw y .sid requeridos por la cartografía oficial nacional. Para que el comando spatialite funcione en la shell, asegúrese de marcar el paquete libspatialite en la sección Libs.\n\n\n\n\nVerificación de la Instalación\nAbra la OSGeo4W Shell y ejecute los comandos para verificar la correcta integración de Python y los motores SIG:\npython3 --version\ngdalinfo --version\nspatialite --version\n\nCorrección de Errores al Lanzar QGIS\nSi al iniciar QGIS aparece un error crítico indicando ModuleNotFoundError: No module named 'gdal', se debe a una sintaxis de importación obsoleta en ciertos complementos (Rosas-Chavoya et al., 2022).\nError identificado: File \".../agknow_utils.py\", line 29, in &lt;module&gt; import gdal, osr\nSolución: Debe modificar el archivo del plugin para usar el espacio de nombres de OSGeo:\n\nLocalice el archivo en: %AppData%\\QGIS\\QGIS3\\profiles\\default\\python\\plugins\\agknow_qgis\\agknow_utils.py.\nReemplace la línea 29:\n\nIncorrecto: import gdal, osr\nCorrecto: from osgeo import gdal, osr\n\n\n\n\n\n\n\n\nNota sobre R y Julia\n\n\n\nPara el uso intensivo de R y Julia, se recomienda la Opción A (Docker) (Inc., 2025) ya que viene con las librerías espaciales pre-configuradas, evitando errores de vinculación de DLLs comunes en instalaciones nativas de Windows.",
    "crumbs": [
      "Instalación y Entornos",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Guía de Instalación. Opción B: QGIS y PyQGIS</span>"
    ]
  },
  {
    "objectID": "03-guia_instalacion_B_qgis.html#sec-qgis-gee-pixi",
    "href": "03-guia_instalacion_B_qgis.html#sec-qgis-gee-pixi",
    "title": "3  Guía de Instalación. Opción B: QGIS y PyQGIS",
    "section": "3.2 Opción B.2: QGIS + GEE usando Pixi",
    "text": "3.2 Opción B.2: QGIS + GEE usando Pixi\nAntes de comenzar, es indispensable contar con una cuenta de Google Cloud habilitada para Google Earth Engine (GEE). Puede dar de alta su cuenta en earthengine.google.com.\n\n\n\n\n\n\nRequisito de Google Cloud\n\n\n\nAsegúrese de haber creado un proyecto en la consola de Google Cloud y de tener activadas las APIs for Earth Engine para dicho proyecto; de lo contrario, el proceso de autenticación fallará.\n\n\nVideo gúia de creación y registro en GEE\n\n\nInstalación de Pixi\nPixi es un gestor de paquetes extremadamente rápido basado en el ecosistema de Conda, pero mucho más ligero. Permite crear entornos aislados sin romper las librerías de su sistema operativo.\n\nEn Linux / macOS (bash/zsh)\nEjecute el siguiente comando en su terminal:\ncurl -fsSL https://pixi.sh/install.sh | sh\nNota: Cierre y vuelva a abrir su terminal para que pixi se añada a su PATH. Confirme la instalación con:\npixi --version\n\n\nEn Windows (PowerShell)\nAbra PowerShell (no requiere permisos de Administrador) y ejecute:\npowershell -ExecutionPolicy Bypass -c \"irm -useb https://pixi.sh/install.ps1 | iex\"\nReinicie PowerShell y confirme la versión:\npixi --version\n\n\n\n\nCreación del Proyecto\nNavegue hasta la carpeta (diferente a todas las utilizadas hasta el momento) donde desea guardar sus trabajos y cree un nuevo proyecto llamado geocd:\npixi init geocd\ncd geocd\n\n\n\nConfiguración del Entorno Geográfico\nInstalaremos un stack potente que incluye QGIS y las herramientas necesarias para trabajar con Google Earth Engine y datos ráster/vectoriales en Python.\nDesde la carpeta geocd, ejecute:\npixi add qgis geemap geopandas xee rioxarray\n\n\n\n\n\n\n¿Qué estamos instalando?\n\n\n\n\nQGIS: El software SIG profesional de uso libre mas popular.\ngeemap: Librería para visualización interactiva de GEE.\ngeopandas: Gestión de datos vectoriales.\nxee & rioxarray: Motores para leer cubos de datos y archivos ráster.\n\n\n\n\n\n\nAutenticación de Earth Engine\nFinalmente, debe vincular su entorno local con su cuenta de Google Cloud. Este comando abrirá una ventana en su navegador para autorizar el acceso:\npixi run earthengine authenticate\nSiga las instrucciones en pantalla, seleccione su proyecto de Google Cloud y copie el código de verificación si el sistema se lo solicita. ¡Ya está listo para procesar datos satelitales a escala global!\n\n\nTrabajar GEE dentro de QGIS\nUna vez que el entorno está configurado y autenticado, el siguiente paso es integrar Google Earth Engine directamente en la interfaz de QGIS. Para esto, utilizaremos el complemento desarrollado por el equipo de OpenGeos: El Plugin: GEE Data Catalog. Este complemento permite navegar por los miles de datasets de Earth Engine (Sentinel, Landsat, MODIS, etc.) y cargarlos en el lienzo de QGIS con un solo clic, utilizando el motor de procesamiento en la nube.\n\n\nRecursos Adicionales\n\nRepositorio oficial: opengeos/qgis-gee-data-catalogs-plugin\nVideo Guía Earth Engine Data Catalogs Plugin for QGIS: aquí\nVideo Guía Time Series Satellite Images in Seconds: aquí",
    "crumbs": [
      "Instalación y Entornos",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Guía de Instalación. Opción B: QGIS y PyQGIS</span>"
    ]
  },
  {
    "objectID": "03-guia_instalacion_B_qgis.html#otras-referencias-importantes",
    "href": "03-guia_instalacion_B_qgis.html#otras-referencias-importantes",
    "title": "3  Guía de Instalación. Opción B: QGIS y PyQGIS",
    "section": "3.3 Otras referencias importantes",
    "text": "3.3 Otras referencias importantes\n\nPyQGIS cookbook en markdown y Jupyter notebook formats (Wu, 2023a)\nQGIS Notebook Plugin: Integrate Jupyter Notebooks into QGIS (Wu, 2023b)\n\n\n\n\n\nBezanson, J., Edelman, A., Karpinski, S., & Shah, V. B. (2017). Julia: A fresh approach to numerical computing. SIAM review, 59(1), 65-98.\n\n\nInc., D. (2025). Docker Desktop Documentation. https://docs.docker.com\n\n\nLawhead, J. (2017). QGIS python programming cookbook. Packt Publishing Ltd.\n\n\nMitchell, T. (2015). An Introduction to Open Source Geospatial Tools.\n\n\nNeteler, M., Bowman, M. H., Landa, M., & Metz, M. (2012). GRASS GIS: A multi-purpose open source GIS. Environmental Modelling & Software, 31, 124-130.\n\n\nPassy, P., & Théry, S. (2018). The use of SAGA GIS modules in QGIS. QGIS and generic tools, 1, 107-149.\n\n\nPython Software Foundation. (2025). Python 3 Documentation. https://docs.python.org/3/\n\n\nR Core Team. (2025). R: A Language and Environment for Statistical Computing. R Foundation for Statistical Computing. https://www.R-project.org/\n\n\nRosas-Chavoya, M., Gallardo-Salazar, J. L., López-Serrano, P. M., Alcántara-Concepción, P. C., & León-Miranda, A. K. (2022). QGIS a constantly growing free and open-source geospatial software contributing to scientific development. Cuadernos de Investigación Geográfica, 48(1), 197-213.\n\n\nWijayaningrum, V. N., Lestari, V. A., et al. (2022). Jupyter lab platform-based interactive learning. 2022 International Conference on Electrical and Information Technology (IEIT), 295-301.\n\n\nWu, Q. (2023a). PyQGIS cookbook in markdown and Jupyter notebook formats. En GitHub repository. https://github.com/opengeos/pyqgis-cookbook; GitHub.\n\n\nWu, Q. (2023b). QGIS Notebook Plugin: Integrate Jupyter Notebooks into QGIS. En GitHub repository [Software]. https://github.com/opengeos/qgis-notebook-plugin; GitHub.",
    "crumbs": [
      "Instalación y Entornos",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Guía de Instalación. Opción B: QGIS y PyQGIS</span>"
    ]
  },
  {
    "objectID": "04-guia_instalacion_C_ArcGIS.html",
    "href": "04-guia_instalacion_C_ArcGIS.html",
    "title": "4  Guía de Instalación. Opción C: ArcGIS Pro y ArcPy",
    "section": "",
    "text": "4.1 ..",
    "crumbs": [
      "Instalación y Entornos",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Guía de Instalación. Opción C: ArcGIS Pro y ArcPy</span>"
    ]
  },
  {
    "objectID": "05-variables_tipos_de_datos.html",
    "href": "05-variables_tipos_de_datos.html",
    "title": "5  Variables y Tipos de Datos",
    "section": "",
    "text": "5.1 Función j_eval y j_plot en R\nCódigo\n# #| include: false\n#| results: asis\nsource(\"./docs/j_eval_j_plot.r\")",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Función j_eval y j_plot en R</span>"
    ]
  },
  {
    "objectID": "05-variables_tipos_de_datos.html#introducción",
    "href": "05-variables_tipos_de_datos.html#introducción",
    "title": "5  Variables y Tipos de Datos",
    "section": "5.2 Introducción",
    "text": "5.2 Introducción",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Función j_eval y j_plot en R</span>"
    ]
  },
  {
    "objectID": "05-variables_tipos_de_datos.html#objetivos-de-aprendizaje",
    "href": "05-variables_tipos_de_datos.html#objetivos-de-aprendizaje",
    "title": "5  Variables y Tipos de Datos",
    "section": "5.3 Objetivos de aprendizaje",
    "text": "5.3 Objetivos de aprendizaje",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Función j_eval y j_plot en R</span>"
    ]
  },
  {
    "objectID": "05-variables_tipos_de_datos.html#variables",
    "href": "05-variables_tipos_de_datos.html#variables",
    "title": "5  Variables y Tipos de Datos",
    "section": "5.4 Variables",
    "text": "5.4 Variables\n\n\n\nTabla 5.1: Comparación de sintaxis básica entre Python, R y Julia\n\n\n\n\n\n\n\n\n\n\n\nLenguaje\nOperador de asignación\nComando para imprimir\nDescripción y Alternativas\n\n\n\n\nPython\n=\nprint()\nEl operador = es el estándar único para asignación. Para imprimir, print() añade automáticamente un salto de línea. En entornos interactivos, se puede usar display() para una representación visual más rica.\n\n\nR\n&lt;-\nprint()\nAunque = funciona, se prefiere &lt;-. Además de print(), existe cat(), útil para concatenar texto sin mostrar índices de vector.\n\n\nJulia\n=\nprintln()\nSe usa = para asignación. println() imprime con salto de línea, mientras que print() lo hace sin él. Al igual que en Python, existe display().\n\n\n\n\n\n\n\nPythonRJulia\n\n\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\n#Variable numérica\nnumero_dptos = 32\n\n#Imprimir\nprint(numero_dptos)\n\n#Ver contenido (en modo interactivo)\nnumero_dptos\n\n\n\n\n\n# #| eval: false\n#Variable numérica\nnumero_dptos = 32\n\n#Imprimir\nprint(numero_dptos)\n\n32\n\n#Ver contenido (en modo interactivo)\nnumero_dptos\n\n32\n\n\n\n\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\n# Variable numérica (en R se prefiere el operador &lt;-)\nnumero_dptos &lt;- 32\n\n# Imprimir\nprint(numero_dptos)\n\n# Ver contenido\nnumero_dptos\n\n\n\n\n\n# #| eval: false\n# Variable numérica (en R se prefiere el operador &lt;-)\nnumero_dptos &lt;- 32\n\n# Imprimir\nprint(numero_dptos)\n\n[1] 32\n\n# Ver contenido\nnumero_dptos\n\n[1] 32\n\n\n\n\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\n# Variable numérica\nnumero_dptos = 32\n\n# Imprimir\nprintln(numero_dptos)\n\n# Ver contenido\nnumero_dptos\n\n\n\n\n# #| eval: false\nj_eval('\n# Variable numérica\nnumero_dptos = 32\n\n# Imprimir\nprintln(numero_dptos)\n\n# Ver contenido\nnumero_dptos\n\natributos_elemento\n')\nStarting Julia ...\njulia&gt; # Variable numérica\n\n\njulia&gt; numero_dptos = 32\n\n32\n\n\njulia&gt; # Imprimir\n\n\njulia&gt; println(numero_dptos)\n\n32\n\n\njulia&gt; # Ver contenido\n\n\njulia&gt; numero_dptos\n\n32\n\n\njulia&gt; atributos_elemento\njulia&gt; Error: UndefVarError(:atributos_elemento)\n\n\n\n\n\nAsignación de variables\n\n\n\nTabla 5.2: Estructuras de datos y comportamiento de asignación\n\n\n\n\n\n\n\n\n\n\n\nLenguaje\nColección Base\nOperador\nDescripción y Flexibilidad\n\n\n\n\nPython\nLista []\n=\nPermite mezclar tipos en una lista. Es dinámico y fuerte: no permite operaciones inválidas entre tipos (ej. sumarle un texto a un número).\n\n\nR\nVector c()\n&lt;-\nEl vector atómico (c) exige que todos los elementos sean del mismo tipo. Si se mezclan, R los convierte automáticamente (coerción).\n\n\nJulia\nArreglo []\n=\nMuy similar a la lista de Python pero optimizado para rendimiento. Es dinámico pero permite declarar tipos para ganar velocidad.\n\n\n\n\n\n\n\n\nConceptos clave de programación\nPara entender cómo estos lenguajes manejan la información de la Tabla 5.2, es fundamental diferenciar los sistemas de tipado:\n\nTipado Dinámico: El tipo de la variable se define en tiempo de ejecución. No es necesario declarar que una variable es un entero o un texto antes de usarla; el lenguaje lo infiere. (Python, R y Julia son dinámicos).\nTipado Estático: El tipo de la variable debe definirse al momento de escribir el código (ej. C++ o Java). Una vez definida como “entero”, no puede guardar texto. Esto previene errores antes de ejecutar el programa.\nTipado Fuerte: El lenguaje no permite operaciones entre tipos incompatibles sin una conversión explícita. Por ejemplo, en Python, 5 + \"10\" arrojará un error.\nTipado Débil: El lenguaje intenta realizar conversiones automáticas (coerción) para que la operación funcione. En R, si intentas unir un número y un texto en un vector c(1, \"Bogotá\"), R convertirá el 1 en texto \"1\" silenciosamente.\n\n\nPythonRJulia\n\n\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\n# Iniciar con un número (Latitud de Monserrate)\ndatos_ubicacion = 4.6052\n\n# Cambiar a texto (Nombre del lugar)\ndatos_ubicacion = \"Cerro de Monserrate\"\n\n# Cambiar a una lista de coordenadas [Lat, Lon]\ndatos_ubicacion = [4.6052, -74.0554]\n\n# Imprimir resultado final\nprint(datos_ubicacion)\n\n\n\n\n\n# #| eval: false\n# Iniciar con un número (Latitud de Monserrate)\ndatos_ubicacion = 4.6052\n\n# Cambiar a texto (Nombre del lugar)\ndatos_ubicacion = \"Cerro de Monserrate\"\n\n# Cambiar a una lista de coordenadas [Lat, Lon]\ndatos_ubicacion = [4.6052, -74.0554]\n\n# Imprimir resultado final\nprint(datos_ubicacion)\n\n[4.6052, -74.0554]\n\n\n\n\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\n# Iniciar con un número (Latitud de Monserrate)\ndatos_ubicacion &lt;- 4.6052\n\n# Cambiar a texto (Nombre del lugar)\ndatos_ubicacion &lt;- \"Cerro de Monserrate\"\n\n# Cambiar a un vector de coordenadas (c es para combinar/concatenar)\ndatos_ubicacion &lt;- c(4.6052, -74.0554)\n\n# Imprimir resultado final\nprint(datos_ubicacion)\n\n\n\n\n\n# #| eval: false\n# Iniciar con un número (Latitud de Monserrate)\ndatos_ubicacion &lt;- 4.6052\n\n# Cambiar a texto (Nombre del lugar)\ndatos_ubicacion &lt;- \"Cerro de Monserrate\"\n\n# Cambiar a un vector de coordenadas (c es para combinar/concatenar)\ndatos_ubicacion &lt;- c(4.6052, -74.0554)\n\n# Imprimir resultado final\nprint(datos_ubicacion)\n\n[1]   4.6052 -74.0554\n\n\n\n\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\n# Iniciar con un número (Latitud de Monserrate)\ndatos_ubicacion = 4.6052\n\n# Cambiar a texto (Nombre del lugar)\ndatos_ubicacion = \"Cerro de Monserrate\"\n\n# Cambiar a un arreglo (Array) de coordenadas\ndatos_ubicacion = [4.6052, -74.0554]\n\n# Imprimir resultado final\nprintln(datos_ubicacion)\n\n\n\n\n# #| eval: false\nj_eval('\n# Iniciar con un número (Latitud de Monserrate)\ndatos_ubicacion = 4.6052\n\n# Cambiar a texto (Nombre del lugar)\ndatos_ubicacion = \"Cerro de Monserrate\"\n\n# Cambiar a un arreglo (Array) de coordenadas\ndatos_ubicacion = [4.6052, -74.0554]\n\n# Imprimir resultado final\nprintln(datos_ubicacion)\n')\njulia&gt; # Iniciar con un número (Latitud de Monserrate)\n\n\njulia&gt; datos_ubicacion = 4.6052\n\n4.6052\n\n\njulia&gt; # Cambiar a texto (Nombre del lugar)\n\n\njulia&gt; datos_ubicacion = \"Cerro de Monserrate\"\n\n\"Cerro de Monserrate\"\n\n\njulia&gt; # Cambiar a un arreglo (Array) de coordenadas\n\n\njulia&gt; datos_ubicacion = [4.6052, -74.0554]\n\n2-element Vector{Float64}:\n   4.6052\n -74.0554\n\n\njulia&gt; # Imprimir resultado final\n\n\njulia&gt; println(datos_ubicacion)\n\n[4.6052, -74.0554]",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Función j_eval y j_plot en R</span>"
    ]
  },
  {
    "objectID": "05-variables_tipos_de_datos.html#nombres-para-las-variables",
    "href": "05-variables_tipos_de_datos.html#nombres-para-las-variables",
    "title": "5  Variables y Tipos de Datos",
    "section": "5.5 Nombres para las variables",
    "text": "5.5 Nombres para las variables\n¿Por qué es clave usar nombres adecuados?\nEn programación, los nombres que eliges para tus variables no son solo etiquetas; son las instrucciones que permiten que otras personas (y tú mismo en el futuro) entiendan la lógica del código sin errores. Usar nombres estandarizados es vital por las siguientes razones:\n\nEvitar errores técnicos: Los lenguajes de programación son muy estrictos. Un espacio, una tilde o una ñ pueden hacer que un programa que funciona bien en tu computadora falle al abrirlo en otra.\nClaridad en la lectura: Es mucho más fácil entender un proceso si la variable se llama distancia_metros en lugar de simplemente d.\nPortabilidad: El uso de estándares internacionales asegura que tus datos e investigaciones puedan integrarse fácilmente entre diferentes plataformas como Python, R o Julia.\n\n\n\n\n\n\n\nResumen de Reglas de Estilo (snake_case)\n\n\n\n\n\nPara que tus programas sean profesionales y compatibles, sigue estas reglas básicas:\n\nTodo en minúsculas: Evita mezclar mayúsculas para mantener la uniformidad.\nUsa el guion bajo (_): Dado que los espacios están prohibidos, el guion bajo une las palabras (ej. precio_gasolina).\nSolo letras básicas y números: Usa solo caracteres de la a a la z. Evita tildes, eñes o símbolos especiales (!, #, $).\nProhibido el guion medio (-): El computador lo interpreta como una operación de resta.\n\n\n\n\n\n#| code-summary: \"Ejemplos comparativos (Python, R, Julia)\"\n\n# FORMA CORRECTA: Clara y sin errores\nestacion_climatologica = \"Dorado\"\ntemperatura_celsius = 20.5\nconteo_puntos_gps = 15\n\n# FORMA INCORRECTA: Genera errores o confusión\nestacion climatologica = \"Dorado\"  # ERROR: Los espacios no están permitidos\ntemperatura-celsius = 20.5         # ERROR: El guion medio intenta restar\nt = 20.5                           # MAL: Es una variable muy vaga\naño_inicio = 2024                  # EVITAR: La 'ñ' causa fallos de lectura\n\nPythonRJulia\n\n\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\n# Nombres de variables recomendatos\n# Variables geoespaciales claras\nlatitud_bogota = 4.7110\nlongitud_bogota = -74.0721\naltura_msnm = 2640.0\nmunicipio_nombre = \"Chinchiná\"\nconteo_viviendas_afectadas = 150\nsistema_referencia = \"MAGNA-SIRGAS / Origen Nacional\"\n\n\n# Nombres de variables NO recomendatos\n# Evitar nombres genéricos o confusos\nx = 4.7110  # ¿Es latitud o un índice?\nd = \"Chinchiná\"  # Muy vago (¿Distrito, Departamento, Dato?)\nval = 2640  # Ambiguo: ¿Valor, Valencia, Variable?\ncoords = [4.71, -74.07]  # Lista sin etiquetas claras\n\n\n\n\n\n# #| eval: false\n# Nombres de variables recomendatos\n# Variables geoespaciales claras\nlatitud_bogota = 4.7110\nlongitud_bogota = -74.0721\naltura_msnm = 2640.0\nmunicipio_nombre = \"Chinchiná\"\nconteo_viviendas_afectadas = 150\nsistema_referencia = \"MAGNA-SIRGAS / Origen Nacional\"\n\n\n# Nombres de variables NO recomendatos\n# Evitar nombres genéricos o confusos\nx = 4.7110  # ¿Es latitud o un índice?\nd = \"Chinchiná\"  # Muy vago (¿Distrito, Departamento, Dato?)\nval = 2640  # Ambiguo: ¿Valor, Valencia, Variable?\ncoords = [4.71, -74.07]  # Lista sin etiquetas claras\n\n\n\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\n# Nombres de variables recomendatos\n# Estilo snake_case (común en R para análisis de datos)\nlatitud_medellin &lt;- 6.2442\nlongitud_medellin &lt;- -75.5812\ncota_terreno &lt;- 1495\nnombre_departamento &lt;- \"Antioquia\"\npoblacion_censo_2018 &lt;- 6407000\nproyeccion_cartografica &lt;- \"EPSG:9377\"\n\n\n# Nombres de variables NO recomendatos\n# Evitar abreviaturas extremas\nl &lt;- 6.2442 # ¿Latitud, Longitud, Límite, Localidad?\nnom &lt;- \"Antioquia\" # \"nombre\" es mejor\ntemp &lt;- 1495 # ¿Temperatura o un archivo temporal?\np &lt;- 6407000 # ¿Población, Perímetro, Pendiente, P-value?\n\n\n\n\n\n# #| eval: false\n# Nombres de variables recomendatos\n# Estilo snake_case (común en R para análisis de datos)\nlatitud_medellin &lt;- 6.2442\nlongitud_medellin &lt;- -75.5812\ncota_terreno &lt;- 1495\nnombre_departamento &lt;- \"Antioquia\"\npoblacion_censo_2018 &lt;- 6407000\nproyeccion_cartografica &lt;- \"EPSG:9377\"\n\n\n# Nombres de variables NO recomendatos\n# Evitar abreviaturas extremas\nl &lt;- 6.2442 # ¿Latitud, Longitud, Límite, Localidad?\nnom &lt;- \"Antioquia\" # \"nombre\" es mejor\ntemp &lt;- 1495 # ¿Temperatura o un archivo temporal?\np &lt;- 6407000 # ¿Población, Perímetro, Pendiente, P-value?\n\n\n\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\n# Nombres de variables recomendatos\n# Aprovechando el soporte Unicode de Julia\nlatitud_cali = 3.4516\nlongitud_cali = -76.5320\nelevación_cauca = 995.0\nnombre_vereda = \"La Elvira\"\ndensidad_poblacional = 120.5\nreferencia_espacial = \"MAGNA-SIRGAS\"\n\n\n# Nombres de variables NO recomendatos\n# Nombres que no dicen nada del contexto geográfico\nvar1 = 3.4516\ninfo = \"La Elvira\"\ntmp = 995.0 # Típico error: ¿Temperatura o Temporal?\nlista = [3.45, -76.53] # Difícil de leer en modelos de optimización\n\n\n\n\n# #| eval: false\nj_eval('\n# Nombres de variables recomendatos\n# Aprovechando el soporte Unicode de Julia\nlatitud_cali = 3.4516\nlongitud_cali = -76.5320\nelevación_cauca = 995.0\nnombre_vereda = \"La Elvira\"\ndensidad_poblacional = 120.5\nreferencia_espacial = \"MAGNA-SIRGAS\"\n')\njulia&gt; # Nombres de variables recomendatos\n\n\njulia&gt; # Aprovechando el soporte Unicode de Julia\n\n\njulia&gt; latitud_cali = 3.4516\n\n3.4516\n\n\njulia&gt; longitud_cali = -76.5320\n\n-76.532\n\n\njulia&gt; elevación_cauca = 995.0\n\n995.0\n\n\njulia&gt; nombre_vereda = \"La Elvira\"\n\n\"La Elvira\"\n\n\njulia&gt; densidad_poblacional = 120.5\n\n120.5\n\n\njulia&gt; referencia_espacial = \"MAGNA-SIRGAS\"\n\n\"MAGNA-SIRGAS\"\n\n\nj_eval('\n# Nombres de variables NO recomendatos\n# Nombres que no dicen nada del contexto geográfico\nvar1 = 3.4516\ninfo = \"La Elvira\"\ntmp = 995.0 # Típico error: ¿Temperatura o Temporal?\nlista = [3.45, -76.53] # Difícil de leer en modelos de optimización\n')\njulia&gt; # Nombres de variables NO recomendatos\n\n\njulia&gt; # Nombres que no dicen nada del contexto geográfico\n\n\njulia&gt; var1 = 3.4516\n\n3.4516\n\n\njulia&gt; info = \"La Elvira\"\n\n\"La Elvira\"\n\n\njulia&gt; tmp = 995.0 # Típico error: ¿Temperatura o Temporal?\n\n995.0\n\n\njulia&gt; lista = [3.45, -76.53] # Difícil de leer en modelos de optimización\n\n2-element Vector{Float64}:\n   3.45\n -76.53",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Función j_eval y j_plot en R</span>"
    ]
  },
  {
    "objectID": "05-variables_tipos_de_datos.html#tipos-de-datos",
    "href": "05-variables_tipos_de_datos.html#tipos-de-datos",
    "title": "5  Variables y Tipos de Datos",
    "section": "5.6 Tipos de datos",
    "text": "5.6 Tipos de datos\n\nPythonRJulia\n\n\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\n# Representa el número de elementos en un dataset geoespacial\nnum_elementos = 500  \n\n# Representa la latitud de un punto (Nevado del Ruiz)\nlatitud = 4.8920  \n\n# Representa la longitud de un punto\nlongitud = -75.3188  \n\n# Representa el sistema de referencia oficial de Colombia\nsistema_coordenadas = \"MAGNA-SIRGAS / Origen Nacional\"  \n\n# Representa si el dataset está georreferenciado o no\nesta_georeferenciado = True  \n\n# Una lista que representa latitud y longitud\ncoordenadas = [4.8920, -75.3188]  \n\n# Un diccionario con los atributos del elemento geográfico\natributos_elemento = {\n    \"nombre\": \"Nevado del Ruiz\",\n    \"altura_msnm\": 5321,\n    \"tipo\": \"Estratovolcán\",\n    \"ubicacion\": [4.8920, -75.3188],\n}\n\nprint(atributos_elemento)\n\n# Tipo de dato\ntype(atributos_elemento)\n\n# Acceder a la primera coordenada (índice 0) dentro de la clave 'ubicacion'\nlatitud_ruiz = atributos_elemento[\"ubicacion\"][0]\nlatitud_ruiz\n\n\n\n\n\n# #| eval: false\n\n# Representa el número de elementos en un dataset geoespacial\nnum_elementos = 500  \n\n# Representa la latitud de un punto (Nevado del Ruiz)\nlatitud = 4.8920  \n\n# Representa la longitud de un punto\nlongitud = -75.3188  \n\n# Representa el sistema de referencia oficial de Colombia\nsistema_coordenadas = \"MAGNA-SIRGAS / Origen Nacional\"  \n\n# Representa si el dataset está georreferenciado o no\nesta_georeferenciado = True  \n\n# Una lista que representa latitud y longitud\ncoordenadas = [4.8920, -75.3188]  \n\n# Un diccionario con los atributos del elemento geográfico\natributos_elemento = {\n    \"nombre\": \"Nevado del Ruiz\",\n    \"altura_msnm\": 5321,\n    \"tipo\": \"Estratovolcán\",\n    \"ubicacion\": [4.8920, -75.3188],\n}\n\nprint(atributos_elemento)\n\n{'nombre': 'Nevado del Ruiz', 'altura_msnm': 5321, 'tipo': 'Estratovolcán', 'ubicacion': [4.892, -75.3188]}\n\n# Tipo de dato\ntype(atributos_elemento)\n\n&lt;class 'dict'&gt;\n\n# Acceder a la primera coordenada (índice 0) dentro de la clave 'ubicacion'\nlatitud_ruiz = atributos_elemento[\"ubicacion\"][0]\nlatitud_ruiz\n\n4.892\n\n\n\n\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\n# Representa el número de elementos (L indica tipo integer)\nnum_elementos &lt;- 500L  \n\n# Representa la latitud de un punto (Nevado del Ruiz)\nlatitud &lt;- 4.8920  \n\n# Representa la longitud de un punto\nlongitud &lt;- -75.3188  \n\n# Representa el sistema de referencia oficial (tipo character)\nsistema_coordenadas &lt;- \"MAGNA-SIRGAS / Origen Nacional\"  \n\n# Representa si el dataset está georreferenciado (logical)\nesta_georeferenciado &lt;- TRUE  \n\n# Un vector que representa latitud y longitud\ncoordenadas &lt;- c(4.8920, -75.3188)  \n\n# Una lista que representa los atributos del elemento geográfico\natributos_elemento &lt;- list(\n    \"nombre\" = \"Nevado del Ruiz\",\n    \"altura_msnm\" = 5321,\n    \"tipo\" = \"Estratovolcán\",\n    \"ubicacion\" = c(4.8920, -75.3188)\n)\n\nprint(atributos_elemento)\n\n# Tipo de dato\nclass(atributos_elemento)\n\n# Acceder a la latitud (índice 1 en R) dentro del elemento 'ubicacion'\nlatitud_ruiz &lt;- atributos_elemento$ubicacion[1]\nlatitud_ruiz\n\n\n\n\n\n# #| eval: false\n\n# Representa el número de elementos (L indica tipo integer)\nnum_elementos &lt;- 500L  \n\n# Representa la latitud de un punto (Nevado del Ruiz)\nlatitud &lt;- 4.8920  \n\n# Representa la longitud de un punto\nlongitud &lt;- -75.3188  \n\n# Representa el sistema de referencia oficial (tipo character)\nsistema_coordenadas &lt;- \"MAGNA-SIRGAS / Origen Nacional\"  \n\n# Representa si el dataset está georreferenciado (logical)\nesta_georeferenciado &lt;- TRUE  \n\n# Un vector que representa latitud y longitud\ncoordenadas &lt;- c(4.8920, -75.3188)  \n\n# Una lista que representa los atributos del elemento geográfico\natributos_elemento &lt;- list(\n    \"nombre\" = \"Nevado del Ruiz\",\n    \"altura_msnm\" = 5321,\n    \"tipo\" = \"Estratovolcán\",\n    \"ubicacion\" = c(4.8920, -75.3188)\n)\n\nprint(atributos_elemento)\n\n$nombre\n[1] \"Nevado del Ruiz\"\n\n$altura_msnm\n[1] 5321\n\n$tipo\n[1] \"Estratovolcán\"\n\n$ubicacion\n[1]   4.8920 -75.3188\n\n# Tipo de dato\nclass(atributos_elemento)\n\n[1] \"list\"\n\n# Acceder a la latitud (índice 1 en R) dentro del elemento 'ubicacion'\nlatitud_ruiz &lt;- atributos_elemento$ubicacion[1]\nlatitud_ruiz\n\n[1] 4.892\n\n\n\n\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\n# Representa el número de elementos en el dataset\nnum_elementos = 500  \n\n# Representa la latitud del punto (Nevado del Ruiz)\nlatitud = 4.8920  \n\n# Representa la longitud del punto\nlongitud = -75.3188  \n\n# Representa el sistema de referencia espacial\nsistema_coordenadas = \"MAGNA-SIRGAS / Origen Nacional\"  \n\n# Representa el estado de georreferenciación (tipo Bool)\nesta_georeferenciado = true  \n\n# Un arreglo que representa latitud y longitud\ncoordenadas = [4.8920, -75.3188]  \n\n# Un diccionario (Dict) para almacenar los atributos\natributos_elemento = Dict(\n    \"nombre\" =&gt; \"Nevado del Ruiz\",\n    \"altura_msnm\" =&gt; 5321,\n    \"tipo\" =&gt; \"Estratovolcán\",\n    \"ubicacion\" =&gt; [4.8920, -75.3188],\n)\n\nprint(atributos_elemento)\n\n# Tipo de dato\ntypeof(atributos_elemento)\n\n# Acceder a la latitud (índice 1 en Julia) dentro de la clave \"ubicacion\"\nlatitud_ruiz = atributos_elemento[\"ubicacion\"][1]\nlatitud_ruiz\n\n\n\n\n# #| eval: false\nj_eval('\n# Representa el número de elementos en el dataset\nnum_elementos = 500  \n\n# Representa la latitud del punto (Nevado del Ruiz)\nlatitud = 4.8920  \n\n# Representa la longitud del punto\nlongitud = -75.3188  \n\n# Representa el sistema de referencia espacial\nsistema_coordenadas = \"MAGNA-SIRGAS / Origen Nacional\"  \n\n# Representa el estado de georreferenciación (tipo Bool)\nesta_georeferenciado = true  \n\n# Un arreglo que representa latitud y longitud\ncoordenadas = [4.8920, -75.3188]  \n\n# Un diccionario (Dict) para almacenar los atributos\natributos_elemento = Dict(\n    \"nombre\" =&gt; \"Nevado del Ruiz\",\n    \"altura_msnm\" =&gt; 5321,\n    \"tipo\" =&gt; \"Estratovolcán\",\n    \"ubicacion\" =&gt; [4.8920, -75.3188],\n)\n\nprintln(atributos_elemento)\n\n# Tipo de dato\ntypeof(atributos_elemento)\n\n# Acceder a la latitud (índice 1 en Julia) dentro de la clave \"ubicacion\"\nlatitud_ruiz = atributos_elemento[\"ubicacion\"][1]\nlatitud_ruiz\n')\njulia&gt; # Representa el número de elementos en el dataset\n\n\njulia&gt; num_elementos = 500\n\n500\n\n\njulia&gt; # Representa la latitud del punto (Nevado del Ruiz)\n\n\njulia&gt; latitud = 4.8920\n\n4.892\n\n\njulia&gt; # Representa la longitud del punto\n\n\njulia&gt; longitud = -75.3188\n\n-75.3188\n\n\njulia&gt; # Representa el sistema de referencia espacial\n\n\njulia&gt; sistema_coordenadas = \"MAGNA-SIRGAS / Origen Nacional\"\n\n\"MAGNA-SIRGAS / Origen Nacional\"\n\n\njulia&gt; # Representa el estado de georreferenciación (tipo Bool)\n\n\njulia&gt; esta_georeferenciado = true\n\ntrue\n\n\njulia&gt; # Un arreglo que representa latitud y longitud\n\n\njulia&gt; coordenadas = [4.8920, -75.3188]\n\n2-element Vector{Float64}:\n   4.892\n -75.3188\n\n\njulia&gt; # Un diccionario (Dict) para almacenar los atributos\n\n\njulia&gt; atributos_elemento = Dict(\n           \"nombre\" =&gt; \"Nevado del Ruiz\",\n           \"altura_msnm\" =&gt; 5321,\n           \"tipo\" =&gt; \"Estratovolcán\",\n           \"ubicacion\" =&gt; [4.8920, -75.3188],\n       )\n\nDict{String, Any} with 4 entries:\n  \"tipo\" =&gt; \"Estratovolcán\"\n  \"nombre\" =&gt; \"Nevado del Ruiz\"\n  \"altura_msnm\" =&gt; 5321\n  \"ubicacion\" =&gt; [4.892, -75.3188]\n\n\njulia&gt; println(atributos_elemento)\n\nDict{String, Any}(\"tipo\" =&gt; \"Estratovolcán\", \"nombre\" =&gt; \"Nevado del Ruiz\", \"altura_msnm\" =&gt; 5321, \"ubicacion\" =&gt; [4.892, -75.3188])\n\n\njulia&gt; # Tipo de dato\n\n\njulia&gt; typeof(atributos_elemento)\n\nDict{String, Any}\n\n\njulia&gt; # Acceder a la latitud (índice 1 en Julia) dentro de la clave \"ubicacion\"\n\n\njulia&gt; latitud_ruiz = atributos_elemento[\"ubicacion\"][1]\n\n4.892\n\n\njulia&gt; latitud_ruiz\n\n4.892\n\n\n\n\n\n\n\n\nTabla 5.3: Comparación detallada de sintaxis y tipos de datos\n\n\n\n\n\n\n\n\n\n\n\nCaracterística / Variable\nPython\nR\nJulia\n\n\n\n\nSufijo L (num_elementos)\nNo se usa. 500 es entero.\nSe usa 500L para integer. Sin L es numeric.\nNo se usa. 500 es Int64.\n\n\nAsignación en Diccionario\nv = {clave: valor, ...} (Usa :).\nv &lt;- list(clave = valor, ...). (Usa = )\nv = Dict(clave =&gt; valor, ...) (Usa =&gt;).\n\n\nnum_elementos\nint\ninteger (con el sufijo L)\nInt64\n\n\nlatitud / longitud\nfloat\nnumeric (doble precisión)\nFloat64\n\n\nsistema_coordenadas\nstr\ncharacter\nString\n\n\nesta_georeferenciado\nbool (True / False)\nlogical (TRUE / FALSE)\nBool (true / false)\n\n\ncoordenadas\nlist [ , ]: Colección mutable de objetos.\nvector c( , ): Colección indexada de elementos del mismo tipo.\nArray [ , ] (Vector): Arreglo indexado y optimizado para cómputo.\n\n\natributos_elemento\ndict { : }: Estructura nativa de pares clave-valor.\nlist list( = ): Lista con nombres (etiquetas) para cada elemento.\nDict Dict( =&gt; ): Tipo de dato optimizado para mapeos clave-valor.\n\n\n\n\n\n\n\n¿Qué es un diccionario?\nUn Diccionario es una estructura de datos que organiza la información mediante pares de Clave-Valor (Key-Value). A diferencia de las secuencias indexadas (como las listas o vectores) donde los elementos se recuperan por su posición numérica, en un diccionario se accede a la información a través de etiquetas únicas llamadas claves.\n\nIdentificación: Cada valor almacenado debe tener una clave asociada que funciona como su identificador único.\nHeterogeneidad: Permite agrupar diversos tipos de datos (cadenas, números, arreglos) bajo un mismo objeto.\nAcceso Directo: Su implementación técnica permite que la recuperación de un dato sea extremadamente eficiente, sin importar el volumen de información.\nEstándares: Es el concepto fundamental detrás de formatos como JSON, facilitando la organización jerárquica de los datos.",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Función j_eval y j_plot en R</span>"
    ]
  },
  {
    "objectID": "05-variables_tipos_de_datos.html#caracteres-de-escape",
    "href": "05-variables_tipos_de_datos.html#caracteres-de-escape",
    "title": "5  Variables y Tipos de Datos",
    "section": "5.7 Caracteres de escape",
    "text": "5.7 Caracteres de escape\n\nPythonRJulia\n\n\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\n# Salto de línea para separar información de capas geográficas\nprint(\"Capa: Departamentos_Colombia\\nEstado: Procesada exitosamente.\")\n\n# Salto de línea y tabulación para jerarquizar metadatos\nprint(\"Metadatos del proyecto:\\n\\tAutor: IGAC\\n\\tEscala: 1:100.000\")\n\n# Uso de comillas simples dentro de dobles para nombres propios\nprint(\"Nombre del archivo: 'Mapa_Relieve_Colombia.shp'\")\n\n\n\n\n\n# #| eval: false\n\n# Salto de línea para separar información de capas geográficas\nprint(\"Capa: Departamentos_Colombia\\nEstado: Procesada exitosamente.\")\n\nCapa: Departamentos_Colombia\nEstado: Procesada exitosamente.\n\n# Salto de línea y tabulación para jerarquizar metadatos\nprint(\"Metadatos del proyecto:\\n\\tAutor: IGAC\\n\\tEscala: 1:100.000\")\n\nMetadatos del proyecto:\n    Autor: IGAC\n    Escala: 1:100.000\n\n# Uso de comillas simples dentro de dobles para nombres propios\nprint(\"Nombre del archivo: 'Mapa_Relieve_Colombia.shp'\")\n\nNombre del archivo: 'Mapa_Relieve_Colombia.shp'\n\n\n\n\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\n# Salto de línea para separar información de capas geográficas\nprint(\"Capa: Departamentos_Colombia\\nEstado: Procesada exitosamente.\")\n\n# Salto de línea y tabulación para jerarquizar metadatos\ncat(\"Metadatos del proyecto:\\n\\tAutor: IGAC\\n\\tEscala: 1:100.000\")\n\n# Uso de comillas simples dentro de dobles para nombres propios\nprint(\"Nombre del archivo: 'Mapa_Relieve_Colombia.shp'\")\n\n\n\n\n\n# #| eval: false\n\n# Salto de línea para separar información de capas geográficas\nprint(\"Capa: Departamentos_Colombia\\nEstado: Procesada exitosamente.\")\n\n[1] \"Capa: Departamentos_Colombia\\nEstado: Procesada exitosamente.\"\n\n# Salto de línea y tabulación para jerarquizar metadatos (cat interpreta mejor los caracteres)\ncat(\"Metadatos del proyecto:\\n\\tAutor: IGAC\\n\\tEscala: 1:100.000\")\n\nMetadatos del proyecto:\n    Autor: IGAC\n    Escala: 1:100.000\n\n# Uso de comillas simples dentro de dobles para nombres propios\nprint(\"Nombre del archivo: 'Mapa_Relieve_Colombia.shp'\")\n\n[1] \"Nombre del archivo: 'Mapa_Relieve_Colombia.shp'\"\n\n\n\n\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\n# Salto de línea para separar información de capas geográficas\nprintln(\"Capa: Departamentos_Colombia\\nEstado: Procesada exitosamente.\")\n\n# Salto de línea y tabulación para jerarquizar metadatos\nprintln(\"Metadatos del proyecto:\\n\\tAutor: IGAC\\n\\tEscala: 1:100.000\")\n\n# Uso de comillas simples dentro de dobles para nombres propios\nprintln(\"Nombre del archivo: 'Mapa_Relieve_Colombia.shp'\")\n\n\n\n\n# #| eval: false\nj_eval('\n# Salto de línea para separar información de capas geográficas\nprintln(\"Capa: Departamentos_Colombia\\nEstado: Procesada exitosamente.\")\n\n# Salto de línea y tabulación para jerarquizar metadatos\nprintln(\"Metadatos del proyecto:\\n\\tAutor: IGAC\\n\\tEscala: 1:100.000\")\n\n# Uso de comillas simples dentro de dobles para nombres propios\nprintln(\"Nombre del archivo: \\'Mapa_Relieve_Colombia.shp\\'\")\n')\njulia&gt; # Salto de línea para separar información de capas geográficas\n\n\njulia&gt; println(\"Capa: Departamentos_Colombia\n       Estado: Procesada exitosamente.\")\n\nCapa: Departamentos_Colombia\nEstado: Procesada exitosamente.\n\n\njulia&gt; # Salto de línea y tabulación para jerarquizar metadatos\n\n\njulia&gt; println(\"Metadatos del proyecto:\n           Autor: IGAC\n           Escala: 1:100.000\")\n\nMetadatos del proyecto:\n    Autor: IGAC\n    Escala: 1:100.000\n\n\njulia&gt; # Uso de comillas simples dentro de dobles para nombres propios\n\n\njulia&gt; println(\"Nombre del archivo: 'Mapa_Relieve_Colombia.shp'\")\n\nNombre del archivo: 'Mapa_Relieve_Colombia.shp'\n\n\n\n\n\n\nCaracteres especiales de escape\n\n\n\nTabla 5.4: Caracteres de escape comunes en lenguajes de programación\n\n\n\n\n\n\n\n\n\n\nCarácter\nNombre\nDescripción Técnica\n\n\n\n\n\\n\nSalto de línea (Newline)\nMueve el cursor al inicio de la siguiente línea para organizar texto.\n\n\n\\t\nTabulación (Tab)\nInserta un espacio horizontal para crear jerarquías o sangrías.\n\n\n\\\\\nBarra invertida\nPermite imprimir el carácter \\ (crucial para rutas de archivos en sistemas locales).\n\n\n\\\"\nComilla doble\nPermite insertar comillas dobles sin cerrar prematuramente la cadena de texto.\n\n\n\\'\nComilla simple\nPermite insertar comillas simples; en Julia/R dentro de j_eval suele requerir escape extra.",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Función j_eval y j_plot en R</span>"
    ]
  },
  {
    "objectID": "05-variables_tipos_de_datos.html#comentarios",
    "href": "05-variables_tipos_de_datos.html#comentarios",
    "title": "5  Variables y Tipos de Datos",
    "section": "5.8 Comentarios",
    "text": "5.8 Comentarios\n\nPythonRJulia\n\n\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\n# Comentario de bloque: Información de procesamiento\nprint(\"Capa: Departamentos_Colombia\\nEstado: Procesada exitosamente.\")\n\n# Comentario en línea: RMSE en metros\nrmse = 0.05  # Tolerancia para precisión submétrica\n\n\"\"\"\nEste es un comentario multilínea en Python.\nSe utilizan triples comillas (aunque técnicamente son cadenas\nde texto no asignadas, se usan para documentar bloques extensos).\n\"\"\"\nprint(\"Nombre del archivo: 'Mapa_Relieve_Colombia.shp'\")\n\n\n\n\n\n# #| eval: false\n\n# Comentario de bloque: Información de procesamiento\nprint(\"Capa: Departamentos_Colombia\\nEstado: Procesada exitosamente.\")\n\nCapa: Departamentos_Colombia\nEstado: Procesada exitosamente.\n\n# Comentario en línea: RMSE en metros\nrmse = 0.05  # Tolerancia para precisión submétrica\n\n\"\"\"\nEste es un comentario multilínea en Python.\nSe utilizan triples comillas (aunque técnicamente son cadenas\nde texto no asignadas, se usan para documentar bloques extensos).\n\"\"\"\n\n'\\nEste es un comentario multilínea en Python.\\nSe utilizan triples comillas (aunque técnicamente son cadenas\\nde texto no asignadas, se usan para documentar bloques extensos).\\n'\n\nprint(\"Nombre del archivo: 'Mapa_Relieve_Colombia.shp'\")\n\nNombre del archivo: 'Mapa_Relieve_Colombia.shp'\n\n\n\n\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\n# Comentario de bloque: Información de procesamiento\nprint(\"Capa: Departamentos_Colombia\\nEstado: Procesada exitosamente.\")\n\n# Comentario en línea: RMSE en metros\nrmse &lt;- 0.05  # Tolerancia para precisión submétrica\n\n# R no tiene un operador nativo para comentarios multilínea.\n# Se deben usar múltiples numerales consecutivos para\n# documentar bloques de código extensos.\ncat(\"Metadatos del proyecto:\\n\\tAutor: IGAC\\n\\tEscala: 1:100.000\")\n\n\n\n\n\n# #| eval: false\n\n# Comentario de bloque: Información de procesamiento\nprint(\"Capa: Departamentos_Colombia\\nEstado: Procesada exitosamente.\")\n\n[1] \"Capa: Departamentos_Colombia\\nEstado: Procesada exitosamente.\"\n\n# Comentario en línea: RMSE en metros\nrmse &lt;- 0.05  # Tolerancia para precisión submétrica\n\n# R no tiene un operador nativo para comentarios multilínea.\n# Se deben usar múltiples numerales consecutivos para\n# documentar bloques de código extensos.\ncat(\"Metadatos del proyecto:\\n\\tAutor: IGAC\\n\\tEscala: 1:100.000\")\n\nMetadatos del proyecto:\n    Autor: IGAC\n    Escala: 1:100.000\n\n\n\n\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\n# Comentario de bloque: Información de procesamiento\nprintln(\"Capa: Departamentos_Colombia\\nEstado: Procesada exitosamente.\")\n\n# Comentario en línea: RMSE en metros\nrmse = 0.05  # Tolerancia para precisión submétrica\n\n#=\nEste es un comentario multilínea nativo en Julia.\nPermite comentar grandes bloques de código o explicaciones\nextensas sin necesidad de colocar numerales en cada línea.\n=#\n\n# En Julia las tres comillas sirven para \n# definir archivos de texto en memoria (no son comentarios)\ncsv_data = \"\"\"\nmunicipio,altitud\nBogota,2625\nMedellin,1495\nCali,1018\nQuibdo,43\n\"\"\"\ncsv_data\n\nprintln(\"Nombre del archivo: 'Mapa_Relieve_Colombia.shp'\")\n\n\n\n\n# #| eval: false\nj_eval('\n# Comentario de bloque: Información de procesamiento\nprintln(\"Capa: Departamentos_Colombia\\nEstado: Procesada exitosamente.\")\n\n# Comentario en línea: RMSE en metros\nrmse = 0.05  # Tolerancia para precisión submétrica\n\n#=\nEste es un comentario multilínea nativo en Julia.\nPermite comentar grandes bloques de código o explicaciones\nextensas sin necesidad de colocar numerales en cada línea.\n=#\n\n# En Julia las tres comillas sirven para \n# definir archivos de texto en memoria (no son comentarios)\ncsv_data = \"\"\"\nmunicipio,altitud\nBogota,2625\nMedellin,1495\nCali,1018\nQuibdo,43\n\"\"\"\ncsv_data\n\nprintln(\"Nombre del archivo: \\'Mapa_Relieve_Colombia.shp\\'\")\n')\njulia&gt; # Comentario de bloque: Información de procesamiento\n\n\njulia&gt; println(\"Capa: Departamentos_Colombia\n       Estado: Procesada exitosamente.\")\n\nCapa: Departamentos_Colombia\nEstado: Procesada exitosamente.\n\n\njulia&gt; # Comentario en línea: RMSE en metros\n\n\njulia&gt; rmse = 0.05  # Tolerancia para precisión submétrica\n\n0.05\n\n\njulia&gt; #=\n       Este es un comentario multilínea nativo en Julia.\n       Permite comentar grandes bloques de código o explicaciones\n       extensas sin necesidad de colocar numerales en cada línea.\n       =#\n\n\njulia&gt; # En Julia las tres comillas sirven para\n\n\njulia&gt; # definir archivos de texto en memoria (no son comentarios)\n\n\njulia&gt; csv_data = \"\"\"\n       municipio,altitud\n       Bogota,2625\n       Medellin,1495\n       Cali,1018\n       Quibdo,43\n       \"\"\"\n\n\"municipio,altitud\\nBogota,2625\\nMedellin,1495\\nCali,1018\\nQuibdo,43\\n\"\n\n\njulia&gt; csv_data\n\n\"municipio,altitud\\nBogota,2625\\nMedellin,1495\\nCali,1018\\nQuibdo,43\\n\"\n\n\njulia&gt; println(\"Nombre del archivo: 'Mapa_Relieve_Colombia.shp'\")\n\nNombre del archivo: 'Mapa_Relieve_Colombia.shp'\n\n\n\n\n\n\nDocumentación y caracteres especiales\n\n\n\nTabla 5.5: Sintaxis de documentación, escape y cadenas especiales\n\n\n\n\n\n\n\n\n\n\nCarácter\nNombre\nFunción Técnica\n\n\n\n\n#\nNumeral\nInicia comentarios de una sola línea en los tres lenguajes.\n\n\n\\n\nNewline\nInserta un salto de línea dentro de una cadena de texto.\n\n\n\\t\nTab\nInserta una tabulación horizontal (sangría).\n\n\n\"\"\"\nTriple comilla\nPython: Documentación de bloques (docstrings). Julia: Cadenas multilínea (útil para definir archivos o bloques de texto en memoria). R: No se utiliza (causa error de sintaxis).\n\n\n#= =#\nBlock comment\nDelimitador nativo de Julia para comentarios multilínea.\n\n\n\n\n\n\n\nNota técnica: En el desarrollo de herramientas automatizadas, los comentarios multilínea son el estándar para definir el encabezado del script, detallando licencias, el sistema de referencia de coordenadas (CRS) y las dependencias. Es fundamental diferenciar entre un comentario real y una cadena de texto: mientras que # y #= =# son ignorados por el compilador, las triples comillas \"\"\" en Python y Julia generan objetos en la memoria. En Python, estas actúan como comentarios “de facto” solo si no se asignan a una variable (siendo la base de los docstrings), mientras que en Julia su propósito principal es la creación de bloques de texto estructurado o archivos en memoria.",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Función j_eval y j_plot en R</span>"
    ]
  },
  {
    "objectID": "05-variables_tipos_de_datos.html#trabajando-con-variables-y-tipos-de-datos",
    "href": "05-variables_tipos_de_datos.html#trabajando-con-variables-y-tipos-de-datos",
    "title": "5  Variables y Tipos de Datos",
    "section": "5.9 Trabajando con variables y tipos de datos",
    "text": "5.9 Trabajando con variables y tipos de datos\n\nPythonRJulia\n\n\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\nimport math\n\n# Inicialización de variables para asegurar la ejecución\nnum_elementos = 500\n\n# Incrementar el número de elementos existentes\nnum_elementos += 20\nnum_elementos\n\n# Convertir la latitud de grados decimales a radianes\nlatitud_ruiz = 4.8920\nlatitud_radianes = math.radians(latitud_ruiz)\n\n# Agregar nuevas coordenadas a la lista [Lat, Lon] de Bogotá\ncoordenadas = [4.8920, -75.3188]\ncoordenadas.append(4.6097)  # Latitud de Bogotá\ncoordenadas.append(-74.0817) # Longitud de Bogotá\n\n# Acceso y formateo de cadenas usando el diccionario de atributos\nnombre_volcan = atributos_elemento[\"nombre\"]\naltura_volcan = atributos_elemento[\"altura_msnm\"]\nmensaje = f\"{nombre_volcan} tiene una altura de {altura_volcan} metros.\"\n\n# Mostrar el resultado final\nmensaje\n\n\n\n\n\n# #| eval: false\n\nimport math\n\n# Inicialización de variables para asegurar la ejecución\nnum_elementos = 500\n\n# Incrementar el número de elementos existentes\nnum_elementos += 20\nnum_elementos\n\n520\n\n# Convertir la latitud de grados decimales a radianes\nlatitud_ruiz = 4.8920\nlatitud_radianes = math.radians(latitud_ruiz)\n\n# Agregar nuevas coordenadas a la lista [Lat, Lon] de Bogotá\ncoordenadas = [4.8920, -75.3188]\ncoordenadas.append(4.6097)  # Latitud de Bogotá\ncoordenadas.append(-74.0817) # Longitud de Bogotá\n\n# Acceso y formateo de cadenas usando el diccionario de atributos\nnombre_volcan = atributos_elemento[\"nombre\"]\naltura_volcan = atributos_elemento[\"altura_msnm\"]\nmensaje = f\"{nombre_volcan} tiene una altura de {altura_volcan} metros.\"\n\n# Mostrar el resultado final\nmensaje\n\n'Nevado del Ruiz tiene una altura de 5321 metros.'\n\n\n\n\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\n# Inicialización de variables necesarias\nnum_elementos &lt;- 500\n# Incrementar el número de elementos\nnum_elementos &lt;- num_elementos + 20\nnum_elementos\n\n# Convertir latitud a radianes\nlatitud_ruiz &lt;- 4.8920\nlatitud_radianes &lt;- latitud_ruiz * (pi / 180)\n\n# Agregar elementos a un vector (creando una copia combinada)\ncoordenadas &lt;- c(4.8920, -75.3188)\ncoordenadas &lt;- c(coordenadas, 4.6097, -74.0817)\n\n# Acceso a lista y formateo de cadenas\nnombre_volcan &lt;- atributos_elemento$nombre\naltura_volcan &lt;- atributos_elemento$altura_msnm\nmensaje &lt;- paste(nombre_volcan, \"tiene una altura de\", altura_volcan, \"metros.\")\n\n# Mostrar el resultado final\nmensaje\n\n\n\n\n\n# #| eval: false\n\n# Inicialización de variables necesarias\nnum_elementos &lt;- 500\n# Incrementar el número de elementos\nnum_elementos &lt;- num_elementos + 20\nnum_elementos\n\n[1] 520\n\n# Convertir latitud a radianes\nlatitud_ruiz &lt;- 4.8920\nlatitud_radianes &lt;- latitud_ruiz * (pi / 180)\n\n# Agregar elementos a un vector (creando una copia combinada)\ncoordenadas &lt;- c(4.8920, -75.3188)\ncoordenadas &lt;- c(coordenadas, 4.6097, -74.0817)\n\n# Acceso a lista y formateo de cadenas\nnombre_volcan &lt;- atributos_elemento$nombre\naltura_volcan &lt;- atributos_elemento$altura_msnm\nmensaje &lt;- paste(nombre_volcan, \"tiene una altura de\", altura_volcan, \"metros.\")\n\n# Mostrar el resultado final\nmensaje\n\n[1] \"Nevado del Ruiz tiene una altura de 5321 metros.\"\n\n\n\n\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\n# Inicialización de variables necesarias\nnum_elementos = 500\n# Incrementar el número de elementos\nnum_elementos += 20\nnum_elementos\n\n# Convertir latitud a radianes usando la función nativa deg2rad\nlatitud_ruiz = 4.8920\nlatitud_radianes = deg2rad(latitud_ruiz)\n\n# Agregar coordenadas a un arreglo (push! modifica el objeto original)\ncoordenadas = [4.8920, -75.3188]\npush!(coordenadas, 4.6097)\npush!(coordenadas, -74.0817)\n\n# Acceso a Diccionario e interpolación de texto\nnombre_volcan = atributos_elemento[\"nombre\"]\naltura_volcan = atributos_elemento[\"altura_msnm\"]\nmensaje = \"$nombre_volcan tiene una altura de $altura_volcan metros.\"\n\n# Mostrar el resultado final\nmensaje\n\n\n\n\n# #| eval: false\nj_eval('\n# Inicialización de variables necesarias\nnum_elementos = 500\n# Incrementar el número de elementos\nnum_elementos += 20\nnum_elementos\n\n# Convertir latitud a radianes usando la función nativa deg2rad\nlatitud_ruiz = 4.8920\nlatitud_radianes = deg2rad(latitud_ruiz)\n\n# Agregar coordenadas a un arreglo\ncoordenadas = [4.8920, -75.3188]\npush!(coordenadas, 4.6097)\npush!(coordenadas, -74.0817)\n\n# Acceso e interpolación de texto\nnombre_volcan = atributos_elemento[\"nombre\"]\naltura_volcan = atributos_elemento[\"altura_msnm\"]\nmensaje = \"$nombre_volcan tiene una altura de $altura_volcan metros.\"\n\n# Mostrar el resultado final\nmensaje\n')\njulia&gt; # Inicialización de variables necesarias\n\n\njulia&gt; num_elementos = 500\n\n500\n\n\njulia&gt; # Incrementar el número de elementos\n\n\njulia&gt; num_elementos += 20\n\n520\n\n\njulia&gt; num_elementos\n\n520\n\n\njulia&gt; # Convertir latitud a radianes usando la función nativa deg2rad\n\n\njulia&gt; latitud_ruiz = 4.8920\n\n4.892\n\n\njulia&gt; latitud_radianes = deg2rad(latitud_ruiz)\n\n0.08538150700756261\n\n\njulia&gt; # Agregar coordenadas a un arreglo\n\n\njulia&gt; coordenadas = [4.8920, -75.3188]\n\n2-element Vector{Float64}:\n   4.892\n -75.3188\n\n\njulia&gt; push!(coordenadas, 4.6097)\n\n3-element Vector{Float64}:\n   4.892\n -75.3188\n   4.6097\n\n\njulia&gt; push!(coordenadas, -74.0817)\n\n4-element Vector{Float64}:\n   4.892\n -75.3188\n   4.6097\n -74.0817\n\n\njulia&gt; # Acceso e interpolación de texto\n\n\njulia&gt; nombre_volcan = atributos_elemento[\"nombre\"]\n\n\"Nevado del Ruiz\"\n\n\njulia&gt; altura_volcan = atributos_elemento[\"altura_msnm\"]\n\n5321\n\n\njulia&gt; mensaje = \"$nombre_volcan tiene una altura de $altura_volcan metros.\"\n\n\"Nevado del Ruiz tiene una altura de 5321 metros.\"\n\n\njulia&gt; # Mostrar el resultado final\n\n\njulia&gt; mensaje\n\n\"Nevado del Ruiz tiene una altura de 5321 metros.\"\n\n\n\n\n\n\n\n\nTabla 5.6: Comparación de operaciones comunes con variables\n\n\n\n\n\n\n\n\n\n\n\nOperación\nPython\nR\nJulia\n\n\n\n\nIncremento\n+=\nx &lt;- x + n\n+=\n\n\nGrados a Radianes\nmath.radians()\nx * (pi/180)\ndeg2rad()\n\n\nAgregar a lista\n.append() (Mutable)\nc(x, n) (Inmutable)\npush!() (Mutable)\n\n\nInterpolación de texto\nf\"{var}\"\npaste() / sprintf()\n\"$var\"\n\n\n\n\n\n\nNota técnica: En el desarrollo de algoritmos geográficos, la mutabilidad es un concepto clave. Mientras que Python y Julia permiten modificar una lista de coordenadas directamente (append / push!), en R los vectores son inmutables; cada vez que “agregamos” un dato, R crea una copia nueva del vector en memoria.",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Función j_eval y j_plot en R</span>"
    ]
  },
  {
    "objectID": "05-variables_tipos_de_datos.html#operaciones-básicas-con-texto",
    "href": "05-variables_tipos_de_datos.html#operaciones-básicas-con-texto",
    "title": "5  Variables y Tipos de Datos",
    "section": "5.10 Operaciones básicas con texto",
    "text": "5.10 Operaciones básicas con texto\n\nPythonRJulia\n\n\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\n# Inicialización de la variable de texto\nnombre_ciudad = \"cartagena de indias\"\n\n# Convertir a minúsculas\nciudad_minusculas = nombre_ciudad.lower()\nprint(\"Minúsculas:\", ciudad_minusculas)\n\n# Convertir a mayúsculas (útil para estandarizar tablas de atributos)\nciudad_mayusculas = nombre_ciudad.upper()\nprint(\"Mayúsculas:\", ciudad_mayusculas)\n\n# Convertir a formato título (primera letra de cada palabra en mayúscula)\nciudad_titulo = nombre_ciudad.title()\nprint(\"Formato título:\", ciudad_titulo)\n\n# Reemplazar texto específico dentro de una cadena\nciudad_original = \"San Andrés\"\nnueva_ciudad = ciudad_original.replace(\"San\", \"Isla de San\")\nprint(\"Original:\", ciudad_original)\nprint(\"Modificada:\", nueva_ciudad)\n\n# Limpiar espacios en blanco al inicio y al final (Trim)\ndatos_ubicacion = \"   Bogotá D.C.   \"\nubicacion_limpia = datos_ubicacion.strip()\nprint(\"Texto limpio:\", f\"'{ubicacion_limpia}'\")\n\n\n\n\n\n# #| eval: false\n\n# Inicialización de la variable de texto\nnombre_ciudad = \"cartagena de indias\"\n\n# Convertir a minúsculas\nciudad_minusculas = nombre_ciudad.lower()\nprint(\"Minúsculas:\", ciudad_minusculas)\n\nMinúsculas: cartagena de indias\n\n# Convertir a mayúsculas (útil para estandarizar tablas de atributos)\nciudad_mayusculas = nombre_ciudad.upper()\nprint(\"Mayúsculas:\", ciudad_mayusculas)\n\nMayúsculas: CARTAGENA DE INDIAS\n\n# Convertir a formato título (primera letra de cada palabra en mayúscula)\nciudad_titulo = nombre_ciudad.title()\nprint(\"Formato título:\", ciudad_titulo)\n\nFormato título: Cartagena De Indias\n\n# Reemplazar texto específico dentro de una cadena\nciudad_original = \"San Andrés\"\nnueva_ciudad = ciudad_original.replace(\"San\", \"Isla de San\")\nprint(\"Original:\", ciudad_original)\n\nOriginal: San Andrés\n\nprint(\"Modificada:\", nueva_ciudad)\n\nModificada: Isla de San Andrés\n\n# Limpiar espacios en blanco al inicio y al final (Trim)\ndatos_ubicacion = \"   Bogotá D.C.   \"\nubicacion_limpia = datos_ubicacion.strip()\nprint(\"Texto limpio:\", f\"'{ubicacion_limpia}'\")\n\nTexto limpio: 'Bogotá D.C.'\n\n\n\n\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\n# Cargar paquete nativo recomendado para formato título\nlibrary(tools)\n\n# Inicialización de la variable de texto\nnombre_ciudad &lt;- \"cartagena de indias\"\n\n# Convertir a minúsculas\nciudad_minusculas &lt;- tolower(nombre_ciudad)\ncat(\"Minúsculas:\", ciudad_minusculas, \"\\n\")\n\n# Convertir a mayúsculas (útil para estandarizar tablas de atributos)\nciudad_mayusculas &lt;- toupper(nombre_ciudad)\ncat(\"Mayúsculas:\", ciudad_mayusculas, \"\\n\")\n\n# Convertir a formato título\nciudad_titulo &lt;- toTitleCase(nombre_ciudad)\ncat(\"Formato título:\", ciudad_titulo, \"\\n\")\n\n# Reemplazar texto específico dentro de una cadena\nciudad_original &lt;- \"San Andrés\"\nnueva_ciudad &lt;- gsub(\"San\", \"Isla de San\", ciudad_original)\ncat(\"Original:\", ciudad_original, \"\\n\")\ncat(\"Modificada:\", nueva_ciudad, \"\\n\")\n\n# Limpiar espacios en blanco al inicio y al final (Trim)\ndatos_ubicacion &lt;- \"   Bogotá D.C.   \"\nubicacion_limpia &lt;- trimws(datos_ubicacion)\ncat(\"Texto limpio: '\", ubicacion_limpia, \"'\\n\", sep=\"\")\n\n\n\n\n\n# #| eval: false\n\n# Cargar paquete nativo recomendado para formato título\nlibrary(tools)\n\n# Inicialización de la variable de texto\nnombre_ciudad &lt;- \"cartagena de indias\"\n\n# Convertir a minúsculas\nciudad_minusculas &lt;- tolower(nombre_ciudad)\ncat(\"Minúsculas:\", ciudad_minusculas, \"\\n\")\n\nMinúsculas: cartagena de indias \n\n# Convertir a mayúsculas (útil para estandarizar tablas de atributos)\nciudad_mayusculas &lt;- toupper(nombre_ciudad)\ncat(\"Mayúsculas:\", ciudad_mayusculas, \"\\n\")\n\nMayúsculas: CARTAGENA DE INDIAS \n\n# Convertir a formato título\nciudad_titulo &lt;- toTitleCase(nombre_ciudad)\ncat(\"Formato título:\", ciudad_titulo, \"\\n\")\n\nFormato título: Cartagena De Indias \n\n# Reemplazar texto específico dentro de una cadena\nciudad_original &lt;- \"San Andrés\"\nnueva_ciudad &lt;- gsub(\"San\", \"Isla de San\", ciudad_original)\ncat(\"Original:\", ciudad_original, \"\\n\")\n\nOriginal: San Andrés \n\ncat(\"Modificada:\", nueva_ciudad, \"\\n\")\n\nModificada: Isla de San Andrés \n\n# Limpiar espacios en blanco al inicio y al final (Trim)\ndatos_ubicacion &lt;- \"   Bogotá D.C.   \"\nubicacion_limpia &lt;- trimws(datos_ubicacion)\ncat(\"Texto limpio: '\", ubicacion_limpia, \"'\\n\", sep=\"\")\n\nTexto limpio: 'Bogotá D.C.'\n\n\n\n\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\n# Inicialización de la variable de texto\nnombre_ciudad = \"cartagena de indias\"\n\n# Convertir a minúsculas\nciudad_minusculas = lowercase(nombre_ciudad)\nprintln(\"Minúsculas: \", ciudad_minusculas)\n\n# Convertir a mayúsculas (útil para estandarizar tablas de atributos)\nciudad_mayusculas = uppercase(nombre_ciudad)\nprintln(\"Mayúsculas: \", ciudad_mayusculas)\n\n# Convertir a formato título (primera letra de cada palabra en mayúscula)\nciudad_titulo = titlecase(nombre_ciudad)\nprintln(\"Formato título: \", ciudad_titulo)\n\n# Reemplazar texto específico dentro de una cadena (usa el operador Pair =&gt;)\nciudad_original = \"San Andrés\"\nnueva_ciudad = replace(ciudad_original, \"San\" =&gt; \"Isla de San\")\nprintln(\"Original: \", ciudad_original)\nprintln(\"Modificada: \", nueva_ciudad)\n\n# Limpiar espacios en blanco al inicio y al final (Trim)\ndatos_ubicacion = \"   Bogotá D.C.   \"\nubicacion_limpia = strip(datos_ubicacion)\nprintln(\"Texto limpio: '\", ubicacion_limpia, \"'\")\n\n\n\n\n# #| eval: false\nj_eval('\n# Inicialización de la variable de texto\nnombre_ciudad = \"cartagena de indias\"\n\n# Convertir a minúsculas\nciudad_minusculas = lowercase(nombre_ciudad)\nprintln(\"Minúsculas: \", ciudad_minusculas)\n\n# Convertir a mayúsculas (útil para estandarizar tablas de atributos)\nciudad_mayusculas = uppercase(nombre_ciudad)\nprintln(\"Mayúsculas: \", ciudad_mayusculas)\n\n# Convertir a formato título (primera letra de cada palabra en mayúscula)\nciudad_titulo = titlecase(nombre_ciudad)\nprintln(\"Formato título: \", ciudad_titulo)\n\n# Reemplazar texto específico dentro de una cadena (usa el operador Pair =&gt;)\nciudad_original = \"San Andrés\"\nnueva_ciudad = replace(ciudad_original, \"San\" =&gt; \"Isla de San\")\nprintln(\"Original: \", ciudad_original)\nprintln(\"Modificada: \", nueva_ciudad)\n\n# Limpiar espacios en blanco al inicio y al final (Trim)\ndatos_ubicacion = \"   Bogotá D.C.   \"\nubicacion_limpia = strip(datos_ubicacion)\nprintln(\"Texto limpio: \\'\", ubicacion_limpia, \"\\'\")\n')\njulia&gt; # Inicialización de la variable de texto\n\n\njulia&gt; nombre_ciudad = \"cartagena de indias\"\n\n\"cartagena de indias\"\n\n\njulia&gt; # Convertir a minúsculas\n\n\njulia&gt; ciudad_minusculas = lowercase(nombre_ciudad)\n\n\"cartagena de indias\"\n\n\njulia&gt; println(\"Minúsculas: \", ciudad_minusculas)\n\nMinúsculas: cartagena de indias\n\n\njulia&gt; # Convertir a mayúsculas (útil para estandarizar tablas de atributos)\n\n\njulia&gt; ciudad_mayusculas = uppercase(nombre_ciudad)\n\n\"CARTAGENA DE INDIAS\"\n\n\njulia&gt; println(\"Mayúsculas: \", ciudad_mayusculas)\n\nMayúsculas: CARTAGENA DE INDIAS\n\n\njulia&gt; # Convertir a formato título (primera letra de cada palabra en mayúscula)\n\n\njulia&gt; ciudad_titulo = titlecase(nombre_ciudad)\n\n\"Cartagena De Indias\"\n\n\njulia&gt; println(\"Formato título: \", ciudad_titulo)\n\nFormato título: Cartagena De Indias\n\n\njulia&gt; # Reemplazar texto específico dentro de una cadena (usa el operador Pair =&gt;)\n\n\njulia&gt; ciudad_original = \"San Andrés\"\n\n\"San Andrés\"\n\n\njulia&gt; nueva_ciudad = replace(ciudad_original, \"San\" =&gt; \"Isla de San\")\n\n\"Isla de San Andrés\"\n\n\njulia&gt; println(\"Original: \", ciudad_original)\n\nOriginal: San Andrés\n\n\njulia&gt; println(\"Modificada: \", nueva_ciudad)\n\nModificada: Isla de San Andrés\n\n\njulia&gt; # Limpiar espacios en blanco al inicio y al final (Trim)\n\n\njulia&gt; datos_ubicacion = \"   Bogotá D.C.   \"\n\n\"   Bogotá D.C.   \"\n\n\njulia&gt; ubicacion_limpia = strip(datos_ubicacion)\n\n\"Bogotá D.C.\"\n\n\njulia&gt; println(\"Texto limpio: '\", ubicacion_limpia, \"'\")\n\nTexto limpio: 'Bogotá D.C.'\n\n\n\n\n\n\n\n\nTabla 5.7: Equivalencias de funciones para manipulación de cadenas de texto\n\n\n\n\n\n\n\n\n\n\n\nOperación\nPython\nR\nJulia\n\n\n\n\nMinúsculas\n.lower()\ntolower()\nlowercase()\n\n\nMayúsculas\n.upper()\ntoupper()\nuppercase()\n\n\nFormato Título\n.title()\ntools::toTitleCase()\ntitlecase()\n\n\nReemplazar\n.replace(\"viejo\", \"nuevo\")\ngsub(\"viejo\", \"nuevo\", var)\nreplace(var, \"viejo\" =&gt; \"nuevo\")\n\n\nLimpiar Espacios\n.strip()\ntrimws()\nstrip()\n\n\n\n\n\n\n\nNota técnica: En el geoprocesamiento, la limpieza de cadenas de texto (string parsing) es una fase crítica antes de realizar cruces espaciales o uniones de tablas (joins). Diferencias imperceptibles como espacios en blanco accidentales (\"Bogotá \" vs \"Bogotá\") o discrepancias de mayúsculas y minúsculas provocarán que el software GIS falle al emparejar los registros. Las funciones de strip() y upper() son la primera línea de defensa para garantizar la integridad topológica y tabular de los datos.",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Función j_eval y j_plot en R</span>"
    ]
  },
  {
    "objectID": "05-variables_tipos_de_datos.html#resumen-de-aprendizajes-cheat-sheet",
    "href": "05-variables_tipos_de_datos.html#resumen-de-aprendizajes-cheat-sheet",
    "title": "5  Variables y Tipos de Datos",
    "section": "5.11 Resumen de aprendizajes (cheat sheet)",
    "text": "5.11 Resumen de aprendizajes (cheat sheet)\nEn esta sección hemos abordado los cimientos de la programación aplicados al análisis de datos. A continuación, se presenta un Cheat Sheet (Hoja de Referencia) consolidado con las equivalencias sintácticas y funcionales entre Python, R y Julia.\n\n1. Asignación, Variables e Indexación\n\n\n\nTabla 5.8: Resumen de sintaxis y manejo de variables\n\n\n\n\n\n\n\n\n\n\n\nConcepto / Operación\nPython\nR\nJulia\n\n\n\n\nAsignación Básica\n=\n&lt;- (Recomendado) o =\n=\n\n\nImprimir en consola\nprint(var)\nprint(var) o cat(var)\nprintln(var)\n\n\nInterpolación de texto\nf\"Texto {var}\"\npaste(\"Texto\", var)\n\"Texto $var\"\n\n\nIncrementar valor\nx += 1\nx &lt;- x + 1\nx += 1\n\n\nÍndice Inicial (Arrays)\n[0] (Base 0)\n[1] (Base 1)\n[1] (Base 1)\n\n\nÚltimo elemento\n[-1]\n[length(x)]\n[end]\n\n\n\n\n\n\n\n\n2. Estructuras y Tipos de Datos Geoespaciales\n\n\n\nTabla 5.9: Resumen de estructuras de datos y tipos\n\n\n\n\n\n\n\n\n\n\n\nConcepto\nPython\nR\nJulia\n\n\n\n\nNúmero Entero\nint (ej. 500)\ninteger (ej. 500L)\nInt64 (ej. 500)\n\n\nNúmero Decimal\nfloat\nnumeric\nFloat64\n\n\nBooleano\nbool (True/False)\nlogical (TRUE/FALSE)\nBool (true/false)\n\n\nLista de Coordenadas\nlist [4.8, -75.3] (Mutable)\nvector c(4.8, -75.3) (Inmutable)\nArray [4.8, -75.3] (Mutable)\n\n\nAgregar a Lista/Array\nlista.append(x)\nv &lt;- c(v, x)\npush!(lista, x)\n\n\nAtributos (Diccionario)\ndict { \"clave\": valor }\nlist list(clave = valor)\nDict Dict(\"clave\" =&gt; valor)\n\n\n\n\n\n\n\n\n3. Manipulación de Cadenas de Texto (Limpieza Tabular)\n\n\n\nTabla 5.10: Resumen de funciones para limpieza de texto (String Parsing)\n\n\n\n\n\n\n\n\n\n\n\nOperación\nPython\nR\nJulia\n\n\n\n\nA minúsculas\nvar.lower()\ntolower(var)\nlowercase(var)\n\n\nA MAYÚSCULAS\nvar.upper()\ntoupper(var)\nuppercase(var)\n\n\nFormato Título\nvar.title()\ntools::toTitleCase(var)\ntitlecase(var)\n\n\nReemplazar texto\nvar.replace(\"a\", \"b\")\ngsub(\"a\", \"b\", var)\nreplace(var, \"a\" =&gt; \"b\")\n\n\nQuitar espacios vacíos\nvar.strip()\ntrimws(var)\nstrip(var)\n\n\n\n\n\n\n\n\n4. Documentación y Caracteres Especiales\n\n\n\nTabla 5.11: Resumen de caracteres de escape y documentación\n\n\n\n\n\n\n\n\n\n\n\nCarácter\nPython\nR\nJulia\n\n\n\n\n#\nComentario en línea.\nComentario en línea.\nComentario en línea.\n\n\n\\n\nSalto de línea.\nSalto de línea.\nSalto de línea.\n\n\n\\t\nTabulación.\nTabulación.\nTabulación.\n\n\n\"\"\"\nDocstrings (Comentarios).\nCausa error de sintaxis.\nCadenas/Archivos multilínea.\n\n\n#= =#\nNo soportado.\nNo soportado.\nComentario de bloque nativo.\n\n\n\n\n\n\n\nConclusión del Módulo: La correcta elección de los tipos de datos (Listas vs. Diccionarios), la comprensión del índice de origen (Base 0 vs. Base 1) y la estandarización de nombres (snake_case) son los pilares fundamentales para escribir algoritmos robustos. Un manejo deficiente en la limpieza de texto (mayúsculas, minúsculas, espacios) o en la mutabilidad de las variables, suele ser la causa principal de fallos silenciosos durante los procesos de cruce y análisis espacial.",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Función j_eval y j_plot en R</span>"
    ]
  },
  {
    "objectID": "05-variables_tipos_de_datos.html#ejercicios",
    "href": "05-variables_tipos_de_datos.html#ejercicios",
    "title": "5  Variables y Tipos de Datos",
    "section": "5.12 Ejercicios",
    "text": "5.12 Ejercicios\nPara poner en práctica los conceptos aprendidos, deberás resolver los siguientes dos ejercicios. Puedes elegir resolverlos en Python, R o Julia (o implementar la solución en varios lenguajes si deseas retarte).\n\nEjercicio 1: Asignación de variables y operaciones básicas\nContexto: Formas parte del equipo SIG de una corporación autónoma regional y necesitas estructurar los metadatos de una nueva estación de monitoreo ambiental antes de ingresarla a la base de datos espacial.\nInstrucciones de código:\n\nDefine las siguientes variables respetando estrictamente el estándar snake_case:\n\nNombre de la estación: “Páramo de Santurbán”\nLatitud: 7.2514\nLongitud: -72.9069\nElevación en metros: 3350\n¿Está activa?: Verdadero (Usa el tipo booleano correcto según tu lenguaje).\n\nCrea una estructura de colección (Lista en Python, Vector en R, o Array en Julia) que contenga la Latitud y la Longitud, en ese orden.\nCrea un Diccionario (o Lista con nombres en R) llamado metadatos_estacion que agrupe todas las variables anteriores bajo claves descriptivas.\nUsando la indexación adecuada (Base 0 o Base 1, según el lenguaje que elegiste), extrae específicamente la Longitud desde la colección de coordenadas que está dentro del diccionario y guárdala en una nueva variable.\nSe ha realizado una nueva medición topográfica y la elevación real es 12.5 metros más alta. Actualiza la variable de elevación utilizando el operador de incremento.\nImprime en consola un mensaje dinámico utilizando interpolación de texto (ej. f-strings, paste() o $) que diga exactamente: “La estación [Nombre] se encuentra operativa en la longitud [Longitud] a una altura actualizada de [Elevación] msnm.”\n\n\n\nEjercicio 2: Trabajando con strings\nContexto: Has recibido una tabla de Excel con la toponimia de áreas protegidas de Colombia capturada manualmente por diferentes operarios. Los textos están sucios y, si intentas hacer un cruce espacial (Spatial Join) con la capa oficial del IGAC, el software arrojará errores de topología tabular.\nInstrucciones de código:\n\nInicializa una variable con el siguiente texto crudo y problemático: registro_crudo = \"   sAnTuaRio de fAuna Y flora iGuaQue   \"\nUtiliza el método o función nativa de tu lenguaje (vista en la sección anterior) para eliminar los espacios en blanco accidentales al inicio y al final del texto.\nUsa el comando correspondiente para convertir el texto limpio a formato de Título (Title Case), estandarizando así las mayúsculas y minúsculas.\nEmplea la herramienta de reemplazo de texto para cambiar la letra ” Y ” por ” y ” (en minúscula), de modo que el conector gramatical sea correcto.\nUtiliza caracteres de escape (\\n y \\t) para imprimir un pequeño reporte estructurado que muestre el antes y el después, similar a esto:\n\nReporte de Limpieza Toponímica:\n    Registro Original: \"   sAnTuaRio de fAuna Y flora iGuaQue   \"\n    Registro Limpio: \"Santuario De Fauna y Flora Iguaque\"\nEstado: Listo para cruce espacial.\n\n\nEntregables y Criterios de Evaluación\nEl objetivo de esta evaluación no es solo que el código funcione, sino que seas capaz de documentar y explicar tus decisiones técnicas.\n1. Archivos de Código: Debes desarrollar los algoritmos en al menos uno de los siguientes formatos de archivo: * Script tradicional (.py, .R, .jl) * Notebook interactivo (.ipynb) * Documento computacional (.qmd con chunks de código)\n2. Documento Analítico (Quarto): Independientemente del formato de tu código fuente, debes redactar un documento en Quarto (.qmd) y renderizarlo tanto en HTML como en PDF. En este documento debes incluir tus bloques de código y responder argumentativamente a las siguientes preguntas:\n\nSobre el Ejercicio 1: ¿Qué índice numérico utilizaste para extraer la longitud de la colección y por qué ese número específicamente? ¿Qué error arrojaría el lenguaje si usas el índice del lenguaje opuesto (ej. usar 0 en R o 1 en Python buscando el primer elemento)?\nSobre el Ejercicio 2: En términos de geoprocesamiento de bases de datos relacionales, ¿por qué es un paso crítico y obligatorio aplicar métodos de limpieza como .strip() o trimws() antes de realizar uniones de tablas (Joins) basadas en nombres de municipios o regiones?\nPregunta General: Explica brevemente la diferencia fundamental entre el uso de triples comillas \"\"\" en Python versus su uso en Julia.\n\n3. Repositorio en GitHub: Sube tu carpeta del proyecto (que debe contener tus scripts, el archivo .qmd y los renders finales en HTML y PDF) a un repositorio público en tu cuenta personal de GitHub. * Entrega: Deberás enviar únicamente el enlace (URL) a tu repositorio de GitHub para la calificación.",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Función j_eval y j_plot en R</span>"
    ]
  },
  {
    "objectID": "06-estructuras_datos.html",
    "href": "06-estructuras_datos.html",
    "title": "6  Estructuras de datos",
    "section": "",
    "text": "6.1 Función j_eval y j_plot en R\nCódigo\n# #| include: false\n#| results: asis\nsource(\"./docs/j_eval_j_plot.r\")",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Función j_eval y j_plot en R</span>"
    ]
  },
  {
    "objectID": "06-estructuras_datos.html#introducción",
    "href": "06-estructuras_datos.html#introducción",
    "title": "6  Estructuras de datos",
    "section": "6.2 Introducción",
    "text": "6.2 Introducción",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Función j_eval y j_plot en R</span>"
    ]
  },
  {
    "objectID": "06-estructuras_datos.html#objetivos-de-aprendizaje",
    "href": "06-estructuras_datos.html#objetivos-de-aprendizaje",
    "title": "6  Estructuras de datos",
    "section": "6.3 Objetivos de aprendizaje",
    "text": "6.3 Objetivos de aprendizaje",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Función j_eval y j_plot en R</span>"
    ]
  },
  {
    "objectID": "06-estructuras_datos.html#tuplas",
    "href": "06-estructuras_datos.html#tuplas",
    "title": "6  Estructuras de datos",
    "section": "6.4 Tuplas",
    "text": "6.4 Tuplas\nLas Tuplas son estructuras de datos diseñadas para almacenar una colección de elementos. Su característica más importante es la inmutabilidad: una vez creada una tupla, sus elementos no pueden ser alterados, añadidos ni eliminados. Esto las hace perfectas para almacenar pares de coordenadas estáticas (Latitud, Longitud) que no deben modificarse accidentalmente durante la ejecución de un algoritmo espacial.\n\nPythonRJulia\n\n\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\n# Creación de una tupla estática (Latitud, Longitud) de Bogotá\npunto_bogota = (4.6097, -74.0817)\nprint(f\"Coordenadas de Bogotá: {punto_bogota}\")\n\n# Acceso a los elementos de la tupla (Recordar: Índice Base 0)\nlatitud = punto_bogota[0]\nlongitud = punto_bogota[1]\nprint(f\"Latitud: {latitud}\")\nprint(f\"Longitud: {longitud}\")\n\n# Desempaquetado de tuplas (Tuple Unpacking) en variables separadas\nlat, lon = punto_bogota\nprint(f\"Bogotá está ubicada a {lat}°N, {lon}°W\")\n\n# Almacenamiento de múltiples puntos geográficos como tuplas\nmedellin = (6.2442, -75.5812)\ncali = (3.4516, -76.5320)\ncartagena = (10.3910, -75.4794)\n\nprint(f\"Medellín: {medellin}\")\nprint(f\"Cali: {cali}\")\nprint(f\"Cartagena: {cartagena}\")\n\n\n\n\n\n# #| eval: false\n\n# Creación de una tupla estática (Latitud, Longitud) de Bogotá\npunto_bogota = (4.6097, -74.0817)\nprint(f\"Coordenadas de Bogotá: {punto_bogota}\")\n\nCoordenadas de Bogotá: (4.6097, -74.0817)\n\n# Acceso a los elementos de la tupla (Recordar: Índice Base 0)\nlatitud = punto_bogota[0]\nlongitud = punto_bogota[1]\nprint(f\"Latitud: {latitud}\")\n\nLatitud: 4.6097\n\nprint(f\"Longitud: {longitud}\")\n\nLongitud: -74.0817\n\n# Desempaquetado de tuplas (Tuple Unpacking) en variables separadas\nlat, lon = punto_bogota\nprint(f\"Bogotá está ubicada a {lat}°N, {lon}°W\")\n\nBogotá está ubicada a 4.6097°N, -74.0817°W\n\n# Almacenamiento de múltiples puntos geográficos como tuplas\nmedellin = (6.2442, -75.5812)\ncali = (3.4516, -76.5320)\ncartagena = (10.3910, -75.4794)\n\nprint(f\"Medellín: {medellin}\")\n\nMedellín: (6.2442, -75.5812)\n\nprint(f\"Cali: {cali}\")\n\nCali: (3.4516, -76.532)\n\nprint(f\"Cartagena: {cartagena}\")\n\nCartagena: (10.391, -75.4794)\n\n\n\n\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\n# R no tiene \"tuplas\" nativas; usamos vectores 'c()' para coordenadas\npunto_bogota &lt;- c(4.6097, -74.0817)\ncat(\"Coordenadas de Bogotá:\", punto_bogota, \"\\n\")\n\n# Acceso a los elementos (Recordar: Índice Base 1)\nlatitud &lt;- punto_bogota[1]\nlongitud &lt;- punto_bogota[2]\ncat(\"Latitud:\", latitud, \"\\n\")\ncat(\"Longitud:\", longitud, \"\\n\")\n\n# Asignación de variables (R nativo no tiene desempaquetado automático)\nlat &lt;- punto_bogota[1]\nlon &lt;- punto_bogota[2]\ncat(sprintf(\"Bogotá está ubicada a %s°N, %s°W\\n\", lat, lon))\n\n# Almacenamiento de múltiples puntos geográficos\nmedellin &lt;- c(6.2442, -75.5812)\ncali &lt;- c(3.4516, -76.5320)\ncartagena &lt;- c(10.3910, -75.4794)\n\ncat(\"Medellín:\", medellin, \"\\n\")\ncat(\"Cali:\", cali, \"\\n\")\ncat(\"Cartagena:\", cartagena, \"\\n\")\n\n\n\n\n\n# #| eval: false\n\n# R no tiene \"tuplas\" nativas; usamos vectores 'c()' para coordenadas\npunto_bogota &lt;- c(4.6097, -74.0817)\ncat(\"Coordenadas de Bogotá:\", punto_bogota, \"\\n\")\n\nCoordenadas de Bogotá: 4.6097 -74.0817 \n\n# Acceso a los elementos (Recordar: Índice Base 1)\nlatitud &lt;- punto_bogota[1]\nlongitud &lt;- punto_bogota[2]\ncat(\"Latitud:\", latitud, \"\\n\")\n\nLatitud: 4.6097 \n\ncat(\"Longitud:\", longitud, \"\\n\")\n\nLongitud: -74.0817 \n\n# Asignación de variables (R nativo no tiene desempaquetado automático)\nlat &lt;- punto_bogota[1]\nlon &lt;- punto_bogota[2]\ncat(sprintf(\"Bogotá está ubicada a %s°N, %s°W\\n\", lat, lon))\n\nBogotá está ubicada a 4.6097°N, -74.0817°W\n\n# Almacenamiento de múltiples puntos geográficos\nmedellin &lt;- c(6.2442, -75.5812)\ncali &lt;- c(3.4516, -76.5320)\ncartagena &lt;- c(10.3910, -75.4794)\n\ncat(\"Medellín:\", medellin, \"\\n\")\n\nMedellín: 6.2442 -75.5812 \n\ncat(\"Cali:\", cali, \"\\n\")\n\nCali: 3.4516 -76.532 \n\ncat(\"Cartagena:\", cartagena, \"\\n\")\n\nCartagena: 10.391 -75.4794 \n\n\n\n\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\n# Creación de una tupla estática (Latitud, Longitud) de Bogotá\npunto_bogota = (4.6097, -74.0817)\nprintln(\"Coordenadas de Bogotá: \", punto_bogota)\n\n# Acceso a los elementos de la tupla (Recordar: Índice Base 1)\nlatitud = punto_bogota[1]\nlongitud = punto_bogota[2]\nprintln(\"Latitud: \", latitud)\nprintln(\"Longitud: \", longitud)\n\n# Desempaquetado de tuplas (Tuple Unpacking)\nlat, lon = punto_bogota\nprintln(\"Bogotá está ubicada a $lat°N, $lon°W\")\n\n# Almacenamiento de múltiples puntos geográficos como tuplas\nmedellin = (6.2442, -75.5812)\ncali = (3.4516, -76.5320)\ncartagena = (10.3910, -75.4794)\n\nprintln(\"Medellín: \", medellin)\nprintln(\"Cali: \", cali)\nprintln(\"Cartagena: \", cartagena)\n\n\n\n\n# #| eval: false\nj_eval('\n# Creación de una tupla estática (Latitud, Longitud) de Bogotá\npunto_bogota = (4.6097, -74.0817)\nprintln(\"Coordenadas de Bogotá: \", punto_bogota)\n\n# Acceso a los elementos de la tupla (Recordar: Índice Base 1)\nlatitud = punto_bogota[1]\nlongitud = punto_bogota[2]\nprintln(\"Latitud: \", latitud)\nprintln(\"Longitud: \", longitud)\n\n# Desempaquetado de tuplas (Tuple Unpacking)\nlat, lon = punto_bogota\nprintln(\"Bogotá está ubicada a $lat°N, $lon°W\")\n\n# Almacenamiento de múltiples puntos geográficos como tuplas\nmedellin = (6.2442, -75.5812)\ncali = (3.4516, -76.5320)\ncartagena = (10.3910, -75.4794)\n\nprintln(\"Medellín: \", medellin)\nprintln(\"Cali: \", cali)\nprintln(\"Cartagena: \", cartagena)\n')\nStarting Julia ...\njulia&gt; # Creación de una tupla estática (Latitud, Longitud) de Bogotá\n\n\njulia&gt; punto_bogota = (4.6097, -74.0817)\n\n(4.6097, -74.0817)\n\n\njulia&gt; println(\"Coordenadas de Bogotá: \", punto_bogota)\n\nCoordenadas de Bogotá: (4.6097, -74.0817)\n\n\njulia&gt; # Acceso a los elementos de la tupla (Recordar: Índice Base 1)\n\n\njulia&gt; latitud = punto_bogota[1]\n\n4.6097\n\n\njulia&gt; longitud = punto_bogota[2]\n\n-74.0817\n\n\njulia&gt; println(\"Latitud: \", latitud)\n\nLatitud: 4.6097\n\n\njulia&gt; println(\"Longitud: \", longitud)\n\nLongitud: -74.0817\n\n\njulia&gt; # Desempaquetado de tuplas (Tuple Unpacking)\n\n\njulia&gt; lat, lon = punto_bogota\n\n(4.6097, -74.0817)\n\n\njulia&gt; println(\"Bogotá está ubicada a $lat°N, $lon°W\")\njulia&gt; Error: UndefVarError(:lat°N)\n\njulia&gt; # Almacenamiento de múltiples puntos geográficos como tuplas\n\n\njulia&gt; medellin = (6.2442, -75.5812)\n\n(6.2442, -75.5812)\n\n\njulia&gt; cali = (3.4516, -76.5320)\n\n(3.4516, -76.532)\n\n\njulia&gt; cartagena = (10.3910, -75.4794)\n\n(10.391, -75.4794)\n\n\njulia&gt; println(\"Medellín: \", medellin)\n\nMedellín: (6.2442, -75.5812)\n\n\njulia&gt; println(\"Cali: \", cali)\n\nCali: (3.4516, -76.532)\n\n\njulia&gt; println(\"Cartagena: \", cartagena)\n\nCartagena: (10.391, -75.4794)\n\n\n\n\n\n\n\n\nTabla 6.1: Comparación técnica de tuplas y equivalentes\n\n\n\n\n\n\n\n\n\n\n\nCaracterística\nPython\nR\nJulia\n\n\n\n\nSintaxis de Creación\nt = (x, y)\nv &lt;- c(x, y) (Vector)\nt = (x, y)\n\n\nInmutabilidad estricta\nSí (genera error si se intenta alterar).\nNo aplica. Los vectores hacen una copia en memoria si se alteran.\nSí (genera error si se intenta alterar).\n\n\nDesempaquetado (Unpacking)\nx, y = t\nRequiere extraer por índice manual x &lt;- v[1]; y &lt;- v[2].\nx, y = t\n\n\nUso Principal en SIG\nProteger pares de coordenadas estáticas de alteraciones en iteraciones.\nCreación rápida de puntos geométricos.\nTipado estricto y seguro de coordenadas para máximo rendimiento.\n\n\n\n\n\n\n\nNota técnica: Las tuplas no existen nativamente en R con el comportamiento de “desempaquetado” e “inmutabilidad estricta” que vemos en Python y Julia. En R, utilizamos vectores (c()) o listas (list()) para agrupar coordenadas. Es crucial entender que en Python y Julia, si intentas ejecutar punto_bogota[0] = 5.0, el programa colapsará inmediatamente para proteger los datos (porque una tupla es inmutable). En R, punto_bogota[1] &lt;- 5.0 sí funcionará, reescribiendo la coordenada silenciosamente.",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Función j_eval y j_plot en R</span>"
    ]
  },
  {
    "objectID": "06-estructuras_datos.html#listas-y-vectores",
    "href": "06-estructuras_datos.html#listas-y-vectores",
    "title": "6  Estructuras de datos",
    "section": "6.5 Listas (y Vectores)",
    "text": "6.5 Listas (y Vectores)\nA diferencia de las tuplas, las Listas (en Python y Julia) o los Vectores (en R) son secuencias mutables y dinámicas. Son la estructura de datos más utilizada en geomática para almacenar series temporales, perfiles de elevación, atributos de una tabla o una secuencia ordenada de vértices que conforman una ruta, ya que permiten agregar, eliminar o modificar datos sobre la marcha.\n\nPythonRJulia\n\n\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\n# 1. CREACIÓN DE LISTAS\n# Una lista de tuplas de coordenadas representando una ruta de viaje\nruta = [\n    (4.6097, -74.0817),  # Bogotá\n    (6.2442, -75.5812),  # Medellín\n    (3.4516, -76.5320),  # Cali\n]\nprint(\"Ruta inicial:\", ruta)\n\n# Una lista de mediciones de elevación (en metros)\nelevaciones = [2600.5, 2650.2, 2710.8, 2800.3, 2950.7, 3100.1]\nprint(\"Perfil de elevación:\", elevaciones)\n\n# Una lista de cadenas de texto (nombres de ciudades)\nciudades = [\"Bogotá\", \"Medellín\", \"Cali\"]\nprint(\"Ciudades a visitar:\", ciudades)\n\n# 2. AGREGAR ELEMENTOS (Mutabilidad)\n# Agregamos Cartagena a nuestra ruta y su elevación al perfil\nruta.append((10.3910, -75.4794))\nelevaciones.append(2.0)\nprint(\"Ruta actualizada:\", ruta)\n\n# 3. ACCEDER A ELEMENTOS (Índices)\n# Acceder a la primera ciudad de la ruta (Índice 0)\nprimera_parada = ruta[0]\nprint(f\"Primera parada: {primera_parada}\")\n\n# Acceder a la última ciudad usando indexación negativa\nultima_parada = ruta[-1]\nprint(f\"Última parada: {ultima_parada}\")\n\n# 4. SLICING (Extraer porciones de la lista)\n# Obtener las dos primeras paradas (índices 0 y 1, el 2 es exclusivo)\nprimeras_dos = ruta[:2]\nprint(\"Primeras dos paradas:\", primeras_dos)\n\n# Obtener una porción central de las elevaciones (índices 2, 3 y 4)\nelevaciones_medias = elevaciones[2:5]\nprint(\"Elevaciones intermedias:\", elevaciones_medias)\n\n# 5. OPERACIONES ÚTILES\n# Contar el número de vértices (puntos de ruta)\nnum_vertices = len(ruta)\nprint(f\"Número de vértices: {num_vertices}\")\n\n# Encontrar la elevación máxima\nelev_maxima = max(elevaciones)\nprint(f\"Elevación máxima: {elev_maxima} metros\")\n\n# Calcular la elevación promedio\nelev_promedio = sum(elevaciones) / len(elevaciones)\nprint(f\"Elevación promedio: {elev_promedio:.1f} metros\")\n\n\n\n\n\n# #| eval: false\n\n# 1. CREACIÓN DE LISTAS\n# Una lista de tuplas de coordenadas representando una ruta de viaje\nruta = [\n    (4.6097, -74.0817),  # Bogotá\n    (6.2442, -75.5812),  # Medellín\n    (3.4516, -76.5320),  # Cali\n]\nprint(\"Ruta inicial:\", ruta)\n\nRuta inicial: [(4.6097, -74.0817), (6.2442, -75.5812), (3.4516, -76.532)]\n\n# Una lista de mediciones de elevación (en metros)\nelevaciones = [2600.5, 2650.2, 2710.8, 2800.3, 2950.7, 3100.1]\nprint(\"Perfil de elevación:\", elevaciones)\n\nPerfil de elevación: [2600.5, 2650.2, 2710.8, 2800.3, 2950.7, 3100.1]\n\n# Una lista de cadenas de texto (nombres de ciudades)\nciudades = [\"Bogotá\", \"Medellín\", \"Cali\"]\nprint(\"Ciudades a visitar:\", ciudades)\n\nCiudades a visitar: ['Bogotá', 'Medellín', 'Cali']\n\n# 2. AGREGAR ELEMENTOS (Mutabilidad)\n# Agregamos Cartagena a nuestra ruta y su elevación al perfil\nruta.append((10.3910, -75.4794))\nelevaciones.append(2.0)\nprint(\"Ruta actualizada:\", ruta)\n\nRuta actualizada: [(4.6097, -74.0817), (6.2442, -75.5812), (3.4516, -76.532), (10.391, -75.4794)]\n\n# 3. ACCEDER A ELEMENTOS (Índices)\n# Acceder a la primera ciudad de la ruta (Índice 0)\nprimera_parada = ruta[0]\nprint(f\"Primera parada: {primera_parada}\")\n\nPrimera parada: (4.6097, -74.0817)\n\n# Acceder a la última ciudad usando indexación negativa\nultima_parada = ruta[-1]\nprint(f\"Última parada: {ultima_parada}\")\n\nÚltima parada: (10.391, -75.4794)\n\n# 4. SLICING (Extraer porciones de la lista)\n# Obtener las dos primeras paradas (índices 0 y 1, el 2 es exclusivo)\nprimeras_dos = ruta[:2]\nprint(\"Primeras dos paradas:\", primeras_dos)\n\nPrimeras dos paradas: [(4.6097, -74.0817), (6.2442, -75.5812)]\n\n# Obtener una porción central de las elevaciones (índices 2, 3 y 4)\nelevaciones_medias = elevaciones[2:5]\nprint(\"Elevaciones intermedias:\", elevaciones_medias)\n\nElevaciones intermedias: [2710.8, 2800.3, 2950.7]\n\n# 5. OPERACIONES ÚTILES\n# Contar el número de vértices (puntos de ruta)\nnum_vertices = len(ruta)\nprint(f\"Número de vértices: {num_vertices}\")\n\nNúmero de vértices: 4\n\n# Encontrar la elevación máxima\nelev_maxima = max(elevaciones)\nprint(f\"Elevación máxima: {elev_maxima} metros\")\n\nElevación máxima: 3100.1 metros\n\n# Calcular la elevación promedio\nelev_promedio = sum(elevaciones) / len(elevaciones)\nprint(f\"Elevación promedio: {elev_promedio:.1f} metros\")\n\nElevación promedio: 2402.1 metros\n\n\n\n\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\n# 1. CREACIÓN DE LISTAS Y VECTORES\n# En R, usamos 'list' para agrupar objetos complejos como vectores de coordenadas\nruta &lt;- list(\n    c(4.6097, -74.0817),  # Bogotá\n    c(6.2442, -75.5812),  # Medellín\n    c(3.4516, -76.5320)   # Cali\n)\ncat(\"Ruta inicial:\\n\"); print(ruta)\n\n# Los datos homogéneos (números o textos solos) van en vectores atómicos 'c()'\nelevaciones &lt;- c(2600.5, 2650.2, 2710.8, 2800.3, 2950.7, 3100.1)\ncat(\"Perfil de elevación:\", elevaciones, \"\\n\")\n\nciudades &lt;- c(\"Bogotá\", \"Medellín\", \"Cali\")\ncat(\"Ciudades a visitar:\", ciudades, \"\\n\")\n\n# 2. AGREGAR ELEMENTOS\n# Agregamos Cartagena a la ruta (usando append para listas)\nruta &lt;- append(ruta, list(c(10.3910, -75.4794)))\n# Agregamos la elevación al vector (creando un nuevo vector combinado)\nelevaciones &lt;- c(elevaciones, 2.0)\n\n# 3. ACCEDER A ELEMENTOS (Índice Base 1)\n# En listas de R, se usa doble corchete [[ ]] para extraer el elemento real\nprimera_parada &lt;- ruta[[1]]\ncat(\"Primera parada:\", primera_parada, \"\\n\")\n\n# Acceder a la última ciudad usando la longitud total\nultima_parada &lt;- ruta[[length(ruta)]]\ncat(\"Última parada:\", ultima_parada, \"\\n\")\n\n# 4. SLICING (Extraer porciones)\n# En R, el índice final SÍ se incluye en el rango\nprimeras_dos &lt;- ruta[1:2] # Usa corchete simple para rebanar listas\n\n# Para extraer las elevaciones equivalentes (3er, 4to y 5to elemento)\nelevaciones_medias &lt;- elevaciones[3:5]\ncat(\"Elevaciones intermedias:\", elevaciones_medias, \"\\n\")\n\n# 5. OPERACIONES ÚTILES\nnum_vertices &lt;- length(ruta)\ncat(\"Número de vértices:\", num_vertices, \"\\n\")\n\nelev_maxima &lt;- max(elevaciones)\ncat(\"Elevación máxima:\", elev_maxima, \"metros\\n\")\n\n# R tiene una función nativa para el promedio\nelev_promedio &lt;- mean(elevaciones)\ncat(sprintf(\"Elevación promedio: %.1f metros\\n\", elev_promedio))\n\n\n\n\n\n# #| eval: false\n\n# 1. CREACIÓN DE LISTAS Y VECTORES\n# En R, usamos 'list' para agrupar objetos complejos como vectores de coordenadas\nruta &lt;- list(\n    c(4.6097, -74.0817),  # Bogotá\n    c(6.2442, -75.5812),  # Medellín\n    c(3.4516, -76.5320)   # Cali\n)\ncat(\"Ruta inicial:\\n\"); print(ruta)\n\nRuta inicial:\n\n\n[[1]]\n[1]   4.6097 -74.0817\n\n[[2]]\n[1]   6.2442 -75.5812\n\n[[3]]\n[1]   3.4516 -76.5320\n\n# Los datos homogéneos (números o textos solos) van en vectores atómicos 'c()'\nelevaciones &lt;- c(2600.5, 2650.2, 2710.8, 2800.3, 2950.7, 3100.1)\ncat(\"Perfil de elevación:\", elevaciones, \"\\n\")\n\nPerfil de elevación: 2600.5 2650.2 2710.8 2800.3 2950.7 3100.1 \n\nciudades &lt;- c(\"Bogotá\", \"Medellín\", \"Cali\")\ncat(\"Ciudades a visitar:\", ciudades, \"\\n\")\n\nCiudades a visitar: Bogotá Medellín Cali \n\n# 2. AGREGAR ELEMENTOS\n# Agregamos Cartagena a la ruta (usando append para listas)\nruta &lt;- append(ruta, list(c(10.3910, -75.4794)))\n# Agregamos la elevación al vector (creando un nuevo vector combinado)\nelevaciones &lt;- c(elevaciones, 2.0)\n\n# 3. ACCEDER A ELEMENTOS (Índice Base 1)\n# En listas de R, se usa doble corchete [[ ]] para extraer el elemento real\nprimera_parada &lt;- ruta[[1]]\ncat(\"Primera parada:\", primera_parada, \"\\n\")\n\nPrimera parada: 4.6097 -74.0817 \n\n# Acceder a la última ciudad usando la longitud total\nultima_parada &lt;- ruta[[length(ruta)]]\ncat(\"Última parada:\", ultima_parada, \"\\n\")\n\nÚltima parada: 10.391 -75.4794 \n\n# 4. SLICING (Extraer porciones)\n# En R, el índice final SÍ se incluye en el rango\nprimeras_dos &lt;- ruta[1:2] # Usa corchete simple para rebanar listas\n\n# Para extraer las elevaciones equivalentes (3er, 4to y 5to elemento)\nelevaciones_medias &lt;- elevaciones[3:5]\ncat(\"Elevaciones intermedias:\", elevaciones_medias, \"\\n\")\n\nElevaciones intermedias: 2710.8 2800.3 2950.7 \n\n# 5. OPERACIONES ÚTILES\nnum_vertices &lt;- length(ruta)\ncat(\"Número de vértices:\", num_vertices, \"\\n\")\n\nNúmero de vértices: 4 \n\nelev_maxima &lt;- max(elevaciones)\ncat(\"Elevación máxima:\", elev_maxima, \"metros\\n\")\n\nElevación máxima: 3100.1 metros\n\n# R tiene una función nativa para el promedio\nelev_promedio &lt;- mean(elevaciones)\ncat(sprintf(\"Elevación promedio: %.1f metros\\n\", elev_promedio))\n\nElevación promedio: 2402.1 metros\n\n\n\n\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\n# 1. CREACIÓN DE ARREGLOS (Listas)\n# Un Array de tuplas de coordenadas\nruta = [\n    (4.6097, -74.0817),  # Bogotá\n    (6.2442, -75.5812),  # Medellín\n    (3.4516, -76.5320),  # Cali\n]\nprintln(\"Ruta inicial: \", ruta)\n\n# Array de valores numéricos de coma flotante\nelevaciones = [2600.5, 2650.2, 2710.8, 2800.3, 2950.7, 3100.1]\nprintln(\"Perfil de elevación: \", elevaciones)\n\n# Array de cadenas de texto\nciudades = [\"Bogotá\", \"Medellín\", \"Cali\"]\nprintln(\"Ciudades a visitar: \", ciudades)\n\n# 2. AGREGAR ELEMENTOS (Mutabilidad directa con push!)\npush!(ruta, (10.3910, -75.4794))\npush!(elevaciones, 2.0)\nprintln(\"Ruta actualizada: \", ruta)\n\n# 3. ACCEDER A ELEMENTOS (Índice Base 1)\n# Acceder al primer vértice\nprimera_parada = ruta[1]\nprintln(\"Primera parada: \", primera_parada)\n\n# Julia tiene la palabra clave 'end' para acceder al último elemento\nultima_parada = ruta[end]\nprintln(\"Última parada: \", ultima_parada)\n\n# 4. SLICING (Extraer porciones)\n# El rango [1:2] incluye ambos límites\nprimeras_dos = ruta[1:2]\nprintln(\"Primeras dos paradas: \", primeras_dos)\n\n# Las posiciones equivalentes (3er, 4to y 5to elemento)\nelevaciones_medias = elevaciones[3:5]\nprintln(\"Elevaciones intermedias: \", elevaciones_medias)\n\n# 5. OPERACIONES ÚTILES\nnum_vertices = length(ruta)\nprintln(\"Número de vértices: \", num_vertices)\n\n# En Julia se prefiere 'maximum' para colecciones completas\nelev_maxima = maximum(elevaciones)\nprintln(\"Elevación máxima: \", elev_maxima, \" metros\")\n\n# Promedio (sumatoria sobre longitud)\nelev_promedio = sum(elevaciones) / length(elevaciones)\nprintln(\"Elevación promedio: \", round(elev_promedio, digits=1), \" metros\")\n\n\n\n\n# #| eval: false\nj_eval('\n# 1. CREACIÓN DE ARREGLOS (Listas)\n# Un Array de tuplas de coordenadas\nruta = [\n    (4.6097, -74.0817),  # Bogotá\n    (6.2442, -75.5812),  # Medellín\n    (3.4516, -76.5320),  # Cali\n]\nprintln(\"Ruta inicial: \", ruta)\n\n# Array de valores numéricos de coma flotante\nelevaciones = [2600.5, 2650.2, 2710.8, 2800.3, 2950.7, 3100.1]\nprintln(\"Perfil de elevación: \", elevaciones)\n\n# Array de cadenas de texto\nciudades = [\"Bogotá\", \"Medellín\", \"Cali\"]\nprintln(\"Ciudades a visitar: \", ciudades)\n\n# 2. AGREGAR ELEMENTOS (Mutabilidad directa con push!)\npush!(ruta, (10.3910, -75.4794))\npush!(elevaciones, 2.0)\nprintln(\"Ruta actualizada: \", ruta)\n\n# 3. ACCEDER A ELEMENTOS (Índice Base 1)\n# Acceder al primer vértice\nprimera_parada = ruta[1]\nprintln(\"Primera parada: \", primera_parada)\n\n# Julia tiene la palabra clave \"end\" para acceder al último elemento\nultima_parada = ruta[end]\nprintln(\"Última parada: \", ultima_parada)\n\n# 4. SLICING (Extraer porciones)\n# El rango [1:2] incluye ambos límites\nprimeras_dos = ruta[1:2]\nprintln(\"Primeras dos paradas: \", primeras_dos)\n\n# Las posiciones equivalentes (3er, 4to y 5to elemento)\nelevaciones_medias = elevaciones[3:5]\nprintln(\"Elevaciones intermedias: \", elevaciones_medias)\n\n# 5. OPERACIONES ÚTILES\nnum_vertices = length(ruta)\nprintln(\"Número de vértices: \", num_vertices)\n\n# En Julia se prefiere \"maximum\" para colecciones completas\nelev_maxima = maximum(elevaciones)\nprintln(\"Elevación máxima: \", elev_maxima, \" metros\")\n\n# Promedio (sumatoria sobre longitud)\nelev_promedio = sum(elevaciones) / length(elevaciones)\nprintln(\"Elevación promedio: \", round(elev_promedio, digits=1), \" metros\")\n')\njulia&gt; # 1. CREACIÓN DE ARREGLOS (Listas)\n\n\njulia&gt; # Un Array de tuplas de coordenadas\n\n\njulia&gt; ruta = [\n           (4.6097, -74.0817),  # Bogotá\n           (6.2442, -75.5812),  # Medellín\n           (3.4516, -76.5320),  # Cali\n       ]\n\n3-element Vector{Tuple{Float64, Float64}}:\n (4.6097, -74.0817)\n (6.2442, -75.5812)\n (3.4516, -76.532)\n\n\njulia&gt; println(\"Ruta inicial: \", ruta)\n\nRuta inicial: [(4.6097, -74.0817), (6.2442, -75.5812), (3.4516, -76.532)]\n\n\njulia&gt; # Array de valores numéricos de coma flotante\n\n\njulia&gt; elevaciones = [2600.5, 2650.2, 2710.8, 2800.3, 2950.7, 3100.1]\n\n6-element Vector{Float64}:\n 2600.5\n 2650.2\n 2710.8\n 2800.3\n 2950.7\n 3100.1\n\n\njulia&gt; println(\"Perfil de elevación: \", elevaciones)\n\nPerfil de elevación: [2600.5, 2650.2, 2710.8, 2800.3, 2950.7, 3100.1]\n\n\njulia&gt; # Array de cadenas de texto\n\n\njulia&gt; ciudades = [\"Bogotá\", \"Medellín\", \"Cali\"]\n\n3-element Vector{String}:\n \"Bogotá\"\n \"Medellín\"\n \"Cali\"\n\n\njulia&gt; println(\"Ciudades a visitar: \", ciudades)\n\nCiudades a visitar: [\"Bogotá\", \"Medellín\", \"Cali\"]\n\n\njulia&gt; # 2. AGREGAR ELEMENTOS (Mutabilidad directa con push!)\n\n\njulia&gt; push!(ruta, (10.3910, -75.4794))\n\n4-element Vector{Tuple{Float64, Float64}}:\n (4.6097, -74.0817)\n (6.2442, -75.5812)\n (3.4516, -76.532)\n (10.391, -75.4794)\n\n\njulia&gt; push!(elevaciones, 2.0)\n\n7-element Vector{Float64}:\n 2600.5\n 2650.2\n 2710.8\n 2800.3\n 2950.7\n 3100.1\n    2.0\n\n\njulia&gt; println(\"Ruta actualizada: \", ruta)\n\nRuta actualizada: [(4.6097, -74.0817), (6.2442, -75.5812), (3.4516, -76.532), (10.391, -75.4794)]\n\n\njulia&gt; # 3. ACCEDER A ELEMENTOS (Índice Base 1)\n\n\njulia&gt; # Acceder al primer vértice\n\n\njulia&gt; primera_parada = ruta[1]\n\n(4.6097, -74.0817)\n\n\njulia&gt; println(\"Primera parada: \", primera_parada)\n\nPrimera parada: (4.6097, -74.0817)\n\n\njulia&gt; # Julia tiene la palabra clave \"end\" para acceder al último elemento\n\n\njulia&gt; ultima_parada = ruta[end]\n\n(10.391, -75.4794)\n\n\njulia&gt; println(\"Última parada: \", ultima_parada)\n\nÚltima parada: (10.391, -75.4794)\n\n\njulia&gt; # 4. SLICING (Extraer porciones)\n\n\njulia&gt; # El rango [1:2] incluye ambos límites\n\n\njulia&gt; primeras_dos = ruta[1:2]\n\n2-element Vector{Tuple{Float64, Float64}}:\n (4.6097, -74.0817)\n (6.2442, -75.5812)\n\n\njulia&gt; println(\"Primeras dos paradas: \", primeras_dos)\n\nPrimeras dos paradas: [(4.6097, -74.0817), (6.2442, -75.5812)]\n\n\njulia&gt; # Las posiciones equivalentes (3er, 4to y 5to elemento)\n\n\njulia&gt; elevaciones_medias = elevaciones[3:5]\n\n3-element Vector{Float64}:\n 2710.8\n 2800.3\n 2950.7\n\n\njulia&gt; println(\"Elevaciones intermedias: \", elevaciones_medias)\n\nElevaciones intermedias: [2710.8, 2800.3, 2950.7]\n\n\njulia&gt; # 5. OPERACIONES ÚTILES\n\n\njulia&gt; num_vertices = length(ruta)\n\n4\n\n\njulia&gt; println(\"Número de vértices: \", num_vertices)\n\nNúmero de vértices: 4\n\n\njulia&gt; # En Julia se prefiere \"maximum\" para colecciones completas\n\n\njulia&gt; elev_maxima = maximum(elevaciones)\n\n3100.1\n\n\njulia&gt; println(\"Elevación máxima: \", elev_maxima, \" metros\")\n\nElevación máxima: 3100.1 metros\n\n\njulia&gt; # Promedio (sumatoria sobre longitud)\n\n\njulia&gt; elev_promedio = sum(elevaciones) / length(elevaciones)\n\n2402.085714285714\n\n\njulia&gt; println(\"Elevación promedio: \", round(elev_promedio, digits=1), \" metros\")\n\nElevación promedio: 2402.1 metros\n\n\n\n\n\n\nResumen de Operaciones en Listas/Vectores\n\n\n\nTabla 6.2: Equivalencias para el manejo de secuencias ordenadas\n\n\n\n\n\n\n\n\n\n\n\nOperación\nPython\nR\nJulia\n\n\n\n\nCreación\n[x, y, z]\nc(x, y, z)\n[x, y, z]\n\n\nAgregar\n.append(x)\nc(vector, x)\npush!(array, x)\n\n\nÚltimo Elemento\n[-1]\n[length(x)]\n[end]\n\n\nRango (Slicing)\n[2:5] (Excluye el 5)\n[3:5] (Incluye el 5)\n[3:5] (Incluye el 5)\n\n\nLargo total\nlen(x)\nlength(x)\nlength(x)\n\n\nMáximo\nmax(x)\nmax(x)\nmaximum(x)\n\n\nPromedio\nsum(x)/len(x)\nmean(x)\nsum(x)/length(x)\n\n\n\n\n\n\n\nNota técnica sobre Slicing (Rebanado): Extraer porciones de datos (slicing) es una de las mayores fuentes de error topológico y estadístico al migrar código. * En Python, la sintaxis [2:5] extrae los elementos en los índices 2, 3 y 4 (omitiendo el final). Dado que Python inicia en 0, esto corresponde al 3er, 4to y 5to elemento real de los datos. * En R y Julia, la sintaxis [3:5] extrae los elementos en los índices 3, 4 y 5 (incluyendo ambos extremos). Como inician en 1, esto corresponde directamente al 3er, 4to y 5to dato.\n\n\n\n\n\n\nEl dilema en R: ¿Vectores c() o Listas list()?\n\n\n\nExiste un choque de terminología fundamental al pasar de lenguajes como Python o Julia hacia R: lo que Python y Julia llaman “Lista” ([1, 2, 3]), R lo llama “Vector Atómico” (c(1, 2, 3)). Y lo que R llama “Lista” (list()), en Python suele comportarse más como una lista anidada o, si tiene nombres, como un Diccionario.\nPara evitar errores al manipular datos espaciales en R, es vital entender esta diferencia práctica:\n\nVectores Atómicos c(): Exigen que todos los elementos sean del mismo tipo (todos números o todos texto). Son estructuras planas (1D). Se usan para series de datos simples, como un perfil de elevaciones o una columna de nombres de municipios.\n\nEjemplo: c(2600.5, 2650.2, 2710.8)\n\nListas list(): Son contenedores flexibles. Permiten mezclar texto con números, e incluso pueden contener otros vectores u otras listas dentro de sí mismas (anidación). Se usan para agrupar objetos complejos, como los pares de coordenadas (x,y) independientes que componen una ruta.\n\nEjemplo: list( c(4.6, -74.0), c(6.2, -75.5) )\n\n\nRegla de oro en R: Usa c() para colecciones de datos homogéneos. Usa list() cuando necesites agrupar geometrías complejas, atributos mixtos o emular la estructura de un diccionario clave-valor.",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Función j_eval y j_plot en R</span>"
    ]
  },
  {
    "objectID": "06-estructuras_datos.html#conjuntos-sets",
    "href": "06-estructuras_datos.html#conjuntos-sets",
    "title": "6  Estructuras de datos",
    "section": "6.6 Conjuntos (Sets)",
    "text": "6.6 Conjuntos (Sets)\nLos Conjuntos son estructuras de datos que almacenan colecciones de elementos sin orden y sin duplicados. Son la traducción computacional de la teoría matemática de conjuntos. En el análisis espacial, son indispensables para obtener listas de valores únicos (por ejemplo, extraer todos los códigos de municipios de una gran base de datos sin repeticiones) y para realizar operaciones espaciales lógicas como intersecciones, uniones o diferencias de atributos entre dos zonas geográficas.\n[Image of set theory Venn diagram operations]\n\nPythonRJulia\n\n\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\n# 1. CREACIÓN Y LIMPIEZA DE DUPLICADOS\n# Crear un conjunto con llaves {}\nregiones_visitadas = {\"Andina\", \"Caribe\", \"Pacífica\"}\nprint(\"Regiones:\", regiones_visitadas)\n\n# Crear un conjunto desde una lista (elimina duplicados automáticamente)\ncodigos_dptos = [\"ANT\", \"BOG\", \"VAL\", \"ANT\", \"BOG\"]\ncodigos_unicos = set(codigos_dptos)\nprint(\"Códigos únicos:\", codigos_unicos)\n\n# 2. AGREGAR ELEMENTOS\n# Agregar una región nueva\nregiones_visitadas.add(\"Orinoquía\")\n# Intentar agregar un duplicado (Python lo ignorará sin dar error)\nregiones_visitadas.add(\"Caribe\") \nprint(\"Regiones actualizadas:\", regiones_visitadas)\n\n# 3. OPERACIONES DE CONJUNTOS (Venn)\n# Especies observadas en dos polígonos diferentes\narea_a = {\"Roble\", \"Pino\", \"Frailejón\", \"Aliso\"}\narea_b = {\"Pino\", \"Frailejón\", \"Palma de Cera\", \"Yagrumo\"}\n\n# Intersección: Especies comunes en ambas áreas\ncomunes = area_a.intersection(area_b)\nprint(\"Especies en ambas áreas:\", comunes)\n\n# Diferencia: Especies exclusivas del Área A\nsolo_a = area_a - area_b\nprint(\"Especies exclusivas de A:\", solo_a)\n\n# Unión: Todas las especies registradas\ntodas_especies = area_a.union(area_b)\nprint(\"Todas las especies:\", todas_especies)\n\n# 4. MEMBRESÍA (Comprobar si existe)\nif \"Pino\" in comunes:\n    print(\"El Pino está en la zona de intersección.\")\n\n\n\n\n\n# #| eval: false\n\n# 1. CREACIÓN Y LIMPIEZA DE DUPLICADOS\n# Crear un conjunto con llaves {}\nregiones_visitadas = {\"Andina\", \"Caribe\", \"Pacífica\"}\nprint(\"Regiones:\", regiones_visitadas)\n\nRegiones: {'Caribe', 'Andina', 'Pacífica'}\n\n# Crear un conjunto desde una lista (elimina duplicados automáticamente)\ncodigos_dptos = [\"ANT\", \"BOG\", \"VAL\", \"ANT\", \"BOG\"]\ncodigos_unicos = set(codigos_dptos)\nprint(\"Códigos únicos:\", codigos_unicos)\n\nCódigos únicos: {'VAL', 'BOG', 'ANT'}\n\n# 2. AGREGAR ELEMENTOS\n# Agregar una región nueva\nregiones_visitadas.add(\"Orinoquía\")\n# Intentar agregar un duplicado (Python lo ignorará sin dar error)\nregiones_visitadas.add(\"Caribe\") \nprint(\"Regiones actualizadas:\", regiones_visitadas)\n\nRegiones actualizadas: {'Caribe', 'Andina', 'Orinoquía', 'Pacífica'}\n\n# 3. OPERACIONES DE CONJUNTOS (Venn)\n# Especies observadas en dos polígonos diferentes\narea_a = {\"Roble\", \"Pino\", \"Frailejón\", \"Aliso\"}\narea_b = {\"Pino\", \"Frailejón\", \"Palma de Cera\", \"Yagrumo\"}\n\n# Intersección: Especies comunes en ambas áreas\ncomunes = area_a.intersection(area_b)\nprint(\"Especies en ambas áreas:\", comunes)\n\nEspecies en ambas áreas: {'Pino', 'Frailejón'}\n\n# Diferencia: Especies exclusivas del Área A\nsolo_a = area_a - area_b\nprint(\"Especies exclusivas de A:\", solo_a)\n\nEspecies exclusivas de A: {'Aliso', 'Roble'}\n\n# Unión: Todas las especies registradas\ntodas_especies = area_a.union(area_b)\nprint(\"Todas las especies:\", todas_especies)\n\nTodas las especies: {'Aliso', 'Palma de Cera', 'Yagrumo', 'Pino', 'Frailejón', 'Roble'}\n\n# 4. MEMBRESÍA (Comprobar si existe)\nif \"Pino\" in comunes:\n    print(\"El Pino está en la zona de intersección.\")\n\nEl Pino está en la zona de intersección.\n\n\n\n\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\n# 1. CREACIÓN Y LIMPIEZA DE DUPLICADOS\n# En R, usamos vectores atómicos normales y les aplicamos funciones lógicas\nregiones_visitadas &lt;- c(\"Andina\", \"Caribe\", \"Pacífica\")\n\n# Eliminar duplicados usando unique()\ncodigos_dptos &lt;- c(\"ANT\", \"BOG\", \"VAL\", \"ANT\", \"BOG\")\ncodigos_unicos &lt;- unique(codigos_dptos)\ncat(\"Códigos únicos:\", codigos_unicos, \"\\n\")\n\n# 2. AGREGAR ELEMENTOS\n# Concatenamos y aplicamos unique() para mantener la lógica de conjuntos\nregiones_visitadas &lt;- unique(c(regiones_visitadas, \"Orinoquía\", \"Caribe\"))\ncat(\"Regiones actualizadas:\", regiones_visitadas, \"\\n\")\n\n# 3. OPERACIONES DE CONJUNTOS (Venn)\narea_a &lt;- c(\"Roble\", \"Pino\", \"Frailejón\", \"Aliso\")\narea_b &lt;- c(\"Pino\", \"Frailejón\", \"Palma de Cera\", \"Yagrumo\")\n\n# Intersección: Especies comunes\ncomunes &lt;- intersect(area_a, area_b)\ncat(\"Especies en ambas áreas:\", comunes, \"\\n\")\n\n# Diferencia: Especies exclusivas de A\nsolo_a &lt;- setdiff(area_a, area_b)\ncat(\"Especies exclusivas de A:\", solo_a, \"\\n\")\n\n# Unión: Todas las especies (elimina duplicados automáticamente)\ntodas_especies &lt;- union(area_a, area_b)\ncat(\"Todas las especies:\", todas_especies, \"\\n\")\n\n# 4. MEMBRESÍA (Comprobar si existe con %in%)\nif (\"Pino\" %in% comunes) {\n  cat(\"El Pino está en la zona de intersección.\\n\")\n}\n\n\n\n\n\n# #| eval: false\n\n# 1. CREACIÓN Y LIMPIEZA DE DUPLICADOS\n# En R, usamos vectores atómicos normales y les aplicamos funciones lógicas\nregiones_visitadas &lt;- c(\"Andina\", \"Caribe\", \"Pacífica\")\n\n# Eliminar duplicados usando unique()\ncodigos_dptos &lt;- c(\"ANT\", \"BOG\", \"VAL\", \"ANT\", \"BOG\")\ncodigos_unicos &lt;- unique(codigos_dptos)\ncat(\"Códigos únicos:\", codigos_unicos, \"\\n\")\n\nCódigos únicos: ANT BOG VAL \n\n# 2. AGREGAR ELEMENTOS\n# Concatenamos y aplicamos unique() para mantener la lógica de conjuntos\nregiones_visitadas &lt;- unique(c(regiones_visitadas, \"Orinoquía\", \"Caribe\"))\ncat(\"Regiones actualizadas:\", regiones_visitadas, \"\\n\")\n\nRegiones actualizadas: Andina Caribe Pacífica Orinoquía \n\n# 3. OPERACIONES DE CONJUNTOS (Venn)\narea_a &lt;- c(\"Roble\", \"Pino\", \"Frailejón\", \"Aliso\")\narea_b &lt;- c(\"Pino\", \"Frailejón\", \"Palma de Cera\", \"Yagrumo\")\n\n# Intersección: Especies comunes\ncomunes &lt;- intersect(area_a, area_b)\ncat(\"Especies en ambas áreas:\", comunes, \"\\n\")\n\nEspecies en ambas áreas: Pino Frailejón \n\n# Diferencia: Especies exclusivas de A\nsolo_a &lt;- setdiff(area_a, area_b)\ncat(\"Especies exclusivas de A:\", solo_a, \"\\n\")\n\nEspecies exclusivas de A: Roble Aliso \n\n# Unión: Todas las especies (elimina duplicados automáticamente)\ntodas_especies &lt;- union(area_a, area_b)\ncat(\"Todas las especies:\", todas_especies, \"\\n\")\n\nTodas las especies: Roble Pino Frailejón Aliso Palma de Cera Yagrumo \n\n# 4. MEMBRESÍA (Comprobar si existe con %in%)\nif (\"Pino\" %in% comunes) {\n  cat(\"El Pino está en la zona de intersección.\\n\")\n}\n\nEl Pino está en la zona de intersección.\n\n\n\n\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\n# 1. CREACIÓN Y LIMPIEZA DE DUPLICADOS\n# En Julia existe el tipo nativo Set\nregiones_visitadas = Set([\"Andina\", \"Caribe\", \"Pacífica\"])\n\n# Crear un Set a partir de un Array elimina duplicados\ncodigos_dptos = [\"ANT\", \"BOG\", \"VAL\", \"ANT\", \"BOG\"]\ncodigos_unicos = Set(codigos_dptos)\nprintln(\"Códigos únicos: \", codigos_unicos)\n\n# 2. AGREGAR ELEMENTOS\n# Usamos push! para agregar elementos in-place\npush!(regiones_visitadas, \"Orinoquía\")\npush!(regiones_visitadas, \"Caribe\") # Se ignora el duplicado\nprintln(\"Regiones actualizadas: \", regiones_visitadas)\n\n# 3. OPERACIONES DE CONJUNTOS (Venn)\narea_a = Set([\"Roble\", \"Pino\", \"Frailejón\", \"Aliso\"])\narea_b = Set([\"Pino\", \"Frailejón\", \"Palma de Cera\", \"Yagrumo\"])\n\n# Intersección\ncomunes = intersect(area_a, area_b)\nprintln(\"Especies en ambas áreas: \", comunes)\n\n# Diferencia\nsolo_a = setdiff(area_a, area_b)\nprintln(\"Especies exclusivas de A: \", solo_a)\n\n# Unión\ntodas_especies = union(area_a, area_b)\nprintln(\"Todas las especies: \", todas_especies)\n\n# 4. MEMBRESÍA (Operador in)\nif in(\"Pino\", comunes) # También se puede escribir: \"Pino\" in comunes\n    println(\"El Pino está en la zona de intersección.\")\nend\n\n\n\n\n# #| eval: false\nj_eval('\n# 1. CREACIÓN Y LIMPIEZA DE DUPLICADOS\n# En Julia existe el tipo nativo Set\nregiones_visitadas = Set([\"Andina\", \"Caribe\", \"Pacífica\"])\n\n# Crear un Set a partir de un Array elimina duplicados\ncodigos_dptos = [\"ANT\", \"BOG\", \"VAL\", \"ANT\", \"BOG\"]\ncodigos_unicos = Set(codigos_dptos)\nprintln(\"Códigos únicos: \", codigos_unicos)\n\n# 2. AGREGAR ELEMENTOS\n# Usamos push! para agregar elementos in-place\npush!(regiones_visitadas, \"Orinoquía\")\npush!(regiones_visitadas, \"Caribe\") # Se ignora el duplicado\nprintln(\"Regiones actualizadas: \", regiones_visitadas)\n\n# 3. OPERACIONES DE CONJUNTOS (Venn)\narea_a = Set([\"Roble\", \"Pino\", \"Frailejón\", \"Aliso\"])\narea_b = Set([\"Pino\", \"Frailejón\", \"Palma de Cera\", \"Yagrumo\"])\n\n# Intersección\ncomunes = intersect(area_a, area_b)\nprintln(\"Especies en ambas áreas: \", comunes)\n\n# Diferencia\nsolo_a = setdiff(area_a, area_b)\nprintln(\"Especies exclusivas de A: \", solo_a)\n\n# Unión\ntodas_especies = union(area_a, area_b)\nprintln(\"Todas las especies: \", todas_especies)\n\n# 4. MEMBRESÍA (Operador in)\nif in(\"Pino\", comunes) # También se puede escribir: \"Pino\" in comunes\n    println(\"El Pino está en la zona de intersección.\")\nend\n')\njulia&gt; # 1. CREACIÓN Y LIMPIEZA DE DUPLICADOS\n\n\njulia&gt; # En Julia existe el tipo nativo Set\n\n\njulia&gt; regiones_visitadas = Set([\"Andina\", \"Caribe\", \"Pacífica\"])\n\nSet{String} with 3 elements:\n  \"Andina\"\n  \"Pacífica\"\n  \"Caribe\"\n\n\njulia&gt; # Crear un Set a partir de un Array elimina duplicados\n\n\njulia&gt; codigos_dptos = [\"ANT\", \"BOG\", \"VAL\", \"ANT\", \"BOG\"]\n\n5-element Vector{String}:\n \"ANT\"\n \"BOG\"\n \"VAL\"\n \"ANT\"\n \"BOG\"\n\n\njulia&gt; codigos_unicos = Set(codigos_dptos)\n\nSet{String} with 3 elements:\n  \"BOG\"\n  \"VAL\"\n  \"ANT\"\n\n\njulia&gt; println(\"Códigos únicos: \", codigos_unicos)\n\nCódigos únicos: Set([\"BOG\", \"VAL\", \"ANT\"])\n\n\njulia&gt; # 2. AGREGAR ELEMENTOS\n\n\njulia&gt; # Usamos push! para agregar elementos in-place\n\n\njulia&gt; push!(regiones_visitadas, \"Orinoquía\")\n\nSet{String} with 4 elements:\n  \"Andina\"\n  \"Pacífica\"\n  \"Caribe\"\n  \"Orinoquía\"\n\n\njulia&gt; push!(regiones_visitadas, \"Caribe\") # Se ignora el duplicado\n\nSet{String} with 4 elements:\n  \"Andina\"\n  \"Pacífica\"\n  \"Caribe\"\n  \"Orinoquía\"\n\n\njulia&gt; println(\"Regiones actualizadas: \", regiones_visitadas)\n\nRegiones actualizadas: Set([\"Andina\", \"Pacífica\", \"Caribe\", \"Orinoquía\"])\n\n\njulia&gt; # 3. OPERACIONES DE CONJUNTOS (Venn)\n\n\njulia&gt; area_a = Set([\"Roble\", \"Pino\", \"Frailejón\", \"Aliso\"])\n\nSet{String} with 4 elements:\n  \"Roble\"\n  \"Pino\"\n  \"Frailejón\"\n  \"Aliso\"\n\n\njulia&gt; area_b = Set([\"Pino\", \"Frailejón\", \"Palma de Cera\", \"Yagrumo\"])\n\nSet{String} with 4 elements:\n  \"Palma de Cera\"\n  \"Pino\"\n  \"Frailejón\"\n  \"Yagrumo\"\n\n\njulia&gt; # Intersección\n\n\njulia&gt; comunes = intersect(area_a, area_b)\n\nSet{String} with 2 elements:\n  \"Pino\"\n  \"Frailejón\"\n\n\njulia&gt; println(\"Especies en ambas áreas: \", comunes)\n\nEspecies en ambas áreas: Set([\"Pino\", \"Frailejón\"])\n\n\njulia&gt; # Diferencia\n\n\njulia&gt; solo_a = setdiff(area_a, area_b)\n\nSet{String} with 2 elements:\n  \"Roble\"\n  \"Aliso\"\n\n\njulia&gt; println(\"Especies exclusivas de A: \", solo_a)\n\nEspecies exclusivas de A: Set([\"Roble\", \"Aliso\"])\n\n\njulia&gt; # Unión\n\n\njulia&gt; todas_especies = union(area_a, area_b)\n\nSet{String} with 6 elements:\n  \"Roble\"\n  \"Palma de Cera\"\n  \"Pino\"\n  \"Frailejón\"\n  \"Yagrumo\"\n  \"Aliso\"\n\n\njulia&gt; println(\"Todas las especies: \", todas_especies)\n\nTodas las especies: Set([\"Roble\", \"Palma de Cera\", \"Pino\", \"Frailejón\", \"Yagrumo\", \"Aliso\"])\n\n\njulia&gt; # 4. MEMBRESÍA (Operador in)\n\n\njulia&gt; if in(\"Pino\", comunes) # También se puede escribir: \"Pino\" in comunes\n           println(\"El Pino está en la zona de intersección.\")\n       end\n\nEl Pino está en la zona de intersección.\n\n\n\n\n\n\nResumen de Operaciones con Conjuntos\n\n\n\nTabla 6.3: Equivalencias para operaciones lógicas de conjuntos\n\n\n\n\n\n\n\n\n\n\n\nOperación\nPython\nR\nJulia\n\n\n\n\nCreación Básica\n{\"A\", \"B\"} o set()\nc(\"A\", \"B\") (Vectores)\nSet([\"A\", \"B\"])\n\n\nEliminar Duplicados\nset(lista)\nunique(vector)\nSet(array) o unique(array)\n\n\nAgregar Elemento\nset.add(x)\nunique(c(v, x))\npush!(set, x)\n\n\nIntersección (Común)\na.intersection(b) o a & b\nintersect(a, b)\nintersect(a, b)\n\n\nUnión (Todos)\na.union(b) o a | b\nunion(a, b)\nunion(a, b)\n\n\nDiferencia (Solo en A)\na - b\nsetdiff(a, b)\nsetdiff(a, b)\n\n\nPertenece a\nx in set\nx %in% v\nin(x, set) o x in set\n\n\n\n\n\n\n\nNota técnicas:\n\nTenga cuidado al crear conjuntos vacíos en Python. Si escribe mis_datos = {}, Python creará un Diccionario vacío, no un conjunto. Para crear un conjunto vacío obligatoriamente debe usar mis_datos = set(). Por otro lado, si inicializa con datos como {\"Andina\", \"Caribe\"}, Python sí entenderá automáticamente que es un conjunto.\nA diferencia de Python y Julia, que tienen una estructura de datos Set específica (las cuales ignoran intrínsecamente los duplicados), R no posee un tipo de dato “Conjunto” nativo. En R, trabajamos con vectores regulares y utilizamos funciones lógicas (union, intersect, setdiff, unique) que simulan el comportamiento de los conjuntos matemáticos al evaluarlos.",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Función j_eval y j_plot en R</span>"
    ]
  },
  {
    "objectID": "06-estructuras_datos.html#diccionarios",
    "href": "06-estructuras_datos.html#diccionarios",
    "title": "6  Estructuras de datos",
    "section": "6.7 Diccionarios",
    "text": "6.7 Diccionarios\nLos Diccionarios son estructuras de datos que almacenan información mediante pares de Clave-Valor (Key-Value). A diferencia de las listas (donde accedes por la posición numérica), en un diccionario accedes a los datos a través de “etiquetas” únicas (las claves).\nEn el ámbito de los Sistemas de Información Geográfica, los diccionarios son, literalmente, la base técnica de cómo se estructuran los atributos de un vector. De hecho, el popular formato GeoJSON no es más que un gran diccionario anidado.\n\nPythonRJulia\n\n\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\n# 1. CREACIÓN DE DICCIONARIOS\n# Diccionario almacenando atributos de una ciudad\ninfo_bogota = {\n    \"nombre\": \"Bogotá\",\n    \"poblacion\": 7181469,\n    \"coordenadas\": (4.6097, -74.0817),\n    \"pais\": \"Colombia\",\n    \"fundacion\": 1538,\n}\nprint(\"Información de Bogotá:\", info_bogota)\n\n# 2. ACCESO A VALORES\n# Acceder a información específica usando la clave entre corchetes\nnombre_ciudad = info_bogota[\"nombre\"]\npoblacion_ciudad = info_bogota[\"poblacion\"]\nprint(f\"Ciudad: {nombre_ciudad} | Población: {poblacion_ciudad:,}\")\n\n# Acceso seguro con get() para evitar errores si la clave no existe\narea = info_bogota.get(\"area_km2\", \"No especificada\")\nprint(f\"Área: {area}\")\n\n# 3. AGREGAR Y ACTUALIZAR VALORES\n# Agregar nueva información al diccionario\ninfo_bogota[\"area_km2\"] = 1775\ninfo_bogota[\"poblacion\"] = 7900000  # Actualizar un valor existente\nprint(\"Info actualizada:\", info_bogota)\n\n# 4. TRABAJANDO CON COLECCIONES ANIDADAS (Estilo GeoJSON)\ncapitales_deptos = {\n    \"Antioquia\": {\n        \"capital\": \"Medellín\",\n        \"coordenadas\": (6.2442, -75.5812),\n        \"poblacion\": 2533424\n    },\n    \"Valle del Cauca\": {\n        \"capital\": \"Cali\",\n        \"coordenadas\": (3.4516, -76.5320),\n        \"poblacion\": 2227642\n    }\n}\n\n# Acceder a información anidada\ninfo_valle = capitales_deptos[\"Valle del Cauca\"]\nprint(f\"Capital del Valle: {info_valle['capital']}\")\n\n# 5. EXPLORACIÓN DE DICCIONARIOS\nprint(\"Claves disponibles:\", list(info_bogota.keys()))\n\n# Comprobar si una clave existe\nif \"coordenadas\" in info_bogota:\n    print(\"La información de coordenadas está disponible.\")\n\n# 6. EJEMPLO PRÁCTICO: Metadatos de un Waypoint GPS\npunto_gps = {\n    \"id\": \"PC001\",\n    \"nombre\": \"Inicio Sendero Cocora\",\n    \"latitud\": 4.6395,\n    \"longitud\": -75.4851,\n    \"elevacion\": 2400,\n    \"tipo_cobertura\": \"Bosque de Palma\",\n    \"facilidades\": [\"parqueadero\", \"guía\", \"restaurante\"]\n}\n\nprint(f\"Punto: {punto_gps['nombre']} a {punto_gps['elevacion']} msnm\")\nprint(f\"Servicios: {', '.join(punto_gps['facilidades'])}\")\n\n\n\n\n\n# #| eval: false\n\n# 1. CREACIÓN DE DICCIONARIOS\n# Diccionario almacenando atributos de una ciudad\ninfo_bogota = {\n    \"nombre\": \"Bogotá\",\n    \"poblacion\": 7181469,\n    \"coordenadas\": (4.6097, -74.0817),\n    \"pais\": \"Colombia\",\n    \"fundacion\": 1538,\n}\nprint(\"Información de Bogotá:\", info_bogota)\n\nInformación de Bogotá: {'nombre': 'Bogotá', 'poblacion': 7181469, 'coordenadas': (4.6097, -74.0817), 'pais': 'Colombia', 'fundacion': 1538}\n\n# 2. ACCESO A VALORES\n# Acceder a información específica usando la clave entre corchetes\nnombre_ciudad = info_bogota[\"nombre\"]\npoblacion_ciudad = info_bogota[\"poblacion\"]\nprint(f\"Ciudad: {nombre_ciudad} | Población: {poblacion_ciudad:,}\")\n\nCiudad: Bogotá | Población: 7,181,469\n\n# Acceso seguro con get() para evitar errores si la clave no existe\narea = info_bogota.get(\"area_km2\", \"No especificada\")\nprint(f\"Área: {area}\")\n\nÁrea: No especificada\n\n# 3. AGREGAR Y ACTUALIZAR VALORES\n# Agregar nueva información al diccionario\ninfo_bogota[\"area_km2\"] = 1775\ninfo_bogota[\"poblacion\"] = 7900000  # Actualizar un valor existente\nprint(\"Info actualizada:\", info_bogota)\n\nInfo actualizada: {'nombre': 'Bogotá', 'poblacion': 7900000, 'coordenadas': (4.6097, -74.0817), 'pais': 'Colombia', 'fundacion': 1538, 'area_km2': 1775}\n\n# 4. TRABAJANDO CON COLECCIONES ANIDADAS (Estilo GeoJSON)\ncapitales_deptos = {\n    \"Antioquia\": {\n        \"capital\": \"Medellín\",\n        \"coordenadas\": (6.2442, -75.5812),\n        \"poblacion\": 2533424\n    },\n    \"Valle del Cauca\": {\n        \"capital\": \"Cali\",\n        \"coordenadas\": (3.4516, -76.5320),\n        \"poblacion\": 2227642\n    }\n}\n\n# Acceder a información anidada\ninfo_valle = capitales_deptos[\"Valle del Cauca\"]\nprint(f\"Capital del Valle: {info_valle['capital']}\")\n\nCapital del Valle: Cali\n\n# 5. EXPLORACIÓN DE DICCIONARIOS\nprint(\"Claves disponibles:\", list(info_bogota.keys()))\n\nClaves disponibles: ['nombre', 'poblacion', 'coordenadas', 'pais', 'fundacion', 'area_km2']\n\n# Comprobar si una clave existe\nif \"coordenadas\" in info_bogota:\n    print(\"La información de coordenadas está disponible.\")\n\nLa información de coordenadas está disponible.\n\n# 6. EJEMPLO PRÁCTICO: Metadatos de un Waypoint GPS\npunto_gps = {\n    \"id\": \"PC001\",\n    \"nombre\": \"Inicio Sendero Cocora\",\n    \"latitud\": 4.6395,\n    \"longitud\": -75.4851,\n    \"elevacion\": 2400,\n    \"tipo_cobertura\": \"Bosque de Palma\",\n    \"facilidades\": [\"parqueadero\", \"guía\", \"restaurante\"]\n}\n\nprint(f\"Punto: {punto_gps['nombre']} a {punto_gps['elevacion']} msnm\")\n\nPunto: Inicio Sendero Cocora a 2400 msnm\n\nprint(f\"Servicios: {', '.join(punto_gps['facilidades'])}\")\n\nServicios: parqueadero, guía, restaurante\n\n\n\n\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\n# 1. CREACIÓN DE DICCIONARIOS\n# En R, usamos listas nombradas (named lists) para emular diccionarios\ninfo_bogota &lt;- list(\n    nombre = \"Bogotá\",\n    poblacion = 7181469,\n    coordenadas = c(4.6097, -74.0817),\n    pais = \"Colombia\",\n    fundacion = 1538\n)\ncat(\"Información de Bogotá:\\n\"); print(info_bogota)\n\n# 2. ACCESO A VALORES\n# Accedemos mediante el símbolo del dólar '$' o doble corchete '[[]]'\nnombre_ciudad &lt;- info_bogota$nombre\npoblacion_ciudad &lt;- info_bogota$poblacion\ncat(sprintf(\"Ciudad: %s | Población: %s\\n\", nombre_ciudad, format(poblacion_ciudad, big.mark=\",\")))\n\n# En R, acceder a una clave inexistente devuelve NULL de forma nativa\narea &lt;- if(is.null(info_bogota$area_km2)) \"No especificada\" else info_bogota$area_km2\ncat(sprintf(\"Área: %s\\n\", area))\n\n# 3. AGREGAR Y ACTUALIZAR VALORES\ninfo_bogota$area_km2 &lt;- 1775\ninfo_bogota$poblacion &lt;- 7900000\ncat(\"Info actualizada:\\n\"); print(info_bogota)\n\n# 4. TRABAJANDO CON COLECCIONES ANIDADAS\ncapitales_deptos &lt;- list(\n    Antioquia = list(\n        capital = \"Medellín\",\n        coordenadas = c(6.2442, -75.5812),\n        poblacion = 2533424\n    ),\n    Valle_del_Cauca = list(\n        capital = \"Cali\",\n        coordenadas = c(3.4516, -76.5320),\n        poblacion = 2227642\n    )\n)\n\ninfo_valle &lt;- capitales_deptos$Valle_del_Cauca\ncat(sprintf(\"Capital del Valle: %s\\n\", info_valle$capital))\n\n# 5. EXPLORACIÓN DE DICCIONARIOS\ncat(\"Claves disponibles:\", names(info_bogota), \"\\n\")\n\nif (\"coordenadas\" %in% names(info_bogota)) {\n    cat(\"La información de coordenadas está disponible.\\n\")\n}\n\n# 6. EJEMPLO PRÁCTICO: Metadatos de un Waypoint GPS\npunto_gps &lt;- list(\n    id = \"PC001\",\n    nombre = \"Inicio Sendero Cocora\",\n    latitud = 4.6395,\n    longitud = -75.4851,\n    elevacion = 2400,\n    tipo_cobertura = \"Bosque de Palma\",\n    facilidades = c(\"parqueadero\", \"guía\", \"restaurante\")\n)\n\ncat(sprintf(\"Punto: %s a %s msnm\\n\", punto_gps$nombre, punto_gps$elevacion))\ncat(sprintf(\"Servicios: %s\\n\", paste(punto_gps$facilidades, collapse=\", \")))\n\n\n\n\n\n# #| eval: false\n\n# 1. CREACIÓN DE DICCIONARIOS\n# En R, usamos listas nombradas (named lists) para emular diccionarios\ninfo_bogota &lt;- list(\n    nombre = \"Bogotá\",\n    poblacion = 7181469,\n    coordenadas = c(4.6097, -74.0817),\n    pais = \"Colombia\",\n    fundacion = 1538\n)\ncat(\"Información de Bogotá:\\n\"); print(info_bogota)\n\nInformación de Bogotá:\n\n\n$nombre\n[1] \"Bogotá\"\n\n$poblacion\n[1] 7181469\n\n$coordenadas\n[1]   4.6097 -74.0817\n\n$pais\n[1] \"Colombia\"\n\n$fundacion\n[1] 1538\n\n# 2. ACCESO A VALORES\n# Accedemos mediante el símbolo del dólar '$' o doble corchete '[[]]'\nnombre_ciudad &lt;- info_bogota$nombre\npoblacion_ciudad &lt;- info_bogota$poblacion\ncat(sprintf(\"Ciudad: %s | Población: %s\\n\", nombre_ciudad, format(poblacion_ciudad, big.mark=\",\")))\n\nCiudad: Bogotá | Población: 7,181,469\n\n# En R, acceder a una clave inexistente devuelve NULL de forma nativa\narea &lt;- if(is.null(info_bogota$area_km2)) \"No especificada\" else info_bogota$area_km2\ncat(sprintf(\"Área: %s\\n\", area))\n\nÁrea: No especificada\n\n# 3. AGREGAR Y ACTUALIZAR VALORES\ninfo_bogota$area_km2 &lt;- 1775\ninfo_bogota$poblacion &lt;- 7900000\ncat(\"Info actualizada:\\n\"); print(info_bogota)\n\nInfo actualizada:\n\n\n$nombre\n[1] \"Bogotá\"\n\n$poblacion\n[1] 7900000\n\n$coordenadas\n[1]   4.6097 -74.0817\n\n$pais\n[1] \"Colombia\"\n\n$fundacion\n[1] 1538\n\n$area_km2\n[1] 1775\n\n# 4. TRABAJANDO CON COLECCIONES ANIDADAS\ncapitales_deptos &lt;- list(\n    Antioquia = list(\n        capital = \"Medellín\",\n        coordenadas = c(6.2442, -75.5812),\n        poblacion = 2533424\n    ),\n    Valle_del_Cauca = list(\n        capital = \"Cali\",\n        coordenadas = c(3.4516, -76.5320),\n        poblacion = 2227642\n    )\n)\n\ninfo_valle &lt;- capitales_deptos$Valle_del_Cauca\ncat(sprintf(\"Capital del Valle: %s\\n\", info_valle$capital))\n\nCapital del Valle: Cali\n\n# 5. EXPLORACIÓN DE DICCIONARIOS\ncat(\"Claves disponibles:\", names(info_bogota), \"\\n\")\n\nClaves disponibles: nombre poblacion coordenadas pais fundacion area_km2 \n\nif (\"coordenadas\" %in% names(info_bogota)) {\n    cat(\"La información de coordenadas está disponible.\\n\")\n}\n\nLa información de coordenadas está disponible.\n\n# 6. EJEMPLO PRÁCTICO: Metadatos de un Waypoint GPS\npunto_gps &lt;- list(\n    id = \"PC001\",\n    nombre = \"Inicio Sendero Cocora\",\n    latitud = 4.6395,\n    longitud = -75.4851,\n    elevacion = 2400,\n    tipo_cobertura = \"Bosque de Palma\",\n    facilidades = c(\"parqueadero\", \"guía\", \"restaurante\")\n)\n\ncat(sprintf(\"Punto: %s a %s msnm\\n\", punto_gps$nombre, punto_gps$elevacion))\n\nPunto: Inicio Sendero Cocora a 2400 msnm\n\ncat(sprintf(\"Servicios: %s\\n\", paste(punto_gps$facilidades, collapse=\", \")))\n\nServicios: parqueadero, guía, restaurante\n\n\n\n\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\n# 1. CREACIÓN DE DICCIONARIOS\n# Julia usa Dict() con el operador =&gt;\ninfo_bogota = Dict(\n    \"nombre\" =&gt; \"Bogotá\",\n    \"poblacion\" =&gt; 7181469,\n    \"coordenadas\" =&gt; (4.6097, -74.0817),\n    \"pais\" =&gt; \"Colombia\",\n    \"fundacion\" =&gt; 1538\n)\nprintln(\"Información de Bogotá: \", info_bogota)\n\n# 2. ACCESO A VALORES\nnombre_ciudad = info_bogota[\"nombre\"]\npoblacion_ciudad = info_bogota[\"poblacion\"]\nprintln(\"Ciudad: $nombre_ciudad | Población: $poblacion_ciudad\")\n\n# Acceso seguro con get()\narea = get(info_bogota, \"area_km2\", \"No especificada\")\nprintln(\"Área: $area\")\n\n# 3. AGREGAR Y ACTUALIZAR VALORES\ninfo_bogota[\"area_km2\"] = 1775\ninfo_bogota[\"poblacion\"] = 7900000\nprintln(\"Info actualizada: \", info_bogota)\n\n# 4. TRABAJANDO CON COLECCIONES ANIDADAS\ncapitales_deptos = Dict(\n    \"Antioquia\" =&gt; Dict(\n        \"capital\" =&gt; \"Medellín\",\n        \"coordenadas\" =&gt; (6.2442, -75.5812),\n        \"poblacion\" =&gt; 2533424\n    ),\n    \"Valle del Cauca\" =&gt; Dict(\n        \"capital\" =&gt; \"Cali\",\n        \"coordenadas\" =&gt; (3.4516, -76.5320),\n        \"poblacion\" =&gt; 2227642\n    )\n)\n\ninfo_valle = capitales_deptos[\"Valle del Cauca\"]\nprintln(\"Capital del Valle: \", info_valle[\"capital\"])\n\n# 5. EXPLORACIÓN DE DICCIONARIOS\nprintln(\"Claves disponibles: \", collect(keys(info_bogota)))\n\nif haskey(info_bogota, \"coordenadas\")\n    println(\"La información de coordenadas está disponible.\")\nend\n\n# 6. EJEMPLO PRÁCTICO: Metadatos de un Waypoint GPS\npunto_gps = Dict(\n    \"id\" =&gt; \"PC001\",\n    \"nombre\" =&gt; \"Inicio Sendero Cocora\",\n    \"latitud\" =&gt; 4.6395,\n    \"longitud\" =&gt; -75.4851,\n    \"elevacion\" =&gt; 2400,\n    \"tipo_cobertura\" =&gt; \"Bosque de Palma\",\n    \"facilidades\" =&gt; [\"parqueadero\", \"guía\", \"restaurante\"]\n)\n\nprintln(\"Punto: \", punto_gps[\"nombre\"], \" a \", punto_gps[\"elevacion\"], \" msnm\")\nprintln(\"Servicios: \", join(punto_gps[\"facilidades\"], \", \"))\n\n\n\n\n# #| eval: false\nj_eval('\n# 1. CREACIÓN DE DICCIONARIOS\n# Julia usa Dict() con el operador =&gt;\ninfo_bogota = Dict(\n    \"nombre\" =&gt; \"Bogotá\",\n    \"poblacion\" =&gt; 7181469,\n    \"coordenadas\" =&gt; (4.6097, -74.0817),\n    \"pais\" =&gt; \"Colombia\",\n    \"fundacion\" =&gt; 1538\n)\nprintln(\"Información de Bogotá: \", info_bogota)\n\n# 2. ACCESO A VALORES\nnombre_ciudad = info_bogota[\"nombre\"]\npoblacion_ciudad = info_bogota[\"poblacion\"]\nprintln(\"Ciudad: $nombre_ciudad | Población: $poblacion_ciudad\")\n\n# Acceso seguro con get()\narea = get(info_bogota, \"area_km2\", \"No especificada\")\nprintln(\"Área: $area\")\n\n# 3. AGREGAR Y ACTUALIZAR VALORES\ninfo_bogota[\"area_km2\"] = 1775\ninfo_bogota[\"poblacion\"] = 7900000\nprintln(\"Info actualizada: \", info_bogota)\n\n# 4. TRABAJANDO CON COLECCIONES ANIDADAS\ncapitales_deptos = Dict(\n    \"Antioquia\" =&gt; Dict(\n        \"capital\" =&gt; \"Medellín\",\n        \"coordenadas\" =&gt; (6.2442, -75.5812),\n        \"poblacion\" =&gt; 2533424\n    ),\n    \"Valle del Cauca\" =&gt; Dict(\n        \"capital\" =&gt; \"Cali\",\n        \"coordenadas\" =&gt; (3.4516, -76.5320),\n        \"poblacion\" =&gt; 2227642\n    )\n)\n\ninfo_valle = capitales_deptos[\"Valle del Cauca\"]\nprintln(\"Capital del Valle: \", info_valle[\"capital\"])\n\n# 5. EXPLORACIÓN DE DICCIONARIOS\nprintln(\"Claves disponibles: \", collect(keys(info_bogota)))\n\nif haskey(info_bogota, \"coordenadas\")\n    println(\"La información de coordenadas está disponible.\")\nend\n\n# 6. EJEMPLO PRÁCTICO: Metadatos de un Waypoint GPS\npunto_gps = Dict(\n    \"id\" =&gt; \"PC001\",\n    \"nombre\" =&gt; \"Inicio Sendero Cocora\",\n    \"latitud\" =&gt; 4.6395,\n    \"longitud\" =&gt; -75.4851,\n    \"elevacion\" =&gt; 2400,\n    \"tipo_cobertura\" =&gt; \"Bosque de Palma\",\n    \"facilidades\" =&gt; [\"parqueadero\", \"guía\", \"restaurante\"]\n)\n\nprintln(\"Punto: \", punto_gps[\"nombre\"], \" a \", punto_gps[\"elevacion\"], \" msnm\")\nprintln(\"Servicios: \", join(punto_gps[\"facilidades\"], \", \"))\n')\njulia&gt; # 1. CREACIÓN DE DICCIONARIOS\n\n\njulia&gt; # Julia usa Dict() con el operador =&gt;\n\n\njulia&gt; info_bogota = Dict(\n           \"nombre\" =&gt; \"Bogotá\",\n           \"poblacion\" =&gt; 7181469,\n           \"coordenadas\" =&gt; (4.6097, -74.0817),\n           \"pais\" =&gt; \"Colombia\",\n           \"fundacion\" =&gt; 1538\n       )\n\nDict{String, Any} with 5 entries:\n  \"coordenadas\" =&gt; (4.6097, -74.0817)\n  \"pais\" =&gt; \"Colombia\"\n  \"nombre\" =&gt; \"Bogotá\"\n  \"poblacion\" =&gt; 7181469\n  \"fundacion\" =&gt; 1538\n\n\njulia&gt; println(\"Información de Bogotá: \", info_bogota)\n\nInformación de Bogotá: Dict{String, Any}(\"coordenadas\" =&gt; (4.6097, -74.0817), \"pais\" =&gt; \"Colombia\", \"nombre\" =&gt; \"Bogotá\", \"poblacion\" =&gt; 7181469, \"fundacion\" =&gt; 1538)\n\n\njulia&gt; # 2. ACCESO A VALORES\n\n\njulia&gt; nombre_ciudad = info_bogota[\"nombre\"]\n\n\"Bogotá\"\n\n\njulia&gt; poblacion_ciudad = info_bogota[\"poblacion\"]\n\n7181469\n\n\njulia&gt; println(\"Ciudad: $nombre_ciudad | Población: $poblacion_ciudad\")\n\nCiudad: Bogotá | Población: 7181469\n\n\njulia&gt; # Acceso seguro con get()\n\n\njulia&gt; area = get(info_bogota, \"area_km2\", \"No especificada\")\n\n\"No especificada\"\n\n\njulia&gt; println(\"Área: $area\")\n\nÁrea: No especificada\n\n\njulia&gt; # 3. AGREGAR Y ACTUALIZAR VALORES\n\n\njulia&gt; info_bogota[\"area_km2\"] = 1775\n\n1775\n\n\njulia&gt; info_bogota[\"poblacion\"] = 7900000\n\n7900000\n\n\njulia&gt; println(\"Info actualizada: \", info_bogota)\n\nInfo actualizada: Dict{String, Any}(\"coordenadas\" =&gt; (4.6097, -74.0817), \"pais\" =&gt; \"Colombia\", \"nombre\" =&gt; \"Bogotá\", \"poblacion\" =&gt; 7900000, \"fundacion\" =&gt; 1538, \"area_km2\" =&gt; 1775)\n\n\njulia&gt; # 4. TRABAJANDO CON COLECCIONES ANIDADAS\n\n\njulia&gt; capitales_deptos = Dict(\n           \"Antioquia\" =&gt; Dict(\n               \"capital\" =&gt; \"Medellín\",\n               \"coordenadas\" =&gt; (6.2442, -75.5812),\n               \"poblacion\" =&gt; 2533424\n           ),\n           \"Valle del Cauca\" =&gt; Dict(\n               \"capital\" =&gt; \"Cali\",\n               \"coordenadas\" =&gt; (3.4516, -76.5320),\n               \"poblacion\" =&gt; 2227642\n           )\n       )\n\nDict{String, Dict{String, Any}} with 2 entries:\n  \"Antioquia\" =&gt; Dict(\"coordenadas\"=&gt;(6.2442, -75.5812), \"capital\"=&gt;\"Medellín\", \"poblacion\"=&gt;2533424)\n  \"Valle del Cauca\" =&gt; Dict(\"coordenadas\"=&gt;(3.4516, -76.532), \"capital\"=&gt;\"Cali\", \"poblacion\"=&gt;2227642)\n\n\njulia&gt; info_valle = capitales_deptos[\"Valle del Cauca\"]\n\nDict{String, Any} with 3 entries:\n  \"coordenadas\" =&gt; (3.4516, -76.532)\n  \"capital\" =&gt; \"Cali\"\n  \"poblacion\" =&gt; 2227642\n\n\njulia&gt; println(\"Capital del Valle: \", info_valle[\"capital\"])\n\nCapital del Valle: Cali\n\n\njulia&gt; # 5. EXPLORACIÓN DE DICCIONARIOS\n\n\njulia&gt; println(\"Claves disponibles: \", collect(keys(info_bogota)))\n\nClaves disponibles: [\"coordenadas\", \"pais\", \"nombre\", \"poblacion\", \"fundacion\", \"area_km2\"]\n\n\njulia&gt; if haskey(info_bogota, \"coordenadas\")\n           println(\"La información de coordenadas está disponible.\")\n       end\n\nLa información de coordenadas está disponible.\n\n\njulia&gt; # 6. EJEMPLO PRÁCTICO: Metadatos de un Waypoint GPS\n\n\njulia&gt; punto_gps = Dict(\n           \"id\" =&gt; \"PC001\",\n           \"nombre\" =&gt; \"Inicio Sendero Cocora\",\n           \"latitud\" =&gt; 4.6395,\n           \"longitud\" =&gt; -75.4851,\n           \"elevacion\" =&gt; 2400,\n           \"tipo_cobertura\" =&gt; \"Bosque de Palma\",\n           \"facilidades\" =&gt; [\"parqueadero\", \"guía\", \"restaurante\"]\n       )\n\nDict{String, Any} with 7 entries:\n  \"latitud\" =&gt; 4.6395\n  \"elevacion\" =&gt; 2400\n  \"facilidades\" =&gt; [\"parqueadero\", \"guía\", \"restaurante\"]\n  \"tipo_cobertura\" =&gt; \"Bosque de Palma\"\n  \"longitud\" =&gt; -75.4851\n  \"id\" =&gt; \"PC001\"\n  \"nombre\" =&gt; \"Inicio Sendero Cocora\"\n\n\njulia&gt; println(\"Punto: \", punto_gps[\"nombre\"], \" a \", punto_gps[\"elevacion\"], \" msnm\")\n\nPunto: Inicio Sendero Cocora a 2400 msnm\n\n\njulia&gt; println(\"Servicios: \", join(punto_gps[\"facilidades\"], \", \"))\n\nServicios: parqueadero, guía, restaurante\n\n\n\n\n\n\nResumen de Diccionarios y Listas Nombradas\n\n\n\nTabla 6.4: Manejo de estructuras Clave-Valor\n\n\n\n\n\n\n\n\n\n\n\nOperación\nPython\nR\nJulia\n\n\n\n\nCreación\n{\"k\": v}\nlist(k = v)\nDict(\"k\" =&gt; v)\n\n\nAcceso a valor\ndict[\"k\"]\nlista$k o lista[[\"k\"]]\ndict[\"k\"]\n\n\nAcceso seguro (Fallback)\ndict.get(\"k\", \"Null\")\nif(is.null(lista$k))\nget(dict, \"k\", \"Null\")\n\n\nActualizar/Añadir\ndict[\"k\"] = nuevo\nlista$k &lt;- nuevo\ndict[\"k\"] = nuevo\n\n\nVerificar si existe\n\"k\" in dict\n\"k\" %in% names(lista)\nhaskey(dict, \"k\")\n\n\nObtener todas las claves\ndict.keys()\nnames(lista)\nkeys(dict)\n\n\n\n\n\n\n\nNota técnica importante sobre errores de acceso: Uno de los comportamientos que más confunde a los analistas de datos ocurre cuando intentan acceder a una clave o atributo que no existe en la estructura.\n\nEn Python y Julia, pedir una clave inexistente (como info_bogota[\"clima\"]) hará que el programa colapse inmediatamente (KeyError). Por eso, es mejor práctica usar la función segura .get() cuando no estamos seguros de si el atributo existe.\nEn R, la aproximación es mucho más laxa. Si pides info_bogota$clima, R no arrojará ningún error, simplemente devolverá NULL (vacío). Esto puede ser peligroso porque el programa sigue ejecutándose silenciosamente, pero los cálculos posteriores podrían fallar o contaminarse con datos nulos.",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Función j_eval y j_plot en R</span>"
    ]
  },
  {
    "objectID": "06-estructuras_datos.html#guía-de-selección-de-estructuras-de-datos",
    "href": "06-estructuras_datos.html#guía-de-selección-de-estructuras-de-datos",
    "title": "6  Estructuras de datos",
    "section": "6.8 Guía de Selección de Estructuras de Datos",
    "text": "6.8 Guía de Selección de Estructuras de Datos\nSaber elegir la estructura de datos correcta es la diferencia entre un script que procesa millones de coordenadas en segundos y uno que colapsa tu computadora. A continuación, te presentamos una guía práctica para tomar esta decisión en tus proyectos de análisis espacial.\n\nÁrbol de decisión rápido\nHazte las siguientes preguntas sobre los datos que necesitas almacenar:\n\n¿Los datos tienen un orden secuencial que importa?\n\nEjemplo: Los vértices de un polígono o los puntos de una ruta GPS. El orden define la geometría.\nSÍ: Pasa a la pregunta 2.\nNO: Pasa a la pregunta 3.\n\n¿Necesitarás agregar, borrar o modificar datos después de crearlos?\n\nSÍ (Mutables): Usa una Lista (o Vector c() en R). Ideal para acumular resultados de un cálculo.\nNO (Inmutables): Usa una Tupla (en Python/Julia). Ideal para fijar pares de coordenadas exactas (Lat, Lon) que nadie deba alterar por error.\n\n¿Cómo vas a buscar la información?\n\nPor una etiqueta o nombre (Clave-Valor): Usa un Diccionario (o list() nombrada en R). Ideal para almacenar los atributos de un municipio (Nombre, Área, Población) o crear metadatos tipo GeoJSON.\nSolo me importan los valores únicos y sin repeticiones: Usa un Conjunto (Set o funciones lógicas en R). Ideal para limpiar bases de datos (ej. obtener los códigos únicos de departamentos desde una tabla nacional de 10,000 registros).\n\n\n\n\n\nCasos de Uso Comunes en Geomática\n\n\n\nTabla 6.5: Escenarios prácticos para la selección de estructuras de datos\n\n\n\n\n\n\n\n\n\n\nEscenario\nEstructura Recomendada\n¿Por qué?\n\n\n\n\nCoordenada estática (X, Y)\nTupla\nProtege el dato. Si un algoritmo intenta mover la X sin mover la Y, el programa arroja error y salva la topología.\n\n\nPerfil de elevación de una ruta\nLista / Vector\nMantiene el orden estricto de los datos. Permite usar funciones matemáticas rápidas (max, mean).\n\n\nTabla de atributos de un lote\nDiccionario\nPermite acceder a los datos intuitivamente por nombre (ej. lote[\"propietario\"]) en lugar de recordar en qué columna numérica estaban.\n\n\nIntersectar áreas de influencia\nConjunto (Set)\nPermite operaciones de Teoría de Conjuntos nativas y ultrarrápidas (union, intersect) para saber, por ejemplo, qué fincas están en zona de riesgo.\n\n\n\n\n\n\n\n\n\n\n\n\nConsejo de Rendimiento\n\n\n\nSi estás procesando Big Data espacial (ej. nubes de puntos LiDAR con millones de registros), evita usar Listas si vas a realizar búsquedas frecuentes (“¿Existe este punto en la lista?”). Buscar en una lista obliga al computador a revisar elemento por elemento. Por el contrario, buscar en un Conjunto o en las claves de un Diccionario es casi instantáneo debido a cómo se estructuran internamente en la memoria (Tablas Hash).",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Función j_eval y j_plot en R</span>"
    ]
  },
  {
    "objectID": "06-estructuras_datos.html#resumen-de-aprendizajes-cheat-sheet",
    "href": "06-estructuras_datos.html#resumen-de-aprendizajes-cheat-sheet",
    "title": "6  Estructuras de datos",
    "section": "6.9 Resumen de Aprendizajes (Cheat Sheet)",
    "text": "6.9 Resumen de Aprendizajes (Cheat Sheet)\nEn este capítulo hemos explorado cómo organizar, almacenar y manipular grupos de datos usando las cuatro estructuras fundamentales de la programación. A continuación, se presenta tu Hoja de Referencia (Cheat Sheet) para traducir estos conceptos entre Python, R y Julia.\n\n1. Creación y Propiedades Fundamentales\n\n\n\nTabla 6.6: Definición de estructuras de datos y mutabilidad\n\n\n\n\n\n\n\n\n\n\n\n\nEstructura\nPython\nR\nJulia\nMutabilidad\n\n\n\n\nTupla (Pares fijos)\nt = (1, 2)\nUsa vectores c(1, 2)\nt = (1, 2)\nInmutable (Py/Jl)\n\n\nLista / Vector (Secuencias)\nl = [1, 2, 3]\nv &lt;- c(1, 2, 3)\na = [1, 2, 3]\nMutable\n\n\nConjunto (Valores únicos)\ns = {\"A\", \"B\"}\nUsa vectores c(\"A\")\ns = Set([\"A\", \"B\"])\nMutable\n\n\nDiccionario (Clave-Valor)\nd = {\"x\": 1}\nd &lt;- list(x = 1)\nd = Dict(\"x\" =&gt; 1)\nMutable\n\n\n\n\n\n\n\n\n2. Acceso, Índices y Extracción (Slicing)\n\n\n\nTabla 6.7: Reglas de indexación y acceso a elementos\n\n\n\n\n\n\n\n\n\n\n\nOperación\nPython (Base 0)\nR (Base 1)\nJulia (Base 1)\n\n\n\n\nPrimer Elemento\nlista[0]\nvector[1] o lista[[1]]\narray[1]\n\n\nÚltimo Elemento\nlista[-1]\nvector[length(vector)]\narray[end]\n\n\nRango (Slicing)\nlista[2:5] (Excluye el 5)\nvector[3:5] (Incluye el 5)\narray[3:5] (Incluye el 5)\n\n\nAcceso a Diccionario\ndict[\"clave\"]\nlista$clave\ndict[\"clave\"]\n\n\nAcceso Seguro (Fallback)\ndict.get(\"clave\", 0)\nif(is.null(l$c)) 0 else l$c\nget(dict, \"clave\", 0)\n\n\n\n\n\n\n\n\n3. Operaciones Principales y Modificaciones\n\n\n\nTabla 6.8: Funciones nativas para manipulación de colecciones\n\n\n\n\n\n\n\n\n\n\n\nObjetivo / Acción\nPython\nR\nJulia\n\n\n\n\nTamaño / Longitud\nlen(datos)\nlength(datos)\nlength(datos)\n\n\nAgregar al final\nlista.append(x)\nv &lt;- c(v, x)\npush!(array, x)\n\n\nEliminar Duplicados\nset(lista)\nunique(vector)\nunique(array) o Set(array)\n\n\nValor Máximo\nmax(lista)\nmax(vector)\nmaximum(array)\n\n\nIntersección (Comunes)\nset1 & set2\nintersect(v1, v2)\nintersect(s1, s2)\n\n\nComprobar si existe\nx in lista\nx %in% vector\nx in array\n\n\n\n\n\n\n\n\n\n\n\n\n\nConclusiones Críticas del Módulo\n\n\n\n\nLa trampa del Índice de Origen: Nunca olvides que Python empieza a contar desde 0, mientras que R y Julia empiezan desde 1. Migrar un código de análisis de series de tiempo de R a Python sin ajustar los índices resultará en datos desplazados o errores de ejecución (IndexError).\nLa ilusión de las Listas en R: En Python y Julia, los corchetes [] crean listas o arreglos dinámicos. En R, una verdadera colección homogénea se crea con la función concatenar c(). El comando list() en R equivale en comportamiento a un Diccionario o a una estructura anidada.\nTuplas para Topología: Acostúmbrate a guardar las coordenadas geográficas siempre como Tuplas en Python y Julia. Su inmutabilidad evitará que un bucle mal programado altere silenciosamente la posición espacial de tus datos originales.",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Función j_eval y j_plot en R</span>"
    ]
  },
  {
    "objectID": "06-estructuras_datos.html#ejercicios",
    "href": "06-estructuras_datos.html#ejercicios",
    "title": "6  Estructuras de datos",
    "section": "6.10 Ejercicios",
    "text": "6.10 Ejercicios\nPara poner en práctica los conceptos aprendidos sobre estructuras de datos, deberás resolver los siguientes dos ejercicios. Puedes elegir resolverlos en Python, R o Julia (o implementar la solución en varios lenguajes si deseas retarte).\n\nEjercicio 1: Rutas de monitoreo (Tuplas y Listas)\nContexto: Trabajas en un proyecto de conservación en la Sierra Nevada de Santa Marta. Los guardabosques realizan recorridos diarios y te envían las coordenadas de los puntos de avistamiento de fauna. Necesitas estructurar esta ruta temporal de forma segura, garantizando que las coordenadas individuales no se alteren, pero permitiendo que la ruta crezca a medida que reportan nuevos puntos.\nInstrucciones de código:\n\nDefine tres variables (punto_1, punto_2, punto_3) que almacenen las coordenadas (Latitud, Longitud) como Tuplas estáticas (o su equivalente más seguro en tu lenguaje).\n\nPunto 1: 11.1198, -74.0321\nPunto 2: 11.1250, -74.0280\nPunto 3: 11.1302, -74.0215\n\nCrea una colección secuencial y mutable (Lista en Python/Julia o Vector/Lista en R) llamada ruta_avistamiento que contenga los tres puntos iniciales en orden.\nLos guardabosques acaban de reportar un cuarto punto (11.1355, -74.0150). Utiliza el método nativo de tu lenguaje para agregar esta nueva coordenada al final de tu ruta.\nUtilizando la indexación dinámica (indexación negativa o comandos como length/end), extrae el último punto de la ruta y guárdalo en una variable llamada ultimo_reporte.\nCrea una nueva lista/vector paralela llamada elevaciones que contenga las alturas de los cuatro puntos: [850.5, 920.0, 1050.2, 1180.8].\nCalcula e imprime la elevación máxima alcanzada en el recorrido y el número total de puntos visitados (vértices), utilizando las funciones nativas (ej. max(), len(), length()).\n\n\n\nEjercicio 2: Metadatos y Ecosistemas (Diccionarios y Conjuntos)\nContexto: Estás diseñando el esquema de base de datos para los Parques Nacionales Naturales (PNN). Necesitas estructurar los atributos de un parque usando un modelo de clave-valor (similar a GeoJSON) y depurar una lista de observaciones de campo que tiene datos duplicados.\nInstrucciones de código:\n\nCrea un Diccionario (o Lista nombrada en R) llamado pnn_tayrona que contenga exactamente las siguientes claves y valores:\n\n\"nombre\": “PNN Tayrona”\n\"area_hectareas\": 15000\n\"abierto_turismo\": Verdadero (tipo Booleano)\n\"ecosistemas\": Una lista/vector con los textos \"Manglar\", \"Bosque Seco\", y \"Coral\".\n\nEmplea la función o método de acceso seguro (ej. .get() en Python o condicionales en R/Julia) para intentar extraer la clave \"fecha_creacion\". Como no existe, debe devolver el texto \"Dato no disponible\" sin que el programa colapse. Imprime el resultado.\nActualiza el diccionario añadiendo una nueva clave llamada \"departamento\" con el valor \"Magdalena\".\nRecibes un reporte de campo crudo con los ecosistemas observados hoy, el cual contiene duplicados: observaciones_crudas = [\"Manglar\", \"Coral\", \"Bosque Seco\", \"Manglar\", \"Coral\", \"Matorral\"] Convierte esta colección en un Conjunto (Set o usando unique()) para eliminar los duplicados y guárdalo en la variable observaciones_unicas.\nUtiliza una operación lógica de conjuntos (intersección) entre la lista oficial de ecosistemas del parque (guardada dentro de tu diccionario en el paso 1) y tus observaciones_unicas. Imprime el resultado para saber qué ecosistemas oficiales fueron efectivamente avistados hoy.\n\n\n\nEntregables y Criterios de Evaluación\nEl objetivo de esta evaluación no es solo que el código funcione, sino que seas capaz de documentar y explicar tus decisiones técnicas.\n1. Archivos de Código: Debes desarrollar los algoritmos en al menos uno de los siguientes formatos de archivo: * Script tradicional (.py, .R, .jl) * Notebook interactivo (.ipynb) * Documento computacional (.qmd con chunks de código)\n2. Documento Analítico (Quarto): Independientemente del formato de tu código fuente, debes redactar un documento en Quarto (.qmd) y renderizarlo tanto en HTML como en PDF. En este documento debes incluir tus bloques de código y responder argumentativamente a las siguientes preguntas:\n\nSobre el Ejercicio 1: En términos de topología espacial y seguridad del código, ¿cuál es la ventaja de guardar las coordenadas individuales (X, Y) como Tuplas inmutables, pero guardar la ruta completa como una Lista mutable? ¿Qué pasaría si intentas modificar directamente la latitud del punto_1 usando punto_1[0] = 12.0000 en Python o Julia?\nSobre el Ejercicio 2: En R, existe un debate constante entre usar c() o list(). Si estuvieras programando en R y necesitaras almacenar la lista de \"ecosistemas\" dentro de las propiedades del parque, ¿qué comando usarías para agrupar esos textos específicos y por qué?\nPregunta General (Slicing): Explica brevemente la diferencia crítica en el comportamiento de extracción de rangos (slicing) si ejecutas ruta[1:3] en Python comparado con ejecutar el mismo código en R o Julia. ¿Cuántos elementos te devuelve cada uno y por qué?\n\n3. Repositorio en GitHub: Sube tu carpeta del proyecto (que debe contener tus scripts, el archivo .qmd y los renders finales en HTML y PDF) a un repositorio público en tu cuenta personal de GitHub. * Entrega: Deberás enviar únicamente el enlace (URL) a tu repositorio de GitHub para la calificación.\nhttps://gispro.gishub.org/book/python/data-structures.html#creating-and-using-tuples",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Función j_eval y j_plot en R</span>"
    ]
  },
  {
    "objectID": "07-operaciones_cadenas.html",
    "href": "07-operaciones_cadenas.html",
    "title": "7  Operaciones con Cadenas de Texto (Strings)",
    "section": "",
    "text": "7.1 Función j_eval y j_plot en R",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Función j_eval y j_plot en R</span>"
    ]
  },
  {
    "objectID": "07-operaciones_cadenas.html#introducción",
    "href": "07-operaciones_cadenas.html#introducción",
    "title": "7  Operaciones con Cadenas de Texto (Strings)",
    "section": "7.2 Introducción",
    "text": "7.2 Introducción\nEn el análisis de datos espaciales, gran parte del tiempo se invierte en la limpieza y manipulación de texto. Ya sea para estandarizar nombres de municipios colombianos, armar rutas de archivos raster, separar coordenadas o construir consultas SQL espaciales, dominar las cadenas de texto es fundamental.",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Función j_eval y j_plot en R</span>"
    ]
  },
  {
    "objectID": "07-operaciones_cadenas.html#objetivos-de-aprendizaje",
    "href": "07-operaciones_cadenas.html#objetivos-de-aprendizaje",
    "title": "7  Operaciones con Cadenas de Texto (Strings)",
    "section": "7.3 Objetivos de aprendizaje",
    "text": "7.3 Objetivos de aprendizaje",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Función j_eval y j_plot en R</span>"
    ]
  },
  {
    "objectID": "07-operaciones_cadenas.html#creación-y-propiedades-básicas",
    "href": "07-operaciones_cadenas.html#creación-y-propiedades-básicas",
    "title": "7  Operaciones con Cadenas de Texto (Strings)",
    "section": "7.4 1. Creación y Propiedades Básicas",
    "text": "7.4 1. Creación y Propiedades Básicas\nUna cadena de texto (string) se puede definir con comillas simples o dobles. Para textos largos (como descripciones de metadatos geográficos), usamos comillas triples.\n\nPythonRJulia\n\n\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\nlugar = \"Pico Cristóbal Colón\"\ndepartamento = 'Magdalena'\ndescripcion = \"\"\"El Pico Cristóbal Colón es la montaña más alta\nde Colombia, ubicada en la Sierra Nevada de Santa Marta.\"\"\"\n\nprint(f\"Lugar: {lugar}\")\nprint(f\"Departamento: {departamento}\")\nprint(f\"Descripción: {descripcion}\")\n\n# Concatenación y Repetición\nubicacion_completa = lugar + \", \" + departamento\nseparador = \"=\" * 40\n\nprint(separador)\nprint(f\"Ubicación Completa: {ubicacion_completa}\")\nprint(f\"Longitud del nombre: {len(lugar)} caracteres\")\nprint(separador)\n\n\n\n\n\nlugar = \"Pico Cristóbal Colón\"\ndepartamento = 'Magdalena'\ndescripcion = \"\"\"El Pico Cristóbal Colón es la montaña más alta\nde Colombia, ubicada en la Sierra Nevada de Santa Marta.\"\"\"\n\nprint(f\"Lugar: {lugar}\")\n\nLugar: Pico Cristóbal Colón\n\nprint(f\"Departamento: {departamento}\")\n\nDepartamento: Magdalena\n\nprint(f\"Descripción: {descripcion}\")\n\nDescripción: El Pico Cristóbal Colón es la montaña más alta\nde Colombia, ubicada en la Sierra Nevada de Santa Marta.\n\n# Concatenación y Repetición\nubicacion_completa = lugar + \", \" + departamento\nseparador = \"=\" * 40\n\nprint(separador)\n\n========================================\n\nprint(f\"Ubicación Completa: {ubicacion_completa}\")\n\nUbicación Completa: Pico Cristóbal Colón, Magdalena\n\nprint(f\"Longitud del nombre: {len(lugar)} caracteres\")\n\nLongitud del nombre: 20 caracteres\n\nprint(separador)\n\n========================================\n\n\n\n\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\nlugar &lt;- \"Pico Cristóbal Colón\"\ndepartamento &lt;- 'Magdalena'\ndescripcion &lt;- \"El Pico Cristóbal Colón es la montaña más alta\\nde Colombia, ubicada en la Sierra Nevada de Santa Marta.\"\n\ncat(\"Lugar:\", lugar, \"\\n\")\ncat(\"Departamento:\", departamento, \"\\n\")\n\n# Concatenación y Repetición\nubicacion_completa &lt;- paste0(lugar, \", \", departamento)\nseparador &lt;- strrep(\"=\", 40)\n\ncat(separador, \"\\n\")\ncat(\"Ubicación Completa:\", ubicacion_completa, \"\\n\")\ncat(\"Longitud del nombre:\", nchar(lugar), \"caracteres\\n\")\ncat(separador, \"\\n\")\n\n\n\n\n\nlugar &lt;- \"Pico Cristóbal Colón\"\ndepartamento &lt;- 'Magdalena'\ndescripcion &lt;- \"El Pico Cristóbal Colón es la montaña más alta\\nde Colombia, ubicada en la Sierra Nevada de Santa Marta.\"\n\ncat(\"Lugar:\", lugar, \"\\n\")\n\nLugar: Pico Cristóbal Colón \n\ncat(\"Departamento:\", departamento, \"\\n\")\n\nDepartamento: Magdalena \n\n# Concatenación y Repetición\nubicacion_completa &lt;- paste0(lugar, \", \", departamento)\nseparador &lt;- strrep(\"=\", 40)\n\ncat(separador, \"\\n\")\n\n======================================== \n\ncat(\"Ubicación Completa:\", ubicacion_completa, \"\\n\")\n\nUbicación Completa: Pico Cristóbal Colón, Magdalena \n\ncat(\"Longitud del nombre:\", nchar(lugar), \"caracteres\\n\")\n\nLongitud del nombre: 20 caracteres\n\ncat(separador, \"\\n\")\n\n======================================== \n\n\n\n\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\nlugar = \"Pico Cristóbal Colón\"\ndepartamento = \"Magdalena\" # En Julia siempre comillas dobles\ndescripcion = \"\"\"El Pico Cristóbal Colón es la montaña más alta\nde Colombia, ubicada en la Sierra Nevada de Santa Marta.\"\"\"\n\nprintln(\"Lugar: $lugar\")\nprintln(\"Departamento: $departamento\")\n\n# Concatenación (*) y Repetición (^)\nubicacion_completa = lugar * \", \" * departamento\nseparador = \"=\" ^ 40\n\nprintln(separador)\nprintln(\"Ubicación Completa: $ubicacion_completa\")\nprintln(\"Longitud del nombre: $(length(lugar)) caracteres\")\nprintln(separador)\n\n\n\n\nj_eval(r\"-(\nlugar = \"Pico Cristóbal Colón\"\ndepartamento = \"Magdalena\" # En Julia siempre comillas dobles\ndescripcion = \"\"\"El Pico Cristóbal Colón es la montaña más alta\nde Colombia, ubicada en la Sierra Nevada de Santa Marta.\"\"\"\n\nprintln(\"Lugar: $lugar\")\nprintln(\"Departamento: $departamento\")\n\n# Concatenación (*) y Repetición (^)\nubicacion_completa = lugar * \", \" * departamento\nseparador = \"=\" ^ 40\n\nprintln(separador)\nprintln(\"Ubicación Completa: $ubicacion_completa\")\nprintln(\"Longitud del nombre: $(length(lugar)) caracteres\")\nprintln(separador)\n)-\")\nStarting Julia ...\njulia&gt; lugar = \"Pico Cristóbal Colón\"\n\n\"Pico Cristóbal Colón\"\n\n\njulia&gt; departamento = \"Magdalena\" # En Julia siempre comillas dobles\n\n\"Magdalena\"\n\n\njulia&gt; descripcion = \"\"\"El Pico Cristóbal Colón es la montaña más alta\n       de Colombia, ubicada en la Sierra Nevada de Santa Marta.\"\"\"\n\n\"El Pico Cristóbal Colón es la montaña más alta\\nde Colombia, ubicada en la Sierra Nevada de Santa Marta.\"\n\n\njulia&gt; println(\"Lugar: $lugar\")\n\nLugar: Pico Cristóbal Colón\n\n\njulia&gt; println(\"Departamento: $departamento\")\n\nDepartamento: Magdalena\n\n\njulia&gt; # Concatenación (*) y Repetición (^)\n\n\njulia&gt; ubicacion_completa = lugar * \", \" * departamento\n\n\"Pico Cristóbal Colón, Magdalena\"\n\n\njulia&gt; separador = \"=\" ^ 40\n\n\"========================================\"\n\n\njulia&gt; println(separador)\n\n========================================\n\n\njulia&gt; println(\"Ubicación Completa: $ubicacion_completa\")\n\nUbicación Completa: Pico Cristóbal Colón, Magdalena\n\n\njulia&gt; println(\"Longitud del nombre: $(length(lugar)) caracteres\")\n\nLongitud del nombre: 20 caracteres\n\n\njulia&gt; println(separador)\n\n========================================\n\n\n\n\n\n\n1.1 Interpolación de Cadenas\nLa interpolación nos permite insertar variables directamente dentro de un texto sin tener que estar abriendo y cerrando comillas constantemente.\n\nPythonRJulia\n\n\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\npico = \"Pico Cristóbal Colón\"\naltura = 5700\n\n# F-strings (Interpolación directa)\nprint(f\"El {pico} tiene una altitud de {altura} msnm.\")\n\n\n\n\n\npico = \"Pico Cristóbal Colón\"\naltura = 5700\n\n# F-strings (Interpolación directa)\nprint(f\"El {pico} tiene una altitud de {altura} msnm.\")\n\nEl Pico Cristóbal Colón tiene una altitud de 5700 msnm.\n\n\n\n\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\npico &lt;- \"Pico Cristóbal Colón\"\naltura &lt;- 5700\n\n# En R usamos sprintf (%s para texto, %d para enteros)\nmensaje &lt;- sprintf(\"El %s tiene una altitud de %d msnm.\", pico, altura)\ncat(mensaje)\n\n\n\n\n\npico &lt;- \"Pico Cristóbal Colón\"\naltura &lt;- 5700\n\n# En R usamos sprintf (%s para texto, %d para enteros)\nmensaje &lt;- sprintf(\"El %s tiene una altitud de %d msnm.\", pico, altura)\ncat(mensaje)\n\nEl Pico Cristóbal Colón tiene una altitud de 5700 msnm.\n\n\n\n\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\npico = \"Pico Cristóbal Colón\"\naltura = 5700\n\n# Julia usa el símbolo $ para interpolar variables\nprintln(\"El $pico tiene una altitud de $altura msnm.\")\n\n\n\n\nj_eval(r\"-(\npico = \"Pico Cristóbal Colón\"\naltura = 5700\n\n# Julia usa el símbolo $ para interpolar variables\nprintln(\"El $pico tiene una altitud de $altura msnm.\")\n)-\")\njulia&gt; pico = \"Pico Cristóbal Colón\"\n\n\"Pico Cristóbal Colón\"\n\n\njulia&gt; altura = 5700\n\n5700\n\n\njulia&gt; # Julia usa el símbolo $ para interpolar variables\n\n\njulia&gt; println(\"El $pico tiene una altitud de $altura msnm.\")\n\nEl Pico Cristóbal Colón tiene una altitud de 5700 msnm.\n\n\n\n\n\nResumen de Sintaxis: Creación y Propiedades\n\n\n\n\n\n\n\n\n\nOperación\nPython\nR\nJulia\n\n\n\n\nDefinir String\n\"Col\", 'Col'\n\"Col\", 'Col'\n\"Col\" (Solo dobles)\n\n\nMultilínea\n\"\"\"Texto\"\"\"\n\"Texto\\nTexto\"\n\"\"\"Texto\"\"\"\n\n\nConcatenar\n+\npaste0(a, b)\n*\n\n\nRepetir\n* n\nstrrep(str, n)\n^ n\n\n\nLongitud\nlen(str)\nnchar(str)\nlength(str)\n\n\nInterpolación\nf\"Texto {var}\"\nsprintf(\"Texto %s\", var)\n\"Texto $var\"",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Función j_eval y j_plot en R</span>"
    ]
  },
  {
    "objectID": "07-operaciones_cadenas.html#métodos-de-limpieza-y-transformación",
    "href": "07-operaciones_cadenas.html#métodos-de-limpieza-y-transformación",
    "title": "7  Operaciones con Cadenas de Texto (Strings)",
    "section": "7.5 2. Métodos de Limpieza y Transformación",
    "text": "7.5 2. Métodos de Limpieza y Transformación\nLos datos de entidades como el DANE o el IGAC a veces vienen con errores de digitación o espacios accidentales. Veamos cómo limpiar un topónimo colombiano.\n\nPythonRJulia\n\n\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\ntoponimo = \"   sAnTuaRio de fAuna Y flora iGuaQue   \"\n\n# 1. Quitar espacios laterales\ntexto_limpio = toponimo.strip()\n\n# 2. Formato Título\ntexto_titulo = texto_limpio.title()\n\n# 3. Reemplazo de caracteres (Corregir la 'y')\nregistro_final = texto_titulo.replace(\" Y \", \" y \")\n\nprint(f\"Original: '{toponimo}'\")\nprint(f\"Mayúsculas: '{registro_final.upper()}'\")\nprint(f\"Limpio:   '{registro_final}'\")\n\n\n\n\n\ntoponimo = \"   sAnTuaRio de fAuna Y flora iGuaQue   \"\n\n# 1. Quitar espacios laterales\ntexto_limpio = toponimo.strip()\n\n# 2. Formato Título\ntexto_titulo = texto_limpio.title()\n\n# 3. Reemplazo de caracteres (Corregir la 'y')\nregistro_final = texto_titulo.replace(\" Y \", \" y \")\n\nprint(f\"Original: '{toponimo}'\")\n\nOriginal: '   sAnTuaRio de fAuna Y flora iGuaQue   '\n\nprint(f\"Mayúsculas: '{registro_final.upper()}'\")\n\nMayúsculas: 'SANTUARIO DE FAUNA Y FLORA IGUAQUE'\n\nprint(f\"Limpio:   '{registro_final}'\")\n\nLimpio:   'Santuario De Fauna y Flora Iguaque'\n\n\n\n\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\ntoponimo &lt;- \"   sAnTuaRio de fAuna Y flora iGuaQue   \"\n\n# 1. Quitar espacios\ntexto_limpio &lt;- trimws(toponimo)\n\n# 2. Formato Título (Requiere pasar a minúscula primero)\ntexto_titulo &lt;- tools::toTitleCase(tolower(texto_limpio))\n\n# 3. Reemplazo de caracteres\nregistro_final &lt;- gsub(\" Y \", \" y \", texto_titulo)\n\ncat(sprintf(\"Original: '%s'\\n\", toponimo))\ncat(sprintf(\"Mayúsculas: '%s'\\n\", toupper(registro_final)))\ncat(sprintf(\"Limpio:   '%s'\\n\", registro_final))\n\n\n\n\n\ntoponimo &lt;- \"   sAnTuaRio de fAuna Y flora iGuaQue   \"\n\n# 1. Quitar espacios\ntexto_limpio &lt;- trimws(toponimo)\n\n# 2. Formato Título (Requiere pasar a minúscula primero)\ntexto_titulo &lt;- tools::toTitleCase(tolower(texto_limpio))\n\n# 3. Reemplazo de caracteres\nregistro_final &lt;- gsub(\" Y \", \" y \", texto_titulo)\n\ncat(sprintf(\"Original: '%s'\\n\", toponimo))\n\nOriginal: '   sAnTuaRio de fAuna Y flora iGuaQue   '\n\ncat(sprintf(\"Mayúsculas: '%s'\\n\", toupper(registro_final)))\n\nMayúsculas: 'SANTUARIO DE FAUNA Y FLORA IGUAQUE'\n\ncat(sprintf(\"Limpio:   '%s'\\n\", registro_final))\n\nLimpio:   'Santuario De Fauna y Flora Iguaque'\n\n\n\n\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\ntoponimo = \"   sAnTuaRio de fAuna Y flora iGuaQue   \"\n\n# 1. Quitar espacios\ntexto_limpio = strip(toponimo)\n\n# 2. Formato Título\ntexto_titulo = titlecase(texto_limpio)\n\n# 3. Reemplazo de caracteres\nregistro_final = replace(texto_titulo, \" Y \" =&gt; \" y \")\n\nprintln(\"Original: '$toponimo'\")\nprintln(\"Mayúsculas: '$(uppercase(registro_final))'\")\nprintln(\"Limpio:   '$registro_final'\")\n\n\n\n\nj_eval(r\"-(\ntoponimo = \"   sAnTuaRio de fAuna Y flora iGuaQue   \"\n\n# 1. Quitar espacios\ntexto_limpio = strip(toponimo)\n\n# 2. Formato Título\ntexto_titulo = titlecase(texto_limpio)\n\n# 3. Reemplazo de caracteres\nregistro_final = replace(texto_titulo, \" Y \" =&gt; \" y \")\n\nprintln(\"Original: '$toponimo'\")\nprintln(\"Mayúsculas: '$(uppercase(registro_final))'\")\nprintln(\"Limpio:   '$registro_final'\")\n)-\")\njulia&gt; toponimo = \"   sAnTuaRio de fAuna Y flora iGuaQue   \"\n\n\"   sAnTuaRio de fAuna Y flora iGuaQue   \"\n\n\njulia&gt; # 1. Quitar espacios\n\n\njulia&gt; texto_limpio = strip(toponimo)\n\n\"sAnTuaRio de fAuna Y flora iGuaQue\"\n\n\njulia&gt; # 2. Formato Título\n\n\njulia&gt; texto_titulo = titlecase(texto_limpio)\n\n\"Santuario De Fauna Y Flora Iguaque\"\n\n\njulia&gt; # 3. Reemplazo de caracteres\n\n\njulia&gt; registro_final = replace(texto_titulo, \" Y \" =&gt; \" y \")\n\n\"Santuario De Fauna y Flora Iguaque\"\n\n\njulia&gt; println(\"Original: '$toponimo'\")\n\nOriginal: '   sAnTuaRio de fAuna Y flora iGuaQue   '\n\n\njulia&gt; println(\"Mayúsculas: '$(uppercase(registro_final))'\")\n\nMayúsculas: 'SANTUARIO DE FAUNA Y FLORA IGUAQUE'\n\n\njulia&gt; println(\"Limpio:   '$registro_final'\")\n\nLimpio:   'Santuario De Fauna y Flora Iguaque'\n\n\n\n\n\nResumen de Sintaxis: Transformaciones\n\n\n\n\n\n\n\n\n\nOperación\nPython\nR\nJulia\n\n\n\n\nMayúsculas\n.upper()\ntoupper()\nuppercase()\n\n\nMinúsculas\n.lower()\ntolower()\nlowercase()\n\n\nFormato Título\n.title()\ntools::toTitleCase()\ntitlecase()\n\n\nQuitar Espacios\n.strip()\ntrimws()\nstrip()\n\n\nReemplazar\n.replace(old, new)\ngsub(old, new, str)\nreplace(str, old=&gt;new)",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Función j_eval y j_plot en R</span>"
    ]
  },
  {
    "objectID": "07-operaciones_cadenas.html#separación-y-unión-split-join",
    "href": "07-operaciones_cadenas.html#separación-y-unión-split-join",
    "title": "7  Operaciones con Cadenas de Texto (Strings)",
    "section": "7.6 3. Separación y Unión (Split & Join)",
    "text": "7.6 3. Separación y Unión (Split & Join)\nEs muy común recibir coordenadas en formato de texto separado por comas, o necesitar armar rutas de archivos uniendo directorios para exportar nuestros Shapefiles.\n\nPythonRJulia\n\n\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\n# Separar coordenadas (Plaza de Bolívar, Bogotá)\ncoord_str = \"4.5981,-74.0758\"\nlat_str, lon_str = coord_str.split(\",\")\n\nprint(f\"Latitud: {float(lat_str)}, Longitud: {float(lon_str)}\")\n\n# Unir elementos de una lista (Ruta de archivo)\ncarpetas = [\"datos\", \"colombia\", \"cundinamarca\", \"bogota.geojson\"]\nruta_completa = \"/\".join(carpetas)\n\nprint(f\"Ruta generada: {ruta_completa}\")\n\n\n\n\n\n# Separar coordenadas (Plaza de Bolívar, Bogotá)\ncoord_str = \"4.5981,-74.0758\"\nlat_str, lon_str = coord_str.split(\",\")\n\nprint(f\"Latitud: {float(lat_str)}, Longitud: {float(lon_str)}\")\n\nLatitud: 4.5981, Longitud: -74.0758\n\n# Unir elementos de una lista (Ruta de archivo)\ncarpetas = [\"datos\", \"colombia\", \"cundinamarca\", \"bogota.geojson\"]\nruta_completa = \"/\".join(carpetas)\n\nprint(f\"Ruta generada: {ruta_completa}\")\n\nRuta generada: datos/colombia/cundinamarca/bogota.geojson\n\n\n\n\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\n# Separar coordenadas\n# TABLA COMPARATIVA DE EXTRACCIÓN EN R:\n# | Método                       | Resultado | Metáfora                      |\n# |------------------------------|-----------|-------------------------------|\n# | strsplit(x, \",\")[1]          | Lista     | La caja con el sobre adentro  |\n# | strsplit(x, \",\")[[1]]        | Vector    | El sobre abierto (Contenido)  |\n# | unlist(strsplit(x, \",\"))     | Vector    | El contenido sin el sobre     |\n\ncoord_str &lt;- \"4.5981,-74.0758\"\n\n# Explicación: strsplit es 'vectorizada' (está lista para procesar miles de textos a la vez).\n# Por eso, siempre devuelve una \"Gran Caja\" (Lista). \n# Para sacar el \"Sobre\" con nuestras coordenadas, usamos [[1]]. \n# Si usaras solo [1], tendrías la caja pero no podrías tocar los números.\npartes &lt;- strsplit(coord_str, \",\")[[1]]\n\n# Alternativa más legible (El 'machete'): unlist()\n# Esta función \"desempaqueta\" automáticamente la lista y nos entrega el vector puro.\npartes_alt &lt;- unlist(strsplit(coord_str, \",\"))\n\ncat(\"Resultado con [[1]]:\", partes[1], \"\\n\")\ncat(\"Resultado con unlist:\", partes_alt[1], \"\\n\")\n\ncat(sprintf(\"Latitud: %f, Longitud: %f\\n\", as.numeric(partes[1]), as.numeric(partes[2])))\n\n# Unir elementos de una lista\ncarpetas &lt;- c(\"datos\", \"colombia\", \"cundinamarca\", \"bogota.geojson\")\nruta_completa &lt;- paste(carpetas, collapse = \"/\")\n\ncat(paste(\"Ruta generada:\", ruta_completa, \"\\n\"))\n\n\n\n\n\n# Separar coordenadas\n# TABLA COMPARATIVA DE EXTRACCIÓN EN R:\n# | Método                       | Resultado | Metáfora                      |\n# |------------------------------|-----------|-------------------------------|\n# | strsplit(x, \",\")[1]          | Lista     | La caja con el sobre adentro  |\n# | strsplit(x, \",\")[[1]]        | Vector    | El sobre abierto (Contenido)  |\n# | unlist(strsplit(x, \",\"))     | Vector    | El contenido sin el sobre     |\n\ncoord_str &lt;- \"4.5981,-74.0758\"\n\n# Explicación: strsplit es 'vectorizada' (está lista para procesar miles de textos a la vez).\n# Por eso, siempre devuelve una \"Gran Caja\" (Lista). \n# Para sacar el \"Sobre\" con nuestras coordenadas, usamos [[1]]. \n# Si usaras solo [1], tendrías la caja pero no podrías tocar los números.\npartes &lt;- strsplit(coord_str, \",\")[[1]]\n\n# Alternativa más legible (El 'machete'): unlist()\n# Esta función \"desempaqueta\" automáticamente la lista y nos entrega el vector puro.\npartes_alt &lt;- unlist(strsplit(coord_str, \",\"))\n\ncat(\"Resultado con [[1]]:\", partes[1], \"\\n\")\n\nResultado con [[1]]: 4.5981 \n\ncat(\"Resultado con unlist:\", partes_alt[1], \"\\n\")\n\nResultado con unlist: 4.5981 \n\ncat(sprintf(\"Latitud: %f, Longitud: %f\\n\", as.numeric(partes[1]), as.numeric(partes[2])))\n\nLatitud: 4.598100, Longitud: -74.075800\n\n# Unir elementos de una lista\ncarpetas &lt;- c(\"datos\", \"colombia\", \"cundinamarca\", \"bogota.geojson\")\nruta_completa &lt;- paste(carpetas, collapse = \"/\")\n\ncat(paste(\"Ruta generada:\", ruta_completa, \"\\n\"))\n\nRuta generada: datos/colombia/cundinamarca/bogota.geojson \n\n\n\n\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\n# Separar coordenadas\ncoord_str = \"4.5981,-74.0758\"\nlat_str, lon_str = split(coord_str, \",\")\n\nprintln(\"Latitud: $(parse(Float64, lat_str)), Longitud: $(parse(Float64, lon_str))\")\n\n# Unir elementos de una lista\ncarpetas = [\"datos\", \"colombia\", \"cundinamarca\", \"bogota.geojson\"]\nruta_completa = join(carpetas, \"/\")\n\nprintln(\"Ruta generada: $ruta_completa\")\n\n\n\n\nj_eval(r\"-(\n# Separar coordenadas\ncoord_str = \"4.5981,-74.0758\"\nlat_str, lon_str = split(coord_str, \",\")\n\nprintln(\"Latitud: $(parse(Float64, lat_str)), Longitud: $(parse(Float64, lon_str))\")\n\n# Unir elementos de una lista\ncarpetas = [\"datos\", \"colombia\", \"cundinamarca\", \"bogota.geojson\"]\nruta_completa = join(carpetas, \"/\")\n\nprintln(\"Ruta generada: $ruta_completa\")\n)-\")\njulia&gt; # Separar coordenadas\n\n\njulia&gt; coord_str = \"4.5981,-74.0758\"\n\n\"4.5981,-74.0758\"\n\n\njulia&gt; lat_str, lon_str = split(coord_str, \",\")\n\n2-element Vector{SubString{String}}:\n \"4.5981\"\n \"-74.0758\"\n\n\njulia&gt; println(\"Latitud: $(parse(Float64, lat_str)), Longitud: $(parse(Float64, lon_str))\")\n\nLatitud: 4.5981, Longitud: -74.0758\n\n\njulia&gt; # Unir elementos de una lista\n\n\njulia&gt; carpetas = [\"datos\", \"colombia\", \"cundinamarca\", \"bogota.geojson\"]\n\n4-element Vector{String}:\n \"datos\"\n \"colombia\"\n \"cundinamarca\"\n \"bogota.geojson\"\n\n\njulia&gt; ruta_completa = join(carpetas, \"/\")\n\n\"datos/colombia/cundinamarca/bogota.geojson\"\n\n\njulia&gt; println(\"Ruta generada: $ruta_completa\")\n\nRuta generada: datos/colombia/cundinamarca/bogota.geojson\n\n\n\n\n\nResumen de Sintaxis: Split y Join\n\n\n\n\n\n\n\n\n\nOperación\nPython\nR\nJulia\n\n\n\n\nSeparar (Split)\nstr.split(\",\")\nstrsplit(str, \",\")[[1]] o unlist(strsplit(str, \",\"))\nsplit(str, \",\")\n\n\nUnir (Join)\n\"/\".join(array)\npaste(arr, collapse=\"/\")\njoin(array, \"/\")\n\n\nTexto a Decimal (Float)\nfloat(cadena)\nas.numeric(cadena)\nparse(Float64, cadena)",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Función j_eval y j_plot en R</span>"
    ]
  },
  {
    "objectID": "07-operaciones_cadenas.html#formateo-de-precisión-wkt-y-sql",
    "href": "07-operaciones_cadenas.html#formateo-de-precisión-wkt-y-sql",
    "title": "7  Operaciones con Cadenas de Texto (Strings)",
    "section": "7.7 4. Formateo de Precisión (WKT y SQL)",
    "text": "7.7 4. Formateo de Precisión (WKT y SQL)\nConstruir geometrías en formato de texto (Well-Known Text) o consultas a bases de datos espaciales requiere un control preciso de la interpolación y los decimales.\n\nPythonRJulia\n\n\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\n# 1. Definición de variables (Medellín, Antioquia)\nlat, lon = 6.244203, -75.581211\nciudad = \"Medellín\"\npoblacion = 2529000\npoblacion_min = 1000000\n\n# 2. WKT con precisión decimal (.4f)\nwkt_point = f\"POINT({lon:.4f} {lat:.4f})\"\n\n# 3. Reporte con separador de miles (:,)\nreporte = f\"Población de {ciudad}: {poblacion:,} hab.\"\n\nprint(f\"Geometría: {wkt_point}\")\nprint(reporte)\n\n# 4. Consulta SQL Dinámica (Multilínea)\nsql_query = f\"\"\"\nSELECT geom, nombre FROM municipios \nWHERE depto = 'Antioquia' AND poblacion &gt; {poblacion_min:,}\n\"\"\"\nprint(\"Consulta SQL:\")\nprint(sql_query)\n\n\n\n\n\n# 1. Definición de variables (Medellín, Antioquia)\nlat, lon = 6.244203, -75.581211\nciudad = \"Medellín\"\npoblacion = 2529000\npoblacion_min = 1000000\n\n# 2. WKT con precisión decimal (.4f)\nwkt_point = f\"POINT({lon:.4f} {lat:.4f})\"\n\n# 3. Reporte con separador de miles (:,)\nreporte = f\"Población de {ciudad}: {poblacion:,} hab.\"\n\nprint(f\"Geometría: {wkt_point}\")\n\nGeometría: POINT(-75.5812 6.2442)\n\nprint(reporte)\n\nPoblación de Medellín: 2,529,000 hab.\n\n# 4. Consulta SQL Dinámica (Multilínea)\nsql_query = f\"\"\"\nSELECT geom, nombre FROM municipios \nWHERE depto = 'Antioquia' AND poblacion &gt; {poblacion_min:,}\n\"\"\"\nprint(\"Consulta SQL:\")\n\nConsulta SQL:\n\nprint(sql_query)\n\n\nSELECT geom, nombre FROM municipios \nWHERE depto = 'Antioquia' AND poblacion &gt; 1,000,000\n\n\n\n\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\n# 1. Definición de variables (Medellín, Antioquia)\nlat &lt;- 6.244203\nlon &lt;- -75.581211\nciudad &lt;- \"Medellín\"\npoblacion &lt;- 2529000\npoblacion_min &lt;- 1000000\n\n# 2. WKT con precisión decimal (%.4f)\nwkt_point &lt;- sprintf(\"POINT(%.4f %.4f)\", lon, lat)\n\n# 3. Reporte con separador de miles (big.mark)\npoblacion_fmt &lt;- format(poblacion, big.mark=\",\")\nreporte &lt;- sprintf(\"Población de %s: %s hab.\", ciudad, poblacion_fmt)\n\ncat(\"Geometría:\", wkt_point, \"\\n\")\ncat(reporte, \"\\n\")\n\n# 4. Consulta SQL Dinámica (sprintf para multilínea)\nsql_query &lt;- sprintf(\"\nSELECT geom, nombre FROM municipios \nWHERE depto = 'Antioquia' AND poblacion &gt; %s\n\", format(poblacion_min, big.mark=\",\", scientific = FALSE))\n\ncat(\"Consulta SQL:\\n\")\ncat(sql_query)\n\n\n\n\n\n# 1. Definición de variables (Medellín, Antioquia)\nlat &lt;- 6.244203\nlon &lt;- -75.581211\nciudad &lt;- \"Medellín\"\npoblacion &lt;- 2529000\npoblacion_min &lt;- 1000000\n\n# 2. WKT con precisión decimal (%.4f)\nwkt_point &lt;- sprintf(\"POINT(%.4f %.4f)\", lon, lat)\n\n# 3. Reporte con separador de miles (big.mark)\npoblacion_fmt &lt;- format(poblacion, big.mark=\",\")\nreporte &lt;- sprintf(\"Población de %s: %s hab.\", ciudad, poblacion_fmt)\n\ncat(\"Geometría:\", wkt_point, \"\\n\")\n\nGeometría: POINT(-75.5812 6.2442) \n\ncat(reporte, \"\\n\")\n\nPoblación de Medellín: 2,529,000 hab. \n\n# 4. Consulta SQL Dinámica (sprintf para multilínea)\nsql_query &lt;- sprintf(\"\nSELECT geom, nombre FROM municipios \nWHERE depto = 'Antioquia' AND poblacion &gt; %s\n\", format(poblacion_min, big.mark=\",\", scientific = FALSE))\n\ncat(\"Consulta SQL:\\n\")\n\nConsulta SQL:\n\ncat(sql_query)\n\n\nSELECT geom, nombre FROM municipios \nWHERE depto = 'Antioquia' AND poblacion &gt; 1,000,000\n\n\n\n\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\nusing Printf\n\n# 1. Definición de variables (Medellín, Antioquia)\nlat, lon = 6.244203, -75.581211\nciudad = \"Medellín\"\npoblacion = 2529000\npoblacion_min = 1000000\n\n# 2. WKT con precisión decimal (@sprintf)\nwkt_point = @sprintf(\"POINT(%.4f %.4f)\", lon, lat)\n\n# 3. Reporte con separador de miles (Regex)\npoblacion_coma = replace(string(poblacion), r\"(?&lt;=\\d)(?=(\\d{3})+(?!\\d))\" =&gt; \",\")\nprintln(\"Geometría: $wkt_point\")\nprintln(\"Población de $ciudad: $poblacion_coma hab.\")\n\n# 4. Consulta SQL Dinámica (Triples comillas)\npoblacion_min_coma = replace(string(poblacion_min), r\"(?&lt;=\\d)(?=(\\d{3})+(?!\\d))\" =&gt; \",\")\nsql_query = \"\"\"\nSELECT geom, nombre FROM municipios \nWHERE depto = 'Antioquia' AND poblacion &gt; $poblacion_min_coma\n\"\"\"\nprintln(\"Consulta SQL:\")\nprintln(sql_query)\n\n\n\n\nj_eval(r\"-(\nusing Printf\n\n# 1. Definición de variables (Medellín, Antioquia)\nlat, lon = 6.244203, -75.581211\nciudad = \"Medellín\"\npoblacion = 2529000\npoblacion_min = 1000000\n\n# 2. WKT con precisión decimal (@sprintf)\nwkt_point = @sprintf(\"POINT(%.4f %.4f)\", lon, lat)\n\n# 3. Reporte con separador de miles (Regex)\npoblacion_coma = replace(string(poblacion), r\"(?&lt;=\\d)(?=(\\d{3})+(?!\\d))\" =&gt; \",\")\nprintln(\"Geometría: $wkt_point\")\nprintln(\"Población de $ciudad: $poblacion_coma hab.\")\n\n# 4. Consulta SQL Dinámica (Triples comillas)\npoblacion_min_coma = replace(string(poblacion_min), r\"(?&lt;=\\d)(?=(\\d{3})+(?!\\d))\" =&gt; \",\")\nsql_query = \"\"\"\nSELECT geom, nombre FROM municipios \nWHERE depto = 'Antioquia' AND poblacion &gt; $poblacion_min_coma\n\"\"\"\nprintln(\"Consulta SQL:\")\nprintln(sql_query)\n)-\")\njulia&gt; using Printf\n\n\njulia&gt; # 1. Definición de variables (Medellín, Antioquia)\n\n\njulia&gt; lat, lon = 6.244203, -75.581211\n\n(6.244203, -75.581211)\n\n\njulia&gt; ciudad = \"Medellín\"\n\n\"Medellín\"\n\n\njulia&gt; poblacion = 2529000\n\n2529000\n\n\njulia&gt; poblacion_min = 1000000\n\n1000000\n\n\njulia&gt; # 2. WKT con precisión decimal (@sprintf)\n\n\njulia&gt; wkt_point = @sprintf(\"POINT(%.4f %.4f)\", lon, lat)\n\n\"POINT(-75.5812 6.2442)\"\n\n\njulia&gt; # 3. Reporte con separador de miles (Regex)\n\n\njulia&gt; poblacion_coma = replace(string(poblacion), r\"(?&lt;=\\d)(?=(\\d{3})+(?!\\d))\" =&gt; \",\")\n\n\"2,529,000\"\n\n\njulia&gt; println(\"Geometría: $wkt_point\")\n\nGeometría: POINT(-75.5812 6.2442)\n\n\njulia&gt; println(\"Población de $ciudad: $poblacion_coma hab.\")\n\nPoblación de Medellín: 2,529,000 hab.\n\n\njulia&gt; # 4. Consulta SQL Dinámica (Triples comillas)\n\n\njulia&gt; poblacion_min_coma = replace(string(poblacion_min), r\"(?&lt;=\\d)(?=(\\d{3})+(?!\\d))\" =&gt; \",\")\n\n\"1,000,000\"\n\n\njulia&gt; sql_query = \"\"\"\n       SELECT geom, nombre FROM municipios \n       WHERE depto = 'Antioquia' AND poblacion &gt; $poblacion_min_coma\n       \"\"\"\n\n\"SELECT geom, nombre FROM municipios \\nWHERE depto = 'Antioquia' AND poblacion &gt; 1,000,000\\n\"\n\n\njulia&gt; println(\"Consulta SQL:\")\n\nConsulta SQL:\n\n\njulia&gt; println(sql_query)\n\nSELECT geom, nombre FROM municipios \nWHERE depto = 'Antioquia' AND poblacion &gt; 1,000,000\n\n\n\n\n\n\n\nExplicación técnica: El “Radar” de Miles en Julia\nA diferencia de Python, Julia no tiene un flag nativo (como el :,) para formatear miles automáticamente en el macro @sprintf. Por ello, utilizamos una Expresión Regular (Regex) que actúa como un “radar” de posiciones:\n\n(?&lt;=\\d) (Lookbehind): Le dice al motor: “asegúrate de que haya un número justo antes de esta posición”.\n(?=(\\d{3})+(?!\\d)) (Lookahead): Le dice: “busca grupos de exactamente tres dígitos hacia adelante que lleguen hasta el final del texto (o antes de un punto decimal)”.\n\nLo interesante es que este Regex tiene un ancho de cero; no captura caracteres, sino que localiza el espacio vacío exacto donde debe “inyectarse” el separador.\n\nJulia (Explicación Regex)\n\n\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\n# Ejemplo con la población estimada de la sabana de Bogotá\npoblacion = 10700000\n\n# Usamos replace con el radar de posiciones (Regex)\n# El símbolo =&gt; indica el reemplazo en el hueco hallado\npoblacion_fmt = replace(string(poblacion), r\"(?&lt;=\\d)(?=(\\d{3})+(?!\\d))\" =&gt; \",\")\n\nprintln(\"Población formateada: $poblacion_fmt\")\n\n\n\n\nj_eval(r\"-(\n# Ejemplo con la población estimada de la sabana de Bogotá\npoblacion = 10700000\n\n# Usamos replace con el radar de posiciones (Regex)\n# El símbolo =&gt; indica el reemplazo en el hueco hallado\npoblacion_fmt = replace(string(poblacion), r\"(?&lt;=\\d)(?=(\\d{3})+(?!\\d))\" =&gt; \",\")\n\nprintln(\"Población formateada: $poblacion_fmt\")\n)-\")\njulia&gt; # Ejemplo con la población estimada de la sabana de Bogotá\n\n\njulia&gt; poblacion = 10700000\n\n10700000\n\n\njulia&gt; # Usamos replace con el radar de posiciones (Regex)\n\n\njulia&gt; # El símbolo =&gt; indica el reemplazo en el hueco hallado\n\n\njulia&gt; poblacion_fmt = replace(string(poblacion), r\"(?&lt;=\\d)(?=(\\d{3})+(?!\\d))\" =&gt; \",\")\n\n\"10,700,000\"\n\n\njulia&gt; println(\"Población formateada: $poblacion_fmt\")\n\nPoblación formateada: 10,700,000\n\n\n\n\n\nResumen de Sintaxis: Formateo de Precisión y Consultas\n\n\n\n\n\n\n\n\n\nOperación\nPython\nR\nJulia\n\n\n\n\nInterpolación Básica\nf\"Texto {var}\"\nsprintf(\"Texto %s\", var)\n\"Texto $var\"\n\n\nControl Decimal (ej. 4)\nf\"{lon:.4f}\"\nsprintf(\"%.4f\", lon)\n@sprintf(\"%.4f\", lon)\n\n\nSeparador de Miles1\nf\"{var:,}\"\nformat(var, big.mark=\",\", scientific = FALSE)\nreplace(string(v), r\"...\" =&gt; \",\")\n\n\nConsulta SQL / Multilínea\nf\"\"\" ... {var} ... \"\"\"\nsprintf(\"\\n ... %s \\n\", var)\n\"\"\" ... $var ... \"\"\"",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Función j_eval y j_plot en R</span>"
    ]
  },
  {
    "objectID": "07-operaciones_cadenas.html#resumen-de-aprendizajes-cheat-sheet",
    "href": "07-operaciones_cadenas.html#resumen-de-aprendizajes-cheat-sheet",
    "title": "7  Operaciones con Cadenas de Texto (Strings)",
    "section": "7.8 Resumen de Aprendizajes (Cheat Sheet)",
    "text": "7.8 Resumen de Aprendizajes (Cheat Sheet)\nEn este capítulo hemos explorado cómo limpiar, transformar, dividir y dar formato de precisión a los datos de texto (Strings), habilidades esenciales para procesar topónimos, coordenadas crudas y construir consultas espaciales. A continuación, se presenta tu Hoja de Referencia (Cheat Sheet) para traducir estos conceptos entre Python, R y Julia.\n\n1. Creación y Propiedades Fundamentales\n\n\n\nTabla 7.1: Sintaxis básica para creación y medición de cadenas\n\n\n\n\n\n\n\n\n\n\n\nOperación\nPython\nR\nJulia\n\n\n\n\nDefinir String\n\"Col\", 'Col'\n\"Col\", 'Col'\n\"Col\" (Solo dobles)\n\n\nMultilínea\n\"\"\"Texto\"\"\"\n\"Texto\\nTexto\"\n\"\"\"Texto\"\"\"\n\n\nConcatenar\n+\npaste0(a, b)\n*\n\n\nRepetir\n* n\nstrrep(str, n)\n^ n\n\n\nLongitud\nlen(str)\nnchar(str)\nlength(str)\n\n\nInterpolación\nf\"Texto {var}\"\nsprintf(\"Texto %s\", var)\n\"Texto $var\"\n\n\n\n\n\n\n\n\n2. Transformaciones y Limpieza\n\n\n\nTabla 7.2: Métodos nativos para estandarización de texto\n\n\n\n\n\n\n\n\n\n\n\nOperación\nPython\nR\nJulia\n\n\n\n\nMayúsculas\n.upper()\ntoupper()\nuppercase()\n\n\nMinúsculas\n.lower()\ntolower()\nlowercase()\n\n\nFormato Título\n.title()\ntools::toTitleCase()\ntitlecase()\n\n\nQuitar Espacios\n.strip()\ntrimws()\nstrip()\n\n\nReemplazar\n.replace(old, new)\ngsub(old, new, str)\nreplace(str, old=&gt;new)\n\n\n\n\n\n\n\n\n3. Split, Join y Formateo de Precisión\n\n\n\nTabla 7.3: Funciones críticas para parseo de coordenadas y WKT\n\n\n\n\n\n\n\n\n\n\n\nOperación\nPython\nR\nJulia\n\n\n\n\nSeparar (Split)\nstr.split(\",\")\nunlist(strsplit(str, \",\"))\nsplit(str, \",\")\n\n\nUnir (Join)\n\"/\".join(array)\npaste(arr, collapse=\"/\")\njoin(array, \"/\")\n\n\nTexto a Decimal\nfloat(cadena)\nas.numeric(cadena)\nparse(Float64, cadena)\n\n\nControl Decimal\nf\"{lon:.4f}\"\nsprintf(\"%.4f\", lon)\n@sprintf(\"%.4f\", lon)\n\n\nSeparador Miles\nf\"{v:,}\"\nformat(v, big.mark=\",\", scientific=F)\nreplace(string(v), r\"...\" =&gt; \",\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nConclusiones Críticas del Módulo\n\n\n\n\nLa trampa del Split en R: A diferencia de Python y Julia (que devuelven arreglos simples), la función strsplit() en R siempre devuelve una Lista. Si intentas aplicar cálculos matemáticos directamente al resultado de un strsplit sin desempaquetarlo antes (usando [[1]] o unlist()), R arrojará un error.\nCuidado con la Notación Científica: Al formatear grandes números (como poblaciones o áreas en metros cuadrados), R y Julia pueden saltar a notación científica (ej. 1e+06). En geomática, esto rompe las consultas SQL y las etiquetas de los mapas. Acostúmbrate a forzar la salida decimal (ej. scientific = FALSE en R).\nEl poder de la Interpolación: Construir geometrías WKT o sentencias SQL concatenando pedazos de texto con el símbolo + o * es propenso a errores de espacios y comillas. Usa siempre las herramientas de interpolación literal (f-strings en Python, sprintf en R, y $ en Julia) para mantener tu código legible y seguro.",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Función j_eval y j_plot en R</span>"
    ]
  },
  {
    "objectID": "07-operaciones_cadenas.html#ejercicios",
    "href": "07-operaciones_cadenas.html#ejercicios",
    "title": "7  Operaciones con Cadenas de Texto (Strings)",
    "section": "7.9 Ejercicios",
    "text": "7.9 Ejercicios\nPara poner en práctica los conceptos aprendidos sobre manipulación de cadenas de texto, deberás resolver los siguientes dos ejercicios. Puedes elegir resolverlos en Python, R o Julia (o implementar la solución en varios lenguajes si deseas retarte).\n\nEjercicio 1: Limpieza de Topónimos (PNN Macarena)\nContexto: Has recibido una base de datos antigua del IGAC con los nombres de las áreas protegidas de Colombia. Los datos fueron ingresados manualmente a lo largo de los años, por lo que tienen serios problemas de formato (espacios extra, mayúsculas inconsistentes y errores de digitación). Necesitas estandarizar el nombre del Parque Nacional Natural Serranía de la Macarena para cruzarlo con el sistema actual.\nInstrucciones de código:\n\nDefine una variable llamada registro_crudo que contenga exactamente este texto: \"   pnn  seRRania de la mACaRena   \"\nUtiliza el método nativo de tu lenguaje para eliminar los espacios en blanco al principio y al final del texto. Guarda el resultado en texto_sin_espacios.\nConvierte el texto resultante a Formato Título (donde la primera letra de cada palabra es mayúscula) y guárdalo en texto_titulo.\nEl sistema oficial requiere que las siglas “PNN” estén en mayúscula sostenida. Utiliza la función de reemplazo para cambiar la subcadena “Pnn” por “PNN” dentro de tu texto_titulo. Guarda esto como registro_oficial.\nCalcula la longitud (cantidad de caracteres) de tu registro_oficial.\nImprime un reporte final utilizando interpolación de cadenas que diga exactamente: \"El área protegida limpia es: [AQUI_TU_VARIABLE] y su nombre tiene [AQUI_LONGITUD] caracteres.\"\n\n\n\nEjercicio 2: Parseo de Coordenadas y WKT (Volcán Galeras)\nContexto: Un sensor sísmico ubicado en el Volcán Galeras (Nariño) envía las alertas a través de mensajes de texto planos. Tu objetivo es extraer las coordenadas de ese mensaje de texto, convertirlas a formato numérico, y ensamblar un punto espacial estándar (Well-Known Text) para insertarlo en la base de datos PostGIS del Servicio Geológico.\nInstrucciones de código:\n\nDefine la variable mensaje_sensor con el siguiente texto: \"ALERTA_SISMICA:1.221,-77.359:PROFUNDIDAD_5KM\"\nUtiliza la función de separación (Split) usando los dos puntos (:) como delimitador. Extrae únicamente el bloque central que contiene las coordenadas y guárdalo en la variable bloque_coords.\nVuelve a aplicar la función de separación (Split), esta vez sobre bloque_coords, usando la coma (,) como delimitador para separar la latitud de la longitud.\nLas coordenadas extraídas siguen siendo texto. Conviértelas a formato numérico decimal (Float) y guárdalas en las variables latitud y longitud.\nLa base de datos requiere una precisión estricta. Utilizando las herramientas de formateo de tu lenguaje, construye una cadena de texto en formato WKT (POINT(lon lat)) asegurando que tanto la latitud como la longitud tengan exactamente 4 decimales. Guarda esto en punto_wkt. (Nota: Recuerda que WKT usa el orden Longitud Latitud, separados por un espacio, no por coma).\nEl sensor reportó una anomalía térmica que afectó un área de 1250000 metros cuadrados. Formatea este número agregando un separador de miles (coma o punto) para que sea legible en el reporte final.\nImprime el WKT generado y el área afectada formateada.\n\n\n\nEntregables y Criterios de Evaluación\nEl objetivo de esta evaluación no es solo que el código funcione, sino que seas capaz de documentar y explicar tus decisiones técnicas.\n1. Archivos de Código: Debes desarrollar los algoritmos en al menos uno de los siguientes formatos de archivo:\n\nScript tradicional (.py, .R, .jl)\nNotebook interactivo (.ipynb)\nDocumento computacional (.qmd con chunks de código)\n\n2. Documento Analítico (Quarto): Independientemente del formato de tu código fuente, debes redactar un documento en Quarto (.qmd) y renderizarlo tanto en HTML como en PDF. En este documento debes incluir tus bloques de código y responder argumentativamente a las siguientes preguntas:\n\nSobre el Ejercicio 1: ¿Por qué es una mala práctica depender únicamente de la función “Reemplazar” (.replace() / gsub()) para quitar espacios accidentales al inicio o final de un texto en bases de datos geográficas grandes, en lugar de usar funciones dedicadas como strip() o trimws()?\nSobre el Ejercicio 2: En la creación de la geometría WKT, si omitieras el paso de convertir el texto extraído a número decimal (Float) y construyeras el WKT directamente concatenando los textos originales, ¿qué impacto tendría esto al intentar realizar un cálculo de distancia espacial dentro de PostGIS o QGIS posteriormente?\nPregunta General (Split en R): Si decidiste resolver el Ejercicio 2 usando R, explica por qué fue necesario utilizar unlist() o los dobles corchetes [[1]] después de ejecutar la función strsplit. Si usaste Python o Julia, explica cómo se diferencia la salida de la función split en tu lenguaje respecto a R.\n\n3. Repositorio en GitHub: Sube tu carpeta del proyecto (que debe contener tus scripts, el archivo .qmd y los renders finales en HTML y PDF) a un repositorio público en tu cuenta personal de GitHub.\n\nEntrega: Deberás enviar únicamente el enlace (URL) a tu repositorio de GitHub para la calificación.",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Función j_eval y j_plot en R</span>"
    ]
  },
  {
    "objectID": "07-operaciones_cadenas.html#footnotes",
    "href": "07-operaciones_cadenas.html#footnotes",
    "title": "7  Operaciones con Cadenas de Texto (Strings)",
    "section": "",
    "text": "En Colombia, el estándar suele preferir el punto (.) como separador de miles. Para aplicarlo, simplemente cambie el carácter de reemplazo en cada función: f\"{var:,}\", format(var, big.mark=\",\", scientific = FALSE), replace(string(v), r\"...\" =&gt; \",\").↩︎",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Función j_eval y j_plot en R</span>"
    ]
  },
  {
    "objectID": "12-introduccion_python_r_julia.html",
    "href": "12-introduccion_python_r_julia.html",
    "title": "8  Introducción a Python, R y Julia",
    "section": "",
    "text": "9 Introducción a Python, R y Julia",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Introducción a Python, R y Julia</span>"
    ]
  },
  {
    "objectID": "12-introduccion_python_r_julia.html#introducción",
    "href": "12-introduccion_python_r_julia.html#introducción",
    "title": "8  Introducción a Python, R y Julia",
    "section": "9.1 Introducción",
    "text": "9.1 Introducción\nEste capítulo presenta una introducción práctica y comparativa a los lenguajes Python, R y Julia, enfocada en el uso de comandos básicos y en la lectura e interpretación de resultados en consola. El objetivo no es profundizar en programación avanzada, sino ofrecer una puerta de entrada común para estudiantes que se inician en el uso de herramientas computacionales para geocomputación.\n\nEjecución de código en cada lenguaje\n\nPython y R se ejecutan de forma nativa mediante code chunks estándar.\nJulia, en este curso, no se ejecuta directamente. Todo el código Julia se evalúa desde R utilizando funciones auxiliares:\n\nj_eval() para ejecutar instrucciones generales\nj_plot() para generar gráficos\n\n\nPor esta razón, en el documento encontrarás dos tipos de bloques relacionados con Julia: - Bloques con código Julia puro, que sirven como referencia y pueden copiarse y reutilizarse. - Bloques en R que llaman a j_eval() o j_plot(), que son los que realmente ejecutan el código.\n\n\nSobre los bloques de código\n\nTodos los bloques de código tienen un label, lo que permite su correcta identificación y reutilización.\nAlgunos bloques están pensados exclusivamente para HTML y no se ejecutan. Su función es permitir que el estudiante copie y pegue el código directamente en su entorno de trabajo.\nCuando un bloque no se ejecuta, esto se indica explícitamente en sus opciones.\n\n\n\nAlcance del capítulo\nEn este capítulo aprenderás a: - Acceder a la ayuda y documentación básica en cada lenguaje - Ejecutar comandos simples y entender su salida - Reconocer tipos de objetos y estructuras básicas - Comparar cómo Python, R y Julia resuelven tareas similares\nEste contenido servirá como base para los capítulos posteriores, donde se utilizarán estos lenguajes para la creación de mapas, análisis de datos espaciales y visualización geográfica.",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Introducción a Python, R y Julia</span>"
    ]
  },
  {
    "objectID": "12-introduccion_python_r_julia.html#función-j_eval-y-j_plot-en-r",
    "href": "12-introduccion_python_r_julia.html#función-j_eval-y-j_plot-en-r",
    "title": "8  Introducción a Python, R y Julia",
    "section": "9.2 Función j_eval y j_plot en R",
    "text": "9.2 Función j_eval y j_plot en R\nUsada para ejecutar código Julia en R. j_eval ejecuta comandos que no tengan salidas gráficas, y j_plot es necesaria cuándo el código Julia produce salidas gráficas.\n\nCódigo\n# #| include: false\nsource(\"./docs/j_eval_j_plot.r\")\n\n\nFlujo de ejecución de texto con j_eval\nPara entender por qué los resultados aparecen con colores y cómo se gestionan los bloques de código, observe el siguiente flujo de ejecución de la función j_eval:\nfig-flujo-jeval\n\n\n\n\n\n\nFigura 9.1\n\n\n\n\n\n\n\n\n\nNota\n\n\n\nComo se ilustra en la Figura 9.1, la función no solo “pasa” el texto, sino que actúa como un supervisor que espera a que los bloques de programación estén completos antes de despertar al motor de Julia. Esto garantiza la estabilidad del sistema.\n\n\n\n\nFlujo de generación gráfica con j_plot\nA diferencia de la ejecución de texto, j_plot requiere una coordinación adicional para gestionar archivos físicos. Observe el proceso:\n\n\n\n\n\n\nFigura 9.2\n\n\n\n\n\n\n\n\n\nEl rol del disco duro\n\n\n\nComo muestra la Figura 9.2, el secreto de j_plot es que utiliza un archivo temporal como “puente” visual. Por eso, si usted tiene el archivo tmp_plot.png abierto en otro programa, j_plot podría fallar al intentar sobrescribirlo.\n\n\n\n\nInterpretación de errores y consola\nAl trabajar con la interoperabilidad entre lenguajes (usando las funciones j_eval y j_plot definidas arriba, la consola de VSCode nos devolverá mensajes que debemos aprender a interpretar.\n\nEl error de conexión TCP\nSi al usar Julia recibe un mensaje de error que menciona TCP connection, usualmente significa que el motor de Julia se ha cerrado o ha entrado en conflicto de memoria. * Solución: Ejecute .ensure_julia_ready() en su consola de R para reiniciar el puente de comunicación.\n\n\nInterpretación del Stacktrace en Julia\nCuando Julia detecta un error, genera un rastro de llamadas o Stacktrace. No intente leer cada línea; busque siempre la primera (que define el tipo de error) y la última línea de código escrita por usted.\n# Ejemplo de error por índice fuera de rango\nERROR: BoundsError: attempt to access 5-element Vector{Int64} at index [6]\n\n\nResaltado de sintaxis en la salida\nGracias a la configuración de results: asis en los bloques de código, la salida de nuestras funciones aparecerá con el prompt julia&gt; coloreado, facilitando la distinción entre lo que es un mensaje informativo y un resultado del cálculo.",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Introducción a Python, R y Julia</span>"
    ]
  },
  {
    "objectID": "12-introduccion_python_r_julia.html#ayuda-y-documentación",
    "href": "12-introduccion_python_r_julia.html#ayuda-y-documentación",
    "title": "8  Introducción a Python, R y Julia",
    "section": "9.3 Ayuda y documentación",
    "text": "9.3 Ayuda y documentación\n\n\n\n\n\n\n\n\n\n\nTarea\nDescripción\nPython\nR\nJulia\n\n\n\n\nVer ayuda general\nAbre la documentación interactiva\nhelp()\nhelp.start()\n? en REPL\n\n\nAyuda de función\nDocumentación de un comando\nhelp(sum)\n?mean\n?sum\n\n\nVer ejemplos\nCódigo de ejemplo de una función\nDocstrings\nexample(\"lapply\")\nDocstrings\n\n\nVignettes / guías\nTutoriales extendidos\nobj.__doc__\nbrowseVignettes()\n?Modulo\n\n\nDemo\nEjecutar ejemplos\nlibreria.ejemplos()*\ndemo()\ninclude(\"test\")*\n\n\n\nNota sobre los Docstrings: En Python y Julia, la documentación y los ejemplos de uso residen directamente dentro del código fuente en bloques llamados Docstrings. Al ejecutar los comandos de ayuda (help() o @doc), el intérprete extrae estos comentarios y los muestra en la terminal, permitiendo que el usuario vea ejemplos reales de implementación de inmediato sin necesidad de manuales externos.\nNota sobre los Demos (*): A diferencia de R, Python y Julia no tienen un comando universal demo(). El asterisco indica que el acceso a ejemplos depende de la librería. En Python, se suele explorar la propiedad __doc__ o módulos de datasets. En Julia, se acostumbra a inspeccionar la carpeta de instalación mediante pathof(Modulo) para encontrar archivos de prueba o ejemplos.\n\nPythonRJulia\n\n\n\n# help() busca y muestra el \"Docstring\" de la función\nhelp(sum)\n\n# Ayuda sobre un módulo completo para ver sus funciones disponibles\nimport math\nhelp(math)\n\n# dir() lista todos los métodos y atributos (la \"anatomía\" del objeto)\nimport pandas as pd\ndir(pd.DataFrame)\n\n# pydoc renderiza la documentación técnica en la terminal\nimport pydoc\nprint(pydoc.render_doc(\"math\")) \n\n# Ejemplo de \"Demo\" en Python (vía datasets de una librería SIG)\nimport geopandas as gpd\n# Listamos los mapas de ejemplo que vienen con la librería\nprint(gpd.datasets.available)\n\n\n\n\n# Inicia el servidor de ayuda local en formato HTML\nhelp.start()\n\n# Acceso rápido a la documentación de una función específica\n?mean\nhelp(\"plot\")\n\n# Ejecuta automáticamente el código de ejemplo del manual\nexample(\"lapply\")\n\n# --- Vignettes y Demos ---\n\n# Abre el índice de tutoriales detallados (vignettes)\nbrowseVignettes()\n\n# Listar guías del paquete 'stars' (análisis de cubos de datos)\n# Nota: presione \"q\" al final de la lista para liberar la consola\nvignette(package = \"stars\")\n\n# Visualizar una vignette específica por su nombre\nvignette(\"stars1\", package = \"stars\")\n\n# Importante: requiere dispositivo gráfico (ej. httpgd::hgd())\n# presione \"q\" al final de la lista para salir\ndemo()\n\n# Demos específicos de librerías de Geomática\nlibrary(sf)\ndemo(\"nc\", package = \"sf\")\ndemo(\"ggplot\", package = \"sf\")\n\n\n\n\n# Este comando (?) solo funciona dentro del REPL interactivo\n# ?sum\n\n# En Quarto usamos la macro @doc para acceder al Docstring\n@doc sum\n@doc println\n\n# Julia usa docstrings con ejemplos y ayuda integrados, similar a Python\n# Para encontrar \"Demos\", localizamos la carpeta del paquete en el disco\nusing DataFrames\nprintln(\"Ubicación del código: \", pathof(DataFrames))",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Introducción a Python, R y Julia</span>"
    ]
  },
  {
    "objectID": "12-introduccion_python_r_julia.html#instalación-y-carga-de-paquetes",
    "href": "12-introduccion_python_r_julia.html#instalación-y-carga-de-paquetes",
    "title": "8  Introducción a Python, R y Julia",
    "section": "9.4 Instalación y carga de paquetes",
    "text": "9.4 Instalación y carga de paquetes\n\n\n\n\n\n\n\n\n\n\nTarea\nDescripción\nPython\nR\nJulia\n\n\n\n\nInstalar paquete\nAgregar librerías externas\npip3 install ...\ninstall.packages()\nPkg.add()\n\n\nCargar paquete\nHabilitar funciones del paquete\nimport ...\nlibrary()\nusing ...\n\n\n\n\nPythonRJulia\n\n\n#| label: instalacion_python\n# #| eval: false\n\n# En terminal usamos pip3 \n# para asegurar la versión de Python 3.x\n# pip3 install colorama\n\n# Dentro de python usamos el prefijo \"!\"\n# !pip3 install colorama\n\n# Cargamos solo lo necesario para manejar colores en consola\nfrom colorama import Fore, Style\n\nprint(\"Librería cargada en Python\")\n\n# Aparecerán caracteres especiales al inicio del texto\n# porque el HTML no entiende la instrucción colorear en rojo\n# Fore.RED aplica el color; Style.RESET_ALL evita que el color \"manche\" las siguientes líneas\nprint(Fore.RED + \"Librería cargada en Python\" + Style.RESET_ALL)\n\n\n\n# #| eval: false\n\n# Este comando carga el paquete con require() o lo instala\n# si no existe\nif (!require(\"crayon\", character.only = TRUE)) {\n  install.packages(\"crayon\", dependencies = TRUE, repos = \"https://cran.rstudio.com/\")\n}\n\nLoading required package: crayon\n\n# Activamos el paquete para la sesión actual de R\nlibrary(crayon)\n\n# cat() interpreta los códigos de escape ANSI que generan los colores\ncat(red(\"Librería cargada en R\"))\n\nLibrería cargada en R\n\n\n\n\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\n# Cargamos el gestor de paquetes de Julia\nusing Pkg\n# Instalamos la librería Crayons\nPkg.add(\"Crayons\")\n\n# Cargamos la librería para habilitar sus funciones\nusing Crayons\n\nprintln(\"Librería cargada en Julia\")\n\n# Aparecerán caracteres especiales al inicio del texto\n# porque el HTML no entiende la instrucción colorear en rojo\n# println con Crayon permite aplicar estilos directamente\nprintln(Crayon(foreground=:red), \"Librería cargada en Julia\")\n\n\n\n\n#| label: instalacion_julia_ejecucion\n#| kernel: julia-1.10\n#| results: asis\n# #| eval: false\n#j_eval('\nusing Pkg\n# Verificamos si \"Crayons\" ya está en el proyecto; si no, lo instalamos\nif !haskey(Pkg.dependencies(), Base.UUID(\"a83e43d3-9d41-5979-9952-4e448995a975\"))\n    Pkg.add(\"Crayons\")\nend\nusing Crayons\nprintln(\"Librería cargada en Julia\")\n\n# Aparecerán caracteres especiales al inicio del texto\n# porque el HTML no entiende la instrucción colorear en rojo\nprintln(Crayon(foreground=:red), \"Librería cargada en Julia\")\n#')",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Introducción a Python, R y Julia</span>"
    ]
  },
  {
    "objectID": "12-introduccion_python_r_julia.html#objetos-básicos-y-estructuras-de-datos",
    "href": "12-introduccion_python_r_julia.html#objetos-básicos-y-estructuras-de-datos",
    "title": "8  Introducción a Python, R y Julia",
    "section": "9.5 Objetos básicos y estructuras de datos",
    "text": "9.5 Objetos básicos y estructuras de datos\nEl manejo eficiente de vectores y matrices es el corazón del procesamiento ráster. A continuación, se presenta una comparativa de cómo se declaran y manipulan los objetos básicos.\n\n\n\nTabla 9.1: Comparativa de estructuras de datos\n\n\n\n\n\n\n\n\n\n\n\n\nEstructura\nDescripción\nPython\nR\nJulia\n\n\n\n\nVector\nColección lineal ordenada\nv = np.array([1, 2, 3])\nv &lt;- c(1, 2, 3)\nv = [1, 2, 3]\n\n\nMatriz\nArreglo bidimensional (Ráster)\nm = np.zeros((3,3)) o np.array([[...]])\nm &lt;- matrix(0, 3, 3)\nm = zeros(3, 3) o [... ; ...]\n\n\nDiccionario\nPares clave-valor (Metadatos)\n{key: val} ej. {\"id\": 1}\nlist(k=v) ej. list(id = 1)\nDict(k=&gt;v) ej. Dict(\"id\"=&gt;1)\n\n\nData Frame\nEstructura tabular (Atributos)\npd.DataFrame()\ndata.frame()\nDataFrame(...)\n\n\nIndexación\nPosición del primer elemento\nInicia en 0\nInicia en 1\nInicia en 1\n\n\n\n\n\n\n\nRelación entre estructuras y componentes SIG\nPara entender por qué usamos diferentes estructuras de datos, es útil ver cómo se mapean con los componentes de un Sistema de Información Geográfica:\n\n\n\n\n\n\nFigura 9.3\n\n\n\n\n\n\n\n\n\nNota\n\n\n\nComo se observa en la Figura 9.3, la Matriz es la estructura reina para el análisis ráster, mientras que los DataFrames son los que nos permiten realizar consultas sobre las bases de datos de predios o coberturas.\n\n\n\n\n\n\n\n\nEl peligro de la indexación espacial\n\n\n\nEsta es la fuente más frecuente de errores. Mientras que en Python el primer píxel de una banda satelital es el [0,0], en R y Julia es el [1,1]. Un error de este tipo desplazará todos sus resultados una celda, invalidando análisis de precisión o cambios de cobertura.\n\n\nNota sobre estructuras: En Geomática, los vectores suelen representar coordenadas o valores de píxeles, mientras que los diccionarios son fundamentales para manejar atributos (como en formato JSON o GeoJSON). Las tablas (DataFrames) son el estándar para bases de datos alfanuméricas de predios, municipios o estaciones climáticas.\n\nPythonRJulia\n\n\n\n# #| eval: false\n# 1. Listas: colecciones mutables de elementos\n# Ejemplo: Códigos DANE de departamentos (Antioquia, Cundinamarca, Valle)\ncodigos = [5, 25, 76]\ntype(codigos)\n\n&lt;class 'list'&gt;\n\n# 2. Diccionarios: Estructuras de clave-valor\n# Ideal para representar metadatos de un departamento\nmetadatos = {\n    \"departamento\": [\"Antioquia\", \"Cundinamarca\", \"Valle\"],\n    \"area_km2\": [63612, 22623, 22140],\n    \"capital\": [\"Medellín\", \"Bogotá\", \"Cali\"]\n}\ntype(metadatos)\n\n&lt;class 'dict'&gt;\n\n# 3. DataFrames: Para manejar tablas de atributos SIG\nimport pandas as pd\ndf_colombia = pd.DataFrame(metadatos)\ntype(df_colombia)\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\n\n# Visualizamos el resumen técnico de la tabla\nprint(df_colombia.info())\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 3 entries, 0 to 2\nData columns (total 3 columns):\n #   Column        Non-Null Count  Dtype \n---  ------        --------------  ----- \n 0   departamento  3 non-null      object\n 1   area_km2      3 non-null      int64 \n 2   capital       3 non-null      object\ndtypes: int64(1), object(2)\nmemory usage: 204.0+ bytes\nNone\n\n\n\n\n\n# #| eval: false\n# 1. Vectores: La unidad básica en R (todos los elementos del mismo tipo)\n# Códigos DANE de departamentos\ncodigos &lt;- c(5, 25, 76)\nclass(codigos)\n\n[1] \"numeric\"\n\n# 2. Listas: Pueden contener objetos de diferentes tipos y tamaños\n# En R, las listas con nombres funcionan como los diccionarios\nmetadatos &lt;- list(\n  departamento = c(\"Antioquia\", \"Cundinamarca\", \"Valle\"),\n  area_km2 = c(63612, 22623, 22140),\n  capital = c(\"Medellín\", \"Bogotá\", \"Cali\")\n)\nclass(metadatos)\n\n[1] \"list\"\n\n# 3. Data Frame: La estructura tabular nativa por excelencia\ndf_colombia &lt;- data.frame(metadatos)\nclass(df_colombia)\n\n[1] \"data.frame\"\n\n# str() muestra la estructura interna del objeto (equivalente a info() en Python)\nstr(df_colombia)\n\n'data.frame':   3 obs. of  3 variables:\n $ departamento: chr  \"Antioquia\" \"Cundinamarca\" \"Valle\"\n $ area_km2    : num  63612 22623 22140\n $ capital     : chr  \"Medellín\" \"Bogotá\" \"Cali\"\n\n\n\n\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\n# 1. Vectores: Se definen con corchetes (similar a Python)\ncodigos = [5, 25, 76]\ntypeof(codigos)\n\n# 2. Diccionarios: Se usa el operador =&gt; para asociar clave y valor\nmetadatos = Dict(\n    \"departamento\" =&gt; [\"Antioquia\", \"Cundinamarca\", \"Valle\"],\n    \"area_km2\" =&gt; [63612, 22623, 22140]\n)\ntypeof(metadatos)\n\n# 3. Tablas: En Julia Base se pueden usar vectores de Tuplas Nombradas,\n# pero en Geomática siempre usaremos la librería DataFrames\nusing DataFrames\ndf_colombia = DataFrame(\n    departamento = [\"Antioquia\", \"Cundinamarca\", \"Valle\"],\n    area_km2 = [63612, 22623, 22140],\n    capital = [\"Medellín\", \"Bogotá\", \"Cali\"]\n)\ntypeof(df_colombia)\n\n# describe() da un resumen estadístico de la tabla\nprintln(describe(df_colombia))\n\n\n\n\n# #| eval: false\nj_eval('\n# 1. Vectores: Se definen con corchetes (similar a Python)\ncodigos = [5, 25, 76]\n\ntypeof(codigos)\n\n# 2. Diccionarios: Se usa el operador =&gt; para asociar clave y valor\nmetadatos = Dict(\n    \"departamento\" =&gt; [\"Antioquia\", \"Cundinamarca\", \"Valle\"],\n    \"area_km2\" =&gt; [63612, 22623, 22140]\n)\n\ntypeof(metadatos)\n\n# 3. Tablas: En Julia Base se pueden usar vectores de Tuplas Nombradas,\n# pero en Geomática siempre usaremos la librería DataFrames\nusing DataFrames\ndf_colombia = DataFrame(\n    departamento = [\"Antioquia\", \"Cundinamarca\", \"Valle\"],\n    area_km2 = [63612, 22623, 22140],\n    capital = [\"Medellín\", \"Bogotá\", \"Cali\"]\n)\n\ntypeof(df_colombia)\n\n# describe() da un resumen estadístico de la tabla\nprintln(describe(df_colombia))\n')\nStarting Julia ...\njulia&gt; # 1. Vectores: Se definen con corchetes (similar a Python)\n\n\njulia&gt; codigos = [5, 25, 76]\n\n3-element Vector{Int64}:\n  5\n 25\n 76\n\n\njulia&gt; typeof(codigos)\n\nVector{Int64} (alias for Array{Int64, 1})\n\n\njulia&gt; # 2. Diccionarios: Se usa el operador =&gt; para asociar clave y valor\n\n\njulia&gt; metadatos = Dict(\n           \"departamento\" =&gt; [\"Antioquia\", \"Cundinamarca\", \"Valle\"],\n           \"area_km2\" =&gt; [63612, 22623, 22140]\n       )\n\nDict{String, Vector} with 2 entries:\n  \"departamento\" =&gt; [\"Antioquia\", \"Cundinamarca\", \"Valle\"]\n  \"area_km2\" =&gt; [63612, 22623, 22140]\n\n\njulia&gt; typeof(metadatos)\n\nDict{String, Vector}\n\n\njulia&gt; # 3. Tablas: En Julia Base se pueden usar vectores de Tuplas Nombradas,\n\n\njulia&gt; # pero en Geomática siempre usaremos la librería DataFrames\n\n\njulia&gt; using DataFrames\n\n\njulia&gt; df_colombia = DataFrame(\n           departamento = [\"Antioquia\", \"Cundinamarca\", \"Valle\"],\n           area_km2 = [63612, 22623, 22140],\n           capital = [\"Medellín\", \"Bogotá\", \"Cali\"]\n       )\n\n3×3 DataFrame\n Row │ departamento  area_km2  capital\n     │ String        Int64     String\n─────┼──────────────────────────────────\n   1 │ Antioquia        63612  Medellín\n   2 │ Cundinamarca     22623  Bogotá\n   3 │ Valle            22140  Cali\n\n\njulia&gt; typeof(df_colombia)\n\nDataFrame\n\n\njulia&gt; # describe() da un resumen estadístico de la tabla\n\n\njulia&gt; println(describe(df_colombia))\n\n3×7 DataFrame\n Row │ variable      mean     min        median   max       nmissing  eltype\n     │ Symbol        Union…   Any        Union…   Any       Int64     DataType\n─────┼─────────────────────────────────────────────────────────────────────────\n   1 │ departamento           Antioquia           Valle            0  String\n   2 │ area_km2      36125.0  22140      22623.0  63612            0  Int64\n   3 │ capital                Bogotá              Medellín         0  String",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Introducción a Python, R y Julia</span>"
    ]
  },
  {
    "objectID": "12-introduccion_python_r_julia.html#comandos-básicos-y-manipulación-de-tablas",
    "href": "12-introduccion_python_r_julia.html#comandos-básicos-y-manipulación-de-tablas",
    "title": "8  Introducción a Python, R y Julia",
    "section": "9.6 4. Comandos básicos y manipulación de tablas",
    "text": "9.6 4. Comandos básicos y manipulación de tablas\n\n\n\n\n\n\n\n\n\n\nTarea\nDescripción\nPython\nR\nJulia\n\n\n\n\nDirectorio\nRuta de trabajo actual\nos.getcwd()\ngetwd()\npwd()\n\n\nTipo / clase\nTipo de estructura\ntype()\nclass()\ntypeof()\n\n\nEstructura\nResumen técnico\ndf.info()\nstr()\ndescribe(df)\n\n\nDimensiones\nFilas y columnas\ndf.shape\ndim()\nsize()\n\n\nPrimeras filas\nVista rápida inicial\ndf.head(n)\nhead(df, n)\nfirst(df, n)\n\n\nFrecuencias\nConteo de categorías\nvalue_counts()\ntable()\ncountmap()\n\n\nUnir filas\nConcatenar vertical\npd.concat(..., axis=0)\nrbind()\nvcat()\n\n\nOmitir NA\nLimpiar datos faltantes\ndropna()\nna.omit()\ndropmissing()\n\n\nOrdenar\nOrganizar por columna\nsort_values()\norder() / arrange()\nsort()\n\n\n\n\nPythonRJulia\n\n\n\n# #| eval: false\nimport os\nimport numpy as np\nimport pandas as pd\n\n# 1. Gestión del entorno de trabajo\nprint(f\"Ruta actual: {os.getcwd()}\")\n\nRuta actual: /home/rstudio/work/01_prog_sig\n\n# 2. Creación de datos: Departamentos de Colombia (Población en millones, Área en km2)\ndata = {\n    \"depto\": [\"Antioquia\", \"Cundinamarca\", \"Valle\", \"Bolívar\", \"Atlántico\"],\n    \"pob_2023\": [6.8, 3.2, 4.6, 2.2, 2.8],\n    \"area_km2\": [63612, 22623, 22140, 25978, 3388],\n    \"region\": [\"Andina\", \"Andina\", \"Pacífica\", \"Caribe\", \"Caribe\"]\n}\ndf = pd.DataFrame(data)\n\n# 3. Inspección de la tabla\nprint(df.info())           # Resumen de tipos de datos y memoria\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 5 entries, 0 to 4\nData columns (total 4 columns):\n #   Column    Non-Null Count  Dtype  \n---  ------    --------------  -----  \n 0   depto     5 non-null      object \n 1   pob_2023  5 non-null      float64\n 2   area_km2  5 non-null      int64  \n 3   region    5 non-null      object \ndtypes: float64(1), int64(1), object(2)\nmemory usage: 292.0+ bytes\nNone\n\nprint(f\"Forma: {df.shape}\") # (filas, columnas)\n\nForma: (5, 4)\n\nprint(df.head(3))          # Ver los primeros 3 registros\n\n          depto  pob_2023  area_km2    region\n0     Antioquia       6.8     63612    Andina\n1  Cundinamarca       3.2     22623    Andina\n2         Valle       4.6     22140  Pacífica\n\n# 4. Análisis de frecuencias (¿Cuántos deptos por región?)\nprint(df[\"region\"].value_counts())\n\nregion\nAndina      2\nCaribe      2\nPacífica    1\nName: count, dtype: int64\n\n# 5. Operaciones de unión\n# Crear un nuevo registro para un depto faltante\nnuevo_depto = pd.DataFrame({\"depto\":[\"Chocó\"], \"pob_2023\":[0.5], \"area_km2\":[46530], \"region\":[\"Pacífica\"]})\n# Concatenar verticalmente (axis=0 es por filas)\ndf_extendido = pd.concat([df, nuevo_depto], axis=0, ignore_index=True)\n\n# 6. Ordenamiento\n# Ordenar por población de mayor a menor\ndf_sorted = df_extendido.sort_values(by=\"pob_2023\", ascending=False)\nprint(df_sorted)\n\n          depto  pob_2023  area_km2    region\n0     Antioquia       6.8     63612    Andina\n2         Valle       4.6     22140  Pacífica\n1  Cundinamarca       3.2     22623    Andina\n4     Atlántico       2.8      3388    Caribe\n3       Bolívar       2.2     25978    Caribe\n5         Chocó       0.5     46530  Pacífica\n\n# 7. Localización por condición (¿Dónde la población es &gt; 4M?)\nindices = np.where(df_extendido[\"pob_2023\"] &gt; 4.0)\nprint(f\"Índices detectados: {indices}\")\n\nÍndices detectados: (array([0, 2]),)\n\n\n\n\n\n# #| eval: false\n# 1. Gestión del entorno\ngetwd()\n\n[1] \"/home/rstudio/work/01_prog_sig\"\n\n# 2. Datos de ejemplo (Departamentos de Colombia)\ndf &lt;- data.frame(\n  depto = c(\"Antioquia\", \"Cundinamarca\", \"Valle\", \"Bolívar\", \"Atlántico\"),\n  pob_2023 = c(6.8, 3.2, 4.6, 2.2, 2.8),\n  area_km2 = c(63612, 22623, 22140, 25978, 3388),\n  region = c(\"Andina\", \"Andina\", \"Pacífica\", \"Caribe\", \"Caribe\")\n)\n\n# 3. Inspección básica\nstr(df)          # Estructura del objeto\n\n'data.frame':   5 obs. of  4 variables:\n $ depto   : chr  \"Antioquia\" \"Cundinamarca\" \"Valle\" \"Bolívar\" ...\n $ pob_2023: num  6.8 3.2 4.6 2.2 2.8\n $ area_km2: num  63612 22623 22140 25978 3388\n $ region  : chr  \"Andina\" \"Andina\" \"Pacífica\" \"Caribe\" ...\n\ndim(df)          # Dimensiones (filas y columnas)\n\n[1] 5 4\n\nhead(df, 3)      # Primeras 3 filas\n\n         depto pob_2023 area_km2   region\n1    Antioquia      6.8    63612   Andina\n2 Cundinamarca      3.2    22623   Andina\n3        Valle      4.6    22140 Pacífica\n\n# 4. Frecuencias (Equivalente a value_counts)\ntable(df$region)\n\n\n  Andina   Caribe Pacífica \n       2        2        1 \n\n# 5. Uniones verticales\n# Creamos el registro adicional\nnuevo &lt;- data.frame(depto=\"Chocó\", pob_2023=0.5, area_km2=46530, region=\"Pacífica\")\n# rbind une por filas (necesita que las columnas se llamen igual)\ndf_extendido &lt;- rbind(df, nuevo)\n\n# 6. Ordenamiento\n# order() devuelve los índices; los usamos para reindexar el dataframe\ndf_sorted &lt;- df_extendido[order(-df_extendido$pob_2023), ]\nprint(df_sorted)\n\n         depto pob_2023 area_km2   region\n1    Antioquia      6.8    63612   Andina\n3        Valle      4.6    22140 Pacífica\n2 Cundinamarca      3.2    22623   Andina\n5    Atlántico      2.8     3388   Caribe\n4      Bolívar      2.2    25978   Caribe\n6        Chocó      0.5    46530 Pacífica\n\n# 7. Alternativa con dplyr (El estándar de \"Tidyverse\" para manipular tablas)\nlibrary(dplyr)\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\n# --- Opción A: Paso a paso con variables intermedias ---\n# Útil para depurar y entender qué sucede en cada etapa\n\n# Paso 1: Ordenar la tabla de departamentos por población de forma descendente\ndf_ordenado &lt;- arrange(df_extendido, desc(pob_2023))\nprint(df_ordenado)\n\n         depto pob_2023 area_km2   region\n1    Antioquia      6.8    63612   Andina\n2        Valle      4.6    22140 Pacífica\n3 Cundinamarca      3.2    22623   Andina\n4    Atlántico      2.8     3388   Caribe\n5      Bolívar      2.2    25978   Caribe\n6        Chocó      0.5    46530 Pacífica\n\n# Paso 2: Filtrar los resultados para quedarnos solo con los mayores a 4M\ndf_final &lt;- filter(df_ordenado, pob_2023 &gt; 4.0)\nprint(df_final)\n\n      depto pob_2023 area_km2   region\n1 Antioquia      6.8    63612   Andina\n2     Valle      4.6    22140 Pacífica\n\n# --- Opción B: Uso de Operadores Pipe (Flujo continuo) ---\n# El pipe permite \"pasar\" el resultado de una función a la siguiente sin crear variables nuevas.\n\n# 1. Pipe de la librería dplyr (el clásico: %&gt;%)\n# Se lee como: \"Toma df_extendido, ENTONCES ordena, ENTONCES filtra\"\ndf_extendido %&gt;% \n  arrange(desc(pob_2023)) %&gt;% \n  filter(pob_2023 &gt; 4.0)\n\n      depto pob_2023 area_km2   region\n1 Antioquia      6.8    63612   Andina\n2     Valle      4.6    22140 Pacífica\n\n# 2. Pipe nativo de R (disponible desde la versión 4.1: |&gt;)\n# Es más eficiente en memoria y no depende de cargar librerías extra\ndf_extendido |&gt; \n  arrange(desc(pob_2023)) |&gt; \n  filter(pob_2023 &gt; 4.0)\n\n      depto pob_2023 area_km2   region\n1 Antioquia      6.8    63612   Andina\n2     Valle      4.6    22140 Pacífica\n\n\n\n\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\nusing DataFrames, Statistics\n\n# 1. Directorio actual\npwd()\n\n# 2. Definición de la tabla de departamentos\ndf = DataFrame(\n    depto = [\"Antioquia\", \"Cundinamarca\", \"Valle\", \"Bolívar\", \"Atlántico\"],\n    pob_2023 = [6.8, 3.2, 4.6, 2.2, 2.8],\n    area_km2 = [63612, 22623, 22140, 25978, 3388],\n    region = [\"Andina\", \"Andina\", \"Pacífica\", \"Caribe\", \"Caribe\"]\n)\n\n# 3. Inspección técnica\ndescribe(df)     # Resumen estadístico y de tipos\nnrow(df)         # Número de filas\nfirst(df, 3)     # Primeros 3 registros\n\n# 4. Uniones\nnuevo = DataFrame(depto=[\"Chocó\"], pob_2023=[0.5], area_km2=[46530], region=[\"Pacífica\"])\n# vcat es concatenación vertical\ndf_ext = vcat(df, nuevo)\n\n# 5. Ordenamiento (rev=true para descendente)\ndf_sorted = sort(df_ext, :pob_2023, rev=true)\nprintln(df_sorted)\n\n\n\n\n# #| eval: false\nj_eval('\nusing DataFrames\n\n# Recreamos la tabla en el entorno de Julia\ndf = DataFrame(\n    depto = [\"Antioquia\", \"Cundinamarca\", \"Valle\", \"Bolívar\", \"Atlántico\"],\n    pob_2023 = [6.8, 3.2, 4.6, 2.2, 2.8],\n    area_km2 = [63612, 22623, 22140, 25978, 3388],\n    region = [\"Andina\", \"Andina\", \"Pacífica\", \"Caribe\", \"Caribe\"]\n)\n\n# Ejecutamos inspección y unión\nnuevo = DataFrame(depto=[\"Chocó\"], pob_2023=[0.5], area_km2=[46530], region=[\"Pacífica\"])\ndf_ext = vcat(df, nuevo)\n\n# Ordenar por población y mostrar\nprintln(sort(df_ext, :pob_2023, rev=true))\n')\njulia&gt; using DataFrames\n\n\njulia&gt; # Recreamos la tabla en el entorno de Julia\n\n\njulia&gt; df = DataFrame(\n           depto = [\"Antioquia\", \"Cundinamarca\", \"Valle\", \"Bolívar\", \"Atlántico\"],\n           pob_2023 = [6.8, 3.2, 4.6, 2.2, 2.8],\n           area_km2 = [63612, 22623, 22140, 25978, 3388],\n           region = [\"Andina\", \"Andina\", \"Pacífica\", \"Caribe\", \"Caribe\"]\n       )\n\n5×4 DataFrame\n Row │ depto         pob_2023  area_km2  region\n     │ String        Float64   Int64     String\n─────┼────────────────────────────────────────────\n   1 │ Antioquia          6.8     63612  Andina\n   2 │ Cundinamarca       3.2     22623  Andina\n   3 │ Valle              4.6     22140  Pacífica\n   4 │ Bolívar            2.2     25978  Caribe\n   5 │ Atlántico          2.8      3388  Caribe\n\n\njulia&gt; # Ejecutamos inspección y unión\n\n\njulia&gt; nuevo = DataFrame(depto=[\"Chocó\"], pob_2023=[0.5], area_km2=[46530], region=[\"Pacífica\"])\n\n1×4 DataFrame\n Row │ depto   pob_2023  area_km2  region\n     │ String  Float64   Int64     String\n─────┼──────────────────────────────────────\n   1 │ Chocó        0.5     46530  Pacífica\n\n\njulia&gt; df_ext = vcat(df, nuevo)\n\n6×4 DataFrame\n Row │ depto         pob_2023  area_km2  region\n     │ String        Float64   Int64     String\n─────┼────────────────────────────────────────────\n   1 │ Antioquia          6.8     63612  Andina\n   2 │ Cundinamarca       3.2     22623  Andina\n   3 │ Valle              4.6     22140  Pacífica\n   4 │ Bolívar            2.2     25978  Caribe\n   5 │ Atlántico          2.8      3388  Caribe\n   6 │ Chocó              0.5     46530  Pacífica\n\n\njulia&gt; # Ordenar por población y mostrar\n\n\njulia&gt; println(sort(df_ext, :pob_2023, rev=true))\n\n6×4 DataFrame\n Row │ depto         pob_2023  area_km2  region\n     │ String        Float64   Int64     String\n─────┼────────────────────────────────────────────\n   1 │ Antioquia          6.8     63612  Andina\n   2 │ Valle              4.6     22140  Pacífica\n   3 │ Cundinamarca       3.2     22623  Andina\n   4 │ Atlántico          2.8      3388  Caribe\n   5 │ Bolívar            2.2     25978  Caribe\n   6 │ Chocó              0.5     46530  Pacífica\n\n\n\n\n\n\nOperaciones numéricas y matemáticas básicas\nEn el análisis espacial, estas operaciones son la base para calcular distancias, transformar coordenadas o procesar índices de vegetación (NDVI). A continuación, comparamos la sintaxis para las funciones matemáticas más comunes.\n\n\n\n\n\n\n\n\n\n\nTarea\nDescripción\nPython\nR\nJulia\n\n\n\n\nDivisión entera\nCociente sin decimales\n//\n%/%\ndiv()\n\n\nMódulo\nResiduo de la división\n%\n%%\n%\n\n\nRaíz cuadrada\nCálculo de \\(x^{1/2}\\)\nmath.sqrt()\nsqrt()\nsqrt()\n\n\nLogaritmo\nLogaritmo natural (\\(ln\\))\nmath.log()\nlog()\nlog()\n\n\nConstantes\nValores de \\(\\pi\\) y \\(e\\)\nmath.pi, math.e\npi, exp(1)\npi, exp(1)\n\n\n\n\nPythonRJulia\n\n\n\n# #| eval: false\nimport math\n\n# 1. Aritmética entera (Útil para indexación de matrices)\nprint(f\"División entera (5 // 2): {5 // 2}\")\n\nDivisión entera (5 // 2): 2\n\nprint(f\"Residuo/Módulo (5 % 2): {5 % 2}\")\n\nResiduo/Módulo (5 % 2): 1\n\n# 2. Constantes matemáticas universales\nprint(f\"Número e: {math.e}\")\n\nNúmero e: 2.718281828459045\n\nprint(f\"Número pi: {math.pi}\")\n\nNúmero pi: 3.141592653589793\n\n# 3. Funciones matemáticas (Requieren el módulo math)\nprint(f\"Raíz cuadrada de 2: {math.sqrt(2)}\")\n\nRaíz cuadrada de 2: 1.4142135623730951\n\nprint(f\"Logaritmo natural de 3: {math.log(3)}\")\n\nLogaritmo natural de 3: 1.0986122886681098\n\nprint(f\"Logaritmo base 10 de 3: {math.log(3, 10)}\")\n\nLogaritmo base 10 de 3: 0.47712125471966244\n\n# 4. Valor absoluto (Distancia sin dirección)\nprint(f\"Absoluto de -3.4: {abs(-3.4)}\")\n\nAbsoluto de -3.4: 3.4\n\n\n\n\n\n# #| eval: false\n\n# 1. Aritmética entera\ncat(\"División entera (5 %/% 2):\", 5 %/% 2, \"\\n\")\n\nDivisión entera (5 %/% 2): 2 \n\ncat(\"Residuo/Módulo (5 %% 2):\", 5 %% 2, \"\\n\")\n\nResiduo/Módulo (5 %% 2): 1 \n\n# 2. Constantes (pi es nativo, e se obtiene con exp)\ncat(\"Número e (exp(1)):\", exp(1), \"\\n\")\n\nNúmero e (exp(1)): 2.718282 \n\ncat(\"Número pi:\", pi, \"\\n\")\n\nNúmero pi: 3.141593 \n\n# 3. Funciones matemáticas (Nativas en Base R)\ncat(\"Raíz cuadrada de 2:\", sqrt(2), \"\\n\")\n\nRaíz cuadrada de 2: 1.414214 \n\ncat(\"Logaritmo natural de 3:\", log(3), \"\\n\")\n\nLogaritmo natural de 3: 1.098612 \n\ncat(\"Logaritmo base 10 de 3:\", log(3, 10), \"\\n\")\n\nLogaritmo base 10 de 3: 0.4771213 \n\n# 4. Valor absoluto\ncat(\"Absoluto de -3.4:\", abs(-3.4), \"\\n\")\n\nAbsoluto de -3.4: 3.4 \n\n\n\n\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\n# 1. Aritmética entera\nprintln(\"División entera: \", div(5, 2))\nprintln(\"Residuo: \", 5 % 2)\n\n# 2. Constantes y funciones (Nativas en Julia)\nprintln(\"Número e: \", exp(1))\nprintln(\"Número pi: \", pi)\n\n# 3. Funciones matemáticas\nprintln(\"Raíz cuadrada: \", sqrt(2))\nprintln(\"Logaritmo natural: \", log(3))\nprintln(\"Logaritmo base 10: \", log(10, 3)) # Nota: En Julia log(base, x)\n\n# 4. Valor absoluto\nprintln(\"Absoluto: \", abs(-3.4))\n\n\n\n\n# #| eval: false\nj_eval('\n# Ejecución de operaciones matemáticas vía j_eval\nprintln(\"División entera Julia: \", div(5, 2))\nprintln(\"Residuo Julia: \", 5 % 2)\nprintln(\"Raíz de 2: \", sqrt(2))\nprintln(\"Log natural 3: \", log(3))\nprintln(\"Log base 10: \", log(10, 3)) # Inversión de argumentos frente a R/Python\nprintln(\"Absoluto: \", abs(-3.4))\nprintln(\"Pi: \", pi)\n')\njulia&gt; # Ejecución de operaciones matemáticas vía j_eval\n\n\njulia&gt; println(\"División entera Julia: \", div(5, 2))\n\nDivisión entera Julia: 2\n\n\njulia&gt; println(\"Residuo Julia: \", 5 % 2)\n\nResiduo Julia: 1\n\n\njulia&gt; println(\"Raíz de 2: \", sqrt(2))\n\nRaíz de 2: 1.4142135623730951\n\n\njulia&gt; println(\"Log natural 3: \", log(3))\n\nLog natural 3: 1.0986122886681098\n\n\njulia&gt; println(\"Log base 10: \", log(10, 3)) # Inversión de argumentos frente a R/Python\n\nLog base 10: 0.47712125471966244\n\n\njulia&gt; println(\"Absoluto: \", abs(-3.4))\n\nAbsoluto: 3.4\n\n\njulia&gt; println(\"Pi: \", pi)\n\nPi: π",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Introducción a Python, R y Julia</span>"
    ]
  },
  {
    "objectID": "12-introduccion_python_r_julia.html#lectura-y-escritura-de-datos",
    "href": "12-introduccion_python_r_julia.html#lectura-y-escritura-de-datos",
    "title": "8  Introducción a Python, R y Julia",
    "section": "9.7 5. Lectura y escritura de datos",
    "text": "9.7 5. Lectura y escritura de datos\n\n\n\n\n\n\n\n\n\n\nTarea\nDescripción\nPython\nR\nJulia\n\n\n\n\nLeer CSV\nCargar tabla desde texto/archivo\npd.read_csv()\nread.csv()\nCSV.read()\n\n\nEscribir CSV\nGuardar tabla en disco\ndf.to_csv()\nwrite.csv()\nCSV.write()\n\n\n\nPara este ejercicio, utilizaremos una técnica de simulación de archivos en memoria. Esto es extremadamente útil en programación SIG para procesar datos que vienen de servicios web (APIs) antes de guardarlos físicamente.\n\nPythonRJulia\n\n\n\n# #| eval: false\nimport pandas as pd\nfrom io import StringIO\n\n# Simulamos el contenido de un archivo CSV con municipios y altitudes (msnm)\ncsv_data = \"\"\"\nmunicipio,altitud\nBogota,2625\nMedellin,1495\nCali,1018\nQuibdo,43\n\"\"\"\n\n# StringIO convierte un texto en un \"objeto de archivo\" que pandas puede leer\ndf = pd.read_csv(StringIO(csv_data))\n\n# Mostramos el resultado cargado\nprint(df)\n\n  municipio  altitud\n0    Bogota     2625\n1  Medellin     1495\n2      Cali     1018\n3    Quibdo       43\n\n\n# Guardamos en el disco (index=False evita que se guarde la columna de índices)\ndf.to_csv(\"municipios_altitud.csv\", index=False)\n\n\n\n\n# #| eval: false\n# Contenido simulado\ncsv_data &lt;- \"\nmunicipio,altitud\nBogota,2625\nMedellin,1495\nCali,1018\nQuibdo,43\n\"\n\n# textConnection crea un flujo de lectura a partir de la cadena de texto\ncon &lt;- textConnection(csv_data)\ndf &lt;- read.csv(con)\n\n# Es buena práctica cerrar la conexión después de usarla\nclose(con)\n\n# Visualizamos la tabla\nprint(df)\n\n  municipio altitud\n1    Bogota    2625\n2  Medellin    1495\n3      Cali    1018\n4    Quibdo      43\n\n# Escribimos en el disco (row.names=FALSE para evitar la columna adicional de números)\nwrite.csv(df, \"municipios_altitud.csv\", row.names = FALSE)\n\n\n\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\nusing CSV\nusing DataFrames\n\n# Contenido simulado\ncsv_data = \"\nmunicipio,altitud\nBogota,2625\nMedellin,1495\nCali,1018\nQuibdo,43\n\"\n\n# IOBuffer permite a Julia tratar un String como un archivo abierto\ndf = CSV.read(IOBuffer(csv_data), DataFrame)\n\n# Visualizamos\nprintln(df)\n\n# Guardar datos en el disco\nCSV.write(\"municipios_altitud.csv\", df)\n\n\n\n\n# #| eval: false\nj_eval('\nusing CSV\nusing DataFrames\n\ncsv_data = \"\nmunicipio,altitud\nBogota,2625\nMedellin,1495\nCali,1018\nQuibdo,43\n\"\n\n# Cargamos el string como DataFrame usando el buffer de memoria\ndf = CSV.read(IOBuffer(csv_data), DataFrame)\n\nprintln(\"Tabla cargada en Julia:\")\nprintln(df)\n\n# Escritura física\nCSV.write(\"municipios_altitud.csv\", df)\n')\njulia&gt; using CSV\n\n\njulia&gt; using DataFrames\n\n\njulia&gt; csv_data = \"\n       municipio,altitud\n       Bogota,2625\n       Medellin,1495\n       Cali,1018\n       Quibdo,43\n       \"\n\n\"\\nmunicipio,altitud\\nBogota,2625\\nMedellin,1495\\nCali,1018\\nQuibdo,43\\n\"\n\n\njulia&gt; # Cargamos el string como DataFrame usando el buffer de memoria\n\n\njulia&gt; df = CSV.read(IOBuffer(csv_data), DataFrame)\n\n4×2 DataFrame\n Row │ municipio  altitud\n     │ String15   Int64\n─────┼────────────────────\n   1 │ Bogota        2625\n   2 │ Medellin      1495\n   3 │ Cali          1018\n   4 │ Quibdo          43\n\n\njulia&gt; println(\"Tabla cargada en Julia:\")\n\nTabla cargada en Julia:\n\n\njulia&gt; println(df)\n\n4×2 DataFrame\n Row │ municipio  altitud\n     │ String15   Int64\n─────┼────────────────────\n   1 │ Bogota        2625\n   2 │ Medellin      1495\n   3 │ Cali          1018\n   4 │ Quibdo          43\n\n\njulia&gt; # Escritura física\n\n\njulia&gt; CSV.write(\"municipios_altitud.csv\", df)\n\n\"municipios_altitud.csv\"",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Introducción a Python, R y Julia</span>"
    ]
  },
  {
    "objectID": "12-introduccion_python_r_julia.html#indexación-y-filtrado",
    "href": "12-introduccion_python_r_julia.html#indexación-y-filtrado",
    "title": "8  Introducción a Python, R y Julia",
    "section": "9.8 6. Indexación y filtrado",
    "text": "9.8 6. Indexación y filtrado\nEn esta sección aprenderemos a extraer subconjuntos de datos. En Geomática, esto es vital para aislar, por ejemplo, municipios que superen una altitud crítica o departamentos que pertenecen a una región específica.\n\n\n\n\n\n\n\n\n\n\nTarea\nDescripción\nPython\nR\nJulia\n\n\n\n\nSeleccionar filas\nElegir registros por posición\ndf.iloc[0:2]\ndf[1:2, ]\ndf[1:2, :]\n\n\nFiltrar por condición\nSubset basado en reglas\ndf[df[\"altitud\"] &gt; 1000]\ndf[df$altitud &gt; 1000, ]\nfilter(row -&gt; ...)\n\n\n\n\nPythonRJulia\n\n\n\n# #| eval: false\nimport pandas as pd\n\n# Datos de municipios colombianos con su altitud (msnm)\ndf = pd.DataFrame({\n    \"municipio\": [\"Bogotá\", \"Medellín\", \"Cali\", \"Quibdó\", \"Barranquilla\"],\n    \"altitud\": [2625, 1495, 1018, 43, 18],\n    \"departamento\": [\"Cundinamarca\", \"Antioquia\", \"Valle\", \"Chocó\", \"Atlántico\"]\n})\n\n# 1. Seleccionar filas por posición (índices 0 y 1)\n# iloc permite acceso puramente posicional\nprimeros_dos = df.iloc[0:2]\nprint(\"Primeros dos municipios:\\n\", primeros_dos)\n\nPrimeros dos municipios:\n   municipio  altitud  departamento\n0    Bogotá     2625  Cundinamarca\n1  Medellín     1495     Antioquia\n\n# 2. Filtrar por condición (Municipios de \"Tierras Altas\" &gt; 1500 msnm)\ntierras_altas = df[df[\"altitud\"] &gt; 1500]\nprint(\"\\nMunicipios en tierras altas:\\n\", tierras_altas)\n\n\nMunicipios en tierras altas:\n   municipio  altitud  departamento\n0    Bogotá     2625  Cundinamarca\n\n\n# 3. Filtrado con múltiples condiciones (Andinos y con altitud &gt; 1000)\n# Usamos & para 'y' lógico\nandinos_altos = df[(df[\"altitud\"] &gt; 1000) & (df[\"departamento\"] != \"Chocó\")]\n\n\n\n\n# #| eval: false\ndf &lt;- data.frame(\n  municipio = c(\"Bogotá\", \"Medellín\", \"Cali\", \"Quibdó\", \"Barranquilla\"),\n  altitud = c(2625, 1495, 1018, 43, 18),\n  departamento = c(\"Cundinamarca\", \"Antioquia\", \"Valle\", \"Chocó\", \"Atlántico\")\n)\n\n# 1. Seleccionar filas por posición (En R los índices inician en 1)\nprimeros_dos &lt;- df[1:2, ]\nprint(primeros_dos)\n\n  municipio altitud departamento\n1    Bogotá    2625 Cundinamarca\n2  Medellín    1495    Antioquia\n\n# 2. Filtrar por condición lógica\ntierras_altas &lt;- df[df$altitud &gt; 1500, ]\nprint(tierras_altas)\n\n  municipio altitud departamento\n1    Bogotá    2625 Cundinamarca\n\n# 3. Filtrado usando subset() - más legible en Base R\nandinos_altos &lt;- subset(df, altitud &gt; 1000 & departamento != \"Chocó\")\nprint(andinos_altos)\n\n  municipio altitud departamento\n1    Bogotá    2625 Cundinamarca\n2  Medellín    1495    Antioquia\n3      Cali    1018        Valle\n\n\n\n\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\nusing DataFrames\n\ndf = DataFrame(\n    municipio = [\"Bogotá\", \"Medellín\", \"Cali\", \"Quibdó\", \"Barranquilla\"],\n    altitud = [2625, 1495, 1018, 43, 18],\n    departamento = [\"Cundinamarca\", \"Antioquia\", \"Valle\", \"Chocó\", \"Atlántico\"]\n)\n\n# 1. Selección por posición (similar a R, inicia en 1)\nprimeros_dos = df[1:2, :]\n\n# 2. Filtrado usando la función filter()\n# El operador -&gt; crea una función anónima para evaluar cada fila\ntierras_altas = filter(row -&gt; row.altitud &gt; 1500, df)\n\n# 3. Filtrado abreviado (Sintaxis de Julia 1.7+)\nandinos_altos = df[(df.altitud .&gt; 1000) .& (df.departamento .!= \"Chocó\"), :]\n\n\n\n\n# #| eval: false\nj_eval('\nusing DataFrames\n\ndf = DataFrame(\n    municipio = [\"Bogotá\", \"Medellín\", \"Cali\", \"Quibdó\", \"Barranquilla\"],\n    altitud = [2625, 1495, 1018, 43, 18],\n    departamento = [\"Cundinamarca\", \"Antioquia\", \"Valle\", \"Chocó\", \"Atlántico\"]\n)\n\n# Ejecutamos un filtro y mostramos el resultado\nprintln(\"Municipios con altitud &gt; 1000 msnm:\")\nprintln(filter(row -&gt; row.altitud &gt; 1000, df))\n')\njulia&gt; using DataFrames\n\n\njulia&gt; df = DataFrame(\n           municipio = [\"Bogotá\", \"Medellín\", \"Cali\", \"Quibdó\", \"Barranquilla\"],\n           altitud = [2625, 1495, 1018, 43, 18],\n           departamento = [\"Cundinamarca\", \"Antioquia\", \"Valle\", \"Chocó\", \"Atlántico\"]\n       )\n\n5×3 DataFrame\n Row │ municipio     altitud  departamento\n     │ String        Int64    String\n─────┼─────────────────────────────────────\n   1 │ Bogotá           2625  Cundinamarca\n   2 │ Medellín         1495  Antioquia\n   3 │ Cali             1018  Valle\n   4 │ Quibdó             43  Chocó\n   5 │ Barranquilla       18  Atlántico\n\n\njulia&gt; # Ejecutamos un filtro y mostramos el resultado\n\n\njulia&gt; println(\"Municipios con altitud &gt; 1000 msnm:\")\n\nMunicipios con altitud &gt; 1000 msnm:\n\n\njulia&gt; println(filter(row -&gt; row.altitud &gt; 1000, df))\n\n3×3 DataFrame\n Row │ municipio  altitud  departamento\n     │ String     Int64    String\n─────┼──────────────────────────────────\n   1 │ Bogotá        2625  Cundinamarca\n   2 │ Medellín      1495  Antioquia\n   3 │ Cali          1018  Valle",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Introducción a Python, R y Julia</span>"
    ]
  },
  {
    "objectID": "12-introduccion_python_r_julia.html#estadística-descriptiva-básica",
    "href": "12-introduccion_python_r_julia.html#estadística-descriptiva-básica",
    "title": "8  Introducción a Python, R y Julia",
    "section": "9.9 7. Estadística descriptiva básica",
    "text": "9.9 7. Estadística descriptiva básica\nEl análisis estadístico permite entender la distribución de variables geográficas, como la precipitación acumulada o la densidad de población.\n\n\n\n\n\n\n\n\n\n\nTarea\nDescripción\nPython\nR\nJulia\n\n\n\n\nMedia\nPromedio aritmético\nnp.mean()\nmean()\nmean()\n\n\nDesviación\nMedida de dispersión\nnp.std()\nsd()\nstd()\n\n\nResumen\nEstadísticos básicos\ndf.describe()\nsummary()\ndescribe()\n\n\n\n\nPythonRJulia\n\n\n\n# #| eval: false\nimport numpy as np\nimport pandas as pd\n\n# Altitudes de una muestra de estaciones climáticas en los Andes colombianos\naltitudes = np.array([2625, 1495, 1018, 2150, 1850])\n\n# 1. Estadísticos individuales con Numpy\nprint(f\"Altitud Media: {np.mean(altitudes)} msnm\")\n\nAltitud Media: 1827.6 msnm\n\nprint(f\"Desviación Estándar: {np.std(altitudes):.2f}\")\n\nDesviación Estándar: 548.88\n\n# 2. Resumen completo con Pandas\ndf_alt = pd.DataFrame(altitudes, columns=[\"msnm\"])\nprint(\"\\nResumen Descriptivo:\")\n\n\nResumen Descriptivo:\n\nprint(df_alt.describe())\n\n              msnm\ncount     5.000000\nmean   1827.600000\nstd     613.670351\nmin    1018.000000\n25%    1495.000000\n50%    1850.000000\n75%    2150.000000\nmax    2625.000000\n\n\n\n\n\n# #| eval: false\n# Vector de altitudes msnm\naltitudes &lt;- c(2625, 1495, 1018, 2150, 1850)\n\n# 1. Estadísticos descriptivos básicos\ncat(\"Media:\", mean(altitudes), \"\\n\")\n\nMedia: 1827.6 \n\ncat(\"Desviación Estándar:\", sd(altitudes), \"\\n\")\n\nDesviación Estándar: 613.6704 \n\n# 2. Resumen completo (Min, 1st Qu, Median, Mean, 3rd Qu, Max)\nsummary(altitudes)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   1018    1495    1850    1828    2150    2625 \n\n\n\n\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\nusing Statistics\nusing DataFrames\n\naltitudes = [2625, 1495, 1018, 2150, 1850]\n\n# 1. Las funciones de estadística requieren el paquete 'Statistics'\nprintln(\"Media: \", mean(altitudes))\nprintln(\"Desviación: \", std(altitudes))\n\n# 2. Resumen descriptivo para DataFrames\ndf = DataFrame(msnm = altitudes)\nprintln(describe(df))\n\n\n\n\n# #| eval: false\nj_eval('\nusing Statistics\nusing DataFrames\n\naltitudes = [2625, 1495, 1018, 2150, 1850]\n\nprintln(\"Media aritmética en Julia: \", mean(altitudes))\nprintln(\"Desviación estándar: \", std(altitudes))\n\n# Mostramos el resumen tabular\ndf = DataFrame(msnm = altitudes)\nprintln(describe(df))\n')\njulia&gt; using Statistics\n\n\njulia&gt; using DataFrames\n\n\njulia&gt; altitudes = [2625, 1495, 1018, 2150, 1850]\n\n5-element Vector{Int64}:\n 2625\n 1495\n 1018\n 2150\n 1850\n\n\njulia&gt; println(\"Media aritmética en Julia: \", mean(altitudes))\n\nMedia aritmética en Julia: 1827.6\n\n\njulia&gt; println(\"Desviación estándar: \", std(altitudes))\n\nDesviación estándar: 613.6703512473125\n\n\njulia&gt; # Mostramos el resumen tabular\n\n\njulia&gt; df = DataFrame(msnm = altitudes)\n\n5×1 DataFrame\n Row │ msnm\n     │ Int64\n─────┼───────\n   1 │  2625\n   2 │  1495\n   3 │  1018\n   4 │  2150\n   5 │  1850\n\n\njulia&gt; println(describe(df))\n\n1×7 DataFrame\n Row │ variable  mean     min    median   max    nmissing  eltype\n     │ Symbol    Float64  Int64  Float64  Int64  Int64     DataType\n─────┼──────────────────────────────────────────────────────────────\n   1 │ msnm       1827.6   1018   1850.0   2625         0  Int64",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Introducción a Python, R y Julia</span>"
    ]
  },
  {
    "objectID": "12-introduccion_python_r_julia.html#gráficos-básicos",
    "href": "12-introduccion_python_r_julia.html#gráficos-básicos",
    "title": "8  Introducción a Python, R y Julia",
    "section": "9.10 8. Gráficos básicos",
    "text": "9.10 8. Gráficos básicos\nLa visualización es el primer paso del análisis exploratorio de datos (EDA). En SIG, usamos barras para comparar atributos entre regiones y los histogramas para entender la distribución de variables como la elevación o la precipitación.\n\n\n\n\n\n\n\n\n\n\nTarea\nDescripción\nPython\nR\nJulia\n\n\n\n\nBarras\nComparar categorías\nplt.bar()\nbarplot()\nbar()\n\n\nHistograma\nDistribución de frecuencias\nplt.hist()\nhist()\nhistogram()\n\n\n\n\nPythonRJulia\n\n\n\n# #| eval: false\nimport matplotlib.pyplot as plt\n\n# 1. Gráfico de Barras: Altitud de ciudades principales\nciudades = [\"Bogotá\", \"Medellín\", \"Cali\", \"Quibdó\"]\naltitudes = [2625, 1495, 1018, 43]\n\nplt.bar(ciudades, altitudes, color='skyblue', edgecolor='navy')\nplt.xlabel(\"Ciudad\")\nplt.ylabel(\"Altitud (msnm)\")\nplt.title(\"Comparativa de Altitud - Municipios de Colombia\")\nplt.show()\n\n\n\n\n\n\n\n# 2. Histograma: Distribución de una muestra de altitudes\n# Simulamos 50 estaciones climáticas en diferentes pisos térmicos\nimport numpy as np\nmuestra_altitudes = [2625, 1495, 1018, 43, 18, 2527, 959, 467, 2150, 1850] * 5\n\nplt.hist(muestra_altitudes, bins=5, color='orange', alpha=0.7)\nplt.xlabel(\"Rango de Altitud (msnm)\")\nplt.ylabel(\"Frecuencia (N° Estaciones)\")\nplt.title(\"Distribución de Estaciones por Altitud\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n# #| eval: false\n# 1. Gráfico de Barras\nciudades &lt;- c(\"Bogotá\", \"Medellín\", \"Cali\", \"Quibdó\")\naltitudes &lt;- c(2625, 1495, 1018, 43)\n\n# En R base, barplot es simple y potente\nbarplot(altitudes, \n        names.arg = ciudades, \n        col = \"skyblue\", \n        border = \"navy\",\n        xlab = \"Ciudad\", \n        ylab = \"Altitud (msnm)\",\n        main = \"Altitud de Municipios\")\n\n\n\n\n\n\n\n# 2. Histograma\nmuestra_altitudes &lt;- c(2625, 1495, 1018, 43, 18, 2527, 959, 467, 2150, 1850)\nhist(muestra_altitudes, \n     breaks = 5, \n     col = \"orange\", \n     xlab = \"Altitud (msnm)\", \n     main = \"Distribución de la Muestra\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\nusing Plots\n\n# 1. Gráfico de Barras\nciudades = [\"Bogotá\", \"Medellín\", \"Cali\", \"Quibdó\"]\naltitudes = [2625, 1495, 1018, 43]\n\n# Plots.jl usa una sintaxis muy limpia para etiquetas\nbar(ciudades, altitudes, \n    color=:skyblue, \n    xlabel=\"Ciudad\", \n    ylabel=\"Altitud (msnm)\", \n    title=\"Altitud de Municipios\",\n    legend=false)\n\n# 2. Histograma\nmuestra_altitudes = [2625, 1495, 1018, 43, 18, 2527, 959, 467, 2150, 1850]\nhistogram(muestra_altitudes, \n          bins=5, \n          color=:orange, \n          title=\"Frecuencia de Altitudes\")\n\n\n\n\n# #| eval: false\nj_plot('\nusing Plots\n\n# Datos de Colombia\nciudades = [\"Bogotá\", \"Medellín\", \"Cali\", \"Quibdó\"]\naltitudes = [2625, 1495, 1018, 43]\n\n# En j_plot, el gráfico se genera en el dispositivo configurado\np1 = bar(ciudades, altitudes, title=\"Altitud Municipios\", legend=false)\ndisplay(p1)\n\nmuestra = [2625, 1495, 1018, 43, 18, 2527, 959, 467, 2150, 1850]\np2 = histogram(muestra, bins=5, title=\"Histograma Altitudes\")\ndisplay(p2)\n')\njulia&gt; using Plots\n\n# Datos de Colombia\n\n\njulia&gt; ciudades = [\"Bogotá\", \"Medellín\", \"Cali\", \"Quibdó\"]\n\n4-element Vector{String}:\n \"Bogotá\"\n \"Medellín\"\n \"Cali\"\n \"Quibdó\"\n\n\njulia&gt; altitudes = [2625, 1495, 1018, 43]\n\n# En j_plot, el gráfico se genera en el dispositivo configurado\n4-element Vector{Int64}:\n 2625\n 1495\n 1018\n   43\n\n\njulia&gt; p1 = bar(ciudades, altitudes, title=\"Altitud Municipios\", legend=false)\n\n\njulia&gt; display(p1)\n\n\njulia&gt; muestra = [2625, 1495, 1018, 43, 18, 2527, 959, 467, 2150, 1850]\n\n10-element Vector{Int64}:\n 2625\n 1495\n 1018\n   43\n   18\n 2527\n  959\n  467\n 2150\n 1850\n\n\njulia&gt; p2 = histogram(muestra, bins=5, title=\"Histograma Altitudes\")\n\n\njulia&gt; display(p2)",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Introducción a Python, R y Julia</span>"
    ]
  },
  {
    "objectID": "12-introduccion_python_r_julia.html#transformación-de-datos",
    "href": "12-introduccion_python_r_julia.html#transformación-de-datos",
    "title": "8  Introducción a Python, R y Julia",
    "section": "9.11 9. Transformación de datos",
    "text": "9.11 9. Transformación de datos\nEn el análisis de datos espaciales, frecuentemente necesitamos derivar nuevas variables a partir de las existentes, como convertir unidades de medida (metros a pies) o categorizar valores (crear rangos climáticos).\n\n\n\n\n\n\n\n\n\n\nTarea\nDescripción\nPython\nR\nJulia\n\n\n\n\nCrear columna\nNueva variable calculada\ndf[\"nueva\"] = ...\ndf$nueva &lt;- ...\ndf.nueva = ...\n\n\n\n\nPythonRJulia\n\n\n\n# #| eval: false\nimport pandas as pd\n\n# Definimos un DataFrame con municipios y su altitud en metros (msnm)\ndf = pd.DataFrame({\n    \"municipio\": [\"Bogotá\", \"Medellín\", \"Cali\"],\n    \"altitud_m\": [2625, 1495, 1018]\n})\n\n# 1. Creación de una columna mediante una operación aritmética simple\n# Convertimos metros a pies (aprox. 3.28 pies por metro)\ndf[\"altitud_ft\"] = df[\"altitud_m\"] * 3.28\n\n# 2. Creación de una columna con lógica condicional (Clasificación climática)\n# Usamos una función lambda para evaluar cada fila\ndf[\"clima\"] = df[\"altitud_m\"].apply(lambda x: \"Frío\" if x &gt; 2000 else \"Templado\")\n\nprint(df)\n\n  municipio  altitud_m  altitud_ft     clima\n0    Bogotá       2625     8610.00      Frío\n1  Medellín       1495     4903.60  Templado\n2      Cali       1018     3339.04  Templado\n\n\n\n\n\n# #| eval: false\n# Creamos el data frame base\ndf &lt;- data.frame(\n  municipio = c(\"Bogotá\", \"Medellín\", \"Cali\"),\n  altitud_m = c(2625, 1495, 1018)\n)\n\n# 1. Creación de columna usando el operador de asignación $\n# La operación se aplica de forma vectorizada a toda la columna\ndf$altitud_ft &lt;- df$altitud_m * 3.28\n\n# 2. Creación de columna con lógica condicional usando ifelse()\ndf$clima &lt;- ifelse(df$altitud_m &gt; 2000, \"Frío\", \"Templado\")\n\nprint(df)\n\n  municipio altitud_m altitud_ft    clima\n1    Bogotá      2625    8610.00     Frío\n2  Medellín      1495    4903.60 Templado\n3      Cali      1018    3339.04 Templado\n\n\n\n\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\nusing DataFrames\n\n# Definimos el DataFrame con datos de Colombia\ndf = DataFrame(\n    municipio = [\"Bogotá\", \"Medellín\", \"Cali\"],\n    altitud_m = [2625, 1495, 1018]\n)\n\n# 1. Creación de columna: El punto (.) indica que la operación es vectorizada (broadcast)\n# Es fundamental en Julia para operar sobre todos los elementos de la columna\ndf.altitud_ft = df.altitud_m .* 3.28\n\n# 2. Creación con lógica condicional usando una comprensión de lista\ndf.clima = [x &gt; 2000 ? \"Frío\" : \"Templado\" for x in df.altitud_m]\n\nprintln(df)\n\n\n\n\n# #| eval: false\nj_eval('\nusing DataFrames\n\n# Recreamos el DataFrame en el entorno de Julia\ndf = DataFrame(\n    municipio = [\"Bogotá\", \"Medellín\", \"Cali\"],\n    altitud_m = [2625, 1495, 1018]\n)\n\n# Aplicamos las transformaciones\ndf.altitud_ft = df.altitud_m .* 3.28\ndf.clima = [x &gt; 2000 ? \"Frío\" : \"Templado\" for x in df.altitud_m]\n\n# Mostramos el resultado final\nprintln(df)\n')\njulia&gt; using DataFrames\n\n\njulia&gt; # Recreamos el DataFrame en el entorno de Julia\n\n\njulia&gt; df = DataFrame(\n           municipio = [\"Bogotá\", \"Medellín\", \"Cali\"],\n           altitud_m = [2625, 1495, 1018]\n       )\n\n3×2 DataFrame\n Row │ municipio  altitud_m\n     │ String     Int64\n─────┼──────────────────────\n   1 │ Bogotá          2625\n   2 │ Medellín        1495\n   3 │ Cali            1018\n\n\njulia&gt; # Aplicamos las transformaciones\n\n\njulia&gt; df.altitud_ft = df.altitud_m .* 3.28\n\n3-element Vector{Float64}:\n 8610.0\n 4903.599999999999\n 3339.04",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Introducción a Python, R y Julia</span>"
    ]
  },
  {
    "objectID": "12-introduccion_python_r_julia.html#resumen-comparativo-cheat-sheet",
    "href": "12-introduccion_python_r_julia.html#resumen-comparativo-cheat-sheet",
    "title": "8  Introducción a Python, R y Julia",
    "section": "9.12 10. Resumen comparativo (cheat sheet)",
    "text": "9.12 10. Resumen comparativo (cheat sheet)\nEsta tabla sirve como guía de referencia rápida para transitar entre los tres lenguajes durante el desarrollo de proyectos de análisis espacial.\n\n\n\n\n\n\n\n\n\n\nCategoría\nTarea\nPython\nR\nJulia\n\n\n\n\nEcosistema\nAyuda de función\nhelp(f)\n?f\n?f\n\n\n\nInstalar paquete\npip3 install x\ninstall.packages(\"x\")\nPkg.add(\"x\")\n\n\nEstructuras\nVector / Lista\n[1, 2, 3]\nc(1, 2, 3)\n[1, 2, 3]\n\n\n\nDiccionario / Mapa\n{\"k\": v}\nlist(k = v)\nDict(k =&gt; v)\n\n\n\nData Frame\npd.DataFrame(d)\ndata.frame(d)\nDataFrame(d)\n\n\nI/O\nLeer CSV\npd.read_csv(\"f.csv\")\nread.csv(\"f.csv\")\nCSV.read(\"f.csv\", DF)\n\n\nManipulación\nVer estructura\ndf.info()\nstr(df)\ndescribe(df)\n\n\n\nFiltrar filas\ndf[df.col &gt; x]\ndf[df$col &gt; x, ]\nfilter(r -&gt; r.col &gt; x, df)\n\n\n\nCrear columna\ndf[\"n\"] = x * 2\ndf$n &lt;- x * 2\ndf.n = x .* 2\n\n\nAnálisis\nMedia\nnp.mean(x)\nmean(x)\nmean(x)\n\n\n\nDimensiones\ndf.shape\ndim(df)\nsize(df)\n\n\nVisualización\nBarras\nplt.bar(x, y)\nbarplot(y, names=x)\nbar(x, y)\n\n\n\n\nObservaciones finales\nPara evitar errores comunes en el procesamiento de datos geoespaciales, tenga siempre en cuenta estos tres pilares de la programación moderna:\n\n1. Índices de arreglos (posicionamiento)\nLa forma en que los lenguajes cuentan las posiciones es la causa principal de errores en la extracción de coordenadas o píxeles:\n\nPython: Utiliza indexación base-0 (el primer elemento está en la posición 0).\nR: Utiliza indexación base-1 (el primer elemento está en la posición 1).\nJulia: Al igual que R, utiliza indexación base-1.\n\n\n\n2. Vectorización y broadcasting (eficiencia)\nLa capacidad de operar sobre columnas completas sin usar bucles manuales (que son lentos) varía en su sintaxis y naturaleza:\n\nPython: La vectorización no es nativa de las listas base. Depende totalmente de librerías como numpy o pandas. Si intenta multiplicar una lista estándar por 2 ([1, 2] * 2), Python duplicará los elementos de la lista en lugar de realizar el cálculo matemático.\nR: La vectorización es nativa y automática. Casi todas las funciones de R están diseñadas para recibir un vector y devolver otro. Al hacer vector * 2, R entiende por defecto que debe multiplicarse cada elemento.\nJulia: Utiliza el concepto de Broadcasting. Es el más explícito: requiere añadir un punto antes del operador (.*, ./, .^) o de la función. Este punto le indica al compilador de Julia que “esparza” la operación sobre todos los elementos del vector con una eficiencia comparable al lenguaje C.\n\n\n\n3. El flujo de datos: el pipe (., %&gt;%, |&gt;)\nEl “Pipe” permite escribir código que se lee de izquierda a derecha (como una receta), evitando el anidamiento excesivo de paréntesis.\n\nPython (pandas): Utiliza el encadenamiento de métodos mediante el punto (.). Cada operación devuelve un nuevo objeto sobre el cual se aplica la siguiente: df.filter(...).sort(...).\nR (dplyr / Nativo): El pipe clásico de Tidyverse (%&gt;%) o el nativo (|&gt;) pasa el objeto automáticamente como primer argumento de la siguiente función: df %&gt;% filter(...).\nJulia (|&gt; / Chain.jl): El pipe nativo (|&gt;) es un operador de tubería simple. Para flujos de datos complejos y legibles, la comunidad de Julia prefiere la macro @chain del paquete Chain.jl.\n\n\n\n\n\nLibrerías de referencia (caja de herramientas)\nPara que su entorno de trabajo esté completo, asegúrese de tener instaladas y cargadas estas librerías base:\n\nPython: pandas (tablas de atributos), numpy (álgebra de mapas), matplotlib (salidas gráficas).\nR: base y dplyr (manipulación), graphics (visualización rápida).\nJulia: DataFrames (tablas), CSV (lectura), Statistics y Plots.\n\n\nNota sobre el rendimiento: Ninguno de los comandos vistos en este capítulo ejecuta procesamiento en paralelo (uso de múltiples núcleos). La vectorización y el pipe son herramientas de eficiencia lógica y computacional en un solo núcleo. El procesamiento multihilo se reservará para el análisis de grandes volúmenes de datos en capítulos posteriores.",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Introducción a Python, R y Julia</span>"
    ]
  },
  {
    "objectID": "12-introduccion_python_r_julia.html#ejercicios",
    "href": "12-introduccion_python_r_julia.html#ejercicios",
    "title": "8  Introducción a Python, R y Julia",
    "section": "9.13 Ejercicios",
    "text": "9.13 Ejercicios\nPara poner en práctica los conceptos introductorios abordados en este capítulo, deberás resolver los siguientes dos ejercicios. Puedes elegir resolverlos en Python, R o Julia (o implementar la solución en varios lenguajes si deseas retarte).\n\nEjercicio 1: Hidrología del Río Magdalena (Vectores y Matemáticas)\nContexto: Estás analizando el comportamiento de las estaciones hidrológicas del IDEAM a lo largo del Río Magdalena. Has recibido el reporte del caudal medio mensual (en metros cúbicos por segundo, \\(m^3/s\\)) de cinco estaciones clave y necesitas extraer estadísticos básicos y transformar las unidades para un informe ambiental.\nInstrucciones de código:\n\nDefine una colección ordenada (Vector/Lista/Array) llamada estaciones con los siguientes nombres: \"Honda\", \"Puerto Berrío\", \"Barrancabermeja\", \"Puerto Wilches\", \"Calamar\".\nDefine otra colección paralela llamada caudales_m3s con los siguientes valores numéricos: 1500, 2100, 2800, 3200, 4500.\nUtilizando las funciones estadísticas nativas de tu lenguaje elegido, calcula e imprime:\n\nEl caudal máximo registrado en el río.\nEl caudal promedio de las cinco estaciones.\n\nPara un estudio local, necesitas el caudal en litros por segundo (l/s). Utilizando el concepto de vectorización (o broadcasting), multiplica la colección caudales_m3s por 1000 y guarda el resultado en una nueva variable llamada caudales_ls. (Asegúrate de no usar bucles for).\nImprime la colección resultante caudales_ls.\n\n\n\nEjercicio 2: Calidad del Aire en Bogotá (DataFrames y Filtrado)\nContexto: La Red de Monitoreo de Calidad del Aire de Bogotá ha publicado los datos promedio diarios de Material Particulado 2.5 (\\(PM_{2.5}\\)). Debes organizar estos datos en una estructura tabular, filtrar las estaciones que presentan riesgos para la salud (según la OMS) y visualizar los resultados.\nInstrucciones de código:\n\nCrea un DataFrame llamado df_aire (utilizando la librería adecuada según tu lenguaje: pandas, data.frame o DataFrames.jl) que contenga dos columnas:\n\nestacion: \"Carvajal\", \"Kennedy\", \"Fontibón\", \"Suba\", \"Usaquén\"\npm25: 55, 42, 38, 15, 12\n\nImprime un resumen descriptivo/técnico de tu DataFrame (usando la función equivalente a info(), str() o describe()).\nEl límite diario recomendado por la OMS para \\(PM_{2.5}\\) es de 15 \\(\\mu g/m^3\\). Crea un nuevo DataFrame llamado df_alerta que filtre y contenga únicamente las estaciones donde el nivel de pm25 sea estrictamente mayor a 15.\nCrea una nueva columna en df_alerta llamada estado y asígnale a todas sus filas el valor de texto \"Crítico\".\nUtiliza la librería gráfica nativa de tu entorno para generar un gráfico de barras simple usando el DataFrame original (df_aire), donde el eje X sean las estaciones y el eje Y sean los niveles de \\(PM_{2.5}\\).\n\n\n\nEntregables y Criterios de Evaluación\nEl objetivo de esta evaluación no es solo que el código funcione, sino que seas capaz de documentar y explicar las diferencias fundamentales entre lenguajes.\n1. Archivos de Código: Debes desarrollar los algoritmos en al menos uno de los siguientes formatos de archivo:\n\nScript tradicional (.py, .R, .jl)\nNotebook interactivo (.ipynb)\nDocumento computacional (.qmd con chunks de código)\n\n2. Documento Analítico (Quarto): Independientemente del formato de tu código fuente, debes redactar un documento en Quarto (.qmd) y renderizarlo tanto en HTML como en PDF. En este documento debes incluir tus bloques de código y responder argumentativamente a las siguientes preguntas:\n\nSobre el Ejercicio 1 (Vectorización): Intenta explicar qué sucedería si decides hacer este ejercicio en Python y creas caudales_m3s como una Lista nativa ([1500, 2100...]) y la multiplicas directamente por 1000 (caudales_m3s * 1000). ¿Realizaría la operación matemática deseada? ¿Qué librería de Python soluciona este problema y cómo se diferencia este comportamiento del de R o Julia?\nPregunta General (Indexación): Escribe la línea de código exacta que usarías en tu lenguaje elegido para extraer las tres primeras estaciones del DataFrame del Ejercicio 2 usando indexación por rangos (slicing). Explica brevemente si el límite superior del rango que escribiste se incluye o se excluye en el resultado final, justificando esto según el tipo de indexación (Base-0 vs Base-1) de tu lenguaje.\n\n3. Repositorio en GitHub: Sube tu carpeta del proyecto (que debe contener tus scripts, el archivo .qmd y los renders finales en HTML y PDF) a un repositorio público en tu cuenta personal de GitHub.\n\nEntrega: Deberás enviar únicamente el enlace (URL) a tu repositorio de GitHub para la calificación.",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Introducción a Python, R y Julia</span>"
    ]
  },
  {
    "objectID": "13-estructuras_datos_geo.html",
    "href": "13-estructuras_datos_geo.html",
    "title": "9  Estructuras de Datos Geoespaciales",
    "section": "",
    "text": "9.1 Función j_eval y j_plot en R",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Estructuras de Datos Geoespaciales</span>"
    ]
  },
  {
    "objectID": "13-estructuras_datos_geo.html#el-estándar-simple-features-iso-19125",
    "href": "13-estructuras_datos_geo.html#el-estándar-simple-features-iso-19125",
    "title": "9  Estructuras de Datos Geoespaciales",
    "section": "9.2 El Estándar Simple Features (ISO 19125)",
    "text": "9.2 El Estándar Simple Features (ISO 19125)\nLa mayoría de las librerías modernas de programación SIG (Geopandas en Python, sf en R y LibGEOS/ArchGDAL en Julia) implementan el estándar Simple Features Access de la OGC. Este estándar define un modelo común para almacenar y acceder a geometrías en 2D.\nLas geometrías fundamentales que utilizaremos son:\n\nPoint (Punto): Un par de coordenadas \\((x, y)\\).\nLineString (Línea): Una secuencia de puntos conectados.\nPolygon (Polígono): Un anillo cerrado que puede contener “huecos” (anillos interiores).",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Estructuras de Datos Geoespaciales</span>"
    ]
  },
  {
    "objectID": "13-estructuras_datos_geo.html#creación-de-geometrías-básicas",
    "href": "13-estructuras_datos_geo.html#creación-de-geometrías-básicas",
    "title": "9  Estructuras de Datos Geoespaciales",
    "section": "9.3 Creación de Geometrías Básicas",
    "text": "9.3 Creación de Geometrías Básicas\nA continuación, definiremos la ubicación de la Plaza de Bolívar en Bogotá (aprox. \\(-74.076, 4.598\\)) usando los tres lenguajes.\n\nPython (Shapely)R (sf)Julia (LibGEOS)\n\n\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\nfrom shapely.geometry import Point, LineString\n\n# 1. Crear punto (Longitud, Latitud) para la Plaza de Bolívar\nplaza_bolivar = Point(-74.076, 4.598)\n\n# 2. Crear una línea (un segmento de la Carrera Séptima)\ncalle_septima = LineString([(-74.076, 4.598), (-74.075, 4.605)])\n\n# 3. Imprimir propiedades\nprint(f\"Tipo de geometría: {plaza_bolivar.geom_type}\")\nprint(f\"Representación WKT: {plaza_bolivar.wkt}\")\n\n\n\n\n\n# 1. Crear punto (Longitud, Latitud) para la Plaza de Bolívar\nfrom shapely.geometry import Point, LineString\n\nplaza_bolivar = Point(-74.076, 4.598)\n\n# 2. Crear una línea (un segmento de la Carrera Séptima)\ncalle_septima = LineString([(-74.076, 4.598), (-74.075, 4.605)])\n\n# 3. Imprimir propiedades\nprint(f\"Tipo de geometría: {plaza_bolivar.geom_type}\")\n\nTipo de geometría: Point\n\nprint(f\"Representación WKT: {plaza_bolivar.wkt}\")\n\nRepresentación WKT: POINT (-74.076 4.598)\n\n\n\n\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\nlibrary(sf)\n\n# 1. Crear punto (Longitud, Latitud) para la Plaza de Bolívar\nplaza_bolivar &lt;- st_point(c(-74.076, 4.598))\n\n# 2. Crear una línea (un segmento de la Carrera Séptima)\ncalle_septima &lt;- st_linestring(rbind(c(-74.076, 4.598), c(-74.075, 4.605)))\n\n# 3. Imprimir propiedades\nprint(plaza_bolivar)\n\n\n\n\n\nlibrary(sf)\n\nLinking to GEOS 3.12.1, GDAL 3.8.4, PROJ 9.4.0; sf_use_s2() is TRUE\n\n# 1. Crear punto (Longitud, Latitud) para la Plaza de Bolívar\nplaza_bolivar &lt;- st_point(c(-74.076, 4.598))\n\n# 2. Crear una línea (un segmento de la Carrera Séptima)\ncalle_septima &lt;- st_linestring(rbind(c(-74.076, 4.598), c(-74.075, 4.605)))\n\n# 3. Imprimir propiedades\nprint(plaza_bolivar)\n\nPOINT (-74.076 4.598)\n\n\n\n\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\nusing LibGEOS\n\n# 1. Crear punto desde formato WKT (Plaza de Bolívar)\nplaza_bolivar = LibGEOS.readgeom(\"POINT (-74.076 4.598)\")\n\n# 2. Imprimir propiedades\nprintln(\"Tipo de geometría: \", typeof(plaza_bolivar))\n\n\n\n\nj_eval(r\"-(\nusing LibGEOS\n\n# 1. Crear punto desde formato WKT (Plaza de Bolívar)\nplaza_bolivar = LibGEOS.readgeom(\"POINT (-74.076 4.598)\")\n\n# 2. Imprimir propiedades\nprintln(\"Tipo de geometría: \", typeof(plaza_bolivar))\n)-\")\nStarting Julia ...\njulia&gt; using LibGEOS\n\n\njulia&gt; # 1. Crear punto desde formato WKT (Plaza de Bolívar)\n\n\njulia&gt; plaza_bolivar = LibGEOS.readgeom(\"POINT (-74.076 4.598)\")\n\nPOINT (-74.076 4.598)\n\n\njulia&gt; # 2. Imprimir propiedades\n\n\njulia&gt; println(\"Tipo de geometría: \", typeof(plaza_bolivar))\n\nTipo de geometría: Point",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Estructuras de Datos Geoespaciales</span>"
    ]
  },
  {
    "objectID": "13-estructuras_datos_geo.html#atributos-y-tablas-espaciales",
    "href": "13-estructuras_datos_geo.html#atributos-y-tablas-espaciales",
    "title": "9  Estructuras de Datos Geoespaciales",
    "section": "9.4 Atributos y Tablas Espaciales",
    "text": "9.4 Atributos y Tablas Espaciales\nUn SIG es la unión de geometría + atributos. Cada lenguaje tiene una estructura principal para manejar estas tablas:\n\n\n\nConcepto\nPython\nR\nJulia\n\n\n\n\nLibrería\ngeopandas\nsf\nGeoTables.jl\n\n\nEstructura\nGeoDataFrame\nsf (data.frame)\nGeoTable\n\n\n\n\nEjemplo: Ciudades Principales de Colombia\n\nPython (GeoPandas)R (sf)Julia (GeoTables)\n\n\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\nimport geopandas as gpd\nimport pandas as pd\nfrom shapely.geometry import Point\n\n# 1. Datos alfanuméricos\ndf = pd.DataFrame({\n    'Ciudad': ['Bogotá', 'Medellín', 'Cali'],\n    'Pob_Millones': [7.9, 2.5, 2.2]\n})\n\n# 2. Geometrías (Lista de puntos: Longitud, Latitud)\ngeoms = [Point(-74.08, 4.60), Point(-75.56, 6.25), Point(-76.52, 3.42)]\n\n# 3. Unión en GeoDataFrame asignando el sistema de referencia\ngdf = gpd.GeoDataFrame(df, geometry=geoms, crs=\"EPSG:4326\")\nprint(gdf)\n\n\n\n\n\nimport geopandas as gpd\nimport pandas as pd\nfrom shapely.geometry import Point\n\n# 1. Datos alfanuméricos\ndf = pd.DataFrame({\n    'Ciudad': ['Bogotá', 'Medellín', 'Cali'],\n    'Pob_Millones': [7.9, 2.5, 2.2]\n})\n\n# 2. Geometrías (Lista de puntos: Longitud, Latitud)\ngeoms = [Point(-74.08, 4.60), Point(-75.56, 6.25), Point(-76.52, 3.42)]\n\n# 3. Unión en GeoDataFrame asignando el sistema de referencia\ngdf = gpd.GeoDataFrame(df, geometry=geoms, crs=\"EPSG:4326\")\nprint(gdf)\n\n     Ciudad  Pob_Millones             geometry\n0    Bogotá           7.9   POINT (-74.08 4.6)\n1  Medellín           2.5  POINT (-75.56 6.25)\n2      Cali           2.2  POINT (-76.52 3.42)\n\n\n\n\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\nlibrary(sf)\n\n# 1. Datos alfanuméricos y coordenadas en un solo DataFrame\nciudades &lt;- data.frame(\n  Ciudad = c(\"Bogotá\", \"Medellín\", \"Cali\"),\n  Pob_Millones = c(7.9, 2.5, 2.2),\n  lon = c(-74.08, -75.56, -76.52),\n  lat = c(4.60, 6.25, 3.42)\n)\n\n# 2. Convertir a objeto espacial (sf) asignando columnas y CRS\ngdf &lt;- st_as_sf(ciudades, coords = c(\"lon\", \"lat\"), crs = 4326)\nprint(gdf)\n\n\n\n\n\nlibrary(sf)\n\n# 1. Datos alfanuméricos y coordenadas en un solo DataFrame\nciudades &lt;- data.frame(\n  Ciudad = c(\"Bogotá\", \"Medellín\", \"Cali\"),\n  Pob_Millones = c(7.9, 2.5, 2.2),\n  lon = c(-74.08, -75.56, -76.52),\n  lat = c(4.60, 6.25, 3.42)\n)\n\n# 2. Convertir a objeto espacial (sf) asignando columnas y CRS\ngdf &lt;- st_as_sf(ciudades, coords = c(\"lon\", \"lat\"), crs = 4326)\nprint(gdf)\n\nSimple feature collection with 3 features and 2 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: -76.52 ymin: 3.42 xmax: -74.08 ymax: 6.25\nGeodetic CRS:  WGS 84\n    Ciudad Pob_Millones            geometry\n1   Bogotá          7.9  POINT (-74.08 4.6)\n2 Medellín          2.5 POINT (-75.56 6.25)\n3     Cali          2.2 POINT (-76.52 3.42)\n\n\n\n\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\nimport Pkg\nPkg.add([\"GeoTables\", \"Meshes\"])\n\nusing GeoTables, Meshes, DataFrames\n\n# 1. Datos alfanuméricos\ndf = DataFrame(Ciudad = [\"Bogotá\", \"Medellín\", \"Cali\"], Pob_Millones = [7.9, 2.5, 2.2])\n\n# 2. Geometrías (Llamamos a Meshes.Point explícitamente para evitar conflictos en memoria)\npuntos = [Meshes.Point(-74.08, 4.60), Meshes.Point(-75.56, 6.25), Meshes.Point(-76.52, 3.42)]\n\n# 3. Unión en GeoTable usando georef (el constructor estándar)\ngt = georef(df, puntos)\n\nprintln(gt)\n\n\n\n\nj_eval(r\"-(\nimport Pkg\nPkg.add([\"GeoTables\", \"Meshes\"])\n\nusing GeoTables, Meshes, DataFrames\n\n# 1. Datos alfanuméricos\ndf = DataFrame(Ciudad = [\"Bogotá\", \"Medellín\", \"Cali\"], Pob_Millones = [7.9, 2.5, 2.2])\n\n# 2. Geometrías (Llamamos a Meshes.Point explícitamente para evitar conflictos en memoria)\npuntos = [Meshes.Point(-74.08, 4.60), Meshes.Point(-75.56, 6.25), Meshes.Point(-76.52, 3.42)]\n\n# 3. Unión en GeoTable usando georef (el constructor estándar)\ngt = georef(df, puntos)\n\nprintln(gt)\n)-\")\njulia&gt; import Pkg\n\n\njulia&gt; Pkg.add([\"GeoTables\", \"Meshes\"])\n\n\njulia&gt; using GeoTables, Meshes, DataFrames\n\n\njulia&gt; # 1. Datos alfanuméricos\n\n\njulia&gt; df = DataFrame(Ciudad = [\"Bogotá\", \"Medellín\", \"Cali\"], Pob_Millones = [7.9, 2.5, 2.2])\n\n3×2 DataFrame\n Row │ Ciudad    Pob_Millones\n     │ String    Float64\n─────┼────────────────────────\n   1 │ Bogotá             7.9\n   2 │ Medellín           2.5\n   3 │ Cali               2.2\n\n\njulia&gt; # 2. Geometrías (Llamamos a Meshes.Point explícitamente para evitar conflictos en memoria)\n\n\njulia&gt; puntos = [Meshes.Point(-74.08, 4.60), Meshes.Point(-75.56, 6.25), Meshes.Point(-76.52, 3.42)]\n\n3-element Vector{Meshes.Point{𝔼{2}, CoordRefSystems.Cartesian2D{CoordRefSystems.NoDatum, Unitful.Quantity{Float64, 𝐋, Unitful.FreeUnits{(m,), 𝐋, nothing}}}}}:\n Point(x: -74.08 m, y: 4.6 m)\n Point(x: -75.56 m, y: 6.25 m)\n Point(x: -76.52 m, y: 3.42 m)\n\n\njulia&gt; # 3. Unión en GeoTable usando georef (el constructor estándar)\n\n\njulia&gt; gt = georef(df, puntos)\n\n              3×3 GeoTable over 3 PointSet\n┌─────────────┬──────────────┬──────────────────────────┐\n│   Ciudad    │ Pob_Millones │         geometry         │\n│ Categorical │  Continuous  │          Point           │\n│  [NoUnits]  │  [NoUnits]   │   🖈 Cartesian{NoDatum}   │\n├─────────────┼──────────────┼──────────────────────────┤\n│   Bogotá    │     7.9      │ (x: -74.08 m, y: 4.6 m)  │\n│  Medellín   │     2.5      │ (x: -75.56 m, y: 6.25 m) │\n│    Cali     │     2.2      │ (x: -76.52 m, y: 3.42 m) │\n└─────────────┴──────────────┴──────────────────────────┘\n\n\njulia&gt; println(gt)\n\n3×3 GeoTable over 3 PointSet",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Estructuras de Datos Geoespaciales</span>"
    ]
  },
  {
    "objectID": "13-estructuras_datos_geo.html#sistemas-de-referencia-de-coordenadas-crs",
    "href": "13-estructuras_datos_geo.html#sistemas-de-referencia-de-coordenadas-crs",
    "title": "9  Estructuras de Datos Geoespaciales",
    "section": "9.5 Sistemas de Referencia de Coordenadas (CRS)",
    "text": "9.5 Sistemas de Referencia de Coordenadas (CRS)\nEn Colombia, trabajamos principalmente con:\n\nWGS84 (EPSG:4326): Grados decimales.\nMAGNA-SIRGAS / Origen Nacional (EPSG:9377): Metros.\n\n\n\n\n\n\n\nImportante\n\n\n\nNunca realice cálculos de área o distancia usando coordenadas en grados (EPSG:4326). Siempre proyecte a EPSG:9377 para obtener resultados en metros.",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Estructuras de Datos Geoespaciales</span>"
    ]
  },
  {
    "objectID": "13-estructuras_datos_geo.html#resumen-de-aprendizajes-cheat-sheet",
    "href": "13-estructuras_datos_geo.html#resumen-de-aprendizajes-cheat-sheet",
    "title": "9  Estructuras de Datos Geoespaciales",
    "section": "9.6 Resumen de Aprendizajes (Cheat Sheet)",
    "text": "9.6 Resumen de Aprendizajes (Cheat Sheet)\nEn este capítulo sentamos las bases del estándar Simple Features. A continuación, se presenta tu Hoja de Referencia (Cheat Sheet) para transitar entre las principales librerías espaciales de los tres lenguajes.\n\nFunciones Centrales (Simple Features)\n\n\n\nTabla 9.1: Estructuras fundacionales para análisis espacial\n\n\n\n\n\n\n\n\n\n\n\nOperación\nPython (shapely/geopandas)\nR (sf)\nJulia (LibGEOS/GeoTables)\n\n\n\n\nCrear Punto\nPoint(x, y)\nst_point(c(x, y))\nreadgeom(\"POINT(x y)\")\n\n\nCrear Línea\nLineString([(x,y), ...])\nst_linestring(rbind(...))\nreadgeom(\"LINESTRING(...)\")\n\n\nCrear Tabla Geo\nGeoDataFrame(df, geometry=g)\nst_as_sf(df, coords=...)\nGeoTable(df, geometry=g)\n\n\nAsignar CRS\ncrs=\"EPSG:4326\"\ncrs = 4326\nImplícito / Vía Proj.jl\n\n\n\n\n\n\n\n\n\n\n\n\n\nConclusiones Críticas del Módulo\n\n\n\n\nOrden de las Coordenadas: Históricamente en geografía decimos “Latitud, Longitud” (Y, X). Sin embargo, en el estándar Simple Features y en programación pura, el orden matemático estricto es siempre (X, Y), lo que equivale a (Longitud, Latitud). Intercambiarlos ubicará sus datos en el océano o en otro país.\nTablas Mágicas: Un GeoDataFrame en Python o un sf en R no son más que tablas tradicionales (DataFrames) a las que se les ha inyectado una columna especial con “superpoderes” geométricos. Si borra esa columna, pierde las capacidades espaciales.",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Estructuras de Datos Geoespaciales</span>"
    ]
  },
  {
    "objectID": "13-estructuras_datos_geo.html#ejercicios",
    "href": "13-estructuras_datos_geo.html#ejercicios",
    "title": "9  Estructuras de Datos Geoespaciales",
    "section": "9.7 Ejercicios",
    "text": "9.7 Ejercicios\nPara consolidar tu comprensión de las geometrías básicas y las tablas espaciales, deberás resolver los siguientes ejercicios en Python, R o Julia.\n\nEjercicio 1: Topología del Río Cauca (Líneas y Puntos)\nContexto: Estás analizando estaciones de monitoreo de calidad del agua sobre un tramo del Río Cauca. Tienes las coordenadas de las estaciones y necesitas construir los objetos geométricos individuales para luego incluirlos en tu reporte base.\nInstrucciones de código:\n\nUtilizando las herramientas de creación de geometrías nativas de tu lenguaje, crea un Punto que represente la Estación Juanchito (Coordenadas aproximadas: Lon: -76.45, Lat: 3.45). Guárdalo en la variable pt_juanchito.\nCrea un segundo Punto para la Estación Mediacanoa (Lon: -76.38, Lat: 3.88). Guárdalo en la variable pt_mediacanoa.\nImagina que el río conecta ambos puntos en línea recta. Crea una geometría tipo Línea (LineString) que una la coordenada de Juanchito con la de Mediacanoa. Guárdalo en la variable tramo_cauca.\nImprime el tipo de geometría (o la representación en texto/WKT) de tu variable tramo_cauca.\n\n\n\nEjercicio 2: Catastro de Zonas de Riesgo (Tabla Espacial)\nContexto: El equipo de Gestión del Riesgo te ha entregado un archivo tabular tradicional (CSV) con los barrios que reportan riesgo de inundación y sus coordenadas. Tu misión es convertir esta tabla “plana” en un objeto espacial oficial con un sistema de referencia.\nInstrucciones de código:\n\nCrea un DataFrame clásico con la siguiente información:\n\nColumna Barrio: “La Virginia”, “Puerto Mallarino”\nColumna Riesgo: “Alto”, “Medio”\nColumna Lon: -75.88, -76.21\nColumna Lat: 4.90, 3.95\n\nUtiliza la función apropiada de tu librería espacial (GeoPandas, sf o GeoTables) para convertir ese DataFrame en una Tabla Espacial. Asegúrate de mapear las columnas Lon y Lat como las geometrías.\nAl realizar la conversión, asigna explícitamente el sistema de coordenadas geográficas estándar (WGS84), es decir, el código EPSG:4326.\nImprime en consola tu nueva tabla espacial.\n\n\n\nEntregables y Criterios de Evaluación\n1. Archivos de Código: Debes desarrollar los algoritmos en al menos uno de los siguientes formatos de archivo: * Script tradicional (.py, .R, .jl) * Notebook interactivo (.ipynb) * Documento computacional (.qmd con chunks de código)\n2. Documento Analítico (Quarto): Independientemente del formato de tu código fuente, debes redactar un documento en Quarto (.qmd) y renderizarlo tanto en HTML como en PDF. En este documento debes incluir tus bloques de código y responder argumentativamente a las siguientes preguntas:\n\nSobre la Topología (Ejercicio 1): Basado en la lectura y tu experiencia práctica, ¿por qué es crítico respetar el orden matemático (X, Y) o (Longitud, Latitud) al momento de construir un Point o LineString en lugar de usar el orden verbal cotidiano “Latitud, Longitud”?\nSobre la Proyección: El texto de la lección hace una advertencia sobre calcular áreas usando el EPSG:4326 (Grados). Explica con tus palabras por qué medir un área en “grados cuadrados” carece de utilidad práctica en la ingeniería o el planeamiento territorial en Colombia, y por qué el EPSG:9377 soluciona esto.\n\n3. Repositorio en GitHub: Sube tu carpeta del proyecto a un repositorio público en tu cuenta personal de GitHub. * Entrega: Deberás enviar únicamente el enlace (URL) a tu repositorio de GitHub para la calificación.",
    "crumbs": [
      "Fundamentos",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Estructuras de Datos Geoespaciales</span>"
    ]
  },
  {
    "objectID": "41-practica_1_benchmark_raster.html",
    "href": "41-practica_1_benchmark_raster.html",
    "title": "10  Evaluación Comparativa de Procesamiento Geoespacial",
    "section": "",
    "text": "10.1 Introducción",
    "crumbs": [
      "Prácticas",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Evaluación Comparativa de Procesamiento Geoespacial</span>"
    ]
  },
  {
    "objectID": "41-practica_1_benchmark_raster.html#introducción",
    "href": "41-practica_1_benchmark_raster.html#introducción",
    "title": "10  Evaluación Comparativa de Procesamiento Geoespacial",
    "section": "",
    "text": "Materia: Programación SIG: Python, R, Julia\nPráctica 1: Sentinel-2 (1GB) - R (terra) vs R (stars) vs Python (rasterio) vs Julia (ArchGDAL + Raster.jl)\nAutores: Alexys Rodríguez-Avellaneda Ph.D. & herramientas IA",
    "crumbs": [
      "Prácticas",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Evaluación Comparativa de Procesamiento Geoespacial</span>"
    ]
  },
  {
    "objectID": "41-practica_1_benchmark_raster.html#función-j_eval-y-j_plot-en-r",
    "href": "41-practica_1_benchmark_raster.html#función-j_eval-y-j_plot-en-r",
    "title": "10  Evaluación Comparativa de Procesamiento Geoespacial",
    "section": "10.2 Función j_eval y j_plot en R",
    "text": "10.2 Función j_eval y j_plot en R\nUsada para ejecutar código Julia en R. j_eval ejecuta comandos que no tengan salidas gráficas, y j_plot es necesaria cuándo el código Julia produce salidas gráficas.\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\n# Código en R \nj_eval &lt;- function(cmd) {\n  .ensure_julia_ready()\n  lineas &lt;- strsplit(cmd, \"\\n\")[[1]]\n  buffer_bloque &lt;- \"\"; en_bloque &lt;- 0; resultado_final &lt;- NULL\n\n  for (l in lineas) {\n    if (trimws(l) == \"\") next\n    buffer_bloque &lt;- paste0(buffer_bloque, l, \"\\n\")\n    abrir &lt;- grepl(\"\\\\b(do|function|for|if|begin|let|while)\\\\b\", l) & !grepl(\"\\\\bend\\\\b\", l)\n    cerrar &lt;- grepl(\"\\\\bend\\\\b\", l)\n    en_bloque &lt;- en_bloque + abrir - cerrar\n    \n    if (en_bloque &lt;= 0) {\n      res_raw &lt;- JuliaConnectoR::juliaCall(\"_unal_core_executor\", buffer_bloque, FALSE, \"\", 72, 800, 500, 12)\n      cat(res_raw)\n      lineas_res &lt;- strsplit(res_raw, \"\\n\")[[1]]\n      lineas_res &lt;- trimws(lineas_res[lineas_res != \"\"])\n      # Capturamos solo si hay contenido real\n      temp_res &lt;- tail(lineas_res[!grepl(\"^julia&gt;\", lineas_res)], 1)\n      if (length(temp_res) &gt; 0) resultado_final &lt;- temp_res\n      buffer_bloque &lt;- \"\"; en_bloque &lt;- 0\n    }\n  }\n  if (is.null(resultado_final)) return(NULL) # Evita el error de length zero\n  val_limpio &lt;- gsub('\"', '', resultado_final)\n  num_val &lt;- suppressWarnings(as.numeric(val_limpio))\n  return(if (!is.na(num_val)) num_val else val_limpio)\n}\n\nj_plot &lt;- function(cmd, n = \"tmp_plot.png\", dpi = 300, w = 800, h = NULL, ratio = 1.6, fontsize = 12) {\n  .ensure_julia_ready()\n  if (is.null(h)) h &lt;- round(w / ratio)\n  \n  lineas &lt;- strsplit(cmd, \"\\n\")[[1]]\n  buffer_bloque &lt;- \"\"; en_bloque &lt;- 0\n  \n  for (i in 1:length(lineas)) {\n    l &lt;- lineas[i]\n    if (trimws(l) == \"\") next\n    buffer_bloque &lt;- paste0(buffer_bloque, l, \"\\n\")\n    \n    # Lógica de detección de bloques (do, function, for, etc.)\n    abrir &lt;- grepl(\"\\\\b(do|function|for|if|begin|let|while)\\\\b\", l) & !grepl(\"\\\\bend\\\\b\", l)\n    cerrar &lt;- grepl(\"\\\\bend\\\\b\", l)\n    en_bloque &lt;- en_bloque + abrir - cerrar\n    \n    # Solo ejecutamos si el bloque está cerrado\n    if (en_bloque &lt;= 0) {\n      # ¿Es el último bloque? Si sí, activamos el guardado de imagen (TRUE)\n      es_ultimo &lt;- (i == length(lineas))\n      \n      log_out &lt;- JuliaConnectoR::juliaCall(\n        \"_unal_core_executor\", \n        buffer_bloque, \n        es_ultimo, # Solo la última ejecución guarda el PNG\n        n, dpi, as.integer(w), as.integer(h), as.integer(fontsize)\n      )\n      \n      if (nchar(log_out) &gt; 0) cat(log_out)\n      buffer_bloque &lt;- \"\"; en_bloque &lt;- 0\n    }\n  }\n  \n  # Renderizado de la imagen en R (solo si se creó el archivo)\n  if (file.exists(n)) {\n    img &lt;- png::readPNG(n)\n    grid::grid.newpage()\n    grid::grid.raster(img)\n    # Opcional: borrar el temporal después de leerlo para no dejar basura\n    # unlink(n) \n  }\n}",
    "crumbs": [
      "Prácticas",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Evaluación Comparativa de Procesamiento Geoespacial</span>"
    ]
  },
  {
    "objectID": "41-practica_1_benchmark_raster.html#preparación-de-los-datos-sentinel-2a",
    "href": "41-practica_1_benchmark_raster.html#preparación-de-los-datos-sentinel-2a",
    "title": "10  Evaluación Comparativa de Procesamiento Geoespacial",
    "section": "10.3 Preparación de los Datos: Sentinel-2A",
    "text": "10.3 Preparación de los Datos: Sentinel-2A\nEn este ejercicio procesamos una escena de Sentinel-2A en formato .zip. En lugar de extraer el archivo (lo cual duplicaría el espacio en disco a casi 2GB), usamos el driver VSI (Virtual Systems Interface) de GDAL.\n\nAnatomía de la Imagen\nLa imagen Sentinel-2 se organiza por bandas. Para este benchmark usaremos la Banda 4 (Red), fundamental para el cálculo de índices de vegetación como el NDVI.\n\n\n\nBanda\nResolución\nLongitud de Onda\nUso\n\n\n\n\nB02 (Blue)\n10m\n490 nm\nMapeo de aguas, suelos\n\n\nB03 (Green)\n10m\n560 nm\nVigor de vegetación\n\n\nB04 (Red)\n10m\n665 nm\nAbsorción de clorofila\n\n\nB08 (NIR)\n10m\n842 nm\nBiomasa, salud foliar\n\n\n\n\nDescubrir la Ruta de la Imagen Sentinel-2\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\n# Código en R\n\nlibrary(starsdata)\nlibrary(terra)\nlibrary(stars)\nlibrary(reticulate)\n\n# 1. Localización del ZIP dentro del paquete starsdata\nf &lt;- \"sentinel/S2A_MSIL1C_20180220T105051_N0206_R051_T32ULE_20180221T134037.zip\"\ngranule &lt;- system.file(file = f, package = \"starsdata\")\ngranule\n\n# 2. Construcción de la ruta Virtual de GDAL (/vsizip/)\n# Rompemos la cadena en varias líneas para que LaTeX pueda procesarla\nbase_name &lt;- strsplit(basename(granule), \".zip\")[[1]]\nbase_name\n\n\n# Esta ruta permite leer directamente el XML de metadatos dentro del ZIP sin descomprimir.\n#s2_path &lt;- paste0(\"SENTINEL2_L1C:/vsizip/\", granule, \"/\", base_name, \".SAFE/MTD_MSIL1C.xml:10m:EPSG_32632\")\ns2_path &lt;- paste0(\n  \"SENTINEL2_L1C:/vsizip/\", \n  granule, \n  \"/\", \n  base_name, \n  \".SAFE/MTD_MSIL1C.xml:10m:EPSG_32632\"\n)\n#s2_path\n\n# Mostramos el resultado sin comillas ni índices [1] para el libro\ncat(\"Ruta generada:\", s2_path, fill = TRUE)\n\n# Guardamos la ruta en un archivo compartido para que Python y Julia la lean\nwriteLines(s2_path, \"s2_shared_path.txt\")\n\n\n\n\n\n\nCódigo\nlibrary(starsdata)\nlibrary(terra)\n\n\nterra 1.8.93\n\n\n\nAttaching package: 'terra'\n\n\nThe following object is masked from 'package:grid':\n\n    depth\n\n\nCódigo\nlibrary(stars)\n\n\nLoading required package: abind\n\n\nLoading required package: sf\n\n\nLinking to GEOS 3.12.1, GDAL 3.8.4, PROJ 9.4.0; sf_use_s2() is TRUE\n\n\nCódigo\nlibrary(reticulate)\n\n# 1. Localización del ZIP dentro del paquete starsdata\nf &lt;- \"sentinel/S2A_MSIL1C_20180220T105051_N0206_R051_T32ULE_20180221T134037.zip\"\ngranule &lt;- system.file(file = f, package = \"starsdata\")\ngranule\n\n\n[1] \"/usr/local/lib/R/site-library/starsdata/sentinel/S2A_MSIL1C_20180220T105051_N0206_R051_T32ULE_20180221T134037.zip\"\n\n\nCódigo\nbase_name &lt;- strsplit(basename(granule), \".zip\")[[1]]\nbase_name\n\n\n[1] \"S2A_MSIL1C_20180220T105051_N0206_R051_T32ULE_20180221T134037\"\n\n\nCódigo\n# 2. Construcción de la ruta Virtual de GDAL (/vsizip/)\n# Esta ruta permite leer directamente el XML de metadatos dentro del ZIP sin descomprimir.\ns2_path &lt;- paste0(\"SENTINEL2_L1C:/vsizip/\", granule, \"/\", base_name, \".SAFE/MTD_MSIL1C.xml:10m:EPSG_32632\")\ns2_path\n\n\n[1] \"SENTINEL2_L1C:/vsizip//usr/local/lib/R/site-library/starsdata/sentinel/S2A_MSIL1C_20180220T105051_N0206_R051_T32ULE_20180221T134037.zip/S2A_MSIL1C_20180220T105051_N0206_R051_T32ULE_20180221T134037.SAFE/MTD_MSIL1C.xml:10m:EPSG_32632\"\n\n\nCódigo\n# Guardamos la ruta en un archivo compartido para que Python y Julia la lean\nwriteLines(s2_path, \"s2_shared_path.txt\")",
    "crumbs": [
      "Prácticas",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Evaluación Comparativa de Procesamiento Geoespacial</span>"
    ]
  },
  {
    "objectID": "41-practica_1_benchmark_raster.html#metodología-de-la-evaluación-comparativa-benchmarking",
    "href": "41-practica_1_benchmark_raster.html#metodología-de-la-evaluación-comparativa-benchmarking",
    "title": "10  Evaluación Comparativa de Procesamiento Geoespacial",
    "section": "10.4 Metodología de la evaluación comparativa (benchmarking)",
    "text": "10.4 Metodología de la evaluación comparativa (benchmarking)\nEste experimento evalúa el rendimiento de cuatro motores geoespaciales ampliamente utilizados —terra (R), stars (R), rasterio (Python) y Rasters.jl (Julia)— frente a una operación numéricamente simple pero computacionalmente exigente sobre datos raster de gran tamaño.\nEl flujo de trabajo consiste en:\n\nApertura del archivo raster Sentinel-2.\nSelección de una sola banda (B4).\nAplicación de una operación aritmética escalar.\nCálculo de la media global (mean), que fuerza la evaluación completa del raster.\n\nA diferencia de benchmarks centrados en materialización explícita, este experimento utiliza la operación mean() como operación común de evaluación, permitiendo que cada motor ejecute el cálculo conforme a su propio modelo interno de ejecución (lazy vs eager).\n\n\nDimensión del problema\nUna banda Sentinel-2 a 10 m de resolución contiene:\n\\[10.980 \\times 10.980 = 120.560.400 \\text{ píxeles}\\]\nAsumiendo datos en punto flotante de 32 bits (4 bytes), el volumen teórico mínimo es:\n\\[120.560.400 \\times 4 \\approx 482{,}24 \\text{ MB}\\]\nEste tamaño excede ampliamente la caché de CPU, por lo que el experimento está dominado por I/O, acceso a memoria y eficiencia de recorrido, no por complejidad algorítmica.\n\n\n\nExclusiones deliberadas\n\nLa generación de gráficos (plotting) se ejecuta fuera del bloque cronometrado.\nEl tiempo de renderizado y escritura en disco no refleja la velocidad de procesamiento numérico.\nEn Julia, se realiza una ejecución previa (warm-up) para excluir el costo de compilación Just-In-Time (JIT) del tiempo reportado.\nEn Python y R, el código numérico crítico se ejecuta en librerías ya compiladas (GDAL, NumPy, C/C++), por lo que no existe un costo de compilación comparable. Cualquier efecto de “calentamiento” en estos casos se limita a inicialización de librerías y caché de disco, y no altera de forma significativa los tiempos medidos.\n\n\n\n\nEtapas del proceso evaluado\n\n\n\n\n\n\n\n\nEtapa\nDescripción técnica\nImplementación por motor\n\n\n\n\n1. Apertura del dataset\nLectura de metadatos y establecimiento de conexión al raster (sin carga completa a RAM)\nR / terra: rast()  R / stars: read_stars(proxy = TRUE)  Python / rasterio: rasterio.open()  Julia / ArchGDAL + Rasters.jl: ArchGDAL.read()\n\n\n2. Selección de banda B4\nReferencia a la banda espectral sin materializar todos los píxeles\nR / terra: r[[1]]  R / stars: s[,,,1]  Python / rasterio: src.read(1)  Julia / Rasters.jl: Raster(ds)[Band(1)]\n\n\n3. Operación aritmética escalar\nMultiplicación de cada píxel por un factor constante (1.5)\nR / terra: b4 * 1.5  R / stars: b4 * 1.5  Python / NumPy: b4 * 1.5  Julia / Rasters.jl: r .* 1.5\n\n\n4. Reducción global (mean)\nCálculo de la media global, forzando el recorrido completo del raster\nR / terra: global(res_terra, \"mean\", na.rm = TRUE)[1, 1] (streaming)  R / stars: mean(as.vector(res_mem[[1]]), na.rm = TRUE) (tras materialización explícita)  Python / NumPy: res.mean() (array ya en RAM)  Julia / Rasters.jl: mean(res) (streaming lazy)\n\n\n\n\n\n\nInterpretación clave del paso de reducción (mean)\nEl cálculo de la media es fundamental porque:\n\nObliga a recorrer todos los píxeles del raster.\nGarantiza que la operación aritmética fue realmente ejecutada.\nPermite forzar la evaluación completa del flujo de cálculo sin introducir operaciones adicionales.\n\nNo obstante, cada motor implementa este paso de forma distinta: algunos realizan la reducción en streaming sin materializar el raster completo, mientras que otros requieren una materialización explícita en memoria. Estas diferencias responden a decisiones de diseño propias de cada librería y constituyen una limitación inevitable de la comparación.\n\n\n\nDiferencias estructurales entre motores\nCada motor está optimizado para un tipo distinto de análisis. terra y rasterio están especialmente afinados para cálculos numéricos simples sobre grandes volúmenes de datos, mientras que stars y Rasters.jl priorizan flexibilidad y modelos de datos más generales, lo cual puede afectar el rendimiento en operaciones simples como una media global.\n\n\n\n\n\n\n\n\nMotor\n¿Cómo trabaja internamente?\n¿Qué implica en este benchmark?\n\n\n\n\nterra (R)\nUsa archivos raster “por referencia” y hace los cálculos en C++\nRecorre el raster una sola vez de forma muy eficiente\n\n\nstars (R)\nManeja los datos como cubos multidimensionales con mucha información espacial\nEs más flexible, pero la media global es más lenta por el manejo de metadatos\n\n\nrasterio (Python)\nCarga la banda completa en un arreglo NumPy\nLos datos quedan contiguos en memoria y se procesan muy rápido\n\n\nRasters.jl (Julia)\nEvalúa las operaciones paso a paso y por bloques\nEs muy general, pero en este caso introduce más sobrecarga\n\n\n\n\n\n\nLimitaciones inevitables del benchmarking\nEste benchmark no mide qué lenguaje es “más rápido”, sino cómo funciona todo el conjunto de herramientas que usa cada uno (librerías, forma de leer datos y manera de calcular).\nEn particular:\n\nPython (rasterio) es muy rápido porque lee la banda completa en memoria y usa arreglos NumPy optimizados.\nterra (R) está muy bien optimizado para hacer operaciones matemáticas sobre rasters usando código en C++.\nstars (R) se enfoca en manejar bien la información espacial y los metadatos, lo que hace más lenta una media global.\nJulia (Rasters.jl) está pensado para análisis espaciales más generales y flexibles, no para un único cálculo masivo como en NumPy.\n\nPor eso, estos resultados deben interpretarse así:\n\nMiden el rendimiento para una tarea específica (leer un raster y calcular una media),\nNo un ranking general de lenguajes de programación.\n\n\n\nInterpretación del benchmark\nEste benchmark representa un caso extremo y muy simplificado:\n\nSe utiliza una sola banda raster.\nSe aplica una operación matemática trivial (multiplicación escalar).\nSe calcula una única media global.\n\nPor lo tanto, no evalúa:\n\nAnálisis con múltiples bandas.\nOperaciones espaciales complejas (vecindarios, máscaras, reproyecciones).\nFlujos de trabajo largos, iterativos o modelos estadísticos.\n\nEl objetivo no es declarar un “lenguaje ganador”, sino entender los costos reales de: - leer los datos, - manejar las abstracciones, - y calcular una estadística global.\n\n¿Qué significa “manejar las abstracciones”?\nLas abstracciones son capas de software que facilitan el trabajo del usuario.\nEstas capas se encargan de:\n\nLeer los datos de forma segura.\nMantener la información espacial (coordenadas, resolución, extensión).\nCoordinar las operaciones sin que el usuario controle cada paso.\n\nAunque hacen el código más claro y seguro, introducen un costo adicional, que se vuelve visible en operaciones simples y masivas, como una reducción global (mean).\n\n\nNivel de abstracción por motor\n\n\n\n\n\n\n\n\nMotor / librería\nNivel de abstracción\nForma de trabajar (idea intuitiva)\n\n\n\n\nPython / rasterio + NumPy\nBaja\n“Aquí tienes un arreglo de números en memoria, hagamos cuentas rápido”\n\n\nR / terra\nMedia\n“Yo manejo el raster y optimizo las operaciones por ti”\n\n\nR / stars\nAlta\n“Además de los valores, manejo dimensiones, tiempo, atributos y geometría”\n\n\nJulia / Rasters.jl\nFlexible\n“Construyo un flujo de operaciones que se evalúa cuando es necesario”\n\n\n\nIdea clave:\n&gt; A mayor nivel de abstracción, mayor comodidad y expresividad para el usuario,\n&gt; pero también mayor costo computacional en operaciones simples como una media global.",
    "crumbs": [
      "Prácticas",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Evaluación Comparativa de Procesamiento Geoespacial</span>"
    ]
  },
  {
    "objectID": "41-practica_1_benchmark_raster.html#análisis-de-rendimiento-y-paralelismo",
    "href": "41-practica_1_benchmark_raster.html#análisis-de-rendimiento-y-paralelismo",
    "title": "10  Evaluación Comparativa de Procesamiento Geoespacial",
    "section": "10.5 Análisis de Rendimiento y Paralelismo",
    "text": "10.5 Análisis de Rendimiento y Paralelismo\n\nBenchmark en Python vs. Julia\n\n🐍 Python (Rasterio)⚡ Julia (Rasters.jl)\n\n\nrasterio es la navaja suiza de Python para rasters. Al combinarse con NumPy, utiliza instrucciones SIMD que paralelizan el cálculo a nivel de procesador (vectorización), aunque la lectura de GDAL sigue siendo monohilo.\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\n# Código en Python\nimport rasterio\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport time\nimport gc\n\n# ------------------------------------------------\n# 1. Leer ruta compartida\n# ------------------------------------------------\nwith open(\"s2_shared_path.txt\", \"r\") as f:\n    s2_path = f.read().strip()\n\n# ------------------------------------------------\n# 2. WARM-UP (compila + cachea)\n# ------------------------------------------------\nwith rasterio.open(s2_path) as src:\n    _ = (src.read(1) * 1.5).mean()\n\ngc.collect()\n\n# ------------------------------------------------\n# 3. BENCHMARK REAL\n# ------------------------------------------------\nt0 = time.perf_counter()\n\nwith rasterio.open(s2_path) as src:\n    b4 = src.read(1)          # lectura banda 4\n    res = b4 * 1.5            # operación\n    m_py = res.mean()         # FORZADO REAL\n\nt_python = time.perf_counter() - t0\n\nprint(f\"🐍 Python: {t_python:.3f} seg | mean = {m_py:.6f}\")\n\n# ------------------------------------------------\n# 4. Plot (FUERA DEL BENCHMARK)\n# ------------------------------------------------\nplt.imshow(res, cmap=\"terrain\")\nplt.title(\"Python: Banda 4 × 1.5\")\nplt.axis(\"off\")\nplt.show()\n\n# ------------------------------------------------\n# 5. Limpieza\n# ------------------------------------------------\ndel b4, res\n#gc.collect()\n\n\n\n\n\n\nCódigo\nimport rasterio\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport time\nimport gc\n\n# ------------------------------------------------\n# 1. Leer ruta compartida\n# ------------------------------------------------\nwith open(\"s2_shared_path.txt\", \"r\") as f:\n    s2_path = f.read().strip()\n\n# ------------------------------------------------\n# 2. WARM-UP (compila + cachea)\n# ------------------------------------------------\nwith rasterio.open(s2_path) as src:\n    _ = (src.read(1) * 1.5).mean()\n\ngc.collect()\n\n\n480\n\n\nCódigo\n# ------------------------------------------------\n# 3. BENCHMARK REAL\n# ------------------------------------------------\nt0 = time.perf_counter()\n\nwith rasterio.open(s2_path) as src:\n    b4 = src.read(1)          # lectura banda 4\n    res = b4 * 1.5            # operación\n    m_py = res.mean()         # FORZADO REAL\n\nt_python = time.perf_counter() - t0\n\nprint(f\"🐍 Python: {t_python:.3f} seg | mean = {m_py:.6f}\")\n\n\n🐍 Python: 2.581 seg | mean = 3766.624630\n\n\nCódigo\n# ------------------------------------------------\n# 4. Plot (FUERA DEL BENCHMARK)\n# ------------------------------------------------\nplt.imshow(res, cmap=\"terrain\")\n\n\n&lt;matplotlib.image.AxesImage object at 0x7fbc3386b8f0&gt;\n\n\nCódigo\nplt.title(\"Python: Banda 4 × 1.5\")\n\n\nText(0.5, 1.0, 'Python: Banda 4 × 1.5')\n\n\nCódigo\nplt.axis(\"off\")\n\n\n(np.float64(-0.5), np.float64(10979.5), np.float64(10979.5), np.float64(-0.5))\n\n\nCódigo\nplt.show()\n\n\n\n\n\n\n\n\n\nCódigo\n\n# ------------------------------------------------\n# 5. Limpieza\n# ------------------------------------------------\ndel b4, res\n#gc.collect()\n\n\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\n# Código en R\n# Aquí es donde creamos t_python para R de la variable t_python en Python. Lo necesitamos en R para la tabla final.\n# Extraemos el valor desde el objeto 'py'\nt_python &lt;- py$t_python\n#t_python &lt;- 0\n\ncat(\"🐍 Tiempo capturado de Python:\", round(t_python, 3), \"seg.\")\n\n\n\n\n\n\nCódigo\n# Aquí es donde creamos t_python para R de la variable t_python en Python. Lo necesitamos en R para la tabla final.\n# Extraemos el valor desde el objeto 'py'\nt_python &lt;- py$t_python\n#t_python &lt;- 0\n\ncat(\"🐍 Tiempo capturado de Python:\", round(t_python, 3), \"seg.\")\n\n\n🐍 Tiempo capturado de Python: 2.581 seg.\n\n\n\n\nJulia es el único de los cuatro motores evaluados que puede explotar paralelismo multihilo en esta operación específica, sin recurrir a librerías externas adicionales, aprovechando los núcleos asignados al contenedor.\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\n# Código en Julia\nusing Rasters, ArchGDAL, Statistics, Plots\n\n# Evita restricciones artificiales de memoria\nRasters.checkmem!(false)\n\n# ------------------------------------------------\n# 1. Leer ruta compartida\n# ------------------------------------------------\npath = strip(read(\"s2_shared_path.txt\", String))\n\n# ------------------------------------------------\n# 2. FUNCIÓN DE BENCHMARK (proxy + mean)\n# ------------------------------------------------\nfunction process_band_mean(path)\n    ArchGDAL.read(path) do ds\n        r   = Raster(ds)[Band(1)]   # proxy, solo banda 4\n        res = r .* 1.5              # operación lazy\n        return mean(res)            # FORZADO REAL (streaming)\n    end\nend\n\n# ------------------------------------------------\n# 3. WARM-UP (compilación)\n# ------------------------------------------------\nprocess_band_mean(path)\nGC.gc()\n\n# ------------------------------------------------\n# 4. BENCHMARK REAL\n# ------------------------------------------------\nt0 = time_ns()\nm_julia = process_band_mean(path)\nt1 = time_ns()\n\nt_julia = (t1 - t0) / 1e9\n\nprintln(\"🟣 Julia: \", round(t_julia, digits=3), \" seg | mean = \", round(m_julia, digits=6))\n\n\n# ------------------------------------------------\n# 5. Plot (FUERA DEL BENCHMARK, proxy)\n# ------------------------------------------------\nArchGDAL.read(path) do ds\n    r   = Raster(ds)[Band(1)]\n    res = r .* 1.5\n    p = plot(res, colormap = :terrain,\n         title = \"Julia: Banda 4 × 1.5\")\n    savefig(p, \"julia_plot.png\")\nend\n\n# Debe ser la última para que j_eval en R capture solo el número\nt_julia\n\n\n\n\n\n\nCódigo\n# 1. Desde R, llamamos a julia con j_eval (la función al inicio de este archivo o en el Rprofile)\n# Ejecutamos dos veces: \n#   la primera compila \"costo de arranque\" (JIT), \n#   la segunda mide el tiempo\n\nt_julia &lt;- j_eval('\nusing Rasters, ArchGDAL, Statistics, Plots\n\n# Evita restricciones artificiales de memoria\nRasters.checkmem!(false)\n\n# ------------------------------------------------\n# 1. Leer ruta compartida\n# ------------------------------------------------\npath = strip(read(\"s2_shared_path.txt\", String))\n\n# ------------------------------------------------\n# 2. FUNCIÓN DE BENCHMARK (proxy + mean)\n# ------------------------------------------------\nfunction process_band_mean(path)\n    ArchGDAL.read(path) do ds\n        r   = Raster(ds)[Band(1)]   # proxy, solo banda 4\n        res = r .* 1.5              # operación lazy\n        return mean(res)            # FORZADO REAL (streaming)\n    end\nend\n\n# ------------------------------------------------\n# 3. WARM-UP (compilación)\n# ------------------------------------------------\nprocess_band_mean(path)\nGC.gc()\n\n# ------------------------------------------------\n# 4. BENCHMARK REAL\n# ------------------------------------------------\nt0 = time_ns()\nm_julia = process_band_mean(path)\nt1 = time_ns()\n\nt_julia = (t1 - t0) / 1e9\n\nprintln(\"🟣 Julia: \", round(t_julia, digits=3), \" seg | mean = \", round(m_julia, digits=6))\n\n\n# ------------------------------------------------\n# 5. Plot (FUERA DEL BENCHMARK, proxy)\n# ------------------------------------------------\nArchGDAL.read(path) do ds\n    r   = Raster(ds)[Band(1)]\n    res = r .* 1.5\n    p = plot(res, colormap = :terrain,\n         title = \"Julia: Banda 4 × 1.5\")\n    savefig(p, \"julia_plot.png\")\nend\n\n# Debe ser la última para que j_eval en R capture solo el número\nt_julia\n')\n\n\nStarting Julia ...\n\n\njulia&gt; using Rasters, ArchGDAL, Statistics, Plots\n\njulia&gt; # Evita restricciones artificiales de memoria\n\njulia&gt; Rasters.checkmem!(false)\nfalse\n\njulia&gt; # ------------------------------------------------\n\njulia&gt; # 1. Leer ruta compartida\n\njulia&gt; # ------------------------------------------------\n\njulia&gt; path = strip(read(\"s2_shared_path.txt\", String))\n\"SENTINEL2_L1C:/vsizip//usr/local/lib/R/site-library/starsdata/sentinel/S2A_MSIL1C_20180220T105051_N0206_R051_T32ULE_20180221T134037.zip/S2A_MSIL1C_20180220T105051_N0206_R051_T32ULE_20180221T134037.SAFE/MTD_MSIL1C.xml:10m:EPSG_32632\"\n\njulia&gt; # ------------------------------------------------\n\njulia&gt; # 2. FUNCIÓN DE BENCHMARK (proxy + mean)\n\njulia&gt; # ------------------------------------------------\n\njulia&gt; function process_band_mean(path)\n    ArchGDAL.read(path) do ds\n        r   = Raster(ds)[Band(1)]   # proxy, solo banda 4\n        res = r .* 1.5              # operación lazy\n        return mean(res)            # FORZADO REAL (streaming)\n    end\nend\nprocess_band_mean (generic function with 1 method)\n\njulia&gt; # ------------------------------------------------\n\njulia&gt; # 3. WARM-UP (compilación)\n\njulia&gt; # ------------------------------------------------\n\njulia&gt; process_band_mean(path)\n3766.6246303263756\n\njulia&gt; GC.gc()\n\njulia&gt; # ------------------------------------------------\n\njulia&gt; # 4. BENCHMARK REAL\n\njulia&gt; # ------------------------------------------------\n\njulia&gt; t0 = time_ns()\n0x000011a36a637f46\n\njulia&gt; m_julia = process_band_mean(path)\n3766.6246303263756\n\njulia&gt; t1 = time_ns()\n0x000011a6191eba41\n\njulia&gt; t_julia = (t1 - t0) / 1e9\n11.521440507\n\njulia&gt; println(\"🟣 Julia: \", round(t_julia, digits=3), \" seg | mean = \", round(m_julia, digits=6))\n🟣 Julia: 11.521 seg | mean = 3766.62463\n\njulia&gt; # ------------------------------------------------\n\njulia&gt; # 5. Plot (FUERA DEL BENCHMARK, proxy)\n\njulia&gt; # ------------------------------------------------\n\njulia&gt; ArchGDAL.read(path) do ds\n    r   = Raster(ds)[Band(1)]\n    res = r .* 1.5\n    p = plot(res, colormap = :terrain,\n         title = \"Julia: Banda 4 × 1.5\")\n    savefig(p, \"julia_plot.png\")\nend\n\"/home/rstudio/work/01_prog_sig/julia_plot.png\"\n\njulia&gt; # Debe ser la última para que j_eval en R capture solo el número\n\njulia&gt; t_julia\n11.521440507\n\n\nCódigo\n# 2. R muestra la imagen guardada por Julia en el HTML\nknitr::include_graphics(\"julia_plot.png\")\n\n\n\n\n\nProcesamiento de alta resolución en Julia\n\n\n\n\nCódigo\n# 3. Impresión desde R\nprint(paste(\"⚡ Tiempo capturado en R:\", t_julia, \" seg.\"))\n\n\n[1] \"⚡ Tiempo capturado en R: 11.521440507  seg.\"\n\n\n\n\n\n\n\nBenchmark en R: Terra vs Stars\n\n🏁 R: terra🌟 R: stars\n\n\nterra está desarrollado sobre C++. Su fortaleza es la velocidad de lectura y el manejo de memoria mediante punteros externos. Paralelismo: Para esta tarea (operación escalar), terra trabaja de forma secuencial (monohilo), confiando en la optimización de sus bucles en C++.\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\n# Código en R\nlibrary(terra)\n# ------------------------------------------------\n# 0. Inicio del cronómetro\n# ------------------------------------------------\nt0 &lt;- Sys.time()\n\n# ------------------------------------------------\n# 1. Abrir raster en modo proxy (NO RAM)\n# ------------------------------------------------\nr &lt;- rast(s2_path)\n\n# ------------------------------------------------\n# 2. Seleccionar solo la banda 4 (sigue siendo proxy)\n# ------------------------------------------------\nb4 &lt;- r[[1]]\n\n# ------------------------------------------------\n# 3. Operación aritmética (lazy)\n# ------------------------------------------------\nres_terra &lt;- b4 * 1.5\n\n# ------------------------------------------------\n# 4. FORZADO REAL (streaming, sin materializar)\n# ------------------------------------------------\nm_terra &lt;- global(res_terra, \"mean\", na.rm = TRUE)[1, 1]\n\n# ------------------------------------------------\n# 5. Tiempo total\n# ------------------------------------------------\nt_terra &lt;- as.numeric(Sys.time() - t0)\n\ncat(\"🟤 Terra:\",\n    round(t_terra, 3), \"seg |\",\n    \"mean =\", round(m_terra, 6), \"\\n\")\n\n# ------------------------------------------------\n# 6. Plot (FUERA DEL BENCHMARK, proxy)\n# ------------------------------------------------\nplot(res_terra, col = terrain.colors(100),\n     main = \"Terra: Banda 4 × 1.5\")\n\n# ------------------------------------------------\n# 7. Limpieza\n# ------------------------------------------------\nrm(r, b4, res_terra)\ngc()\n\n\n\n\n\n\nCódigo\n# library(terra)\n# ------------------------------------------------\n# 0. Inicio del cronómetro\n# ------------------------------------------------\nt0 &lt;- Sys.time()\n\n# ------------------------------------------------\n# 1. Abrir raster en modo proxy (NO RAM)\n# ------------------------------------------------\nr &lt;- rast(s2_path)\n\n# ------------------------------------------------\n# 2. Seleccionar solo la banda 4 (sigue siendo proxy)\n# ------------------------------------------------\nb4 &lt;- r[[1]]\n\n# ------------------------------------------------\n# 3. Operación aritmética (lazy)\n# ------------------------------------------------\nres_terra &lt;- b4 * 1.5\n\n\n\n|---------|---------|---------|---------|\n=========================================\n                                          \n\n\nCódigo\n# ------------------------------------------------\n# 4. FORZADO REAL (streaming, sin materializar)\n# ------------------------------------------------\nm_terra &lt;- global(res_terra, \"mean\", na.rm = TRUE)[1, 1]\n\n# ------------------------------------------------\n# 5. Tiempo total\n# ------------------------------------------------\nt_terra &lt;- as.numeric(Sys.time() - t0)\n\ncat(\"🟤 Terra:\",\n    round(t_terra, 3), \"seg |\",\n    \"mean =\", round(m_terra, 6), \"\\n\")\n\n\n🟤 Terra: 13.293 seg | mean = 3766.625 \n\n\nCódigo\n# ------------------------------------------------\n# 6. Plot (FUERA DEL BENCHMARK, proxy)\n# ------------------------------------------------\nplot(res_terra, col = terrain.colors(100),\n     main = \"Terra: Banda 4 × 1.5\")\n\n\n\n\n\n\n\n\n\nCódigo\n# ------------------------------------------------\n# 7. Limpieza\n# ------------------------------------------------\nrm(r, b4, res_terra)\ngc()\n\n\n          used  (Mb) gc trigger  (Mb) max used  (Mb)\nNcells 2611249 139.5    4975288 265.8  4975288 265.8\nVcells 5098290  38.9   10146329  77.5  8324226  63.6\n\n\n\n\nEl paquete stars está especialmente diseñado para trabajar con cubos de datos multidimensionales, como múltiples bandas, series temporales y atributos espaciales complejos. Esta capacidad lo hace muy expresivo y adecuado para análisis espaciales avanzados.\nSin embargo, cuando se utiliza proxy = FALSE, los datos se materializan completamente en la memoria de R. En rasters de gran tamaño, esto puede introducir un mayor costo computacional asociado a:\n\nLectura completa de los datos desde disco.\nCopia de grandes matrices a la memoria de R.\nGestión de metadatos espaciales y dimensionales.\n\nParalelismo: En operaciones aritméticas simples —como una multiplicación escalar seguida de una media global— ni stars ni terra garantizan paralelismo explícito por defecto. En estos casos, el procesamiento suele realizarse de forma: - Secuencial, o\n- Por bloques, dependiendo de la configuración interna del paquete y del backend utilizado (por ejemplo, GDAL).\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\n# Código en R\nlibrary(stars)\n\n# ------------------------------------------------\n# 0. Inicio del cronómetro\n# ------------------------------------------------\nt0 &lt;- Sys.time()\n\n# ------------------------------------------------\n# 1. Leer raster como proxy (NO RAM)\n# ------------------------------------------------\ns &lt;- read_stars(s2_path, proxy = TRUE)\n\n# ------------------------------------------------\n# 2. Seleccionar solo la banda 4 (proxy)\n# ------------------------------------------------\nb4 &lt;- s[,,,1]\n\n# ------------------------------------------------\n# 3. Operación aritmética (lazy)\n# ------------------------------------------------\nres_stars &lt;- b4 * 1.5\n\n# ------------------------------------------------\n# 4. FORZADO REAL (materializa la banda resultante)\n# ------------------------------------------------\nres_mem &lt;- st_as_stars(res_stars)\n\n# ------------------------------------------------\n# 5. Media escalar (ya numérica)\n# ------------------------------------------------\nm_stars &lt;- mean(as.vector(res_mem[[1]]), na.rm = TRUE)\n\n# ------------------------------------------------\n# 6. Tiempo total\n# ------------------------------------------------\nt_stars &lt;- as.numeric(Sys.time() - t0)\n\ncat(\"🌟 Stars:\",\n    round(t_stars, 3), \"seg |\",\n    \"mean =\", round(m_stars, 6), \"\\n\")\n\n# ------------------------------------------------\n# 7. Plot (FUERA DEL BENCHMARK, proxy)\n# ------------------------------------------------\nplot(res_stars, col = terrain.colors(100),\n     main = \"Stars: Banda 4 × 1.5\")\n\n# ------------------------------------------------\n# 8. Limpieza\n# ------------------------------------------------\nrm(s, b4, res_stars)\ngc()\n\n\n\n\n\n\nCódigo\n# library(stars)\n\n# ------------------------------------------------\n# 0. Inicio del cronómetro\n# ------------------------------------------------\nt0 &lt;- Sys.time()\n\n# ------------------------------------------------\n# 1. Leer raster como proxy (NO RAM)\n# ------------------------------------------------\ns &lt;- read_stars(s2_path, proxy = TRUE)\n\n# ------------------------------------------------\n# 2. Seleccionar solo la banda 4 (proxy)\n# ------------------------------------------------\nb4 &lt;- s[,,,1]\n\n# ------------------------------------------------\n# 3. Operación aritmética (lazy)\n# ------------------------------------------------\nres_stars &lt;- b4 * 1.5\n\n# ------------------------------------------------\n# 4. FORZADO REAL (materializa la banda resultante)\n# ------------------------------------------------\nres_mem &lt;- st_as_stars(res_stars)\n\n# ------------------------------------------------\n# 5. Media escalar (ya numérica)\n# ------------------------------------------------\nm_stars &lt;- mean(as.vector(res_mem[[1]]), na.rm = TRUE)\n\n# ------------------------------------------------\n# 6. Tiempo total\n# ------------------------------------------------\nt_stars &lt;- as.numeric(Sys.time() - t0)\n\ncat(\"🌟 Stars:\",\n    round(t_stars, 3), \"seg |\",\n    \"mean =\", round(m_stars, 6), \"\\n\")\n\n\n🌟 Stars: 10.04 seg | mean = 3766.625 \n\n\nCódigo\n# ------------------------------------------------\n# 7. Plot (FUERA DEL BENCHMARK, proxy)\n# ------------------------------------------------\nplot(res_stars, col = terrain.colors(100),\n     main = \"Stars: Banda 4 × 1.5\")\n\n\ndownsample set to 8\n\n\n\n\n\n\n\n\n\nCódigo\n# ------------------------------------------------\n# 8. Limpieza\n# ------------------------------------------------\nrm(s, b4, res_stars)\ngc()\n\n\n            used  (Mb) gc trigger   (Mb)  max used   (Mb)\nNcells   2662793 142.3    4975288  265.8   4975288  265.8\nVcells 127749982 974.7  562388740 4290.7 702623329 5360.6",
    "crumbs": [
      "Prácticas",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Evaluación Comparativa de Procesamiento Geoespacial</span>"
    ]
  },
  {
    "objectID": "41-practica_1_benchmark_raster.html#resultados-finales",
    "href": "41-practica_1_benchmark_raster.html#resultados-finales",
    "title": "10  Evaluación Comparativa de Procesamiento Geoespacial",
    "section": "10.6 Resultados finales",
    "text": "10.6 Resultados finales\nA continuación, se presenta la comparativa de rendimiento para procesar la Banda 4 (Red) de 10m desde el archivo comprimido original.\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\n# Código en R\nlibrary(knitr)\nlibrary(kableExtra)\n\n# Creamos el dataframe con los datos capturados\nresultados &lt;- data.frame(\n  Motor = c(\"R: terra\", \"R: stars\", \"Python: rasterio\", \"Julia: Rasters.jl\"),\n  Lenguaje = c(\"R (C++)\", \"R\", \"Python (C++/NumPy)\", \"Julia (Nativo)\"),\n  Paralelismo = c(\"Monohilo\", \"Monohilo\", \"SIMD (Vectorizado)\", \"Multihilo (12 hilos)\"),\n  Tiempo_Seg = c(t_terra, t_stars, t_python, t_julia)\n)\nresultados\n# Cálculo de eficiencia: ¿Cuántas veces es más rápido que el más lento?\nmax_t &lt;- max(resultados$Tiempo_Seg, na.rm = TRUE)\nresultados$X_mas_rapido &lt;- round(max_t / resultados$Tiempo_Seg, 2)\n\n# Formateo elegante para el HTML\nkable(resultados, \n      digits = 3, \n      caption = \"Duelo de Titanes: Procesamiento de 1GB Sentinel-2\",\n      col.names = c(\"Motor\", \"Lenguaje\", \"Paralelismo\", \"Tiempo (s)\", \"Eficiencia (X)\")) %&gt;%\n  kable_styling(bootstrap_options = c(\"striped\", \"hover\", \"condensed\"), \n                full_width = F) %&gt;%\n  row_spec(which.min(resultados$Tiempo_Seg), bold = T, color = \"white\", background = \"#2c3e50\")\n\n\n\n\n\n\n              Motor           Lenguaje          Paralelismo Tiempo_Seg\n1          R: terra            R (C++)             Monohilo  13.293477\n2          R: stars                  R             Monohilo  10.040453\n3  Python: rasterio Python (C++/NumPy)   SIMD (Vectorizado)   2.580626\n4 Julia: Rasters.jl     Julia (Nativo) Multihilo (12 hilos)  11.521441\n\n\n\n\nDuelo de Titanes: Procesamiento de 1GB Sentinel-2\n\n\nMotor\nLenguaje\nParalelismo\nTiempo (s)\nEficiencia (X)\n\n\n\n\nR: terra\nR (C++)\nMonohilo\n13.293\n1.00\n\n\nR: stars\nR\nMonohilo\n10.040\n1.32\n\n\nPython: rasterio\nPython (C++/NumPy)\nSIMD (Vectorizado)\n2.581\n5.15\n\n\nJulia: Rasters.jl\nJulia (Nativo)\nMultihilo (12 hilos)\n11.521\n1.15\n\n\n\n\n\n\n\n\nLos tiempos no deben compararse fuera del contexto de este patrón de acceso (lectura secuencial + reducción global).\n\nEl benchmark favorece motores optimizados para recorridos contiguos de memoria y reducciones monolíticas, en particular NumPy (vía rasterio en Python) y el motor C++ interno de terra en R, los cuales pueden ejecutar la operación aritmética y el cálculo estadístico en una única pasada sobre un bloque contiguo de datos en memoria.\n\nEn contraste, motores basados en evaluaciones diferidas (lazy evaluation) y procesamiento por bloques con mayor carga de metadatos, como stars en R y Rasters.jl en Julia, incurren en mayor overhead de abstracción y llamadas intermedias, lo que afecta su desempeño relativo en este escenario específico.\n\nEficiencia de Memoria: terra es el ganador aquí, ya que su gestión de objetos fuera de la RAM de R le permite manejar archivos gigantes sin colapsar.\nParalelismo Real: Solo Julia aprovecha los hilos de ejecución de la CPU para la operación matemática de forma nativa. Python usa optimización de hardware (SIMD) vía NumPy, mientras que R se mantiene secuencial pero optimizado en sus librerías de C++.\nGDAL VSI: Todos los lenguajes demostraron que el driver /vsizip/ es la forma más eficiente de interactuar con datos Sentinel-2 sin el costo de descompresión.\n\n\nJulia: paralelismo y pipelines composables\nEl potencial de paralelismo multihilo no siempre se traduce en mejores tiempos en benchmarks simples como el presente. Esto se debe a que Julia, a través de Rasters.jl, utiliza un modelo basado en pipelines composables.\nUn pipeline composable significa que las operaciones no se ejecutan inmediatamente. En su lugar, Julia construye un flujo de operaciones (lectura → selección de banda → operación aritmética → reducción) que se evalúa solo cuando se solicita un resultado final, como la media global.\nEste enfoque tiene ventajas claras en análisis complejos y encadenados, pero introduce un costo adicional de planificación y abstracción que se vuelve visible en tareas muy simples y masivas, como una única multiplicación seguida de una reducción global.\nEn otras palabras, Julia está optimizada para flujos de trabajo complejos, no para reducciones monolíticas de una sola pasada al estilo NumPy.\n\n\n\n\n\n\n\n\nHerramienta / librería\n¿Pipeline composable?\nEjemplo típico\n\n\n\n\nJulia (Rasters.jl)\n✅ Sí\nmean(r .* 1.5) → se evalúa al final\n\n\nR (dplyr + dbplyr)\n✅ Sí*\nCadena de transformaciones luego collect()\n\n\nPython (xarray + Dask)\n✅ Sí\nresult = data.mean() luego compute()\n\n\nApache Spark\n✅ Sí\nPlan de ejecución (DAG) antes de correr\n\n\nPython (rasterio + NumPy)\n❌ No\nLee y calcula todo inmediatamente\n\n\nR (terra)\n⚠️ Parcial\nOptimiza en C++ pero no expone pipeline diferido\n\n\nR (stars)\n❌ No\nproxy limitado, sin DAG composable completo\n\n\n\n* Nota sobre R (dplyr + dbplyr):\nNo es una solución espacial por sí misma. El pipeline composable existe, pero requiere un backend espacial (por ejemplo: PostGIS, DuckDB + spatial, Spark, BigQuery GIS). Sin ese backend, no aplica directamente a raster/cubos geoespaciales.\nNota sobre stars:\nAunque puede trabajar con proxy = TRUE, stars no implementa un pipeline composable tipo tidyverse, ni un DAG diferido completo. Las operaciones tienden a materializar datos relativamente pronto y no se integran con dplyr/dbplyr para optimización global del flujo.",
    "crumbs": [
      "Prácticas",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Evaluación Comparativa de Procesamiento Geoespacial</span>"
    ]
  },
  {
    "objectID": "41-practica_1_benchmark_raster.html#más-allá-del-benchmarking-optimización-y-virtualización-de-datos-geoespaciales",
    "href": "41-practica_1_benchmark_raster.html#más-allá-del-benchmarking-optimización-y-virtualización-de-datos-geoespaciales",
    "title": "10  Evaluación Comparativa de Procesamiento Geoespacial",
    "section": "10.7 Más allá del benchmarking: optimización y virtualización de datos geoespaciales",
    "text": "10.7 Más allá del benchmarking: optimización y virtualización de datos geoespaciales\nEste benchmark evalúa un caso simple y controlado, pero los proyectos reales con grandes volúmenes de datos geoespaciales rara vez dependen de un solo archivo raster leído de forma local. Hoy en día existen múltiples estrategias para optimizar el rendimiento, muchas de las cuales se basan en virtualización del acceso a datos y formatos eficientes.\nAlgunas de las principales alternativas que deben considerarse en proyectos de gran escala son:\n\nFormatos optimizados para alto volumen\n\nCloud Optimized GeoTIFF (COG)\nPermite leer solo las partes necesarias del raster mediante acceso por bloques y overviews, sin descargar el archivo completo.\nZarr / GeoZarr\nFormato orientado a datos multidimensionales y computación distribuida. Muy eficiente para acceso parcial, paralelismo y almacenamiento en la nube.\nGeoParquet\nFormato columnar optimizado para datos vectoriales masivos. Ideal para análisis a gran escala, consultas selectivas y procesamiento distribuido.\n\n\n\nVirtualización y acceso remoto\n\nGDAL VFS (/vsicurl/, /vsis3/, /vsiaz/)\nPermite trabajar con datos remotos como si fueran archivos locales, leyendo solo los bloques necesarios.\nSTAC (SpatioTemporal Asset Catalog)\nFacilita la búsqueda y acceso estructurado a grandes catálogos de datos espaciales distribuidos.\n\n\n\nParalelismo y ejecución distribuida\n\nProcesamiento por bloques y multihilo (GDAL, terra, rasterio)\nFrameworks distribuidos como Dask, Spark o Ray, especialmente combinados con Zarr o Parquet.\nAceleración en la nube mediante almacenamiento objeto y cómputo escalable.\n\n\n\nMensaje clave\nEste ejercicio muestra los costos mínimos inevitables de leer, abstraer y reducir datos raster. Sin embargo, la verdadera optimización en proyectos reales no suele venir de cambiar de lenguaje, sino de:\n\nElegir formatos de datos adecuados.\nMinimizar movimientos innecesarios de datos.\nAprovechar acceso parcial, paralelismo y virtualización.\nDiseñar flujos de trabajo pensados desde el inicio para grandes volúmenes.\n\nEn resumen:\n&gt; Cuando los datos crecen, la arquitectura y el formato importan tanto o más que el lenguaje.",
    "crumbs": [
      "Prácticas",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Evaluación Comparativa de Procesamiento Geoespacial</span>"
    ]
  },
  {
    "objectID": "41-practica_1_benchmark_raster.html#desafío-de-laboratorio-primer-día",
    "href": "41-practica_1_benchmark_raster.html#desafío-de-laboratorio-primer-día",
    "title": "10  Evaluación Comparativa de Procesamiento Geoespacial",
    "section": "10.8 🏁 Desafío de laboratorio: primer día",
    "text": "10.8 🏁 Desafío de laboratorio: primer día\nPara cerrar esta sesión del “Duelo de Titanes”, deberán resolver el siguiente desafío práctico.\nPueden apoyarse en herramientas de IA para investigar, pero recuerden:\n\nBuscamos precisión y evidencia, no “carreta”.\n\nEste laboratorio incluye ejecución real de código en distintos entornos.\n\n\n🛠️ Instrucciones de entrega\n\nCreen un nuevo repositorio en su GitHub personal llamado taller1-sig.\nTodas las respuestas escritas deben estar en un archivo respuestas.qmd.\nRendericen respuestas.qmd a HTML y PDF.\nSuban al repositorio:\n\nrespuestas.qmd\nrespuestas.html\nrespuestas.pdf\nLos notebooks y scripts solicitados (ver abajo).\n\n\n\n\n\n⚙️ Parte A — Ejecución en JupyterLab (notebooks)\nEjecuten los cuatro procesos del benchmark desde JupyterLab, usando el kernel adecuado para cada lenguaje.\n\n📒 Notebooks obligatorios\nCreen los siguientes notebooks:\n\n01_benchmark_terra.ipynb\n\n02_benchmark_stars.ipynb\n\n03_benchmark_rasterio.ipynb\n\n04_benchmark_rasters_julia.ipynb\n\nCada notebook debe:\n\nLeer el raster\nAplicar la operación matemática (× 1.5)\nCalcular la media global\nImprimir el tiempo total de ejecución\n\n📌 Entrega: - Suban los cuatro notebooks al repositorio. - En respuestas.qmd, incluyan: - El tiempo reportado por cada motor - Una breve observación (1–2 líneas) por notebook\n\n\n\n\n🖥️ Parte B — Ejecución desde VSCode (terminal integrada)\nAhora repitan el benchmark fuera de Jupyter, usando la terminal integrada de VSCode.\n\n📄 Scripts obligatorios\nCreen los siguientes archivos:\n\nbenchmark_terra.R\nbenchmark_stars.R\nbenchmark_rasterio.py\nbenchmark_rasters.jl\n\nCada script debe:\n\nLeer el raster\nEjecutar la operación\nCalcular la media global\nImprimir:\n\nEl tiempo total\nEl valor de la media\n\n\n\n\n▶️ Ejecución esperada\nDesde la terminal de VSCode:\nRscript benchmark_terra.R\nRscript benchmark_stars.R\npython3 benchmark_rasterio.py\njulia benchmark_rasters.jl\n📌 Entrega: - Suban los cuatro scripts al repositorio. - Reporten los tiempos obtenidos en respuestas.qmd.\n\n\n\n\n🪟 Parte C — Ejecución desde el Termina de Windows (PowerShell)\nFinalmente, ejecuten los procesos sin usar VSCode ni Jupyter, directamente desde Windows Terminal (PowerShell), trabajando con Docker.\nPueden usar una o ambas opciones.\n\n\nOpción 1️⃣ — Entrando al intérprete\nEjemplos:\ndocker exec -it contenedor_sig_unal R\ndocker exec -it contenedor_sig_unal python3\ndocker exec -it contenedor_sig_unal julia\nY luego ejecutar el script correspondiente dentro del intérprete.\n\n\n\nOpción 2️⃣ — Ejecución directa\nEjemplos:\ndocker exec contenedor_sig_unal Rscript benchmark_terra.R\ndocker exec contenedor_sig_unal Rscript benchmark_stars.R\ndocker exec contenedor_sig_unal python3 benchmark_rasterio.py\ndocker exec contenedor_sig_unal julia benchmark_rasters.jl\n📌 Entrega: - Indiquen en respuestas.qmd: - Qué opción usaron - Los tiempos obtenidos - Si notaron diferencias frente a JupyterLab o VSCode\n\n\n\n\n❓ Preguntas de análisis\n\n1. 📍 Entorno de ejecución\n¿Notaron diferencias de tiempo entre:\n\nJupyterLab\n\nVSCode (terminal integrada)\n\nWindows Terminal (PowerShell)\n\nDen una razón técnica posible (overhead del kernel, entorno, proceso, etc.).\n\n\n\n2. 🧱 Abstracción en la práctica\n¿En qué motor creen que el costo de las abstracciones es más visible?\nRelacionen su respuesta con los tiempos observados.\n\n\n3. 🔥 Julia y el costo de compilación (Warm-up)\n¿El efecto del warm-up de Julia se notó más en algún entorno específico?\nExpliquen brevemente por qué.\n\n\n\n4. 🧠 Elección informada\nDespués de ejecutar el benchmark en tres entornos distintos,\n¿cambiarían su elección del “Titán” para una emergencia ambiental real?\nJustifiquen en máximo 5 líneas.\n\n\n💡 Nota para el éxito\nEste laboratorio no busca que memoricen comandos,\nsino que entiendan que el rendimiento depende del stack completo: lenguaje, librerías, entorno y forma de ejecución.",
    "crumbs": [
      "Prácticas",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Evaluación Comparativa de Procesamiento Geoespacial</span>"
    ]
  },
  {
    "objectID": "41-practica_1_benchmark_raster.html#limpieza-de-recursos",
    "href": "41-practica_1_benchmark_raster.html#limpieza-de-recursos",
    "title": "10  Evaluación Comparativa de Procesamiento Geoespacial",
    "section": "10.9 Limpieza de recursos",
    "text": "10.9 Limpieza de recursos\n\n\n\n\n\n\n▷ CÓDIGO PURO (Copiar y Pegar)\n\n\n\n\n\n\n# Código en R\n# Eliminar variables\n#rm(res_terra, res_stars, r, s)\n\n# Liberar memoria RAM\ngc()\n\n# Borrar archivo con la ruta\nif(file.exists(\"s2_shared_path.txt\")) file.remove(\"s2_shared_path.txt\")",
    "crumbs": [
      "Prácticas",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Evaluación Comparativa de Procesamiento Geoespacial</span>"
    ]
  },
  {
    "objectID": "61-presentacion_1_clase1.html",
    "href": "61-presentacion_1_clase1.html",
    "title": "11  Temas por Charlar",
    "section": "",
    "text": "11.1 Clase 1: Instalación y uso básico del software",
    "crumbs": [
      "Presentaciones",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Temas por Charlar</span>"
    ]
  },
  {
    "objectID": "61-presentacion_1_clase1.html#clase-1-instalación-y-uso-básico-del-software",
    "href": "61-presentacion_1_clase1.html#clase-1-instalación-y-uso-básico-del-software",
    "title": "11  Temas por Charlar",
    "section": "",
    "text": "Docker Desktop\n\n\nInstalar nuestros contenedores\n\n\nVSCode + Extensiones (dentro del nuestros contenerores)\n\n\nGit + GitHub\n\n\nAcceso a Jupyter Lab\n\n\nCreación de archivos Quarto (*.qmd): HTML & PDF\n\n\nOSGeo4W (QGIS) - QGIS + GEE (Pixi)\n\n\nChequeo ArcGIS Pro",
    "crumbs": [
      "Presentaciones",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Temas por Charlar</span>"
    ]
  },
  {
    "objectID": "61-presentacion_1_clase1.html#syllabus-anterior---contenido",
    "href": "61-presentacion_1_clase1.html#syllabus-anterior---contenido",
    "title": "11  Temas por Charlar",
    "section": "11.2 Syllabus anterior - Contenido",
    "text": "11.2 Syllabus anterior - Contenido\n\n\nPrincipios de Programación.\n\n\nFundamentos de Python.\n\n\nMarcos de Datos.\n\n\nProgramación Orientada a Objetos.\n\n\nPython y PostgreSQL.\n\n\nLibrerías Geoespaciales.\n\n\nArcGIS.\n\n\n👉 Necesitamos modificarlo.",
    "crumbs": [
      "Presentaciones",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Temas por Charlar</span>"
    ]
  },
  {
    "objectID": "61-presentacion_1_clase1.html#syllabus-anterior---estructura",
    "href": "61-presentacion_1_clase1.html#syllabus-anterior---estructura",
    "title": "11  Temas por Charlar",
    "section": "11.3 Syllabus anterior - Estructura",
    "text": "11.3 Syllabus anterior - Estructura\n\n\nExposiciones del Profesor.\n\n\nTeoría.\nPráctica.\n\n\nTrabajos en Grupo.\n\n\nExposiciones de los Estudiantes.\n\n\nLecturas.\n\n\nPrácticas.\n\n\nTrabajo Final.\n\n\n👉 Necesitamos concretarlo y asignar porcentajes.",
    "crumbs": [
      "Presentaciones",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Temas por Charlar</span>"
    ]
  },
  {
    "objectID": "61-presentacion_1_clase1.html#propuestas-de-estudiantes-para-el-curso",
    "href": "61-presentacion_1_clase1.html#propuestas-de-estudiantes-para-el-curso",
    "title": "11  Temas por Charlar",
    "section": "11.4 Propuestas de Estudiantes para el Curso",
    "text": "11.4 Propuestas de Estudiantes para el Curso\n🎯 Tienes la palabra.",
    "crumbs": [
      "Presentaciones",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Temas por Charlar</span>"
    ]
  },
  {
    "objectID": "61-presentacion_1_clase1.html#curso-enfoque-open-science",
    "href": "61-presentacion_1_clase1.html#curso-enfoque-open-science",
    "title": "11  Temas por Charlar",
    "section": "11.5 Curso: Enfoque Open Science",
    "text": "11.5 Curso: Enfoque Open Science\n\nMaterial presentado por profesor\n\nDiapositivas\nCódigo\nTeoría\nArchivos de configuración\n\nMaterial de los estudiantes\nHTML, PDF\nGitHub",
    "crumbs": [
      "Presentaciones",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Temas por Charlar</span>"
    ]
  },
  {
    "objectID": "61-presentacion_1_clase1.html#seminario-latingeo",
    "href": "61-presentacion_1_clase1.html#seminario-latingeo",
    "title": "11  Temas por Charlar",
    "section": "11.6 Seminario LatinGeo",
    "text": "11.6 Seminario LatinGeo\n\nOrganizado por GeoCorp y UNAL.\nPresentar trabajos finales.\nPresentar temas específicos.\nAbierto al público (en línea).\nFormato Open Science.\nPuede contribuir a la nota final.\nPodemos traer invitados.\n\n🎯 LatinGeo: Python, R y Julia",
    "crumbs": [
      "Presentaciones",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Temas por Charlar</span>"
    ]
  },
  {
    "objectID": "61-presentacion_1_clase1.html#temas-para-proyecto-final",
    "href": "61-presentacion_1_clase1.html#temas-para-proyecto-final",
    "title": "11  Temas por Charlar",
    "section": "11.7 Temas para Proyecto Final",
    "text": "11.7 Temas para Proyecto Final\n\n\nGeocomputación en la Nube.\n\n\nVirtualización.\n\n\nLibrerías Geo: Pipelines Composables.\n\n\nCreación de Paquetes (R, Python, Julia).\n\n\nCreación de Extensiones.\n\n\nGitHub Actions.\n\n\nDuckDB\n\n\nGEE - GEEMAP\n\n\nTemas aplicados\n\n\n…",
    "crumbs": [
      "Presentaciones",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Temas por Charlar</span>"
    ]
  },
  {
    "objectID": "62-presentacion_2_benchmark.html",
    "href": "62-presentacion_2_benchmark.html",
    "title": "12  Benchmark geoespacial: cómo leer los resultados",
    "section": "",
    "text": "12.1 ¿Qué estamos comparando?\nEste ejercicio no compara lenguajes de programación.\nEvalúa el rendimiento del stack completo:\n👉 El lenguaje es solo una parte del sistema.",
    "crumbs": [
      "Presentaciones",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Benchmark geoespacial: cómo leer los resultados</span>"
    ]
  },
  {
    "objectID": "62-presentacion_2_benchmark.html#qué-estamos-comparando",
    "href": "62-presentacion_2_benchmark.html#qué-estamos-comparando",
    "title": "12  Benchmark geoespacial: cómo leer los resultados",
    "section": "",
    "text": "GDAL (Geospatial Data Abstraction Library): raster (GDAL) + vector (OGR: OpenGIS Simple Features Reference Implementation)\nLibrerías raster\nModelo de ejecución\nNivel de abstracción",
    "crumbs": [
      "Presentaciones",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Benchmark geoespacial: cómo leer los resultados</span>"
    ]
  },
  {
    "objectID": "62-presentacion_2_benchmark.html#qué-hace-exactamente-el-benchmark",
    "href": "62-presentacion_2_benchmark.html#qué-hace-exactamente-el-benchmark",
    "title": "12  Benchmark geoespacial: cómo leer los resultados",
    "section": "12.2 ¿Qué hace exactamente el benchmark?",
    "text": "12.2 ¿Qué hace exactamente el benchmark?\nEl benchmark ejecuta un caso extremo y muy simplificado:\n\nUsa una sola banda raster\nAplica una operación matemática simple (× 1.5)\nCalcula una media global\n\n🎯 Diseñado para forzar la lectura completa de los datos.",
    "crumbs": [
      "Presentaciones",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Benchmark geoespacial: cómo leer los resultados</span>"
    ]
  },
  {
    "objectID": "62-presentacion_2_benchmark.html#qué-no-evalúa",
    "href": "62-presentacion_2_benchmark.html#qué-no-evalúa",
    "title": "12  Benchmark geoespacial: cómo leer los resultados",
    "section": "12.3 ¿Qué NO evalúa?",
    "text": "12.3 ¿Qué NO evalúa?\nEste benchmark no evalúa:\n\nAnálisis multibanda\nOperaciones espaciales complejas\nVecindarios, máscaras o reproyecciones\nFlujos iterativos o modelos estadísticos\n\n🚫 No representa un flujo SIG real completo.",
    "crumbs": [
      "Presentaciones",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Benchmark geoespacial: cómo leer los resultados</span>"
    ]
  },
  {
    "objectID": "62-presentacion_2_benchmark.html#por-qué-usamos-mean",
    "href": "62-presentacion_2_benchmark.html#por-qué-usamos-mean",
    "title": "12  Benchmark geoespacial: cómo leer los resultados",
    "section": "12.4 ¿Por qué usamos mean()?",
    "text": "12.4 ¿Por qué usamos mean()?\nEl cálculo de la media es clave porque:\n\nObliga a recorrer todos los píxeles\nGarantiza que la operación aritmética fue ejecutada\nFuerza la evaluación completa del raster\n\n⚠️ Cada motor implementa este paso de forma distinta.",
    "crumbs": [
      "Presentaciones",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Benchmark geoespacial: cómo leer los resultados</span>"
    ]
  },
  {
    "objectID": "62-presentacion_2_benchmark.html#modelos-de-ejecución-comparados",
    "href": "62-presentacion_2_benchmark.html#modelos-de-ejecución-comparados",
    "title": "12  Benchmark geoespacial: cómo leer los resultados",
    "section": "12.5 Modelos de ejecución comparados",
    "text": "12.5 Modelos de ejecución comparados\nCada stack sigue una filosofía diferente:\n\nPython / rasterio + NumPy\nLectura completa a memoria + ejecución inmediata\nR / terra\nÁlgebra de ráster optimizado en C++ y procesamiento por bloques, pero sin exponer un pipeline diferido composable\nR / stars\nManejo de cubos de datos multidimensionales y metadatos ricos; el modo proxy difiere la lectura, pero no construye un DAG composable completo\nJulia / Rasters.jl\nFlujos lazy y pipelines composables, evaluados al final como un plan coherente",
    "crumbs": [
      "Presentaciones",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Benchmark geoespacial: cómo leer los resultados</span>"
    ]
  },
  {
    "objectID": "62-presentacion_2_benchmark.html#qué-favorece-este-benchmark",
    "href": "62-presentacion_2_benchmark.html#qué-favorece-este-benchmark",
    "title": "12  Benchmark geoespacial: cómo leer los resultados",
    "section": "12.6 ¿Qué favorece este benchmark?",
    "text": "12.6 ¿Qué favorece este benchmark?\nEste escenario favorece motores optimizados para:\n\nRecorridos contiguos de memoria\nOperaciones simples en una sola pasada\nReducciones globales monolíticas\n\n👉 No todos los motores están diseñados para este patrón.",
    "crumbs": [
      "Presentaciones",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Benchmark geoespacial: cómo leer los resultados</span>"
    ]
  },
  {
    "objectID": "62-presentacion_2_benchmark.html#abstracción-vs-rendimiento",
    "href": "62-presentacion_2_benchmark.html#abstracción-vs-rendimiento",
    "title": "12  Benchmark geoespacial: cómo leer los resultados",
    "section": "12.7 Abstracción vs rendimiento",
    "text": "12.7 Abstracción vs rendimiento\nMás abstracción implica:\n\nMás metadatos\nMás coordinación interna\nMás costo administrativo\n\nPero también ofrece:\n\nCódigo más claro\nMenos errores\nMayor expresividad analítica\n\n⚖️ Es un intercambio inevitable.",
    "crumbs": [
      "Presentaciones",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Benchmark geoespacial: cómo leer los resultados</span>"
    ]
  },
  {
    "objectID": "62-presentacion_2_benchmark.html#niveles-de-abstracción-por-motor",
    "href": "62-presentacion_2_benchmark.html#niveles-de-abstracción-por-motor",
    "title": "12  Benchmark geoespacial: cómo leer los resultados",
    "section": "12.8 Niveles de abstracción por motor",
    "text": "12.8 Niveles de abstracción por motor\n\n\n\n\n\n\n\n\nMotor\nNivel de abstracción\nForma de trabajar\n\n\n\n\nNumPy / rasterio\nBaja\n“Aquí tienes un arreglo, calcula ahora”\n\n\nterra (R)\nMedia\n“Yo optimizo internamente en C++”\n\n\nstars (R)\nAlta\n“Gestiono dimensiones, tiempo y metadatos”\n\n\nRasters.jl (Julia)\nFlexible\n“Defino un pipeline que se evalúa al final”\n\n\n\n📌 Más abstracción = más expresividad, pero más costo administrativo.",
    "crumbs": [
      "Presentaciones",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Benchmark geoespacial: cómo leer los resultados</span>"
    ]
  },
  {
    "objectID": "62-presentacion_2_benchmark.html#paralelismo-y-pipelines-composables",
    "href": "62-presentacion_2_benchmark.html#paralelismo-y-pipelines-composables",
    "title": "12  Benchmark geoespacial: cómo leer los resultados",
    "section": "12.9 Paralelismo y pipelines composables",
    "text": "12.9 Paralelismo y pipelines composables\nSolo algunos stacks permiten componer operaciones y ejecutarlas al final:\n\nJulia (Rasters.jl)\nPipelines composables + paralelismo multihilo nativo,\nsin librerías externas adicionales\nPython (xarray + Dask)\nPipelines lazy con ejecución distribuida explícita\nR (dplyr + dbplyr)\nLenguaje de pipelines, no espacial por sí mismo;\nrequiere backends como PostGIS, DuckDB o Spark\n\n📌 Optimización interna no equivale a pipeline composable.",
    "crumbs": [
      "Presentaciones",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Benchmark geoespacial: cómo leer los resultados</span>"
    ]
  },
  {
    "objectID": "62-presentacion_2_benchmark.html#no-hay-un-ganador-universal",
    "href": "62-presentacion_2_benchmark.html#no-hay-un-ganador-universal",
    "title": "12  Benchmark geoespacial: cómo leer los resultados",
    "section": "12.10 No hay un ganador universal",
    "text": "12.10 No hay un ganador universal\nEste benchmark mide:\n\nRendimiento bajo un patrón específico de acceso y reducción global\n\nNo mide:\n\nCalidad general del lenguaje\nFlexibilidad analítica\nEscalabilidad en flujos SIG complejos\n\n📍 Los resultados deben interpretarse con contexto.",
    "crumbs": [
      "Presentaciones",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Benchmark geoespacial: cómo leer los resultados</span>"
    ]
  },
  {
    "objectID": "62-presentacion_2_benchmark.html#escalando-a-datos-realmente-grandes",
    "href": "62-presentacion_2_benchmark.html#escalando-a-datos-realmente-grandes",
    "title": "12  Benchmark geoespacial: cómo leer los resultados",
    "section": "12.11 Escalando a datos realmente grandes",
    "text": "12.11 Escalando a datos realmente grandes\nEn proyectos reales con grandes volúmenes de datos se consideran:\n\nCloud Optimized GeoTIFF (COG)\nZarr\nGeoParquet\nProcesamiento por bloques\nInfraestructura virtualizada - cloud / HPC - High-Performance Computing (AWS - GCP - Azure)\n\n👉 La arquitectura de datos suele importar más que el lenguaje.",
    "crumbs": [
      "Presentaciones",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Benchmark geoespacial: cómo leer los resultados</span>"
    ]
  },
  {
    "objectID": "62-presentacion_2_benchmark.html#mensaje-final-del-benchmark",
    "href": "62-presentacion_2_benchmark.html#mensaje-final-del-benchmark",
    "title": "12  Benchmark geoespacial: cómo leer los resultados",
    "section": "12.12 Mensaje final del Benchmark",
    "text": "12.12 Mensaje final del Benchmark\nEste ejercicio sirve para:\n\nEntender costos reales de lectura y abstracción\nLeer benchmarks de forma crítica\nElegir herramientas según el problema\n\n🎯 No existe el “lenguaje más rápido”\nexiste el stack adecuado para cada tarea.",
    "crumbs": [
      "Presentaciones",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Benchmark geoespacial: cómo leer los resultados</span>"
    ]
  },
  {
    "objectID": "62-presentacion_2_benchmark.html#qué-es-lo-importante-hoy-y-qué-no",
    "href": "62-presentacion_2_benchmark.html#qué-es-lo-importante-hoy-y-qué-no",
    "title": "12  Benchmark geoespacial: cómo leer los resultados",
    "section": "12.13 ¿Qué es lo importante hoy (y qué no)?",
    "text": "12.13 ¿Qué es lo importante hoy (y qué no)?\nEn este punto del curso:\n❌ No es importante entender cada línea de código\n❌ No es importante memorizar sintaxis\n❌ No es importante “ser rápido programando”\n✅ Sí es importante:\n\nVer el panorama completo de la programación SIG actual\n\nEntender que existen múltiples stacks y enfoques\nReconocer que el rendimiento depende de arquitectura, no solo del lenguaje\n\n👉 El código lo aprenderemos paso a paso.",
    "crumbs": [
      "Presentaciones",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Benchmark geoespacial: cómo leer los resultados</span>"
    ]
  },
  {
    "objectID": "62-presentacion_2_benchmark.html#qué-estamos-aprendiendo-realmente",
    "href": "62-presentacion_2_benchmark.html#qué-estamos-aprendiendo-realmente",
    "title": "12  Benchmark geoespacial: cómo leer los resultados",
    "section": "12.14 ¿Qué estamos aprendiendo realmente?",
    "text": "12.14 ¿Qué estamos aprendiendo realmente?\nMás allá del benchmark, este laboratorio busca que ustedes aprendan a:\n\nUsar GitHub como bitácora de trabajo\nDocumentar con Quarto\nEjecutar análisis en Jupyter Lab\nTrabajar en VSCode\nUsar la terminal (Windows / Linux)\nEjecutar entornos reproducibles con Docker\nCorrer el mismo proceso de muchas formas distintas\n\n🎯 Programar SIG hoy es saber orquestar herramientas, no solo escribir código.",
    "crumbs": [
      "Presentaciones",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Benchmark geoespacial: cómo leer los resultados</span>"
    ]
  },
  {
    "objectID": "62-presentacion_2_benchmark.html#el-límite-lo-ponen-ustedes",
    "href": "62-presentacion_2_benchmark.html#el-límite-lo-ponen-ustedes",
    "title": "12  Benchmark geoespacial: cómo leer los resultados",
    "section": "12.15 El límite lo ponen ustedes",
    "text": "12.15 El límite lo ponen ustedes\nEn clase aprenderemos:\n\nLos conceptos fundamentales\nLas herramientas base\nLos patrones comunes de trabajo\n\nPero el verdadero aprendizaje vendrá de:\n\nSus proyectos\nSu trabajo individual\nLo que decidan explorar más allá del aula\n\n🚀 En programación SIG,\nel límite no lo pone el lenguaje, lo pone la curiosidad y el problema que quieran resolver.",
    "crumbs": [
      "Presentaciones",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Benchmark geoespacial: cómo leer los resultados</span>"
    ]
  },
  {
    "objectID": "80-instalacion_herramientas.html",
    "href": "80-instalacion_herramientas.html",
    "title": "Apéndice A — Resumen instalación de herramientas",
    "section": "",
    "text": "A.1 Introducción\nResumen de herramientas requeridas:",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Resumen instalación de herramientas</span>"
    ]
  },
  {
    "objectID": "80-instalacion_herramientas.html#introducción",
    "href": "80-instalacion_herramientas.html#introducción",
    "title": "Apéndice A — Resumen instalación de herramientas",
    "section": "",
    "text": "Herramienta\nUso\nDetalles\n\n\n\n\ngit\n-\nApéndice E\n\n\nGitHub + SSH (local y contenedor)\n-\nSección E.2, Sección E.6, Sección E.7\n\n\nVSCode + Extensiones + Tinytex (local y contenedor)\n-\nApéndice F, Sección F.6, Sección F.5\n\n\nDocker Desktop + Preparación inicial\n-\nApéndice D, Sección D.2\n\n\nQGIS (OSGeo4w & PIXI + GEE)\n-\nSección L.1.1, Sección L.1.2\n\n\nArcGIS Pro\n-\nApéndice M",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Resumen instalación de herramientas</span>"
    ]
  },
  {
    "objectID": "81-uso_infraestructura_instalada.html",
    "href": "81-uso_infraestructura_instalada.html",
    "title": "Apéndice B — Uso de la Infraestructura Instalada",
    "section": "",
    "text": "B.1 Configuración inicial del entorno (Pre-flight)\nPara automatizar el soporte de gráficos y capturas sin configurar cada archivo individualmente, ejecute estos comandos en la terminal del contenedor contenedor_sig_unal inmediatamente después de iniciar los servicios con docker compose up -d:\n/usr/bin/google-chrome\nGoogle Chrome se necesita para compilar código mermaid dentro de Quarto. Ejecute el siguiente comando para comprobar si Google Chrome web browser está instalado correctamente:\n/usr/lib/R/etc/Rprofile.site /etc/R/Rprofile.site\nLa imagen cargada del archivo tar ya incluye los programas descritos a continuación en Tabla B.2. Esta tabla se deja como referencia para facilitar una futura compilación. La tabla descrita líneas abajo servirá para complementar el archivo Dockerfile.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Uso de la Infraestructura Instalada</span>"
    ]
  },
  {
    "objectID": "81-uso_infraestructura_instalada.html#sec-preflight",
    "href": "81-uso_infraestructura_instalada.html#sec-preflight",
    "title": "Apéndice B — Uso de la Infraestructura Instalada",
    "section": "",
    "text": "Tabla B.1: Comandos de configuración global del contenedor\n\n\n\n\n\n\n\n\n\n\nCategoría\nComando de Configuración\nPropósito\n\n\n\n\nAutomatización R\necho 'Sys.setenv(CHROMOTE_CHROME = \"/opt/google/chrome/chrome\")' &gt;&gt; /etc/R/Rprofile.site\nConfigura la ruta de Chrome para todo el sistema R de forma persistente. (si falla usa /usr/lib/R/etc/Rprofile.site. El R.home(\"etc\") en nuestro sistema es /usr/lib/R/etc)\n\n\nSeguridad Root\necho 'options(chromote.args = c(\"--no-sandbox\", \"--disable-gpu\", \"--headless\", \"--remote-debugging-port=9222\"))' &gt;&gt; /etc/R/Rprofile.site\nHabilita el modo headless y evita bloqueos de sandbox al ejecutar como root. (si falla usa /usr/lib/R/etc/Rprofile.site. El R.home(\"etc\") en nuestro sistema es /usr/lib/R/etc)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTabla B.2: Comandos de configuración global del contenedor ya incluidos en la imagen cargada a partir del archivo .tar\n\n\n\n\n\n\n\n\n\n\nCategoría\nComando de Configuración\nPropósito\n\n\n\n\nSoporte Base\napt-get update && apt-get install -y fonts-symbola wget\nFuentes para emojis y herramienta de descarga de paquetes externos.\n\n\nNavegador\nwget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb && apt install -y ./google-chrome-stable_current_amd64.deb\nInstala Google Chrome (Bypass de Snap). Obligatorio para capturas de mapas en Docker.\n\n\nLibrerías R\nRscript -e \"install.packages('webshot2', repos='https://cloud.r-project.org/')\"\nInstala el motor de captura de widgets HTML y mapas de Leaflet.\n\n\nLibrerías Python\npip3 install selenium\nHabilita la automatización de capturas para visualizaciones dinámicas de Python.\n\n\nLibrerías Julia\njulia -e 'using Pkg; Pkg.add([\"FileIO\", \"ImageIO\"])'\nSoporte esencial para procesar y exportar gráficos en el ecosistema Julia.\n\n\n\n\n\n\n\nVentajas de esta configuración\nAl usar el archivo Rprofile.site, hemos logrado que:\n\nLimpieza: Sus archivos .qmd solo contendrán código de análisis geográfico, eliminando bloques de configuración de sistema repetitivos.\nPersistencia: Cualquier usuario o script que inicie una sesión de R dentro de este contenedor heredará automáticamente la capacidad de tomar capturas de pantalla.\nCompatibilidad: Quarto detectará webshot2 y el navegador Chrome de forma nativa al renderizar a PDF.\n\n\n\nNotas de implementación\n\n\n\n\n\n\n¿Por qué Google Chrome y no Chromium?\n\n\n\nEn distribuciones basadas en Ubuntu 22.04 o superiores, el comando apt install chromium-browser instala una versión ligada a Snap, la cual no puede ejecutarse dentro de un contenedor Docker por restricciones de seguridad del kernel. La instalación manual del paquete .deb de Google Chrome garantiza un binario funcional en /usr/bin/google-chrome.\n\n\n\n\n\n\n\n\nImportancia de ImageIO y FileIO en Julia\n\n\n\nEn Julia, estas librerías actúan como los “drivers” de imagen. Sin ellas, aunque el código genere un mapa o gráfico, Quarto no podrá convertirlo a un formato que LaTeX entienda (como PNG), resultando en bloques vacíos en el PDF final.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Uso de la Infraestructura Instalada</span>"
    ]
  },
  {
    "objectID": "81-uso_infraestructura_instalada.html#introducción-a-la-infraestructura-de-datos",
    "href": "81-uso_infraestructura_instalada.html#introducción-a-la-infraestructura-de-datos",
    "title": "Apéndice B — Uso de la Infraestructura Instalada",
    "section": "B.2 Introducción a la infraestructura de datos",
    "text": "B.2 Introducción a la infraestructura de datos\nEste anexo constituye la guía técnica para la gestión del entorno de desarrollo instalado. Es decir, información que describe y detalla los contenedores instalados (instalación opción A), su estructura y funcionamiento, así mismo como la descripción y detalles adicionales de las dos instalaciones de QGIS (Instalación Opción B)\n\nContenedores instalados (Instalación Opción A)\nSiguiendo los pasos detallados en Capítulo 2 para instalar los contenedores Docker, en resumen, ellos contendrán:\n\nUn contenedor contenedor_sig_unal correspondiente a la imagen image_sig_unal:final el cual contendrá las siguientes herramientas:\n\n\nPython (Apéndice I), R (Apéndice J) y Julia (Apéndice K) con los principales paquetes/librerías para geoprocesamiento.\nQuarto (Ver Apéndice C).\nTinyTeX (Ver Sección F.5).\n\n\nUna contenedor contenedor_postgis_unal correspondiente a la imagen postgis_unal:final el cual contendrá las siguientes herramientas:\n\n\nPostgreSQL + PostGIS (Ver Apéndice N).\n\n\n🧪 Batería de pruebas de integridad del docker\n\n\n\n\n\n\n\n\nID\nComando de Verificación (Docker)\nDescripción\n\n\n\n\n01\ndocker exec contenedor_sig_unal gdalinfo --version\nVerifica que el núcleo de GDAL está activo.\n\n\n02\ndocker exec contenedor_sig_unal R -e \"library(sf); st_point(c(0,0))\"\nPrueba la librería sf y el motor de geometría en R.\n\n\n03\ndocker exec contenedor_sig_unal python3 -c \"import geopandas; print(geopandas.__version__)\"\nVerifica el stack espacial de Python.\n\n\n04\ndocker exec contenedor_sig_unal R -e \"j_eval('sum([1, 2, 3])')\"\nTest Crítico: Verifica la función personalizada y el puente R -&gt; Julia.\n\n\n05\ndocker exec contenedor_sig_unal R -e \"j_plot('plot(rand(10))')\"\nPrueba la generación de gráficos Julia capturados por R.\n\n\n06\ndocker exec contenedor_sig_unal julia -e 'using ArchGDAL; println(ArchGDAL.GDAL.gdalversioninfo(\"RELEASE_NAME\"))'\nCirugía Exitosa: Confirma que Julia accede a GDAL del sistema (v3.12.1).\n\n\n07\ndocker exec contenedor_sig_unal R -e \"library(RPostgres); dbConnect(Postgres(), host='db-postgis', dbname='sig_db_unal', user='profe_unal', password='geomatica2025')\"\nPrueba la conexión R -&gt; PostGIS (Interna).\n\n\n08\ndocker exec contenedor_sig_unal python3 -c \"import psycopg2; conn = psycopg2.connect(host='db-postgis', dbname='sig_db_unal', user='profe_unal', password='geomatica2025'); print('Python PostGIS conectado ✅'); conn.close()\"\nPrueba la conexión Python -&gt; PostGIS (Interna).\n\n\n09\ndocker exec contenedor_sig_unal R -e \"cat(whitebox::wbt_version())\"\nVerifica que los binarios de WhiteboxTools están instalados y accesibles.\n\n\n10\ndocker exec contenedor_sig_unal R -e \"library(httpgd); print('Visor OK')\"\nVerifica que el motor gráfico para VSCode está listo en el puerto 8787.\n\n\n\n\n\nConfiguración de puertos y conectividad\nPara que su computadora (Host) pueda comunicarse con los servicios dentro del contenedor, hemos diseñado un sistema de “puentes” o mapeo de puertos. Esto evita conflictos si ya tiene instalados otros servidores de bases de datos o Jupyter en su PC.\n\n\n\n\n\n\n\n\n\n\nServicio\nPuerto en su PC (Host)\nPuerto en Contenedor\nPropósito\nAcceso / Conexión\n\n\n\n\nJupyter Lab\n8889\n8888\nProgramación y Notebooks\nhttp://localhost:8889\n\n\nVisor R (httpgd)\n8788\n8787\nGráficos de R y VSCode\nhttp://localhost:8788\n\n\nPostGIS (DB)\n5434\n5432\nBase de Datos Espacial\nlocalhost:5434\n\n\n\n\n\n🔑 Credenciales de la base de datos\nUtilice estos datos para configurar sus conexiones en QGIS, ArcGIS Pro o mediante código (R/Python/Julia):\n\nBase de Datos: sig_db_unal\nUsuario: profe_unal\nContraseña: geomatica2025\nHost: localhost\nPuerto: 5434\nHost Interno: db-postgis (Use este nombre únicamente para conexiones dentro de sus scripts).\n\n\n\nLógica de arquitectura (Dockerfile y docker-compose)\nLa configuración del entorno se ha “blindado” técnicamente para garantizar la estabilidad:\n\nEn el Dockerfile: Se usan las instrucciones EXPOSE 8888 y EXPOSE 8787. Esto le avisa a Docker que el contenedor tiene dos “puertas” abiertas internamente. Al fijar httpgd.port = 8787, nos aseguramos de que el visor de gráficos de R no pelee con Jupyter por el mismo canal.\nEn el Docker-Compose:\n\n8889:8888: Permite que este curso conviva con otras instalaciones de Jupyter (que suelen usar el 8888).\n8788:8787: Habilita la conexión independiente de VSCode al visor de gráficos de R.\n5434:5432: Evita el choque con bases de datos locales (Postgres suele usar el 5432 o 5433).\n\n\n\n\nGuía de acceso: El concepto de “lados”\nEs fundamental entender desde dónde está intentando conectar:\n\n🌐 Desde afuera (Su PC / Host)\nEs lo que usted configura en su navegador o en QGIS. Usted ve los puertos mapeados: * Jupyter/Notebooks: http://localhost:8889 (usando el token geomatica2025). * Base de Datos (QGIS/DBeaver): Host: localhost, Puerto: 5434.\n\n\n🐳 Desde adentro (El Contenedor)\nSus scripts de Python, R y Julia no saben que existe un mapeo externo. Dentro de su “casa” Docker, nada ha cambiado: * PostGIS: El código debe buscar el puerto estándar 5432 y el host db-postgis. * httpgd: El servidor de gráficos sigue escuchando en el puerto interno 8787.\n\n\n\n\n\n\n\nTip de Conexión\n\n\n\nSi intenta conectar QGIS usando el puerto 5432 y falla, recuerde que el “puente” hacia el contenedor se construyó específicamente sobre el puerto 5434.\n\n\n\n\nResumen de la infraestructura instalada\n\n\n\n\n\n\n\n\nComponente\nVersión / Estado\nDetalles Técnicos\n\n\n\n\nR Engine\n4.3.3 (Angel Food Cake)\nPuente JuliaConnectoR y visor httpgd configurados.\n\n\nJulia Stack\nv1.10.x\nArchGDAL 3.12.1 operativo mediante enlaces simbólicos.\n\n\nPython Stack\n3.12.x\nGeoPandas, PyTorch y drivers psycopg2 listos.\n\n\nBase de Datos\nPostGIS (Noble)\nHost interno db-postgis con extensión espacial activa.\n\n\nVisualización\nDual Mode\nPuertos 8788 (R/Julia Plots) y 8889 (Jupyter Lab).\n\n\nPersistencia\nVolúmenes Docker\nMapeo bidireccional en /home/rstudio/work confirmado.\n\n\nCirugía SSL\n✅ Aplicada\nCompatibilidad OpenSSL 3.0 (Sistema) vs 3.3 (Julia).",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Uso de la Infraestructura Instalada</span>"
    ]
  },
  {
    "objectID": "81-uso_infraestructura_instalada.html#localización-de-archivos-y-persistencia",
    "href": "81-uso_infraestructura_instalada.html#localización-de-archivos-y-persistencia",
    "title": "Apéndice B — Uso de la Infraestructura Instalada",
    "section": "B.3 Localización de archivos y persistencia",
    "text": "B.3 Localización de archivos y persistencia\nEn el contenedor, su carpeta del equipo local se encuentra vinculada a la ruta /home/rstudio/work. * Cualquier archivo guardado en esa ruta dentro de Jupyter aparecerá en su carpeta de Windows. * Se recomienda organizar su trabajo en las subcarpetas: notebooks, scripts, y data. * La carpeta imagenes (sin tílde y provista para las imágenes usadas en los archivos Quarto) debe residir también en esta ruta para un renderizado correcto.\n\n\n\n\n\n\nPersistencia de Datos\n\n\n\nSi su contenedor se apaga o se reinicia, los datos de su base de datos PostGIS y los datos almancenados en /home/rstudio/work no se pierden. El volumen nombrado actúa como un disco duro externo que sobrevive a cualquier caída del sistema.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Uso de la Infraestructura Instalada</span>"
    ]
  },
  {
    "objectID": "81-uso_infraestructura_instalada.html#sec-cargar_contenedores_vscode",
    "href": "81-uso_infraestructura_instalada.html#sec-cargar_contenedores_vscode",
    "title": "Apéndice B — Uso de la Infraestructura Instalada",
    "section": "B.4 Cargar los contenedores dentro de VSCode",
    "text": "B.4 Cargar los contenedores dentro de VSCode\nPara una experiencia de desarrollo profesional, conecte VSCode directamente al contenedor:\n\nInicie Docker Desktop\nEn el “PowerShell” de windows ubíquese en la carpeta donde instaló los contenedores (ver Sección D.5)\nEjecute el comando: docker compose up -d\nAbra VSCode\nInstale (local) la extensión Dev Containers\nAcceda a la paleta de comandos con Ctrl + Shift + P, escriba (o seleccione) Dev Containers: Attach to Running Container…, y seleccione el contenedor contenedor_sig_unal (imagen image_sig_unal).\nAbra la carpeta /home/rstudio/work (esa carpeta corresponde a la carpeta local en dónde instaló los contenedores)\nUna vez conectado “dentro” del contenedor, debe habilitar/instalar las extensiones (‘Install in Container’). Vea el listado completo en Sección F.6.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Uso de la Infraestructura Instalada</span>"
    ]
  },
  {
    "objectID": "81-uso_infraestructura_instalada.html#sec-httpgd",
    "href": "81-uso_infraestructura_instalada.html#sec-httpgd",
    "title": "Apéndice B — Uso de la Infraestructura Instalada",
    "section": "B.5 Inicialización del visor gráfico (solo una vez por sesión)",
    "text": "B.5 Inicialización del visor gráfico (solo una vez por sesión)\nPara que los gráficos de R (y los puentes de Python/Julia) se visualicen correctamente en VSCode, debe inicializar el dispositivo gráfico. En su terminal de R, ejecute:\n# Lanza el servidor de gráficos httpgd\nhttpgd::hgd()\n\nAcceso al Visor: VSCode debería abrir automáticamente una pestaña con el visor. Si esto no sucede o prefiere usar su navegador externo (Chrome/Edge), acceda a la dirección: http://127.0.0.1:8788.\nNota sobre Puertos: Aunque el comando en R pueda imprimir una URL interna con el puerto 8787 o un token aleatorio, ignore esa dirección. Gracias a nuestro archivo docker-compose.yml, el puerto 8788 de su Windows está “cableado” permanentemente al visor, eliminando la necesidad de buscar tokens o puertos dinámicos. (xxx)",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Uso de la Infraestructura Instalada</span>"
    ]
  },
  {
    "objectID": "81-uso_infraestructura_instalada.html#sec-acceder_jupyterlab",
    "href": "81-uso_infraestructura_instalada.html#sec-acceder_jupyterlab",
    "title": "Apéndice B — Uso de la Infraestructura Instalada",
    "section": "B.6 Ingreso a Jupyter Lab",
    "text": "B.6 Ingreso a Jupyter Lab\nAbra su navegador y acceda a: http://localhost:8889 * Contraseña/Token: (Si se solicita) geomatica2025 * Persistencia: Todo archivo guardado en la carpeta /home/rstudio/work aparecerá automáticamente en su carpeta de Windows. No guarde nada fuera de esa ruta, o se perderá al cerrar el contenedor.\nPuede pasar directamente la url completa:\nhttp://127.0.0.1:8889/lab?token=geomatica2025\nSi la url anterior no funciona, puede verificar cuál url usa actualmente el contenedor, la cual aparece al final del log después de ejecutar el siguiente comando:\ndocker logs contenedor_sig_unal\nAlternativa: Puede iniciar/reiniciar el servidor de Jupyter Lab en la url http://127.0.0.1:8889/lab?token=geomatica2025. Use el siguiente comando ejecutado desde el terminal de VSCode:\njupyter lab --ip=0.0.0.0 --port=8889 --no-browser --allow-root --ServerApp.token='geomatica2025'",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Uso de la Infraestructura Instalada</span>"
    ]
  },
  {
    "objectID": "81-uso_infraestructura_instalada.html#guía-visual-de-jupyterlab",
    "href": "81-uso_infraestructura_instalada.html#guía-visual-de-jupyterlab",
    "title": "Apéndice B — Uso de la Infraestructura Instalada",
    "section": "B.7 Guía Visual de JupyterLab",
    "text": "B.7 Guía Visual de JupyterLab\nAl ingresar, se encontrará con el centro de mando de sus kernels, donde podrá elegir entre R, Python o Julia para sus Notebooks:\n\n\n\n\n\n\nFigura B.1: Interfaz de JupyterLab configurada para el laboratorio.\n\n\n\n\nLa Carpeta ‘work’ y el Espejo de Datos\nEn el panel izquierdo de la Figura B.1, la carpeta /home/rstudio/work/ es el espejo de su directorio local en Windows. Gracias a la configuración de volúmenes en el archivo docker-compose.yml, existe un puente directo: todo cambio realizado en Jupyter se refleja en su disco duro y viceversa, garantizando que su trabajo no se pierda al apagar el contenedor.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Uso de la Infraestructura Instalada</span>"
    ]
  },
  {
    "objectID": "81-uso_infraestructura_instalada.html#sec-compilacion",
    "href": "81-uso_infraestructura_instalada.html#sec-compilacion",
    "title": "Apéndice B — Uso de la Infraestructura Instalada",
    "section": "B.8 Compilación de la guía completa o documentos individuales",
    "text": "B.8 Compilación de la guía completa o documentos individuales\nLa guía del curso está organizada a partir de un archivo orquestador _quarto.yml, el cual contiene una referencia explícita a cada uno de los archivos Quarto (.qmd) que definen los capítulos, las presentaciones, los talleres y los anexos. Este archivo centraliza la organización y el formato de la guía tanto en PDF como en HTML.\n\nCompilación del proyecto completo\nSi desea compilar la guía completa del curso y generar todos los formatos, simplemente ejecute el comando quarto render en la carpeta raíz (donde se encuentra el archivo _quarto.yml):\n# Desde la carpeta raíz donde reside el archivo '_quarto.yml'\nquarto render\n\n\nCompilación de archivos individuales\nEn ocasiones, querrá trabajar en un solo capítulo sin procesar el libro entero. Para compilar un archivo específico (ej. archivo.qmd) de manera independiente y evitar que Quarto aplique las reglas de numeración y referencias del proyecto global, siga estos pasos:\n\nRenombrar temporalmente el orquestador: Cambie el nombre de _quarto.yml a _quarto.yml.back. Esto hace que Quarto trate al archivo como un documento “solitario”.\nEjecutar el renderizado específico:\n\n\nGenerar todos los formatos (HTML y PDF):\n\nquarto render archivo.qmd --to all\n\nGenerar solo formato HTML:\n\nquarto render archivo.qmd --to html\n\nGenerar solo formato PDF:\n\nquarto render archivo.qmd --to pdf\n\n\nNotas de estudio y personalización\n\n\n\n\n\n\n¡Personaliza tu aprendizaje!\n\n\n\nEn Quarto, puedes agregar tus propias notas de estudio usando la sintaxis de “callouts”. Recuerda que este documento está en proceso de construcción y sufrirá cambios permanentes hasta terminar el curso.\nPuedes buscar ayuda en Internet para personalizar la apariencia de tus notas. La sintaxis básica es:\n::: {.callout-tip icon=\"true\"}\n### ¡Escribe tu nota aquí!\nEste es un espacio para tus observaciones personales y recordatorios.\n:::",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Uso de la Infraestructura Instalada</span>"
    ]
  },
  {
    "objectID": "81-uso_infraestructura_instalada.html#mapeo-de-capacidades-sig",
    "href": "81-uso_infraestructura_instalada.html#mapeo-de-capacidades-sig",
    "title": "Apéndice B — Uso de la Infraestructura Instalada",
    "section": "B.9 Mapeo de Capacidades SIG",
    "text": "B.9 Mapeo de Capacidades SIG\nEs vital entender que, aunque usemos lenguajes distintos, todos “beben” de las mismas librerías de bajo nivel instaladas en nuestra imagen base de OSGeo:\n\n\n\n\n\n\n\n\n\n\nOperación\nR (sf / terra)\nPython (GeoPandas)\nJulia (ArchGDAL)\nMotor de Sistema\n\n\n\n\nLectura de Datos\nst_read() / rast()\nread_file() / open()\nArchGDAL.read()\nGDAL\n\n\nBuffers / Geometría\nst_buffer()\n.buffer()\nLibGEOS.buffer()\nGEOS\n\n\nReproyección\nst_transform()\n.to_crs()\nArchGDAL.reproject()\nPROJ",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Uso de la Infraestructura Instalada</span>"
    ]
  },
  {
    "objectID": "81-uso_infraestructura_instalada.html#verificación-de-conectividad-multilenguaje",
    "href": "81-uso_infraestructura_instalada.html#verificación-de-conectividad-multilenguaje",
    "title": "Apéndice B — Uso de la Infraestructura Instalada",
    "section": "B.10 Verificación de Conectividad Multilenguaje",
    "text": "B.10 Verificación de Conectividad Multilenguaje\nNota técnica: Dentro de la red de Docker, el host es db-postgis.\n\nPythonRJulia\n\n\n\nimport psycopg2\nimport geopandas as gpd\nimport fiona\nimport matplotlib.pyplot as plt\nfrom shapely.geometry import Point\n\nprint(\"--- Inicio de Verificación de Python SIG ---\")\n\n--- Inicio de Verificación de Python SIG ---\n\n# 1. Prueba de conexión a la base de datos PostGIS\ntry:\n    conn = psycopg2.connect(\n        host=\"db-postgis\", \n        dbname=\"sig_db_unal\", \n        user=\"profe_unal\", \n        password=\"geomatica2025\"\n    )\n    print(\"✅ Conexión a PostGIS: Exitosa\")\n    conn.close()\nexcept Exception as e:\n    print(f\"❌ Error de conexión a PostGIS: {e}\")\n\n✅ Conexión a PostGIS: Exitosa\n\n# 2. Prueba de Fiona y drivers GDAL\ntry:\n    drivers = len(fiona.supported_drivers)\n    print(f\"✅ Fiona operativo: {drivers} drivers GDAL detectados\")\nexcept Exception as e:\n    print(f\"❌ Error en Fiona/GDAL: {e}\")\n\n✅ Fiona operativo: 17 drivers GDAL detectados\n\n# 3. Prueba de GeoPandas, Motores GEOS y Visualización\ntry:\n    # Creamos un punto y su buffer (GEOS)\n    punto = Point(0, 0)\n    buffer_geom = punto.buffer(1.0)\n    \n    # Creamos GeoDataFrames para graficar\n    gdf_buffer = gpd.GeoDataFrame({'geometry': [buffer_geom]}, crs=\"EPSG:4326\")\n    gdf_punto = gpd.GeoDataFrame({'geometry': [punto]}, crs=\"EPSG:4326\")\n    \n    print(f\"✅ GeoPandas {gpd.__version__}: Operativo\")\n    print(f\"✅ Motores GEOS/Shapely: Verificados\")\n\n    # Generación del Plot Espacial con Ejes y Cuadrícula\n    fig, ax = plt.subplots(figsize=(6, 6))\n    \n    # Graficamos el buffer\n    gdf_buffer.plot(ax=ax, color='lightgreen', edgecolor='green', alpha=0.4, label='Buffer')\n    \n    # Graficamos el punto original (en rojo)\n    gdf_punto.plot(ax=ax, color='red', markersize=50, zorder=5, label='Centro')\n    \n    # Configuración de estilo consistente (Ejes y Grilla)\n    ax.set_title(\"Validación Python SIG: Buffer GEOS\")\n    ax.set_xlabel(\"Longitud\")\n    ax.set_ylabel(\"Latitud\")\n    ax.grid(True, linestyle='--', alpha=0.7) # Cuadrícula activada\n    ax.set_aspect('equal') # Proporción 1:1 para evitar deformación\n    \n    plt.show()\n    print(\"✅ Visualización GeoPandas: Mapa generado con éxito\")\n\nexcept Exception as e:\n    print(f\"❌ Error en el stack espacial de Python: {e}\")\n\n\n\n\n\n\n\nprint(\"--- Verificación Finalizada ---\")\n\n--- Verificación Finalizada ---\n\n\n\n\n\nlibrary(DBI)\nlibrary(RPostgres)\nlibrary(sf)\n\nLinking to GEOS 3.12.1, GDAL 3.8.4, PROJ 9.4.0; sf_use_s2() is TRUE\n\nlibrary(terra)\n\nterra 1.8.93\n\n\n\nAttaching package: 'terra'\n\n\nThe following object is masked from 'package:grid':\n\n    depth\n\ncat(\"--- Inicio de Verificación de R-Spatial ---\\n\")\n\n--- Inicio de Verificación de R-Spatial ---\n\n# 1. Prueba de conexión a la base de datos PostGIS\ntryCatch({\n  con &lt;- dbConnect(\n    RPostgres::Postgres(), \n    host = \"db-postgis\", \n    dbname = \"sig_db_unal\", \n    user = \"profe_unal\", \n    password = \"geomatica2025\"\n  )\n  cat(\"✅ Conexión a PostGIS: Exitosa\\n\")\n  dbDisconnect(con)\n}, error = function(e) {\n  cat(\"❌ Error de conexión a PostGIS:\", conditionMessage(e), \"\\n\")\n})\n\n✅ Conexión a PostGIS: Exitosa\n\n# 2. Prueba de Motores de Sistema y Visualización (sf)\ntryCatch({\n  conf &lt;- sf_extSoftVersion()\n  cat(paste0(\"✅ sf operativo. Motores detectados:\\n\",\n             \"   - GDAL: \", conf[\"GDAL\"], \"\\n\",\n             \"   - GEOS: \", conf[\"GEOS\"], \"\\n\",\n             \"   - PROJ: \", conf[\"PROJ\"], \"\\n\"))\n  \n  # Creamos el punto y el buffer\n  punto &lt;- st_point(c(0, 0))\n  buffer_geom &lt;- st_buffer(punto, dist = 1)\n  cat(\"✅ Prueba geométrica (GEOS): Buffer creado correctamente\\n\")\n\n  # Generación del Plot Espacial\n  # Usamos st_geometry para graficar solo la forma\n  plot(st_geometry(buffer_geom), \n       col = 'lightblue', \n       border = 'blue', \n       main = \"Validación R-Spatial: Buffer GEOS\",\n       axes = TRUE,\n       graticule = TRUE)\n  \n  # Añadimos el punto original para referencia\n  plot(st_geometry(punto), add = TRUE, col = 'red', pch = 20)\n  \n  cat(\"✅ Visualización sf: Mapa generado con éxito\\n\")\n  \n}, error = function(e) {\n  cat(\"❌ Error en el stack sf/GEOS:\", conditionMessage(e), \"\\n\")\n})\n\n✅ sf operativo. Motores detectados:\n   - GDAL: 3.8.4\n   - GEOS: 3.12.1\n   - PROJ: 9.4.0\n✅ Prueba geométrica (GEOS): Buffer creado correctamente\n\n\n\n\n\n\n\n\n\n✅ Visualización sf: Mapa generado con éxito\n\n# 3. Prueba de Raster (terra)\ntryCatch({\n  r &lt;- rast(ncols=10, nrows=10)\n  values(r) &lt;- 1:ncell(r)\n  cat(\"✅ Paquete 'terra' operativo: Objetos Raster verificados\\n\")\n}, error = function(e) {\n  cat(\"❌ Error en el stack terra:\", conditionMessage(e), \"\\n\")\n})\n\n✅ Paquete 'terra' operativo: Objetos Raster verificados\n\ncat(\"--- Verificación Finalizada ---\\n\")\n\n--- Verificación Finalizada ---\n\n\n\n\n\n# #| eval: false\nj_plot('\nusing LibPQ\nusing LibGEOS\nusing ArchGDAL\nusing Plots\n\nprintln(\"--- Inicio de Verificación de Julia SIG ---\")\n\n# 1. Prueba de conexión a la base de datos PostGIS\ntry\n    conn = LibPQ.Connection(\"host=db-postgis dbname=sig_db_unal user=profe_unal password=geomatica2025\")\n    println(\"✅ Conexión a PostGIS: Exitosa\")\n    close(conn)\ncatch e\n    println(\"❌ Error de conexión a PostGIS: \", e)\nend\n\n# 2. Verificación de LibGEOS y Visualización de Geometría\ntry\n    # Creamos un punto y le aplicamos un buffer de 1.0 unidades\n    # Esto valida la integración de Julia con la librería GEOS del sistema\n    punto = LibGEOS.readgeom(\"POINT (0 0)\")\n    buffer_geom = LibGEOS.buffer(punto, 1.0)\n    \n    println(\"✅ LibGEOS operativo: Motores geométricos verificados\")\n    \n    # Graficamos el objeto del buffer\n    # fillcolor y alpha ayudan a ver que es un polígono real\n    plt = plot(buffer_geom, \n               title=\"Validación Julia SIG: Buffer GEOS\", \n               fillcolor=:blue, \n               fillalpha=0.3, \n               aspect_ratio=:equal, \n               legend=false)\n    \n    # display() es OBLIGATORIO para mostrar gráficos dentro de bloques try/catch\n    display(plt) \n    \ncatch e\n    println(\"❌ Error en LibGEOS o Visualización: \", e)\nend\n\n# 3. Verificación de ArchGDAL (Usando llamada de bajo nivel)\ntry\n    # Accedemos directamente al motor de C para evitar errores de exportación\n    gdal_ver = ArchGDAL.GDAL.gdalversioninfo(\"--version\")\n    println(\"✅ ArchGDAL operativo (Versión GDAL: $gdal_ver)\")\ncatch e\n    println(\"❌ Error en ArchGDAL: \", e)\nend\n\nprintln(\"--- Verificación Finalizada ---\")\n')\n\nStarting Julia ...\n\n\njulia&gt; using LibPQ\n\njulia&gt; using LibGEOS\n\njulia&gt; using ArchGDAL\n\njulia&gt; using Plots\n\njulia&gt; println(\"--- Inicio de Verificación de Julia SIG ---\")\n\n# 1. Prueba de conexión a la base de datos PostGIS\n--- Inicio de Verificación de Julia SIG ---\n\njulia&gt; try\n    conn = LibPQ.Connection(\"host=db-postgis dbname=sig_db_unal user=profe_unal password=geomatica2025\")\n    println(\"✅ Conexión a PostGIS: Exitosa\")\n    close(conn)\ncatch e\n    println(\"❌ Error de conexión a PostGIS: \", e)\nend\n\n# 2. Verificación de LibGEOS y Visualización de Geometría\n✅ Conexión a PostGIS: Exitosa\n\njulia&gt; try\n    # Creamos un punto y le aplicamos un buffer de 1.0 unidades\n    # Esto valida la integración de Julia con la librería GEOS del sistema\n    punto = LibGEOS.readgeom(\"POINT (0 0)\")\n    buffer_geom = LibGEOS.buffer(punto, 1.0)\n    \n    println(\"✅ LibGEOS operativo: Motores geométricos verificados\")\n    \n    # Graficamos el objeto del buffer\n    # fillcolor y alpha ayudan a ver que es un polígono real\n    plt = plot(buffer_geom, \n               title=\"Validación Julia SIG: Buffer GEOS\", \n               fillcolor=:blue, \n               fillalpha=0.3, \n               aspect_ratio=:equal, \n               legend=false)\n    \n    # display() es OBLIGATORIO para mostrar gráficos dentro de bloques try/catch\n    display(plt) \n    \ncatch e\n    println(\"❌ Error en LibGEOS o Visualización: \", e)\nend\n\n# 3. Verificación de ArchGDAL (Usando llamada de bajo nivel)\n✅ LibGEOS operativo: Motores geométricos verificados\n\njulia&gt; try\n    # Accedemos directamente al motor de C para evitar errores de exportación\n    gdal_ver = ArchGDAL.GDAL.gdalversioninfo(\"--version\")\n    println(\"✅ ArchGDAL operativo (Versión GDAL: $gdal_ver)\")\ncatch e\n    println(\"❌ Error en ArchGDAL: \", e)\nend\n✅ ArchGDAL operativo (Versión GDAL: GDAL 3.12.1 \"Chicoutimi\", released 2025/12/12)\n\njulia&gt; println(\"--- Verificación Finalizada ---\")\n--- Verificación Finalizada ---\n\n\n\n\n\n\n\n\n\n# Validación de Motores SIG y Conectividad\nusing LibPQ, LibGEOS, ArchGDAL, Plots\n\n# 1. Prueba de conexión a PostGIS\ntry\n    conn = LibPQ.Connection(\"host=db-postgis dbname=sig_db_unal user=profe_unal password=geomatica2025\")\n    println(\"✅ Conexión a PostGIS: Exitosa\")\n    close(conn)\ncatch e\n    println(\"❌ Error de conexión: \", e)\nend\n\n# 2. Prueba de Motores Geométricos (GEOS)\ntry\n    punto = LibGEOS.readgeom(\"POINT (0 0)\")\n    buffer_geom = LibGEOS.buffer(punto, 1.0)\n    println(\"✅ Motores geométricos operativos (GEOS)\")\n    \n    # Visualización del Buffer\n    plt = plot(buffer_geom, title=\"Validación SIG: Buffer GEOS\", \n               fillcolor=:blue, fillalpha=0.3, aspect_ratio=:equal)\n    display(plt)\ncatch e\n    println(\"❌ Error en motores geométricos o gráficos: \", e)\nend",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Uso de la Infraestructura Instalada</span>"
    ]
  },
  {
    "objectID": "82-quarto.html",
    "href": "82-quarto.html",
    "title": "Apéndice C — Quarto: Orquestación y Configuración",
    "section": "",
    "text": "C.1 Opciones del encabezado yml\nEjemplo 1: Solo HTML\nEjemplo 2: HTML y Python",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Quarto: Orquestación y Configuración</span>"
    ]
  },
  {
    "objectID": "82-quarto.html#opciones-del-encabezado-yml",
    "href": "82-quarto.html#opciones-del-encabezado-yml",
    "title": "Apéndice C — Quarto: Orquestación y Configuración",
    "section": "",
    "text": "---\ntitle: \"Título de la Práctica\"\nauthor: \"Nombre del Estudiante\"\ndate: last-modified\nformat:\n  html:\n    toc: true\n    toc-depth: 3\n    toc-location: left\n    number-sections: true\n    theme: lux\n---\n\n---\ntitle: \"Informe Técnico: Análisis Geoespacial\"\nauthor: \"ID Correo UNAL\"\ndate: today\nformat:\n  html:\n    toc: true\n    number-sections: true\n    theme: cosmo\n  pdf:\n    toc: true\n    toc-title: \"Contenido\"\n    number-sections: true\n    documentclass: scrreprt\n    geometry:\n      - top=25mm\n      - left=25mm\n      - right=25mm\n      - bottom=25mm\n---",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Quarto: Orquestación y Configuración</span>"
    ]
  },
  {
    "objectID": "82-quarto.html#resumen-de-comandos-quarto",
    "href": "82-quarto.html#resumen-de-comandos-quarto",
    "title": "Apéndice C — Quarto: Orquestación y Configuración",
    "section": "C.2 Resumen de comandos Quarto",
    "text": "C.2 Resumen de comandos Quarto\nRenderizar todos los formatos definidos en el encabezado yml:\nquarto render archivo.qmd --to all\nRenderizar a HTML:\nquarto render archivo.qmd --to html\nRenderizar a PDF:\nquarto render archivo.qmd --to pdf\nRenderizar a PDF, mostrando todos los detalles en la consola:\nquarto render archivo.qmd --to pdf --trace --verbose`\nChequear estado de instalación de Quarto\nquarto check",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Quarto: Orquestación y Configuración</span>"
    ]
  },
  {
    "objectID": "82-quarto.html#sec-opciones-chunks",
    "href": "82-quarto.html#sec-opciones-chunks",
    "title": "Apéndice C — Quarto: Orquestación y Configuración",
    "section": "C.3 Control de ejecución en Quarto - opciones de chunks",
    "text": "C.3 Control de ejecución en Quarto - opciones de chunks\nPara que sus informes técnicos sean profesionales, no basta con que el código funcione; es necesario controlar qué se muestra y qué se oculta al lector final. En Quarto, esto se logra mediante el uso de “opciones de chunk” utilizando la sintaxis de la tubería de comentarios (#|).\n\n\n\n\n\n\n\n\n\n\nOpción de Chunk\n¿Se ejecuta?\n¿Muestra el Código?\n¿Muestra Resultados / Plots?\nUso Ideal\n\n\n\n\n#| echo: false\n✅ SÍ\n❌ NO\n✅ SÍ\nPara Resultados Finales. Muestra el mapa/tabla sin la “receta”.\n\n\n#| include: false\n✅ SÍ\n❌ NO\n❌ NO\nPara el Setup. Corre todo en secreto, sin mensajes ni advertencias.\n\n\n#| code-fold: true\n✅ SÍ\n📂 Plegado\n✅ SÍ\nPara el Proceso. El código se oculta tras un botón “Code”.\n\n\n#| eval: false\n❌ NO\n✅ SÍ\n❌ NO\nPara Tutoriales. Solo muestra el texto del código sin procesarlo.\n\n\n#| output: false\n✅ SÍ\n✅ SÍ\n❌ NO\nPara Debugging. Ves su código pero no los resultados pesados.\n\n\n#| warning: false\n✅ SÍ\n-\n-\nOculta esos textos naranjas de advertencia de las librerías.\n\n\n#| message: false\n✅ SÍ\n-\n-\nOculta mensajes de carga (ej: “Loading terra package…”).\n\n\n\n\nRecomendaciones de uso según el contexto\nDependiendo de la parte del script en la que se encuentre, existen configuraciones que garantizan un documento más limpio y fluido:\n\n\n\n\n\n\n\n\nTipo de Chunk\nOpción recomendada\n¿Por qué?\n\n\n\n\nSetup / Librerías\n#| include: false\nEjecuta todo pero oculta el código y los mensajes de carga de R/Julia/Python.\n\n\nLimpieza de RAM\n#| include: false\nBorra objetos y vacía el cache en silencio. El lector no necesita ver la “limpieza”.\n\n\nProcesamiento\n#| code-fold: true\nMuestra el mapa pero esconde el código tras un clic. Ideal para transparencia académica.\n\n\nResultados Finales\n#| echo: false\nMuestra solo la tabla comparativa y conclusiones. Es el “veredicto” limpio y profesional.\n\n\n\n\n\n\n\n\n\nSintaxis Correcta\n\n\n\nRecuerde que las opciones deben ir al inicio del chunk, justo después de los corchetes del lenguaje:\n#| echo: false\n#| warning: false\nlibrary(terra)\n# Su código aquí...",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Quarto: Orquestación y Configuración</span>"
    ]
  },
  {
    "objectID": "82-quarto.html#instalación-de-extensiones-de-quarto",
    "href": "82-quarto.html#instalación-de-extensiones-de-quarto",
    "title": "Apéndice C — Quarto: Orquestación y Configuración",
    "section": "C.4 Instalación de Extensiones de Quarto",
    "text": "C.4 Instalación de Extensiones de Quarto\nLas extensiones permiten ampliar las funcionalidades nativas de Quarto, añadiendo nuevos formatos de salida, filtros personalizados o librerías de componentes visuales. Para que el proceso de descarga desde repositorios remotos sea exitoso y seguro, es fundamental haber completado previamente la configuración descrita en la Sección E.7.\n\nEl proceso de instalación\nPara agregar una extensión a tu proyecto, Quarto utiliza el comando add seguido del identificador del repositorio (usualmente usuario/repositorio). Este proceso descarga los archivos necesarios dentro de una carpeta local denominada _extensions/.\n\nEjemplo práctico: Librería de iconos FontAwesome\nComo caso de estudio, instalaremos la extensión oficial para el uso de iconos vectoriales. Ejecuta el siguiente comando en tu terminal:\nquarto add quarto-ext/fontawesome\n\n\n\n\n\n\nConfianza del Autor\n\n\n\nAl ejecutar el comando, el sistema solicitará confirmar si confías en los autores de la extensión. Escribe Y para permitir que Quarto gestione los archivos del filtro en tu directorio de trabajo.\n\n\n\n\n\nGestión de archivos del proyecto\nUna vez finalizada la instalación, notarás que en la raíz de tu proyecto se ha creado la siguiente estructura:\nmi-proyecto/\n├── _extensions/\n│   └── quarto-ext/\n│       └── fontawesome/\n└── tu-archivo.qmd\nEs importante no modificar manualmente los archivos dentro de la carpeta _extensions, ya que Quarto los requiere para procesar el documento final durante el renderizado.\n\n\nAplicación en el documento\nTras la instalación exitosa, puedes utilizar las nuevas funcionalidades mediante shortcodes. En el caso de nuestra extensión de ejemplo, ahora es posible insertar iconos de la siguiente manera:\nPara este análisis utilizaremos:\n\n* {{&lt; fa satellite &gt;}} Datos satelitales.\n* {{&lt; fa location-dot \"red\" &gt;}} Puntos de control terrestre.\n\n\n\n\n\n\nActualización de extensiones\n\n\n\nSi en el futuro deseas actualizar una extensión instalada a su última versión, simplemente vuelve a ejecutar el mismo comando quarto add. El sistema detectará la versión existente y te preguntará si deseas sobrescribirla.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Quarto: Orquestación y Configuración</span>"
    ]
  },
  {
    "objectID": "83-docker_desktop.html",
    "href": "83-docker_desktop.html",
    "title": "Apéndice D — Docker: Gestión de Contenedores e Imágenes",
    "section": "",
    "text": "D.1 Instalación del software\nDescargue e instale la versión oficial de Docker Desktop desde el siguiente enlace:",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Docker: Gestión de Contenedores e Imágenes</span>"
    ]
  },
  {
    "objectID": "83-docker_desktop.html#instalación-del-software",
    "href": "83-docker_desktop.html#instalación-del-software",
    "title": "Apéndice D — Docker: Gestión de Contenedores e Imágenes",
    "section": "",
    "text": "URL: https://www.docker.com/products/docker-desktop/\nDescargue la versión más reciente para el sistema operativo de su máquina local y verifique que el instalador coincida con la arquitectura de su máquina.\nInstalación: Ejecute el instalador y asegúrese de aceptar la actualización del kernel de WSL 2 si el sistema lo solicita, o previamente usar en el terminal wsl --update. Durante la instalación, asegúrese de activar la opción “Use WSL 2 instead of Hyper-V”.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Docker: Gestión de Contenedores e Imágenes</span>"
    ]
  },
  {
    "objectID": "83-docker_desktop.html#sec-preparacion_docker",
    "href": "83-docker_desktop.html#sec-preparacion_docker",
    "title": "Apéndice D — Docker: Gestión de Contenedores e Imágenes",
    "section": "D.2 Preparación Docker Desktop",
    "text": "D.2 Preparación Docker Desktop\nAntes de iniciar la carga o instalación de imágenes/contenedores, es imperativo configurar el entorno local:\n\nConfiguración de Almacenamiento: Debido a que la imagen políglota y la base de datos requieren un espacio considerable, asegúrese de que el disco donde Docker guarda sus archivos .vhdx tenga al menos 50 GB de espacio libre. Tenga en cuenta que el tamaño en disco de las dos imágenes Docker, una vez instaladas, es de aproximadamente 45 GB.\nProcedimiento para cambiar la ubicación de las imágenes (archivos con extensión .vhdx): Si su disco principal (C:) está sin espacio, mueva los archivos Docker a otro disco. En Docker Desktop:\n\nDiríjase a Settings (engranaje) -&gt; Resources -&gt; Advanced.\nLocalice Disk image location.\nHaga clic en Browse y seleccione una carpeta en un disco con mayor capacidad.\nHaga clic en Apply & restart.\n\nOptimización de Memoria Swap: Para procesar datos raster de gran tamaño sin interrupciones en R o Julia, es fundamental ampliar la memoria Swap (espacio de intercambio). Puede consultar más detalles en la Sección D.3 sobre cómo esto impacta el rendimiento.\nProcedimiento para aumentar Swap en Windows (Host): Ajuste la memoria virtual del sistema operativo para evitar cierres por falta de RAM:\n\nEn el buscador de Windows, escriba y seleccione “Ver la configuración avanzada del sistema”.\nEn la pestaña Opciones avanzadas, sección Rendimiento, haga clic en el botón Configuración.\nDiríjase a Opciones avanzadas -&gt; Memoria Virtual y haga clic en Cambiar.\nDesmarque “Administrar automáticamente”, seleccione el disco principal, elija Tamaño personalizado y asigne estos valores sugeridos, que dependen del espacio disponible en el disco (verifíquelo): Inicial 16384 MB / Máximo 32768 MB.\nHaga clic en Establecer y luego en Aceptar (requerirá reiniciar el equipo).\n\nConfiguración de Swap en el Contenedor (WSL2): Dado que Docker opera sobre el subsistema Linux, debe configurar el archivo de intercambio global de WSL2:\n\nAbra el explorador de archivos y diríjase a su carpeta de usuario (escriba %USERPROFILE% en la barra de direcciones).\nCree un archivo nuevo llamado .wslconfig (asegúrese de que no tenga extensión .txt al final).\nPegue el siguiente contenido para definir la RAM y asegurar 32 GB de swap para sus procesos espaciales (sugerido, depende de su espacio en disco):\n\n\n[wsl2]\nmemory=12GB # RAM máxima física asignada a Linux\nswap=32GB   # Memoria de intercambio para evitar el cierre de contenedores\n\n\n\n\n\n\nImportante\n\n\n\nSi desea verificar si estos cambios surtieron efecto dentro de su laboratorio, puede ejecutar el comando free -h en la terminal de Jupyter o VSCode.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Docker: Gestión de Contenedores e Imágenes</span>"
    ]
  },
  {
    "objectID": "83-docker_desktop.html#sec-limpieza_entorno",
    "href": "83-docker_desktop.html#sec-limpieza_entorno",
    "title": "Apéndice D — Docker: Gestión de Contenedores e Imágenes",
    "section": "D.3 Limpieza del entorno",
    "text": "D.3 Limpieza del entorno\n\nEliminar todas las imagenes/contenedores y liberar todo el espacio usado por Docker.\n\n⚠️ Advertencia: Los siguientes comandos eliminarán todos los contenedores, imágenes y volúmenes existentes en su sistema. Úselos solo si no tiene contenedores o imágenes que desee preservar.\n\nEjecute estos comandos en su terminal (PowerShell) para liberar espacio y evitar conflictos:\n# Detener y eliminar todos los contenedores\ndocker stop $(docker ps -aq)\ndocker rm -f $(docker ps -aq)\n\n# Eliminar todas las imágenes\ndocker rmi -f $(docker images -aq)\n\n# Eliminar todos los volúmenes (libera MUCHO espacio)\ndocker volume rm $(docker volume ls -q)\n\n# Eliminar redes de usuario (no borra bridge/host/none)\ndocker network rm $(docker network ls -q | Select-String -NotMatch \"bridge|host|none\")\n\n# Eliminar caché de construcción\ndocker builder prune -a -f\n\n# OPCIÓN MÁS SIMPLE (Todo en un solo comando)\n# docker system prune -a --volumes -f\nPara verificar el espacio liberado, use: docker system df. El resultado debería mostrar valores cercanos a 0 bytes.\n\n\nComandos de rescate de espacio\nEl entorno políglota de este curso es robusto y, por lo tanto, pesado. Tras realizar actualizaciones o varias pruebas de construcción, es posible que el espacio en disco se agote rápidamente.\nSi recibe errores de “Disk Full” o desea limpiar su sistema, ejecute los siguientes comandos en su terminal de Windows (PowerShell):\n# 1. Eliminar contenedores detenidos y redes en desuso\ndocker system prune -f\n\n# 2. Limpiar caché de construcción (libera mucho espacio tras errores de build)\ndocker builder prune -f\n\n# 3. (Uso extremo) Eliminar TODAS las imágenes que no estén siendo usadas\n# docker image prune -a -f\n\n\n\n\n\n\nSeguridad de sus Datos\n\n\n\nNo tema realizar limpiezas periódicas. Gracias a la configuración de volúmenes en nuestro archivo docker-compose.yml, todo su código, scripts y datos espaciales están físicamente en su disco local (en la carpeta de su ID UNAL).\nAl apagar o borrar el contenedor, lo que está dentro de /home/rstudio/work/ siempre estará a salvo en su carpeta de Windows. El contenedor es solo el “motor”, sus archivos son el “combustible” que usted posee.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Docker: Gestión de Contenedores e Imágenes</span>"
    ]
  },
  {
    "objectID": "83-docker_desktop.html#sec-descarga_tar_yml",
    "href": "83-docker_desktop.html#sec-descarga_tar_yml",
    "title": "Apéndice D — Docker: Gestión de Contenedores e Imágenes",
    "section": "D.4 Descarga y preparación de archivos",
    "text": "D.4 Descarga y preparación de archivos\nSiga estos pasos para obtener la imagen base:\n\nDescarga: Obtenga el archivo de 15.5 GB desde el siguiente enlace: Google Drive - sig_unal_completo.zip.\nDescompresión Parte A: Extraiga el contenido de sig_unal_completo.zip.\nRenombrado: Al archivo resultante llamado sig_unal_completo.txt, cámbiele manualmente la extensión a .zip.\nDescompresión Parte B: Extraiga este nuevo archivo .zip para obtener los dos archivos definitivos:\n\nsig_unal_completo.tar (El archivo de la imagen).\ndocker-compose.yml (El NUEVO archivo de orquestación contenido en la descarga).",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Docker: Gestión de Contenedores e Imágenes</span>"
    ]
  },
  {
    "objectID": "83-docker_desktop.html#sec-cargar_docker_tar",
    "href": "83-docker_desktop.html#sec-cargar_docker_tar",
    "title": "Apéndice D — Docker: Gestión de Contenedores e Imágenes",
    "section": "D.5 Cargar imagen/contenedor a partir de imagen/contenedor base guardada en sig_unal_completo.tar y docker-compose.html",
    "text": "D.5 Cargar imagen/contenedor a partir de imagen/contenedor base guardada en sig_unal_completo.tar y docker-compose.html\nEste procedimiento instalará (mediante carga, es decir sin compilación) dos imágenes (una con la base de datos espacial y otra con Python, R y Julia) y configurará una red interna para comunicar su máquina anfitriona (Windows) con las dos máquinas virtuales Linux.\nDesde una terminal situada en la carpeta que contiene los archivos sig_unal_completo.tar y docker-compose.yml, ejecute:\ndocker load -i sig_unal_completo.tar\nEste proceso puede tardar varios minutos o inclusive horas dependiendo de su procesador y disco duro. Verifique que al finalizar aparezca el mensaje “Loaded image” para image_sig_unal:final y postgis_unal:final.\n\nNota: Existen dos versiones diferentes del archivo docker-compose.html. El primero es el que se describe en Sección D.6 y el segundo, que aplica para este procedimiento, es el que se descarga en Sección D.4.\n\n\nArchivo docker-compose.yml (orquestación)\nEste archivo es el manifiesto técnico que automatiza la construcción y coordinación de los servicios del curso. Su propósito es definir las reglas de convivencia entre los contenedores, configurando los siguientes pilares:\n\nImágenes: Versiones exactas de software (GDAL/Ubuntu para análisis y PostGIS para datos).\nPuertos: Mapeos específicos para acceder a las herramientas desde el equipo local sin conflictos (8889 para Jupyter, 8788 para el visor de R y 5434 para la base de datos).\nVolúmenes: Garantizan la persistencia de datos, sincronizando su carpeta local en tiempo real con el entorno interno del contenedor.\n\nA continuación, se describen los dos servicios integrados en este manifiesto:\n\nServicio de Análisis (analisis-geo): Identificado en el archivo como analisis-geo, este servicio no usa Dockerfile (la etiqueta build: . está no está habilitada). Es el motor políglota encargado de procesar R, Python y Julia sobre una base robusta de GDAL. Incluye una configuración de LD_PRELOAD para la estabilidad de las librerías dinámicas y una integración profunda que permite usar el visor httpgd de R como terminal gráfica unificada para todos los lenguajes. Crea el contenedor contenedor_sig_unal. La carpeta /home/rstudio/work del contenedor, mapea la carpeta del equipo local donde instaló las imágenes y contenedores a partir de sig_unal_completo.tar y docker-compose.yml.\nServicio PostGIS (db-postgis): Identificado como db-postgis, este servicio apunta a una imagen que fue creada a partir de la imagen especializada de Kartoza. Levanta el servidor de base de datos sig_db_unal, configurado para recibir conexiones espaciales desde sus scripts o herramientas externas como QGIS o ArcGIS a través del puerto 5434.\n\nservices:\n  analisis-geo:\n    # build: .                          # &lt;--- No utiliza Dockerfile\n    image: image_sig_unal:final         # &lt;--- Agrega esto para nombrar la imagen\n    container_name: contenedor_sig_unal # &lt;--- Cambia esto para el contenedor    \n    tty: true\n    stdin_open: true\n    volumes:\n      - .:/home/rstudio/work\n    environment:\n      - RETICULATE_PYTHON=/usr/bin/python3\n      - QUARTO_PYTHON=/usr/bin/python3\n      - JULIA_HOME=/opt/julia/bin\n      # Mantenemos la \"cirugía\" de Julia para que no choque con GDAL\n      - LD_PRELOAD=/usr/lib/x86_64-linux-gnu/libcurl.so.4:/usr/lib/x86_64-linux-gnu/libstdc++.so.6\n      - GKSwstype=100\n    ports:\n      # Forzamos IPv4 para que VS Code no se pierda en el limbo del [::1]\n      # JUPYTER: El 8889 de tu PC va al 8888 del contenedor\n      - \"127.0.0.1:8889:8888\" # &lt;----- Para programar en Notebooks localhost:8889\n      # R VISOR (httpgd): El 8788 de tu PC va al 8787 del contenedor \n      - \"127.0.0.1:8788:8787\" # &lt;----- Para ver los gráficos de R (httpgd) localhost:8788\n\n    depends_on:\n      - db-postgis\n\n  db-postgis:\n    image: postgis_unal:final\n    container_name: contenedor_postgis_unal    \n    environment:\n      - POSTGRES_USER=profe_unal\n      - POSTGRES_PASS=geomatica2025\n      - POSTGRES_DB=sig_db_unal\n    ports:\n      # Para acceder a la base de datos desde fuera del contenedor se usa 5434\n      - \"127.0.0.1:5434:5432\" \n    volumes:\n      - postgis_data_unal:/var/lib/postgresql\n\nvolumes:\n  postgis_data_unal:",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Docker: Gestión de Contenedores e Imágenes</span>"
    ]
  },
  {
    "objectID": "83-docker_desktop.html#sec-build_docker",
    "href": "83-docker_desktop.html#sec-build_docker",
    "title": "Apéndice D — Docker: Gestión de Contenedores e Imágenes",
    "section": "D.6 Compilar imagen/contenedor a partir de Dockerfile y docker-compose.html",
    "text": "D.6 Compilar imagen/contenedor a partir de Dockerfile y docker-compose.html\nEl procedimiento que garantiza una instalación (carga) exitosa de las imágenes y contenedores fue documentado en Sección D.5. Use este procedimiento solo si necesita compilar una nueva imagen con contenedores que satisfagan necesidades particulares definidas a partir de un archivo Dockerfile. Sin embargo, el Dockerfile que se presenta en esta sección fue el que se utilizó para compilar la imagen empaquetada cuyo proceso de carga se define en Sección D.5.\n\n\n\n\n\n\nOrganización del Proyecto\n\n\n\nPara automatizar el despliegue de los dos contenedores del curso (analisis-geo y db-postgis), se utilizó la orquestación de Docker. Mientras que el entorno de análisis se construyó a medida sobre la imagen base ghcr.io/osgeo/gdal:ubuntu-full-latest, el servicio de base de datos utilizó la imagen especializada kartoza/postgis.\nPara este proceso, se utilizaron dos archivos clave: docker-compose.yml y Dockerfile.\n\n\n\n\n\n\n\n\n\nArchivo\nRol Crítico\n\n\n\n\nDockerfile\nEl “Qué” (La Receta): Crea el entorno políglota desde cero, instala las librerías de NASA/Copernicus y aplica la “cirugía” de OpenSSL para que Julia sea estable en Ubuntu Noble.\n\n\ndocker-compose.yml\nEl “Cómo” (La Orquesta): Despliega los servicios, mapea los puertos externos (8889, 8788, 5434) y asegura que sus mapas y bases de datos no se borren gracias al volumen persistente (postgis_data_unal).\n\n\n\n\nCree una carpeta utilizando su ID de usuario de correo institucional como nombre (el identificador que aparece antes del @unal.edu.co). Por ejemplo, si su correo es juperez@unal.edu.co, la carpeta deberá llamarse juperez. En adelante llamaremos a esa carpeta su_carpeta o la carpeta ID UNAL.\nDentro de ella, guarde los archivos que se presentan a continuación.\n\nAntes de compilar debes:\n\nArrancar Docker Desktop\nCree una carpeta donde desea compilar las imágenes y copie allí los archivos Dockerfile y docker-compose.html.\nUsando la terminal (PowerShell en Windows) del equipo local, cambiase a la carpeta usando el comando cd, ej:\n\ncd \"ruta_a_carpeta\"\n\nConfiguración de Terminal: Abra PowerShell y ejecute el siguiente comando para visualizar correctamente caracteres especiales y logs:\n\n# Forzar UTF8 en el PowerShell\n[Console]::OutputEncoding = [System.Text.Encoding]::UTF8\nEl siguiente paso es compilar (solo una vez):\n\nCompilación limpia (sin usar caché) con archivo log:\n\nOpción 1: (recomendado) - Guarda el log al archivo y también lo muestra en la terminal - No utiliza archivos previamente descargados (--no-cache)\ndocker compose build --no-cache 2&gt;&1 | tee build_sig_unal.log\nOpción 2: - Guarda el log al archivo y no deja ver nada en la terminal - No utiliza archivos previamente descargados (--no-cache) - Se le asigna un etiqueta y una versión a la imagen (mi_sig_env:v1), lo cual evita referirse a ella por su ID hexadecimal que es imposible de recordar.\ndocker build --no-cache -t mi_sig_env:v1 . &gt; build_details.log 2&gt;&1\n\nArchivo docker-compose.yml\nservices:\n  # ============================================================\n  # SERVICIO PRINCIPAL\n  # Entorno de análisis geoespacial y científico\n  # Integra R, Python, Julia, GDAL, Quarto y Jupyter\n  # ============================================================\n  analisis-geo:\n    build: .\n    image: image_sig_unal                 # Nombre de la imagen Docker que se construye localmente\n    container_name: contenedor_sig_unal   # Nombre del contenedor (más fácil de usar en docker exec)\n    \n    # Permite sesiones interactivas (terminal, REPLs, etc.)\n    tty: true\n    stdin_open: true\n\n    # Carpeta compartida:\n    # Todo lo que esté en el proyecto (host) aparece dentro del contenedor\n    volumes:\n      - .:/home/rstudio/work\n\n    # ------------------------------------------------------------\n    # VARIABLES DE ENTORNO\n    # Aseguran que R, Python, Julia y Quarto usen versiones correctas\n    # ------------------------------------------------------------\n    environment:\n      - RETICULATE_PYTHON=/usr/bin/python3   # Python que usará R (reticulate)\n      - QUARTO_PYTHON=/usr/bin/python3       # Python que usará Quarto\n      - JULIA_HOME=/opt/julia/bin             # Ruta base de Julia\n\n      # \"Cirugía\" necesaria para evitar conflictos entre Julia y GDAL\n      # (muy común en entornos científicos mixtos)\n      - LD_PRELOAD=/usr/lib/x86_64-linux-gnu/libcurl.so.4:/usr/lib/x86_64-linux-gnu/libstdc++.so.6\n\n      # Backend gráfico de Julia (evita errores al graficar en contenedores)\n      - GKSwstype=100\n\n    # ------------------------------------------------------------\n    # PUERTOS\n    # izquierda = computador del estudiante (acceso externo con localhost)\n    # derecha   = contenedor (acceso interno - EXPOSE)\n    # ------------------------------------------------------------\n    ports:\n      # Jupyter Notebook / JupyterLab\n      # Se accede desde el navegador en: http://localhost:8889\n      - \"127.0.0.1:8889:8888\"\n\n      # Visor de gráficos de R (httpgd)\n      # Permite ver gráficos interactivos fuera de RStudio\n      - \"127.0.0.1:8788:8787\"\n\n    # Este servicio solo se inicia cuando la base de datos esté lista\n    depends_on:\n      - db-postgis\n\n  # ============================================================\n  # SERVICIO DE BASE DE DATOS\n  # PostgreSQL + PostGIS para datos espaciales\n  # ============================================================\n  db-postgis:\n    image: kartoza/postgis:latest\n    container_name: contenedor_postgis_unal\n\n    # Credenciales y base de datos inicial\n    environment:\n      - POSTGRES_USER=profe_unal\n      - POSTGRES_PASS=geomatica2025\n      - POSTGRES_DB=sig_db_unal\n\n    # Puerto para conectarse desde QGIS, DBeaver, PgAdmin, etc.\n    ports:\n      - \"127.0.0.1:5434:5432\"\n\n    # Volumen persistente:\n    # Los datos NO se pierden aunque el contenedor se borre\n    volumes:\n      - postgis_data_unal:/var/lib/postgresql\n\n# ============================================================\n# VOLUMENES DOCKER\n# Espacio en disco administrado por Docker\n# ============================================================\nvolumes:\n  postgis_data_unal:\n\n\nArchivo Dockerfile (Construcción del Entorno)\nEste archivo constituye la receta de construcción del entorno de análisis. Su función es “congelar” un sistema operativo Ubuntu Noble optimizado, garantizando que todos los estudiantes trabajen exactamente con las mismas versiones de librerías, compiladores y paquetes. Con este archivo Dockerfile y con el anterior archivo docker-compose.yml (Sección D.6.1) fue que se compiló la imagen que después se empaquetó en el archivo sig_unal_completo.tar para la carga de contenedores sin conexión a Internet. Note que el archivo docker-compose.yml (Sección D.5.1) que acompaña a sig_unal_completo.tar es diferente al archivo docker-compose.yml detallado en esta sección.\nLos pilares técnicos del archivo Dockerfile son:\n\nImagen Base Profesional: Utiliza la distribución oficial de OSGeo/GDAL, que provee el stack más estable de librerías geoespaciales (PROJ, GEOS, GDAL) a nivel de sistema.\nPila Políglota Integrada: Automatiza la instalación y configuración de R, Python 3 y Julia 1.10.4, resolviendo dependencias cruzadas que suelen ser difíciles de configurar manualmente.\nMotor de Reportes Científicos: Instala Quarto y TinyTeX, permitiendo la generación automática de informes en PDF y HTML con calidad editorial.\nPuente de Comunicación Maestro: Configura el archivo Rprofile.site, el cual actúa como el “cerebro” que permite a R ejecutar código de Julia y capturar gráficos de Python de forma transparente.\n\n# ============================================================\n# Imagen base\n# ------------------------------------------------------------\n# Imagen oficial de OSGeo con GDAL completo, PROJ, GEOS y soporte\n# raster/vector profesional. Base estándar en SIG reproducible.\n# ============================================================\nFROM ghcr.io/osgeo/gdal:ubuntu-full-latest\n\n\n# ============================================================\n# 1. Base, Locales y Pandoc\n# ------------------------------------------------------------\n# Configuración UTF-8 para evitar problemas con acentos,\n# R, Python, Julia, LaTeX y generación de documentos.\n# ============================================================\nENV LANG=en_US.UTF-8\nENV LC_ALL=en_US.UTF-8\n\n# Herramientas base del sistema:\n# - compiladores y toolchain (C/C++)\n# - git / curl / wget para descargas\n# - pandoc como motor universal de documentos\nRUN apt-get update && apt-get install -y locales git curl wget ca-certificates \\\n    build-essential cmake libtool automake pkg-config software-properties-common \\\n    pandoc && \\\n    locale-gen en_US.UTF-8\n\n\n# ============================================================\n# Librerías criptográficas y de red\n# ------------------------------------------------------------\n# Necesarias para:\n# - conexiones HTTPS\n# - Julia\n# - GDAL\n# - acceso a APIs externas\n# ============================================================\nRUN apt-get update && apt-get install -y --no-install-recommends \\\n    libmbedtls-dev \\\n    libnng-dev \\\n    libssl-dev \\\n    libxml2-dev \\\n    libcurl4-openssl-dev \\\n    git \\\n    cmake\n\n\n# ============================================================\n# 2. R, Python y dependencias de sistema\n# ------------------------------------------------------------\n# Incluye soporte para:\n# - SIG (GDAL / GEOS / PROJ)\n# - NetCDF / HDF5\n# - NASA / Copernicus\n# - WhiteboxTools\n# ============================================================\nRUN apt-get update && apt-get install -y --no-install-recommends \\\n    r-base r-base-dev python3-pip python3-dev \\\n    psmisc lsof net-tools ffmpeg \\\n    libpng-dev libcairo2-dev libsystemd-dev \\\n    libfontconfig1-dev libfreetype6-dev \\\n    libharfbuzz-dev libfribidi-dev \\\n    libcurl4-openssl-dev libsqlite3-dev libxml2-dev libssl-dev \\\n    libgeos-dev libproj-dev libgdal-dev libudunits2-dev \\\n    libgit2-dev libssh2-1-dev libxt-dev libglpk-dev libmount-dev \\\n    libmagick++-dev libpcre2-dev libnetcdf-dev libhdf5-dev \\\n    libxt6 libxrender1 libxext6 default-jdk \\\n    # Elimina la restricción de pip en Debian/Ubuntu modernos\n    && rm /usr/lib/python3.12/EXTERNALLY-MANAGED || true && \\\n    rm -rf /var/lib/apt/lists/*\n\n\n# ============================================================\n# 3. Quarto CLI y TinyTeX\n# ------------------------------------------------------------\n# Quarto: documentos reproducibles (HTML, PDF, slides)\n# TinyTeX: LaTeX liviano para generación de PDF\n# ============================================================\nRUN curl -LO https://github.com/quarto-dev/quarto-cli/releases/download/v1.4.550/quarto-1.4.550-linux-amd64.deb \\\n    && dpkg -i quarto-1.4.550-linux-amd64.deb && rm quarto-1.4.550-linux-amd64.deb \\\n    && quarto install tinytex --no-prompt\n\n\n# ============================================================\n# 4. Python Stack\n# ------------------------------------------------------------\n# Librerías SIG, ciencia de datos, notebooks y visualización\n# ============================================================\nRUN pip3 install --upgrade --ignore-installed --break-system-packages \\\n    # Ya estaban:\n    shapely matplotlib numpy geopandas fiona pyyaml nbformat nbclient ipykernel \\\n    # Nuevos agregados:\n    pandas rasterio rasterstats scipy psycopg2 pysal earthaccess cdsapi leafmap \\\n    geemap segment-geospatial geoai-py lidar pygis whitebox whiteboxgui streamlit \\\n    ghp-import jupyter-book jupyterlab jupytext mystmd notebook\n\n\n# ============================================================\n# 5. R Stack\n# ------------------------------------------------------------\n# Instalación desde CRAN optimizado de Posit para Linux\n# Incluye SIG, visualización, modelado y ML espacial\n# ============================================================\nRUN R -e \"options(timeout = 1000, Ncpus = parallel::detectCores(), repos = c(CRAN = 'https://packagemanager.posit.co/cran/__linux__/noble/latest')); \\\n    install.packages(c('ggplot2', 'patchwork', 'dplyr', 'remotes', 'languageserver', \\\n    'rmarkdown', 'units', 's2', 'sf', 'terra', 'stars', 'reticulate', 'IRkernel', \\\n    'unigd', 'cpp11', 'systemfonts', 'AsioHeaders', 'png', 'grid', 'JuliaCall', 'JuliaConnectoR', \\\n    # Nuevos CRAN:\n    'tidyverse', 'tmap', 'leaflet', 'googleway', 'ggspatial', 'mapview', 'plotly', \\\n    'rasterVis', 'cartogram', 'geogrid', 'geofacet', 'linemap', 'tanaka', 'rayshader', \\\n    'lwgeom', 'gstat', 'spdep', 'spatialreg', 'stplanr', 'sfnetworks', 'spatstat', \\\n    'stpp', 'magrittr', 'giscoR', 'caret', 'tidymodels', 'spatialsample', 'CAST', \\\n    'mlr3spatial', 'mlr3spatiotempcv', 'ncdf4', 'whitebox'))\"\n\n\n# ============================================================\n# Starsdata y repositorios específicos\n# ------------------------------------------------------------\n# Se compila desde código fuente y se usan repos especiales\n# ============================================================\nRUN R -e \"options(timeout = 30000, Ncpus = parallel::detectCores()); \\\n    install.packages('starsdata', repos='https://cran.uni-muenster.de/pebesma/', type='source')\" && \\\n    R -e \"options(timeout = 2000, Ncpus = parallel::detectCores()); \\\n    install.packages(c('mlr3cmprsk', 'survdistr'), repos=c('https://mlr3learners.r-universe.dev', 'https://cloud.r-project.org')); \\\n    install.packages('geocompkg', repos=c('https://geocompr.r-universe.dev', 'https://cloud.r-project.org'), dependencies=TRUE); \\\n    whitebox::install_whitebox(); IRkernel::installspec(user = FALSE)\"\n\n\n# ============================================================\n# httpgd estable\n# ------------------------------------------------------------\n# Dispositivo gráfico moderno para R (gráficos en navegador)\n# ============================================================\nRUN wget https://cran.r-project.org/src/contrib/Archive/httpgd/httpgd_2.0.3.tar.gz && \\\n    R CMD INSTALL httpgd_2.0.3.tar.gz && rm httpgd_2.0.3.tar.gz\n\n# ============================================================\n# 6. Puente Python ↔ R (Backend de Matplotlib para reticulate)\n# ------------------------------------------------------------\n# Permite que gráficos de matplotlib generados desde Python\n# puedan ser capturados y mostrados correctamente desde R\n# usando reticulate (especialmente en notebooks y httpgd).\n# ============================================================\n\n# Creamos la estructura esperada por reticulate\nRUN mkdir -p /usr/local/lib/python3.12/dist-packages/reticulate/matplotlib && \\\n    touch /usr/local/lib/python3.12/dist-packages/reticulate/__init__.py\n\n# Definimos una función que R puede interceptar\n# para recibir el path de la imagen generada por Python\nRUN printf 'def r_graphic_command(path):\\n    import os\\n    if os.path.exists(path): print(f\"r_graphic_command: {path}\")\\n' &gt; /usr/local/lib/python3.12/dist-packages/reticulate/__init__.py\n\n# Backend custom de matplotlib:\n# - Renderiza con Agg\n# - Guarda el gráfico como PNG temporal\n# - Notifica a R para que lo muestre\nRUN printf 'import matplotlib\\nfrom matplotlib.backends.backend_agg import FigureCanvasAgg\\nfrom matplotlib.backend_bases import FigureManagerBase\\n\\ndef show(*args, **kwargs):\\n    import os, tempfile, reticulate\\n    fd, path = tempfile.mkstemp(suffix=\".png\")\\n    os.close(fd)\\n    matplotlib.pyplot.savefig(path)\\n    if hasattr(reticulate, \"r_graphic_command\"):\\n        reticulate.r_graphic_command(path)\\n\\nclass FigureManager(FigureManagerBase):\\n    def show(self):\\n        show()\\n\\ndef new_figure_manager(num, *args, **kwargs):\\n    FigureClass = kwargs.pop(\"FigureClass\", matplotlib.figure.Figure)\\n    thisFig = FigureClass(*args, **kwargs)\\n    return new_figure_manager_given_figure(num, thisFig)\\n\\ndef new_figure_manager_given_figure(num, figure):\\n    canvas = FigureCanvasAgg(figure)\\n    manager = FigureManager(canvas, num)\\n    return manager\\n\\nFigureCanvas = FigureCanvasAgg\\n' &gt; /usr/local/lib/python3.12/dist-packages/reticulate/matplotlib/backend.py\n\n\n# ============================================================\n# 7. Julia: Instalación y Wrapper de Seguridad\n# ------------------------------------------------------------\n# Se instala Julia binaria oficial y se fuerza el uso de\n# librerías del sistema para evitar conflictos con GDAL/OpenSSL\n# ============================================================\n\n# Versión fija de Julia (reproducibilidad total)\nENV JULIA_VERSION=1.10.4\n\n# Descarga e instalación manual de Julia\nRUN wget https://julialang-s3.julialang.org/bin/linux/x64/1.10/julia-${JULIA_VERSION}-linux-x86_64.tar.gz \\\n    && tar -xvzf julia-${JULIA_VERSION}-linux-x86_64.tar.gz && mv julia-1.10.4 /opt/julia\n\n# Wrapper de Julia:\n# - Fuerza LD_PRELOAD\n# - Evita conflictos de libcurl / libstdc++\n# - Garantiza compatibilidad con GDAL\nRUN printf '#!/bin/bash\\nexport LD_PRELOAD=/usr/lib/x86_64-linux-gnu/libcurl.so.4:/usr/lib/x86_64-linux-gnu/libstdc++.so.6\\nexport JULIA_PKG_USE_CLI_GIT=true\\n/opt/julia/bin/julia \"$@\"\\n' &gt; /usr/local/bin/julia && chmod +x /usr/local/bin/julia\n    \n\n# ============================================================\n# 8. Julia: Configuración de librerías nativas\n# ------------------------------------------------------------\n# Se fijan explícitamente las rutas del sistema para:\n# - GDAL\n# - GEOS\n# evitando que Julia use binarios incompatibles\n# ============================================================\nRUN mkdir -p /root/.julia/environments/v1.10 && \\\n    printf \"[LocalPreferences]\\nGDAL_jll = { libgdal_path = \\\"/usr/lib/libgdal.so\\\" }\\nGEOS_jll = { libgeos_path = \\\"/usr/lib/x86_64-linux-gnu/libgeos_c.so\\\" }\\n\" &gt; /root/.julia/environments/v1.10/LocalPreferences.toml\n\n\n# ============================================================\n# 9. Julia: Instalación de paquetes\n# ------------------------------------------------------------\n# Stack SIG completo:\n# - Rasters, ArchGDAL, GeoStats, Makie\n# - Conectores DB, CSV, NetCDF\n# - Visualización y notebooks (IJulia)\n# ============================================================\nRUN julia -e 'using Pkg; Pkg.add([\"Preferences\", \"Suppressor\", \"RCall\", \"LibGEOS\", \"Tables\", \"DataFrames\", \"Plots\", \\\n    \"Statistics\", \"ArchGDAL\", \"LibPQ\", \"GeoDataFrames\", \"IJulia\", \"CSV\", \"CairoMakie\", \"AlgebraOfGraphics\", \\\n    \"DimensionalData\", \"FlexiJoins\", \"GeoFormatTypes\", \"GeoInterface\", \"GeoJSON\", \"GeoMakie\", \"GeometryOps\", \\\n    \"Makie\", \"MakieCore\", \"NaturalEarth\", \"Proj\", \"Rasters\", \"StatsBase\", \"Tyler\", \"GeoStats\", \"Graphs\", \\\n    \"NCDatasets\", \"MetaGraphsNext\"])'\n\n\n# ============================================================\n# Cirugía de librerías (OpenSSL)\n# ------------------------------------------------------------\n# Fuerza a Julia a usar OpenSSL del sistema (Ubuntu Noble)\n# Evita errores de TLS y descargas de paquetes\n# ============================================================\nRUN find /root/.julia/artifacts -name \"libssl.so*\" -exec ln -sf /usr/lib/x86_64-linux-gnu/libssl.so.3 {} \\; && \\\n    find /root/.julia/artifacts -name \"libcrypto.so*\" -exec ln -sf /usr/lib/x86_64-linux-gnu/libcrypto.so.3 {} \\;\n\n\n# ============================================================\n# Precompilación total de Julia\n# ------------------------------------------------------------\n# Garantiza arranque instantáneo en:\n# - VSCode\n# - Jupyter\n# - IJulia\n# ============================================================\nRUN julia -e 'using Pkg; Pkg.precompile()'\n\n\n# ============================================================\n# Configuración de paralelismo\n# ------------------------------------------------------------\n# Julia usará automáticamente todos los núcleos disponibles\n# ============================================================\nENV JULIA_NUM_THREADS=auto\n\n# ============================================================\n# 10. CONFIGURACIÓN MAESTRA Rprofile.site\n# ------------------------------------------------------------\n# Este archivo se ejecuta automáticamente cada vez que inicia R.\n# Centraliza la integración R ↔ Julia ↔ Python ↔ VSCode.\n#\n# Build 47.42:\n# - Control de DPI, tamaño y fuentes\n# - Ejecución segura de Julia desde R\n# - Renderizado consistente de gráficos\n# - Hook para Matplotlib vía reticulate\n# ============================================================\n\nRUN cat &lt;&lt; 'EOF' &gt; /usr/lib/R/etc/Rprofile.site\n# ============================================================\n# --- 1. AJUSTES DE SISTEMA ---\n# ------------------------------------------------------------\n# Variables globales para que R sepa dónde encontrar:\n# - Julia\n# - Python usado por Quarto\n# ============================================================\nSys.setenv(JULIA_BINDIR = \"/opt/julia/bin\")\nSys.setenv(QUARTO_PYTHON = \"/usr/bin/python3\")\n\n# ============================================================\n# Código Julia embebido (auto-sanable)\n# ------------------------------------------------------------\n# Se define como string para:\n# - Inyectarse dinámicamente en Julia\n# - Evitar errores si el kernel se reinicia\n# - Garantizar reproducibilidad en notebooks\n# ============================================================\n.unal_julia_code &lt;- '\nusing Suppressor, Plots, Statistics\n\n# Ejecutor central de código Julia desde R\n# - Evalúa múltiples expresiones\n# - Captura stdout\n# - Maneja gráficos y texto\nfunction _unal_core_executor(code, is_plot, filename, dpi, w, h, fs)\n    @capture_out begin\n        if is_plot\n            # Parámetros gráficos homogéneos (DPI, tamaño, fuentes)\n            default(dpi=dpi, size=(w, h), titlefontsize=fs+2, \n                    guidefontsize=fs, tickfontsize=fs-2, legendfontsize=fs-1)\n        end\n        pos = 1\n        while pos &lt;= lastindex(code)\n            start_idx = pos\n            try\n                ex, pos = Meta.parse(code, pos)\n                cmd_part = strip(code[start_idx:prevind(code, pos)])\n                if !isempty(cmd_part)\n                    println(\"julia&gt; \", cmd_part)\n                    res = eval(ex)\n                    if res !== nothing && !(res isa Plots.Plot)\n                        show(stdout, MIME(\"text/plain\"), res)\n                        println()\n                    end\n                    println() \n                end\n            catch e\n                println(\"julia&gt; Error: \", e)\n                break\n            end\n        end\n        # Guardado del gráfico si aplica\n        if is_plot && current() !== nothing; savefig(current(), filename); end\n    end\nend\n'\n\n# ============================================================\n# Inicialización segura de Julia\n# ------------------------------------------------------------\n# - Verifica que JuliaConnectoR esté disponible\n# - Inyecta el ejecutor solo una vez por sesión\n# ============================================================\n.ensure_julia_ready &lt;- function() {\n  if (!requireNamespace(\"JuliaConnectoR\", quietly = TRUE)) stop(\"JuliaConnectoR missing\")\n  if (!JuliaConnectoR::juliaEval('isdefined(Main, :_unal_core_executor)')) {\n    JuliaConnectoR::juliaEval(.unal_julia_code)\n  }\n}\n\n# ============================================================\n# j_eval(): ejecutar código Julia (solo texto)\n# ------------------------------------------------------------\n# Uso típico:\n# j_eval(\"1 + 1\")\n# ============================================================\nj_eval &lt;- function(cmd) {\n  .ensure_julia_ready()\n  cat(JuliaConnectoR::juliaCall(\"_unal_core_executor\", cmd, FALSE, \"\", 72, 800, 500, 12))\n}\n\n# ============================================================\n# j_plot(): ejecutar código Julia con gráficos\n# ------------------------------------------------------------\n# - Guarda el gráfico en PNG\n# - Lo renderiza directamente en R\n# ============================================================\nj_plot &lt;- function(cmd, n = \"tmp_plot.png\", dpi = 300, w = 800, h = NULL, ratio = 1.6, fontsize = 12) {\n  .ensure_julia_ready()\n  if (is.null(h)) h &lt;- round(w / ratio)\n  log_out &lt;- JuliaConnectoR::juliaCall(\"_unal_core_executor\", cmd, TRUE, n, dpi, as.integer(w), as.integer(h), as.integer(fontsize))\n  if (nchar(log_out) &gt; 0) cat(log_out)\n  if (file.exists(n)) {\n    img &lt;- png::readPNG(n)\n    grid::grid.newpage()\n    grid::grid.raster(img)\n  }\n}\n\n# ============================================================\n# --- 2. CARGA DE LIBRERÍAS Y DISPOSITIVOS ---\n# ------------------------------------------------------------\n# Librerías base para renderizar imágenes\n# ============================================================\nlibrary(png)\nlibrary(grid)\n\nif (interactive()) {\n\n  # ==========================================================\n  # Visor gráfico httpgd (VSCode / navegador)\n  # ----------------------------------------------------------\n  # Permite gráficos interactivos persistentes\n  # ==========================================================\n  if (requireNamespace(\"httpgd\", quietly = TRUE)) {\n    options(device = \"httpgd\", httpgd.host = \"0.0.0.0\", httpgd.port = 8787, httpgd.token = FALSE)\n  }\n  \n  # ==========================================================\n  # Hook Python → R (Matplotlib)\n  # ----------------------------------------------------------\n  # Captura gráficos de matplotlib y los muestra en R\n  # usando el backend custom definido en Docker\n  # ==========================================================\n  setHook(packageEvent(\"reticulate\", \"onLoad\"), function(...) {\n    try({\n      ret_py &lt;- reticulate::import(\"reticulate\", delay_load = TRUE)\n      reticulate::py_set_attr(ret_py, \"r_graphic_command\", function(path) {\n        if (file.exists(path)) {\n          img &lt;- png::readPNG(path)\n          grid::grid.newpage()\n          grid::grid.raster(img)\n        }\n      })\n      reticulate::py_run_string(\"import matplotlib; matplotlib.use('module://reticulate.matplotlib.backend')\")\n    }, silent = TRUE)\n  })\n}\nEOF\n\n\n# ============================================================\n# Compatibilidad multi-R (opcional)\n# ------------------------------------------------------------\n# Permite que R instalado en rutas alternativas use\n# exactamente la misma configuración\n# ============================================================\n#RUN cp /usr/lib/R/etc/Rprofile.site /etc/R/Rprofile.site\n\n\n# ============================================================\n# 10. Finalización del contenedor\n# ------------------------------------------------------------\n# Directorio de trabajo compartido\n# Permisos amplios para docencia\n# ============================================================\nWORKDIR /home/rstudio/work\nRUN chmod -R 777 /home/rstudio/work\n\n# Puertos:\n# 8888 → JupyterLab\n# 8787 → httpgd / RStudio-like viewer\nEXPOSE 8888\nEXPOSE 8787\n\n# Arranque por defecto: JupyterLab\nCMD [\"jupyter\", \"lab\", \"--ip=0.0.0.0\", \"--port=8888\", \"--no-browser\", \"--allow-root\", \"--NotebookApp.token='geomatica2025'\"]",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Docker: Gestión de Contenedores e Imágenes</span>"
    ]
  },
  {
    "objectID": "83-docker_desktop.html#sec-arrancar_detener_contenedores",
    "href": "83-docker_desktop.html#sec-arrancar_detener_contenedores",
    "title": "Apéndice D — Docker: Gestión de Contenedores e Imágenes",
    "section": "D.7 Arrancar y detener las imágenes",
    "text": "D.7 Arrancar y detener las imágenes\n\nArrancar las imágenes\nLos comandos build o load una vez se terminan satisfactoriamente, no necesitan volver a ejecutarse. El principal comando para subir el servicio de las imágenes instaladas se muestra a continuación.\nUse este comando siempre antes de iniciar a trabajar con los contenedores instalados. Esto activará los dos contenedores: uno para análisis geoespacial y otro para la base de datos.:\ndocker compose up -d\nSi detuvo los contenedores con docker compose stop, use este comando para reiniciarlos:\ndocker compose start\n\n\nDetener las imágenes\nPara apagar los contenedores sin borrar datos:\ndocker compose stop\nSi necesita borrar todo (por ejemplo para reinstalar) (los datos de la DB se mantienen en el volumen):\ndocker compose down",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Docker: Gestión de Contenedores e Imágenes</span>"
    ]
  },
  {
    "objectID": "83-docker_desktop.html#verificar-logs-de-instalación",
    "href": "83-docker_desktop.html#verificar-logs-de-instalación",
    "title": "Apéndice D — Docker: Gestión de Contenedores e Imágenes",
    "section": "D.8 Verificar logs de instalación",
    "text": "D.8 Verificar logs de instalación\nVerificación de Logs: Si desea ver el log de instalación de una imagen compilada, ejecute el siguiente comando, sin embargo la url de acceso a Jupyter Lab mostrada después de ejecutar este comando puede estar errónea. Para acceder a Jupyter Lab vea (Sección B.6)\ndocker logs contenedor_sig_unal",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Docker: Gestión de Contenedores e Imágenes</span>"
    ]
  },
  {
    "objectID": "83-docker_desktop.html#comandos-docker",
    "href": "83-docker_desktop.html#comandos-docker",
    "title": "Apéndice D — Docker: Gestión de Contenedores e Imágenes",
    "section": "D.9 Comandos docker",
    "text": "D.9 Comandos docker\nUse la siguiente tabla como referencia para gestionar sus contenedores desde la terminal de su sistema anfitrión (Windows/Mac/Linux).\n\n\n\n\n\n\n\n\nAcción\nComando\nPropósito\n\n\n\n\nConstrucción Inicial\ndocker-compose up --build -d\nCompila el Dockerfile y levanta los servicios (Solo una vez).\n\n\nInicio Diario\ndocker-compose up -d\nInicia los servicios de forma instantánea si ya fueron construidos.\n\n\nMonitoreo de Procesos\ndocker logs -f entorno_unal_sig\nSigue los logs en vivo (ideal para ver pre-compilaciones).\n\n\nVer logs recientes\ndocker logs --tail 20 entorno_unal_sig\nMuestra las últimas 20 líneas (ideal para buscar el token).\n\n\nApagado\ndocker-compose down\nDetiene los servicios y libera recursos del sistema.\n\n\nPrueba de R (sf)\ndocker exec entorno_unal_sig R -e \"library(sf); print('R-Spatial detectado')\"\nConfirmar que R reconoce los drivers geoespaciales del sistema.\n\n\nPrueba de Python\ndocker exec entorno_unal_sig python -c \"import shapely; import geopandas; print('Python OK')\"\nConfirmar que el stack de Python (GeoPandas/Shapely) está instalado.\n\n\nPrueba de Julia\ndocker exec entorno_unal_sig julia -e \"using LibGEOS; println('Julia OK')\"\nConfirmar que Julia tiene acceso a los binarios geoespaciales.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Docker: Gestión de Contenedores e Imágenes</span>"
    ]
  },
  {
    "objectID": "83-docker_desktop.html#compilación-avanzada",
    "href": "83-docker_desktop.html#compilación-avanzada",
    "title": "Apéndice D — Docker: Gestión de Contenedores e Imágenes",
    "section": "D.10 Compilación avanzada",
    "text": "D.10 Compilación avanzada\nPara trabajar con entornos SIG, a menudo necesitamos reconstruir imágenes sin basura previa.\n\nCompilación Limpia (Sin Cache) con Log: Para asegurar que Docker descargue todas las librerías desde cero y guarde un registro detallado de los errores: docker build --no-cache -t mi_sig_env:v1 . --progress=plain &gt; build_details.log 2&gt;&1\nSubir Imagen a Repositorio: docker tag mi_sig_env:v1 usuario_dockerhub/mi_sig_env:v1 docker push usuario_dockerhub/mi_sig_env:v1\nCargar en VSCode: Una vez el contenedor esté corriendo, use la extensión Dev Containers -&gt; Botón verde inferior izquierdo -&gt; Attach to Running Container.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Docker: Gestión de Contenedores e Imágenes</span>"
    ]
  },
  {
    "objectID": "83-docker_desktop.html#cambio-de-ruta-de-almacenamiento-windows",
    "href": "83-docker_desktop.html#cambio-de-ruta-de-almacenamiento-windows",
    "title": "Apéndice D — Docker: Gestión de Contenedores e Imágenes",
    "section": "D.11 Cambio de ruta de almacenamiento (Windows)",
    "text": "D.11 Cambio de ruta de almacenamiento (Windows)\nSi el disco C: se agota debido a las imágenes de Docker, siga estos pasos en Docker Desktop: 1. Vaya a Settings (engranaje). 2. Resources &gt; Advanced. 3. En Disk image location, cambie la ruta a un disco con mayor capacidad (ej. D:\\DockerImages). 4. Presione Apply & Restart.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Docker: Gestión de Contenedores e Imágenes</span>"
    ]
  },
  {
    "objectID": "83-docker_desktop.html#sec-optimizacion-memoria",
    "href": "83-docker_desktop.html#sec-optimizacion-memoria",
    "title": "Apéndice D — Docker: Gestión de Contenedores e Imágenes",
    "section": "D.12 Optimización de memoria RAM y swap",
    "text": "D.12 Optimización de memoria RAM y swap\nCuando procesamos datos masivos (como imágenes Sentinel-2 o rásters globales), la RAM física de 16GB suele ser insuficiente. Para evitar que el sistema aborte los procesos con el error “Killed”, debemos configurar un “pulmón” de emergencia en dos niveles.\n\n1. El “pulmón” de Windows: memoria virtual\nObligamos a Windows a usar el disco duro como si fuera RAM de reserva. Si tiene un disco sólido (SSD) secundario con mucho espacio libre (ej. Disco D:), es el lugar ideal para configurarlo.\n\nEn el buscador de Windows, escriba: “Ajustar la apariencia y rendimiento de Windows”.\nVaya a la pestaña Opciones avanzadas &gt; sección Memoria virtual &gt; clic en Cambiar.\nDesmarque la opción “Administrar automáticamente el tamaño del archivo de paginación para todas las unidades”.\nSeleccione la unidad de disco (C: o D:) y marque Tamaño personalizado.\nEstablezca los siguientes valores (recomendados para este curso):\n\nTamaño inicial: 16384 MB (16 GB).\nTamaño máximo: 32768 MB (32 GB).\n\nHaga clic en Establecer, luego en Aceptar y reinicie su computadora para aplicar los cambios.\n\n\n\n2. El “túnel” de docker: swap de WSL2\nDocker Desktop corre sobre WSL2 (Windows Subsystem for Linux), el cual tiene su propio “presupuesto” limitado. Por defecto, este túnel es estrecho (máximo 4GB de Swap). Si no ampliamos esto, el contenedor nunca podrá aprovechar realmente el espacio que le asignamos a Windows.\nCómo ampliar la tubería: 1. Presione Win + R, escriba %UserProfile% y presione Enter. 2. Busque el archivo .wslconfig. Si no existe, créelo con el Bloc de Notas. 3. Pegue el siguiente contenido:\n[wsl2]\nmemory=12GB # RAM máxima que le permitimos usar a Linux/Docker\nswap=16GB   # El nuevo tamaño de swap que verá el comando 'top' en la terminal\n\nAplicar cambios: Guarde el archivo, abra una terminal (PowerShell) y escriba wsl --shutdown. Luego, inicie Docker Desktop nuevamente.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Docker: Gestión de Contenedores e Imágenes</span>"
    ]
  },
  {
    "objectID": "83-docker_desktop.html#higiene-y-limpieza-de-choque",
    "href": "83-docker_desktop.html#higiene-y-limpieza-de-choque",
    "title": "Apéndice D — Docker: Gestión de Contenedores e Imágenes",
    "section": "D.13 Higiene y limpieza de choque",
    "text": "D.13 Higiene y limpieza de choque\nPara garantizar que un renderizado de Quarto llegue al 100% sin colapsar el contenedor, aplique estas medidas de higiene:\n\nCierre “Vampiros”: Aplicaciones como Chrome, Edge, Teams y Slack consumen RAM de forma agresiva. Ciérrelas antes de procesos pesados.\nLimpieza de disco: Use el Liberador de espacio en disco (cleanmgr) para vaciar archivos de volcado de memoria.\nLa “Escoba” en el Código: Use comandos de limpieza entre procesos de diferentes lenguajes:\n\nR: rm(obj); gc(full = TRUE)\nPython: del var; gc.collect()\nJulia: GC.gc()\n\n\n\n\n\n\n\n\nImportante para Visualización\n\n\n\nEn Julia y R, evite generar gráficos interactivos pesados dentro de bucles de procesamiento. La acumulación de objetos visuales en la memoria de VSCode es la causa número uno de colapsos en el contenedor.\n\n\n\n\n\n\nInc., D. (2025). Docker Desktop Documentation. https://docs.docker.com",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Docker: Gestión de Contenedores e Imágenes</span>"
    ]
  },
  {
    "objectID": "84-git_github.html",
    "href": "84-git_github.html",
    "title": "Apéndice E — Git y GitHub: Sincronización Local-Remota",
    "section": "",
    "text": "E.1 Instalación de Git",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>E</span>  <span class='chapter-title'>Git y GitHub: Sincronización Local-Remota</span>"
    ]
  },
  {
    "objectID": "84-git_github.html#sec-cuenta_github",
    "href": "84-git_github.html#sec-cuenta_github",
    "title": "Apéndice E — Git y GitHub: Sincronización Local-Remota",
    "section": "E.2 Creación de cuenta en GitHub",
    "text": "E.2 Creación de cuenta en GitHub",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>E</span>  <span class='chapter-title'>Git y GitHub: Sincronización Local-Remota</span>"
    ]
  },
  {
    "objectID": "84-git_github.html#sec-git-terminal",
    "href": "84-git_github.html#sec-git-terminal",
    "title": "Apéndice E — Git y GitHub: Sincronización Local-Remota",
    "section": "E.3 Control de versiones - flujo de trabajo en PowerShell",
    "text": "E.3 Control de versiones - flujo de trabajo en PowerShell\nPara gestionar el repositorio de forma robusta y tener control total sobre el historial de cambios, utilice la siguiente secuencia de comandos desde la terminal del contenedor:\n\n\n\nTabla E.1: Comandos esenciales para la gestión de Git en terminal\n\n\n\n\n\n\n\n\n\n\nAcción\nComando\nPropósito\n\n\n\n\nVerificar estado\ngit status\nMuestra la “verdad absoluta” local: archivos modificados o listos para commit.\n\n\nSincronizar índices\ngit remote update\nConsulta el servidor para saber si hay cambios nuevos en la nube sin descargarlos aún.\n\n\nPreparar cambios\ngit add .\nAgrega todos los cambios detectados al área de preparación (Staging).\n\n\nConfirmar versión\ngit commit -m \"mensaje\"\nCrea un punto de control permanente en el historial local.\n\n\nEnviar al remoto\ngit push\nSube los commits locales al servidor (GitHub).\n\n\nActualizar local\ngit pull\nDescarga y fusiona los cambios del servidor en su entorno de trabajo.\n\n\nVer historial\ngit log --oneline\nMuestra un resumen simplificado de la línea de tiempo del proyecto.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>E</span>  <span class='chapter-title'>Git y GitHub: Sincronización Local-Remota</span>"
    ]
  },
  {
    "objectID": "84-git_github.html#sec-git-diagnostico",
    "href": "84-git_github.html#sec-git-diagnostico",
    "title": "Apéndice E — Git y GitHub: Sincronización Local-Remota",
    "section": "E.4 Diagnóstico de archivos “invisibles” o errores de rastreo",
    "text": "E.4 Diagnóstico de archivos “invisibles” o errores de rastreo\nSi ha modificado un archivo pero este no aparece listado tras ejecutar git status, las causas técnicas suelen ser las siguientes:\n\nInterferencia de Repositorios Anidados: Si clonó una carpeta que ya contenía un directorio .git, el repositorio principal la tratará como un objeto opaco (submódulo) y no rastreará sus archivos internos.\n\nSolución: Verifique la presencia de carpetas ocultas con ls -a y elimine la carpeta .git interna si desea que el repositorio raíz tome el control: rm -rf nombre_carpeta/.git.\n\nFiltros en el archivo .gitignore: El archivo puede tener reglas que excluyan carpetas enteras por nombre o extensión.\n\nVerificación: Use el comando git status --ignored para listar todos los archivos que Git está omitiendo deliberadamente.\n\nEstado del sistema de archivos: Git opera sobre los datos escritos en el disco duro. Asegúrese de que el editor de texto haya guardado efectivamente los cambios en el archivo físico antes de consultar el estado.\n\n\n\n\n\n\n\nPersistencia de Credenciales\n\n\n\nSi la terminal le solicita usuario y contraseña en cada push o pull, puede configurar Git para que recuerde sus credenciales temporalmente en la memoria del contenedor con el siguiente comando: git config --global credential.helper cache",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>E</span>  <span class='chapter-title'>Git y GitHub: Sincronización Local-Remota</span>"
    ]
  },
  {
    "objectID": "84-git_github.html#subír-el-contenido-carpeta-local-hacia-github",
    "href": "84-git_github.html#subír-el-contenido-carpeta-local-hacia-github",
    "title": "Apéndice E — Git y GitHub: Sincronización Local-Remota",
    "section": "E.5 Subír el contenido (carpeta local hacia GitHub)",
    "text": "E.5 Subír el contenido (carpeta local hacia GitHub)\nSi ya tiene sus archivos en Windows y quiere subirlos a un repositorio recién creado en GitHub:\n\nInstalar Git\n\n\nDescarga: Acceda a git-scm.com/download/win.\nInstalación: Ejecute el instalador manteniendo las opciones por defecto; asegúrese de que la opción “Git from the command line and also from 3rd-party software” esté activa.\nVerificación: Ejecute git --version en una terminal para confirmar la instalación.\n\n\nCrear una cuenta en GitHub\nAbrir Terminal en la carpeta local:\nIncicializar Git en la carpeta local:\n\ngit init\n\nVer el estado actual del repositorio Git:\n\ngit status\n\nArchivo .gitignore: Crear un archivo de texto .gitignore para indicarle a Git los archivos y carperas que nunca deben ser registrados con Git cuando se use el comando git add (siguiente item del procedimiento). Estos archivos que pueden estar en la raíz de la carpeta o dentro de otras sub-carpetas no se registrarán automáticamente cuando ejecute el comando git add . (ver mas adelante). Sin embargo puede forzar una carpeta o algunos tipos de archivos que estén marcados para ignorar dentro del .gitignore (ver mas adelante).\n\n.quarto/\n_freeze/\n.ipynb_checkpoints/\n__pycache__/\nnotebooks/\nscripts/\ndata/\n\nRegistrar (add) el archivo .gitignore con Git:\n\ngit add .gitignore\n\nRevise nuevamente el estátus y verifique cambios. Puede incluir el listado de los ignorados:\n\ngit status --ignored\n\nSalvar (commit) el archivo en Git (local). Note que en el comando, el texto “Archivo .gitignore” es un comentario que describe lo que está salvando:\n\ngit commit -m \"Archivo .gitignore\"\n\nCambiar al nombre de rama (branch) a principal (main). Pueden haber diferentes ramas con diferentes versiones del mismo archivo. Para cambiar a main:\n\ngit branch -M main\n\nConectar el repositorio local (Git) con nuestro repositorio en GitHub.\n\nPara conectar Git con GitHub, puede hacerlo con SSH (debe realizar el proceso de instalación de llaves Sección E.6) o con HTTPS (debe generar un PAT desde github.com que usará como clave de autenticación). En este caso usaremos HTTPS.\nCree un nuevo repositorio en GitHub y copie la url HTTP del repositorio. Es algo como: https://github.com/usuario/repositorio.git\ngit remote add origin https://github.com/usuario/repositorio.git\n\nProcedimiento para generar el PAT (Personal Access Token) en GitHub.com {#ancla-github_pat}\n\n\nEn lugar de escribir tu contraseña cuando el terminal te la pida, debes pegar un token generado en tu cuenta.\nVe a tu cuenta de GitHub.com: Settings &gt; Developer settings &gt; Personal access tokens &gt; Tokens (classic).\nGenera un nuevo token con el permiso repo activado.\nCopia el token (no lo volverás a ver).\n\n\nSubir (push) la información guardada localmente en Git a nuestro repositorio en GitHub:\n\ngit push -u origin main   \n# Cuanto solicite el password use el PAT/token generado previamente en github.com\nPuedes ver el estatus git status y realizar un procedimiento similar para registrar (add), salvar (commit) y subir (push) mas archivos. Otras opciones de Git se describen a continuación:\n\nRegistrar archivos específicos con Git (local):\n\ngit add file1 file2 ...\n\nForzar archivos y/o carpetas que están marcados para ignorar (bandera -f): el comando a continuación sincronizará con Git toda la carpeta _site/site_libs/ y su contenido, así contenga archivos o carpetas marcados para ignorar en .gitignore. {#ancla-git_add_minus_f}\n\ngit add -f _site/site_libs/\n\nRegistrar todos los archivos y carpetas disponibles y sin registrar, sin embargo todos los archivos y carpetas dentro de .gitignore no serán tenidos en cuenta {#ancla-git_add_punto}:\n\ngit add .\n\nEn resumen estos son los comandos que comúnmente usarás para mentener sincronizados tus archivos con Git y tu Git con GitHub, es decir el proceso de subir (push) archivos a la nube.\n\ngit add (agregar archivos a Git)\ngit commit (guardar archivos en Git)\ngit push (subir archivos a GitHub)\n\nLos otros comandos vistos solo se ejecutan una vez o de acuerdo con necesitades específicas:\n\ngit init (una vez)\ngit remote add origin (una vez)\ngit branch -M main (lo debes usar para cambiar a main en caso de tener múltiples ramas)",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>E</span>  <span class='chapter-title'>Git y GitHub: Sincronización Local-Remota</span>"
    ]
  },
  {
    "objectID": "84-git_github.html#sec-ssh-github",
    "href": "84-git_github.html#sec-ssh-github",
    "title": "Apéndice E — Git y GitHub: Sincronización Local-Remota",
    "section": "E.6 Autenticación segura SSH - Windows",
    "text": "E.6 Autenticación segura SSH - Windows\nLa autenticación mediante SSH permite interactuar con GitHub de forma segura sin necesidad de ingresar credenciales manualmente en cada operación. Siga este procedimiento detallado para configurar su acceso.\n\nRequisito previo: creación de cuenta en GitHub\nEl correo que use para crear esta cuenta debe ser el mismo correo usado para crear las llaves SSH para conexión automática.\n\n\nRequisito previo: instalación de Git\nEs indispensable que su sistema operativo cuente con el motor de Git antes de iniciar la configuración:\n\n\nPreparación del entorno local\n\nNavegación: Diríjase mediante el Explorador de Archivos a la carpeta raíz de su proyecto (ejemplo: carpeta ID Unal).\nTerminal: Abra una ventana de PowerShell en esa ubicación (clic derecho -&gt; “Abrir en Terminal”).\nInicialización: Prepare el repositorio local mediante el comando:\n\ngit init\n\n\nGestión de llaves SSH en Windows\nSSH (Secure Shell) es un protocolo de red diseñado para el acceso, administración y transferencia de datos entre un equipo local y un servidor remoto mediante un canal cifrado. En nuestro flujo de trabajo, implementamos el algoritmo Ed25519, un estándar de vanguardia basado en criptografía de curva elíptica (EdDSA). Este método no solo ofrece un nivel de seguridad superior frente a ataques de fuerza bruta, sino que permite una autenticación transparente y sin contraseña, actuando como un “pasaporte digital” que vincula de forma única su estación de trabajo con GitHub.\n\n\n\n\n\n\n¿Por qué Ed25519?\n\n\n\nA diferencia de los estándares antiguos (como RSA), Ed25519 genera llaves más cortas, rápidas y significativamente más seguras, optimizando la latencia en cada comunicación con el repositorio.\n\n\n\nComprobación de llaves existentes: Verifique si su usuario ya posee llaves configuradas:\n\nls ~/.ssh\n* Si el directorio está vacío o solo contiene `known_hosts`, proceda a generar una nueva.\n* Si visualiza los archivos `id_ed25519` e `id_ed25519.pub`, puede saltar al paso de registro en GitHub.\n\nGeneración de llaves: Cree un par de llaves seguras utilizando el algoritmo Ed25519:\n\nEl correo que use en el siguiente paso, debe ser el correo con el que creó la cuenta de GitHub: “su_correo@domimio.com”\nssh-keygen -t ed25519 -C \"su_correo@domimio.com\"\n* **Nota**: Presione `ENTER` en todas las solicitudes para aceptar las rutas por defecto y no asignar una *passphrase*.\n\n\n\n\n\n\nSeguridad de la Identidad\n\n\n\nLa llave pública (id_ed25519.pub) es la que se entrega a GitHub, mientras que la llave privada (id_ed25519) funciona como su sello personal secreto y nunca debe salir de su equipo.\n\n\n\n\nRegistro de la identidad en GitHub\n\nCopiar la firma pública: Obtenga el contenido de su llave para registrarla:\n\ncat $env:USERPROFILE\\.ssh\\id_ed25519.pub\n*Seleccione y copie toda la cadena de texto resultante.*\n\nConfiguración en la plataforma:\n\nAcceda a su cuenta en GitHub.com.\nEntre a Settings -&gt; SSH and GPG keys.\nSeleccione New SSH key.\nAsigne el título Windows-UNAL-2025, pegue el contenido en el campo Key y presione Add SSH key.\n\n\n\n\nActivación del agente SSH del sistema\nPara que Windows gestione su identidad de forma transparente, debe habilitar el servicio correspondiente:\n\nModo Administrador: Cierre su terminal actual y abra una nueva sesión de PowerShell como Administrador.\nHabilitar Servicio: Ejecute los siguientes comandos para automatizar el arranque del agente:\n\nSet-Service ssh-agent -StartupType Automatic\nStart-Service ssh-agent\n\nCargar la llave privada: Registre su llave en el agente activo:\n\nssh-add $env:USERPROFILE\\.ssh\\id_ed25519\n\n\nVerificación de la autenticación\n\nPrueba de conexión: Compruebe que el túnel de comunicación con los servidores de GitHub funciona correctamente:\n\nssh -T git@github.com\n\nResultado esperado: Si la configuración es exitosa, recibirá un mensaje similar a: Hi usuario! You've successfully authenticated, but GitHub does not provide shell access.\n\n\n¡Túnel SSH Activo y Configurado!\nHas establecido una identidad digital segura entre tu equipo y GitHub. A partir de este momento, la comunicación para sincronizar tus repositorios será transparente y automática.\n\nIdentidad Permanente: Esta configuración se realiza una sola vez por computador; tu “firma digital” ya reside en el sistema.\nAdiós a las Interrupciones: GitHub ya no solicitará tu usuario, contraseña o tokens personales de acceso en cada operación.\nCompatibilidad Total: Esta llave es reconocida automáticamente por PowerShell, VSCode, Positron, RStudio y cualquier otra terminal científica que utilices.\nSeguridad de Grado Profesional: Tus envíos (push) viajan ahora por un canal cifrado bajo el estándar Ed25519.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>E</span>  <span class='chapter-title'>Git y GitHub: Sincronización Local-Remota</span>"
    ]
  },
  {
    "objectID": "84-git_github.html#sec-ssh-linux",
    "href": "84-git_github.html#sec-ssh-linux",
    "title": "Apéndice E — Git y GitHub: Sincronización Local-Remota",
    "section": "E.7 Autenticación segura SSH - Linux (Docker)",
    "text": "E.7 Autenticación segura SSH - Linux (Docker)\nLa autenticación mediante SSH permite interactuar con GitHub de forma segura sin ingresar credenciales manualmente. En contenedores Docker, esto soluciona errores de validación SSL y facilita el uso de extensiones de Quarto.\n\nPreparación del Entorno Global\nAntes de generar las llaves, configura tu identidad de Git y verifica que el contenedor tenga salida a internet.\n\nConfigurar identidad:\n\ngit config --global user.email \"correo@dominio.com\"\ngit config --global user.name \"usuario_github\"\n\nVerificar conexión:\n\ncurl -I https://github.com\n\n\n\n\n\n\nAdvertencia\n\n\n\nSi recibes el error * “Could not resolve host”*, revisa la configuración de red de tu contenedor.\n\n\n\n\nGestión de llaves SSH (Algoritmo Ed25519)\nImplementamos Ed25519, el estándar actual por su seguridad y velocidad.\n\nComprobar llaves existentes:\n\nls -la ~/.ssh\n\nGenerar nueva llave: Ejecuta el comando y presiona ENTER en todas las solicitudes (sin contraseña).\n\nssh-keygen -t ed25519 -C \"alexyshr@gmail.com\"\n\n\n\n\n\n\nNota\n\n\n\nLa llave pública (id_ed25519.pub) se registra en GitHub; la llave privada (id_ed25519) es tu firma secreta.\n\n\n\n\nRegistro de Identidad en GitHub\n\nVisualizar y copiar la llave pública:\n\ncat ~/.ssh/id_ed25519.pub\n\nConfigurar en la web:\n\nVe a Settings -&gt; SSH and GPG keys en tu cuenta de GitHub.\nHaz clic en New SSH key.\nTítulo: Docker-RStudio-Geomatica.\nPega el contenido y guarda.\n\n\n\n\nActivación del Agente SSH\nPara que el sistema use tu llave automáticamente, inicia el agente y regístrala:\n# Iniciar agente\neval \"$(ssh-agent -s)\"\n\n# Cargar la llave privada\nssh-add ~/.ssh/id_ed25519\n\n\nVerificación Final\nComprueba que el túnel de comunicación funciona correctamente:\nssh -T git@github.com\nResultado esperado: &gt; Hi usuario_github! You've successfully authenticated, but GitHub does not provide shell access.\n\n¡Configuración Exitosa!\nTu contenedor ahora es un entorno de confianza para GitHub. Comandos como quarto add o git push funcionarán de forma transparente.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>E</span>  <span class='chapter-title'>Git y GitHub: Sincronización Local-Remota</span>"
    ]
  },
  {
    "objectID": "84-git_github.html#sec-vinculacion-clase",
    "href": "84-git_github.html#sec-vinculacion-clase",
    "title": "Apéndice E — Git y GitHub: Sincronización Local-Remota",
    "section": "E.8 Descargar contenido (GitHub hacia carpeta local)",
    "text": "E.8 Descargar contenido (GitHub hacia carpeta local)\nPara explicar este procedimiento, usaremos el repositorio GitHub con el material de la clase. Los contenidos de la clase están en https://github.com/alexyshr/ProgramacionSIG2026.git (HTTPS) o git@github.com:alexyshr/ProgramacionSIG2026.git (SSH). La elección de uno de estos dos protocolos (HTTPS o SSH), depende de si ha configurado su identidad digital, ver Sección E.6.\n\n\n\n\n\n\n¡Advertencia sobre la Estructura de Carpetas!\n\n\n\nEs fundamental para el orden del curso que el repositorio con los contenidos de la clase se conecte a una carpeta independiente.\nNo sincronice estos archivos dentro de su carpeta local con los contenedores ID UNAL. Mantener directorios separados garantiza que sus ejercicios personales y los materiales de lectura del profesor no se mezclen, evitando errores de sobreescritura y conflictos de Git al realizar actualizaciones del material.\n\n\n\nOpción A: sincronizar mediante SSH (recomendado)\nUtilice este método si ya configuró sus llaves siguiendo los pasos de la Sección E.6.\n\n\n\n\n\n\nUrl SSH del Repositorio para la Clase\n\n\n\ngit@github.com:alexyshr/ProgramacionSIG2026.git\n\n\n\nVincular el repositorio remoto: Si ya inicializó su carpeta local (no la de sus contenedores Docker) con git init, ejecute el siguiente comando para establecer el origen:\n\ngit remote add origin git@github.com:alexyshr/ProgramacionSIG2026.git\n\nDescargar el contenido (Pull): Para traer los archivos del servidor a su computadora por primera vez:\n\ngit pull origin main\n\nVerificación de estado: Confirme que la carpeta local está sincronizada correctamente:\n\ngit status\n*Resultado esperado: `On branch main. Your branch is up to date. working tree clean.`*\n\n\nOpción B: sincronizar mediante HTTPS\nUtilice este método si aún no ha configurado llaves SSH o prefiere una descarga rápida. A diferencia del método anterior, este suele solicitar un Personal Access Token (PAT) (ver líneas arriba) para realizar operaciones de subida (push).\n\n\n\n\n\n\nUrl HTTPS del Repositorio para la Clase\n\n\n\nhttps://github.com/alexyshr/ProgramacionSIG2026.git\n\n\n\nOpción B-1: Descarga rápida mediante git clone\n\nNota: Este procedimiento tiene la desventaja que el nombre de la carpeta es definido por el nombre del respositorio en GitHub, no por el usuario (usted).\n\n\nEste comando descarga el repositorio completo y crea automáticamente una subcarpeta con el nombre del proyecto:\n\ngit clone https://github.com/alexyshr/ProgramacionSIG2026.git\n\nPara chequear por actualizaciones en el repositorio remoto:\n\ngit remote -v\n\nPara descargar las actualizaciones a la carpeta local, es decir sincronizar el repositorio remoto con la carpeta local:\n\ngit pull\n\n\nOpción B-2: Sincronizar repositorio GitHub con carpeta local existente\nUtilice este procedimiento si usted ya creó una carpeta localmente (por ejemplo, ProgramacionSIG2026) y desea vincularla al repositorio oficial de GitHub para recibir actualizaciones sin perder sus archivos actuales.\nEjecute los siguientes comandos desde la terminal dentro de su carpeta de trabajo:\n# 1. Iniciar el repositorio localmente\ngit init\n\n# 2. Vincular la carpeta local con el servidor de GitHub\ngit remote add origin https://github.com/alexyshr/ProgramacionSIG2026.git\n\n# 3. Asegurar que la rama principal se llame 'main'\ngit branch -M main\n\n# 4. Sincronizar (traer los archivos del servidor)\n# Usamos --allow-unrelated-histories para permitir la fusión de carpetas  \n# que no \"nacieron\" del mismo commit original.\ngit pull origin main --allow-unrelated-histories\n\n\n\n\n\n\nManejo de conflictos en el primer pull\n\n\n\nAl ejecutar el git pull en una carpeta existente, es posible que Git le pida resolver conflictos si usted tiene archivos con el mismo nombre que los del repositorio (ej. un README.md genérico).\nSi desea forzar que sus archivos locales sean sobrescritos por los del repositorio oficial, puede usar: git fetch --all git reset --hard origin/main\n\n\n\n\n\n\n\n\nVerificación de la conexión\n\n\n\nPara confirmar que su carpeta quedó bien vinculada, ejecute: git remote -v\nDebería ver la URL de su repositorio tanto para fetch como para push.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>E</span>  <span class='chapter-title'>Git y GitHub: Sincronización Local-Remota</span>"
    ]
  },
  {
    "objectID": "84-git_github.html#notas-de-flujo-de-trabajo",
    "href": "84-git_github.html#notas-de-flujo-de-trabajo",
    "title": "Apéndice E — Git y GitHub: Sincronización Local-Remota",
    "section": "E.9 Notas de flujo de trabajo",
    "text": "E.9 Notas de flujo de trabajo\n\nPersistencia: Una vez clonado o vinculado el repositorio, Git recordará la ruta del servidor (ya sea SSH o HTTPS). No es necesario repetir los comandos de remote add en sesiones futuras.\nSeguridad: Si opta por HTTPS, recuerde que GitHub ya no acepta contraseñas básicas por terminal; deberá generar un PAT (Personal Access Token) en la configuración de su cuenta. Por esta razón, se recomienda priorizar el uso de SSH.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>E</span>  <span class='chapter-title'>Git y GitHub: Sincronización Local-Remota</span>"
    ]
  },
  {
    "objectID": "85-vscode.html",
    "href": "85-vscode.html",
    "title": "Apéndice F — Visual Studio Code (VScode): Extensiones e Interfaz",
    "section": "",
    "text": "F.1 Instalación\nDescargue e instale las versión oficial de VSCode IDE correspondiente al sistema operativo de su máquina local desde el siguiente enlace:",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>F</span>  <span class='chapter-title'>Visual Studio Code (VScode): Extensiones e Interfaz</span>"
    ]
  },
  {
    "objectID": "85-vscode.html#instalación",
    "href": "85-vscode.html#instalación",
    "title": "Apéndice F — Visual Studio Code (VScode): Extensiones e Interfaz",
    "section": "",
    "text": "URL: https://code.visualstudio.com/\nInstalación: Seleccione el instalador .exe más reciente y que coincida con la arquitectura de su máquina.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>F</span>  <span class='chapter-title'>Visual Studio Code (VScode): Extensiones e Interfaz</span>"
    ]
  },
  {
    "objectID": "85-vscode.html#acceso-y-configuración-en-vscode",
    "href": "85-vscode.html#acceso-y-configuración-en-vscode",
    "title": "Apéndice F — Visual Studio Code (VScode): Extensiones e Interfaz",
    "section": "F.2 Acceso y configuración en VSCode",
    "text": "F.2 Acceso y configuración en VSCode\nVer Sección B.4.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>F</span>  <span class='chapter-title'>Visual Studio Code (VScode): Extensiones e Interfaz</span>"
    ]
  },
  {
    "objectID": "85-vscode.html#inicialización-del-visor-gráfico",
    "href": "85-vscode.html#inicialización-del-visor-gráfico",
    "title": "Apéndice F — Visual Studio Code (VScode): Extensiones e Interfaz",
    "section": "F.3 Inicialización del visor gráfico",
    "text": "F.3 Inicialización del visor gráfico\nVer Sección B.5.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>F</span>  <span class='chapter-title'>Visual Studio Code (VScode): Extensiones e Interfaz</span>"
    ]
  },
  {
    "objectID": "85-vscode.html#atajos",
    "href": "85-vscode.html#atajos",
    "title": "Apéndice F — Visual Studio Code (VScode): Extensiones e Interfaz",
    "section": "F.4 Atajos",
    "text": "F.4 Atajos\n\nLa paleta de comandos VSCode\nLa mayoría de las funciones avanzadas de VSCode no tienen un botón visible. Se acceden mediante la Paleta de Comandos presionando Ctrl + Shift + P. A continuación, los comandos más utilizados en este curso:\n\n\n\n\n\n\n\n\nComando (Command Palette)\nPropósito\n¿Cuándo usarlo?\n\n\n\n\nDeveloper: Reload Window\nReinicia la interfaz de VSCode sin cerrar el contenedor.\nCuando una extensión (como la de R o Julia) deja de responder.\n\n\nDev Containers: Rebuild Container\nReconstruye la imagen desde el Dockerfile.\nCuando se realizan cambios en la configuración del entorno.\n\n\nQuarto: Preview\nAbre una ventana lateral con la previsualización del documento.\nPara ver los cambios en el .qmd en tiempo real.\n\n\nR: Create R terminal\nFuerza la apertura de una nueva consola de R vinculada.\nSi el prompt &gt; no aparece automáticamente.\n\n\nJulia: Start REPL\nInicia la consola interactiva de Julia.\nAl abrir el contenedor por primera vez para ejecutar código Julia.\n\n\nPython: Select Interpreter\nPermite elegir la versión de Python del contenedor.\nSi VSCode no detecta automáticamente /usr/bin/python3.\n\n\nPostgreSQL: New Query\nAbre un editor SQL en blanco.\nPara realizar consultas a la base de datos espacial.\n\n\nGit: Pull / Git: Push\nSincroniza cambios con GitHub.\nPara actualizar el repositorio de la clase o subir tareas.\n\n\n\n\n\n\n\n\n\nEl comando de “Primer Auxilio”\n\n\n\nSi notas que el autocompletado desaparece o que los gráficos no cargan en httpgd, el primer paso siempre es ejecutar Developer: Reload Window. Esto refresca todas las conexiones de las extensiones con el contenedor sin interrumpir los procesos que Docker está ejecutando de fondo.\n\n\n\n\nAtajos de teclado rápidos VSCode\nAdemás de la paleta, memorice estos tres para su flujo diario: * Ctrl + Shift +  (acento grave): Abre una nueva Terminal. * Ctrl + J: Mostrar la terminal/consola existente. * Ctrl + Enter: Envía la línea de código actual desde el editor al REPL (R, Julia o Python). * Ctrl + Shift + V: Previsualiza archivos Markdown (.md) de forma rápida.\n\n\nAtajos de teclado JupyterLab (notebooks)\n\n\n\nAcción\nAtajo (Esc Mode)\n\n\n\n\nEjecutar Celda\nCtrl + Enter\n\n\nEjecutar y pasar a la siguiente\nShift + Enter\n\n\nConvertir a Markdown\nM\n\n\nConvertir a Código\nY\n\n\nCrear celda arriba / abajo\nA / B",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>F</span>  <span class='chapter-title'>Visual Studio Code (VScode): Extensiones e Interfaz</span>"
    ]
  },
  {
    "objectID": "85-vscode.html#sec-tinytex",
    "href": "85-vscode.html#sec-tinytex",
    "title": "Apéndice F — Visual Studio Code (VScode): Extensiones e Interfaz",
    "section": "F.5 Instalación Tinytex",
    "text": "F.5 Instalación Tinytex\nTinyTeX es un motor ligero de LaTeX necesario para compilar reportes profesionales (ej. en Quarto) en formato PDF (Xie, 2019). Si desea instalar TinyTeX para generar PDF por fuera del entorno Docker, desde la terminal de VSCode use el comando:\n  quarto install tinytex\n\nLa herramienta Tinytex viene instalada dentro del contenedor contenedor_sig_unal, así que no necesita instalarla.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>F</span>  <span class='chapter-title'>Visual Studio Code (VScode): Extensiones e Interfaz</span>"
    ]
  },
  {
    "objectID": "85-vscode.html#sec-extensiones-vscode",
    "href": "85-vscode.html#sec-extensiones-vscode",
    "title": "Apéndice F — Visual Studio Code (VScode): Extensiones e Interfaz",
    "section": "F.6 Instalación de extensiones",
    "text": "F.6 Instalación de extensiones\nPara que el entorno de desarrollo sea plenamente funcional, es necesario instalar un conjunto de extensiones específicas. Inicialmente todas las extensiones se pueden instalar para el entorno local (ej: Windows), sin embargo esas mismas extensiones deben estar instaladas también dentro del contenedor contenedor_sig_unal.\nUna vez que haya realizado el proceso de “Dev Containers: Attach to Running Container …” (Ctrl + Shift + P en VSCode), asegúrese de que estas herramientas estén instaladas dentro del contenedor (busque el botón azul Install in … en la pestaña de extensiones).\n\n\n\nTabla F.1: Extensiones de VSCode para el entorno de Geomática y Programación SIG\n\n\n\n\n\n\n\n\n\n\n\nCategoría\nHerramienta\nPropósito\nID de la Extensión\n\n\n\n\nInfraestructura\nDev Containers\nConexión y gestión del contenedor activo\nms-vscode-remote.remote-containers\n\n\n\nDocker / Container Tools\nControl de imágenes y recursos del contenedor\nms-azuretools.vscode-docker\n\n\nEcosistema R\nR (REditorSupport)\nSoporte de sintaxis, LSP y terminal de R\nREditorSupport.r\n\n\n\nR Debugger & Tools\nDepuración de scripts y herramientas de desarrollo\nRDebugger.r-debugger\n\n\n\nR Extension Pack\nPack de utilidades (por Yuki Ueda)\nyukiueda.r-extension-pack\n\n\nEcosistema Python\nPython (Microsoft)\nIntelliSense (Pylance) y depuración avanzada\nms-python.python\n\n\n\nPython Debugger\nMotor de depuración específico para Python\nms-python.debugpy\n\n\n\nJupyter (Microsoft)\nSoporte para Notebooks e interactividad nativa\nms-toolsai.jupyter\n\n\nEcosistema Julia\nJulia\nSoporte integral para ejecución y gráficos\njulialang.language-julia\n\n\nBase de Datos\nPostgreSQL\nCliente para explorar la DB (Chris Kolkman)\nckolkman.vscode-postgres\n\n\n\npsql\nHerramienta de consulta SQL (doublefint)\ndoublefint.psql\n\n\nPublicación\nQuarto\nRenderizado y preview de archivos .qmd\nquarto.quarto\n\n\nVersión\nGitHub Repositories\nManejo de archivos remotos sin clonar todo\ngithub.remotehub\n\n\nUtilidad\nLive Server\nServidor local con recarga automática para previsualizar HTML\nritwickdey.liveserver\n\n\n\nCode Spell Checker\nCorrector ortográfico para código y comentarios\nstreetsidesoftware.code-spell-checker\n\n\n\nSpanish - Code Spell Checker\nDiccionario en español para el corrector ortográfico\nstreetsidesoftware.code-spell-checker-spanish\n\n\n\n\n\n\n\nNotas sobre herramientas específicas\n\nPostgreSQL (Chris Kolkman): Esta extensión le permitirá conectarse a la base de datos espacial del contenedor sin salir de VSCode. Podrá ejecutar queries SQL y visualizar tablas directamente.\nJupyter Ecosystem: Incluimos el Jupyter Keymap para aquellos acostumbrados a los atajos de teclado de Jupyter Notebooks. Esto facilita la transición al trabajar con kernels de Python dentro de Quarto.\nSobre psql: La herramienta de línea de comandos psql ya viene preinstalada dentro del sistema operativo del contenedor (PostgreSQL Client). No requiere instalación adicional para funcionar en la terminal del contenedor. Sin embargo, la instalación de psql y dentro de VSCode garantiza soporte adicional, ver Sección F.7 líneas abajo.\nLive Server (Ritwick Dey): Esta extensión le permite lanzar un servidor de desarrollo local con un solo clic. Es extremadamente útil para previsualizar exportaciones de mapas interactivos (Leaflet u OpenLayers) o sitios web estáticos generados por Quarto. La ventaja principal es la “recarga en vivo” (live reload): cada vez que guarde un cambio en su archivo HTML o CSS, el navegador se actualizará automáticamente sin necesidad de recargar la página manualmente.\nCode Spell Checker: Esta extensión es esencial para evitar errores tipográficos en el código y, sobre todo, en la documentación de archivos .qmd. Para que reconozca términos en nuestro idioma, se recomienda instalar también el paquete Spanish - Code Spell Checker (streetsidesoftware.code-spell-checker-spanish).\n\n\n\n\n\n\n\nInstalación Local vs. Remota\n\n\n\nRecuerde que extensiones como Dev Containers y Docker deben estar instaladas en su VSCode local (en Windows), mientras que las de análisis (R, Python, Julia, PostgreSQL) deben estar instaladas dentro de la sesión del contenedor para acceder a los compiladores y librerías de la imagen.\n\n\n\n\n\n\n\n\nSoporte del Lenguaje en R\n\n\n\nPara que el autocompletado y la documentación en tiempo real funcionen, el contenedor requiere el paquete languageserver. Aunque la imagen ya lo incluye por defecto, si nota que el resaltado de sintaxis falla, puede reinstalarlo ejecutando: install.packages(\"languageserver\") en su consola de R.\n\n\n\n\n\n\n\n\n¿Cuándo usar Live Server?\n\n\n\nÚselo cuando necesite probar cómo se comporta un mapa interactivo exportado fuera del entorno de Quarto. Simplemente haga clic derecho sobre su archivo .html en el explorador de VSCode y seleccione “Open with Live Server”. La opción de búsqueda en la página del curso (archivo _site\\index.html) solo funcionará si la ejecuta dentro de Live Server.\n\n\n\nConfiguración del corrector ortográfico\nPara habilitar corrección ortográfica en idioma español:\n\nActive el idioma: Presione Ctrl + Shift + P, escriba “Spell”, seleccione Enable Spanish Spell Checker Dictionary y finalmente seleccione User de la lista.\n\nPara que el corrector funcione simultáneamente con términos técnicos en inglés y redacción en español, puede añadir la siguiente configuración en su archivo settings.json de VSCode:\n{\n    \"cSpell.language\": \"en,es\",\n    \"cSpell.enabled\": true,\n    \"cSpell.spellCheckDelayMs\": 500,\n    \"cSpell.diagnosticLevel\": \"Information\"\n}\n\n\n\n\n\n\nDiccionario técnico\n\n\n\nA medida que trabaje con librerías como geopandas o ArchGDAL, es posible que el corrector marque estas palabras como errores. Puede agregarlas a su “Diccionario de Usuario” haciendo clic derecho sobre la palabra y seleccionando Add to User Dictionary.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>F</span>  <span class='chapter-title'>Visual Studio Code (VScode): Extensiones e Interfaz</span>"
    ]
  },
  {
    "objectID": "85-vscode.html#sec-sinergia-psql",
    "href": "85-vscode.html#sec-sinergia-psql",
    "title": "Apéndice F — Visual Studio Code (VScode): Extensiones e Interfaz",
    "section": "F.7 Sinergia de las extensiones de PostgreSQL en VSCode",
    "text": "F.7 Sinergia de las extensiones de PostgreSQL en VSCode\nContar con ambas extensiones instaladas dentro del contenedor no es redundancia, sino una estrategia para optimizar el flujo de trabajo con datos espaciales. Cada una ofrece una “capa” de interacción distinta que, al combinarse, potencia la productividad.\n\n\n\n\n\n\n\n\nExtensión\nFortaleza técnica\nUtilidad principal\n\n\n\n\nPostgreSQL (Chris Kolkman)\nExploración de objetos\nNavegar visualmente por esquemas, ver la lista de tablas y verificar columnas de PostGIS.\n\n\npsql (doublefint)\nEjecución de consultas\nEjecutar bloques de código SQL directamente desde scripts .sql con atajos de teclado rápidos.\n\n\n\n\nVentajas de la instalación dual\n\nValidación visual inmediata: Mientras escribe una consulta compleja en el editor (usando la extensión de doublefint), puede consultar el panel lateral de Chris Kolkman para verificar nombres de columnas o tipos de datos geográficos sin tener que hacer un SELECT *.\nSoporte de sintaxis robusto: La combinación garantiza que VSCode reconozca perfectamente las palabras clave de SQL y proporcione sugerencias automáticas (IntelliSense) precisas.\nResultados en pestañas independientes: Permite mantener los resultados de una consulta abiertos en una pestaña mientras se sigue editando el código en otra, algo fundamental cuando se comparan estadísticas de diferentes capas ráster o vectoriales.\n\n\n\n\n\n\n\nRecomendación de flujo\n\n\n\n\nUse el panel de Chris Kolkman para conectarse y “ver” qué hay en la base de datos.\nEscriba sus scripts de análisis espacial en archivos .sql y ejecútelos usando la extensión de doublefint para obtener una respuesta rápida en la consola.\n\n\n\n\n\n\n\n\n\nAtajo de teclado (Shortcut)\n\n\n\nPara la mayoría de estas extensiones, puede resaltar una consulta SQL y presionar Ctrl + E (o Cmd + E en Mac) para ejecutarla inmediatamente y ver los resultados en una tabla formateada.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>F</span>  <span class='chapter-title'>Visual Studio Code (VScode): Extensiones e Interfaz</span>"
    ]
  },
  {
    "objectID": "85-vscode.html#verificación-de-conectividad",
    "href": "85-vscode.html#verificación-de-conectividad",
    "title": "Apéndice F — Visual Studio Code (VScode): Extensiones e Interfaz",
    "section": "F.8 Verificación de conectividad",
    "text": "F.8 Verificación de conectividad\nUna vez instaladas las extensiones, verifique que su entorno esté correctamente configurado siguiendo estos puntos:\n\nEstado del Contenedor: En la esquina inferior izquierda de VSCode, debe aparecer un recuadro azul con el texto: Dev Container: contenedor_sig_unal.\nActivación de Kernels: Al abrir un archivo .qmd, en la esquina superior derecha debe poder seleccionar el kernel deseado (R, Python 3 o Julia).\nTerminal Unificada: Al abrir una nueva terminal (Ctrl + Shift + ), la línea de comandos debe estar identificada como rstudio@contenedor_sig_unal:/home/rstudio/work$.\n\n\n\n\n\n\n\nSincronización Automática\n\n\n\nRecuerde que cualquier cambio que realice en la configuración de estas extensiones mientras esté conectado al contenedor se guardará en su perfil local de VSCode, facilitando las conexiones futuras.\n\n\n\n\n\n\nMicrosoft Corporation. (2026). Visual Studio Code. https://code.visualstudio.com/\n\n\nXie, Y. (2019). TinyTeX: A lightweight, cross-platform, and easy-to-maintain LaTeX distribution based on TeX Live. TUGboat, 40(1), 30-32.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>F</span>  <span class='chapter-title'>Visual Studio Code (VScode): Extensiones e Interfaz</span>"
    ]
  },
  {
    "objectID": "86-windows.html",
    "href": "86-windows.html",
    "title": "Apéndice G — Temas técnicos sobre Windows",
    "section": "",
    "text": "G.1 Herramientas de administración",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>G</span>  <span class='chapter-title'>Temas técnicos sobre Windows</span>"
    ]
  },
  {
    "objectID": "86-windows.html#herramientas-de-administración",
    "href": "86-windows.html#herramientas-de-administración",
    "title": "Apéndice G — Temas técnicos sobre Windows",
    "section": "",
    "text": "Acceso Directo\nParámetro / Comando\nDescripción\n\n\n\n\nWindows + R\n%UserProfile%\nAbre tu carpeta personal de usuario (donde se crea el archivo .wslconfig).\n\n\nWindows + R\ncleanmgr\nAbre el Liberador de espacio en disco para purgar basura del sistema.\n\n\nWindows + R\ntaskmgr\n[Ctrl + Shift + Esc] Abre el Administrador de Tareas para ver procesos.\n\n\nWindows + R\nresmon\nAbre el Monitor de Recursos (ideal para ver el uso real de RAM y Swap).\n\n\nWindows + R\nsysdm.cpl\n[Win + Pausa] Propiedades del sistema (configuración de Memoria Virtual).\n\n\nWindows + R\n%temp%\nAbre la carpeta de Archivos temporales del usuario actual.\n\n\nWindows + R\ntemp\nAbre la carpeta de Archivos temporales del sistema (raíz).\n\n\nWindows + R\nprefetch\nCarpeta de precarga de Windows (caché que puedes vaciar para liberar espacio).\n\n\nWindows + R\ndiskmgmt.msc\nAbre la Administración de discos (para vigilar tus unidades C: y D:).\n\n\nWindows + R\nappdata\nAcceso a carpetas de configuración de aplicaciones (Roaming/Local).\n\n\nWindows + R\ncmd\n[Win + X, luego C] Abre el Símbolo del Sistema (Terminal clásica).\n\n\nWindows + R\npowershell\n[Win + X, luego A] Abre PowerShell con permisos de administrador.\n\n\nWindows + R\ncontrol\nAbre el Panel de Control clásico de Windows.\n\n\nWindows + R\nmsconfig\nConfiguración del sistema (gestión de servicios y arranque).\n\n\nWindows + R\nncpa.cpl\nPanel de Conexiones de red (configuración de adaptadores e IPs).\n\n\nNativo\nWin + E\nAbre instantáneamente el Explorador de Archivos.\n\n\nNativo\nWin + I\nAbre el panel de Configuración de Windows (Settings).\n\n\nNativo\nWin + D\nMinimiza/Restaura todo para ir al Escritorio rápidamente.\n\n\nNativo\nWin + V\nAbre el Historial del Portapapeles (muy útil para copiar varios códigos).\n\n\n\n\nProcesos de WSL2 (Windows Subsystem for Linux 2): Docker y Vmmem",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>G</span>  <span class='chapter-title'>Temas técnicos sobre Windows</span>"
    ]
  },
  {
    "objectID": "86-windows.html#comandos-powershell",
    "href": "86-windows.html#comandos-powershell",
    "title": "Apéndice G — Temas técnicos sobre Windows",
    "section": "G.2 Comandos (PowerShell)",
    "text": "G.2 Comandos (PowerShell)\n\nVer uso de RAM: Get-Process | Sort-Object WorkingSet -Descending | Select-Object -First 10\nVer estado de WSL: wsl --list --verbose\nLimpiar Cache de DNS: ipconfig /flushdns",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>G</span>  <span class='chapter-title'>Temas técnicos sobre Windows</span>"
    ]
  },
  {
    "objectID": "87-linux_ubuntu.html",
    "href": "87-linux_ubuntu.html",
    "title": "Apéndice H — Temas Técnicos sobre Linux",
    "section": "",
    "text": "H.1 Comandos adicionales antes de trabajar con los contenedores\nVer Sección B.1.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>H</span>  <span class='chapter-title'>Temas Técnicos sobre Linux</span>"
    ]
  },
  {
    "objectID": "87-linux_ubuntu.html#sec-comandos-so",
    "href": "87-linux_ubuntu.html#sec-comandos-so",
    "title": "Apéndice H — Temas Técnicos sobre Linux",
    "section": "H.2 Comandos comúnes de terminal",
    "text": "H.2 Comandos comúnes de terminal\nAl trabajar dentro de un contenedor Docker, la terminal es su línea directa con el sistema operativo (Ubuntu/Debian). Estos comandos le permitirán verificar que los motores geoespaciales y las librerías de sistema están correctamente instalados.\n\n\n\n\n\n\n\n\nComando\nPropósito\n¿Para qué sirve en el curso?\n\n\n\n\ndpkg -l \\| grep -E \"libpng\\|libgdal\\|libproj\\|libgeos\"\nLista librerías instaladas\nVerificar que los drivers de mapas (GDAL, PROJ, GEOS) están activos.\n\n\ngdalinfo --version\nVersión de GDAL\nConfirmar que el motor de traducción de datos geográficos funciona.\n\n\ndf -h\nEspacio en disco\nEvitar errores de “Disk Full” al descargar imágenes satelitales pesadas.\n\n\nhtop (o top)\nMonitor de recursos\nVer si un proceso de Julia o R está consumiendo toda la RAM o CPU.\n\n\nls -la\nListado detallado\nRevisar permisos de archivos y carpetas (clave para errores de Git).\n\n\npsql --version\nVersión de Postgres\nConfirmar que el cliente de base de datos está listo para usarse.\n\n\nwhich r / which julia\nRuta del ejecutable\nLocalizar dónde están instalados los lenguajes para configurar el Path.\n\n\nfc-list \\| grep -i \"Symbola\"\nBuscar fuentes del sistema\nLocalizar la ruta exacta de fuentes necesarias para emojis y símbolos en el PDF.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>H</span>  <span class='chapter-title'>Temas Técnicos sobre Linux</span>"
    ]
  },
  {
    "objectID": "87-linux_ubuntu.html#verificación-de-librerías-geoespaciales",
    "href": "87-linux_ubuntu.html#verificación-de-librerías-geoespaciales",
    "title": "Apéndice H — Temas Técnicos sobre Linux",
    "section": "H.3 Verificación de librerías geoespaciales",
    "text": "H.3 Verificación de librerías geoespaciales\nEl comando dpkg -l | grep -E \"libpng|libgdal|libproj|libgeos\" es su principal herramienta de diagnóstico. Si al ejecutarlo no obtiene resultados, las funciones de mapeo en R (sf), Python (geopandas) y Julia (ArchGDAL) fallarán, ya que todas dependen de estos binarios del sistema.\n\n\n\n\n\n\nTip de Productividad\n\n\n\nEn la terminal de VSCode, puede usar la tecla Tab para autocompletar nombres de archivos o comandos, y las flechas arriba/abajo para navegar por el historial de comandos ejecutados.\n\n\n\n¿Cómo leer la salida de dpkg?\nAl ejecutar el comando de verificación, verá una lista con el prefijo ii. Esto significa: * i: Desired state (Install) * i: Current state (Installed)\nSi ve algo diferente a ii, el paquete tiene problemas de instalación.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>H</span>  <span class='chapter-title'>Temas Técnicos sobre Linux</span>"
    ]
  },
  {
    "objectID": "87-linux_ubuntu.html#sec-openssl-surgery",
    "href": "87-linux_ubuntu.html#sec-openssl-surgery",
    "title": "Apéndice H — Temas Técnicos sobre Linux",
    "section": "H.4 La cirugía de librerías: el “cambiazo” de OpenSSL",
    "text": "H.4 La cirugía de librerías: el “cambiazo” de OpenSSL\nAl trabajar con contenedores de última generación, a veces nos encontramos con un choque de versiones entre lo que el sistema operativo ofrece y lo que los lenguajes de programación esperan. En nuestro caso, realizamos una “cirugía” técnica utilizando enlaces simbólicos (ln -sf).\n\nEl conflicto: ¿3.0.x o 3.3.x?\nLa respuesta corta es: Físicamente tiene instalada la versión 3.0.x, pero le mentimos al software diciéndole que es la 3.3.x.\n\nLa Realidad (Sistema): Su contenedor corre sobre Ubuntu 24.04 (Noble Numbat). Esta versión viene de fábrica con OpenSSL 3.0.x, que es la versión estable y oficial del sistema.\nLa Expectativa (Julia): Algunos paquetes potentes de Julia (como los binarios JLL de GDAL o NCDatasets) fueron compilados en entornos más recientes que ya usaban OpenSSL 3.3.x.\n\nCuando Julia intenta arrancar, busca una “etiqueta” interna llamada OPENSSL_3.3.0. Al no encontrarla en la librería de Ubuntu, el sistema lanza un error y bloquea la carga de mapas.\n\n\nLa solución: ¿qué hace exactamente ln -sf?\nImagine que Julia es un guardia de seguridad que busca una llave maestra etiquetada como “Llave 3.3”. Al revisar la caja fuerte (el sistema), solo ve la “Llave 3.0” y se niega a abrir. Lo que hicimos fue un “cambiazo” estratégico.\nEjecutamos este comando de “cirugía”:\nfind /root/.julia/artifacts -name \"libssl.so*\" -exec ln -sf /usr/lib/x86_64-linux-gnu/libssl.so.3 {} \\;\nDesglose de la operación: 1. find ... -name \"libssl.so*\": Localiza todos los archivos de librería que Julia descargó por su cuenta (sus propios binarios internos). 2. -exec ln -sf ... {}: Por cada archivo encontrado, borra el original (la -f de force) y crea un enlace simbólico (la -s de symbolic). 3. El Destino: El enlace apunta directamente a la librería real de Ubuntu (/usr/lib/.../libssl.so.3).\n\n\n¿por qué funciona si las versiones son distintas?\nFunciona gracias a que OpenSSL 3 mantiene algo llamado compatibilidad binaria entre sus versiones menores. Las funciones internas se llaman exactamente igual; lo único que cambió fue el “nombre del archivo” que Julia buscaba.\nAl redirigir el nombre, Julia utiliza la librería de Ubuntu pensando que es la suya, y como las instrucciones internas son compatibles, el sistema arranca sin errores y con total estabilidad.\n\n\n\n\n\n\nImportancia para el SIG\n\n\n\nSin esta cirugía, paquetes como ArchGDAL en Julia no podrían cargar los controladores para leer archivos .tif o conectarse a bases de datos espaciales, ya que la comunicación segura (SSL) fallaría al inicio.\n\n\n\n\nLa “factura” de la cirugía: el adiós a JuliaCall\nComo en toda operación de emergencia, el “cambiazo” de librerías tuvo un efecto secundario importante: la ruptura definitiva de la compatibilidad con JuliaCall, el puente más común entre R y Julia.\n\nEl Conflicto: JuliaCall intenta embeber a Julia directamente dentro del proceso de R (comparten la misma memoria). Al detectar que las librerías de OpenSSL han sido redirigidas mediante enlaces simbólicos, el proceso de R entra en un conflicto de seguridad y colapsa inmediatamente (Segmentation Fault), impidiendo cualquier comunicación.\nLa Solución: Para no renunciar a la integración de ambos lenguajes, cambiamos de estrategia y adoptamos JuliaConnectoR. A diferencia del método anterior, este paquete trata a Julia como un servicio independiente que se comunica mediante sockets. Esto lo hace inmune al conflicto de OpenSSL, ya que cada lenguaje corre en su propia parcela de memoria.\n\n\n\nEl nacimiento de j_eval y j_plot\nPara que este cambio de arquitectura fuera invisible para el usuario final, se desarrollaron dos funciones “envolventes” (wrappers) que automatizan la traducción entre lenguajes:\n\nj_eval(): Toma comandos escritos en R, los envía al motor de Julia de forma segura y captura el resultado (numérico o textual) para devolverlo a la consola de R. Es el cerebro detrás de nuestros benchmarks.\nj_plot(): Resuelve el problema del renderizado. Julia genera la visualización geoespacial “tras bambalinas”, y esta función captura la salida gráfica para insertarla automáticamente en el reporte de Quarto.\n\n\n\n\n\n\n\nConclusión Técnica\n\n\n\nGracias a esta combinación estratégica (Cirugía OpenSSL + JuliaConnectoR + Funciones j_), logramos lo que parecía imposible en un entorno Docker restrictivo: un ecosistema donde R, Python y Julia conviven en paz, permitiéndonos procesar datos masivos sin colapsos de memoria ni errores de librerías.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>H</span>  <span class='chapter-title'>Temas Técnicos sobre Linux</span>"
    ]
  },
  {
    "objectID": "88-python.html",
    "href": "88-python.html",
    "title": "Apéndice I — Adicionales Sobre Python",
    "section": "",
    "text": "I.1 Stack instalado de Python\nPara el análisis geoespacial avanzado, en los contenedores se instalaron un conjunto de librerías especializadas. El núcleo de este entorno es geopandas, cuya instalación gestiona automáticamente dependencias críticas como numpy (cálculo numérico), pandas (manipulación de datos) y shapely (operaciones geométricas). Complementariamente, se instaló rasterio para la gestión profesional de datos ráster y rasterstats para la extracción de estadísticas zonales.\nComo veremos, estos paquetes dependen unos de otros. Las dependencias principales se muestran en la Figura I.1:\nLa siguiente tabla vincula las librerías de Python con los motores de cálculo de bajo nivel (C/C++) integrados en el contenedor Docker:",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>I</span>  <span class='chapter-title'>Adicionales Sobre Python</span>"
    ]
  },
  {
    "objectID": "88-python.html#stack-instalado-de-python",
    "href": "88-python.html#stack-instalado-de-python",
    "title": "Apéndice I — Adicionales Sobre Python",
    "section": "",
    "text": "Tabla I.1: Paquetes principales de Python\n\n\n\n\n\nPaquete\nFuncionalidad\nSitio web\n\n\n\n\nnumpy\nArreglos\nhttps://numpy.org/\n\n\npandas\nTablas\nhttps://pandas.pydata.org/\n\n\nshapely\nGeometrías vectoriales\nhttps://shapely.readthedocs.io/\n\n\ngeopandas\nCapas vectoriales\nhttps://geopandas.org/\n\n\nrasterio\nRáster\nhttps://rasterio.readthedocs.io/\n\n\nrasterstats\nEstadísticas zonales\nhttps://github.com/perrygeo/python-rasterstats\n\n\npsycopg2\nInterfaz a PostgreSQL\nhttps://www.psycopg.org/docs/\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigura I.1: Principales dependencias entre los paquetes de Python que vamos a estudiar. Adaptado de Dorman (2025).\n\n\n\n\ngeopandas: Capa superior que integra a pandas, shapely, fiona y pyproj. Permite realizar consultas espaciales complejas y gestionar GeoDataFrames con una sintaxis simplificada.\nrasterio: Basada en la librería GDAL, es el estándar para la lectura, escritura y manipulación de formatos ráster (como GeoTIFF), permitiendo gestionar metadatos y arreglos de píxeles con alta eficiencia.\nscipy: Proporciona algoritmos avanzados de optimización, álgebra lineal y estadística necesarios para procesos de interpolación y análisis de superficies.\nrasterstats: Herramienta específica para extraer estadísticas (medias, sumas) a partir de capas ráster basadas en geometrías vectoriales.\nshapely: Motor geométrico basado en el estándar Simple Features y puente hacia la librería GEOS. Se encarga de la lógica matemática de las geometrías (áreas, intersecciones, buffers y validación topográfica).\npyproj: Interfaz para la librería PROJ. Gestiona proyecciones cartográficas, sistemas de referencia (CRS) y transformaciones de datums.\nfiona / pyogrio: Motores de acceso a datos vectoriales (SHP, GPKG) que actúan como interfaces hacia la librería GDAL/OGR.\nxyzservices: Repositorio de metadatos para conectar con servicios de mapas base dinámicos (como OpenStreetMap).\n\n\n\n\n\n\n\n\n\n\nLibrería Python\nMotor de Sistema (C/C++)\nFunción Principal en Geomática\n\n\n\n\npyproj\nPROJ\nGestión de Proyecciones y Sistemas de Referencia (CRS).\n\n\nshapely\nGEOS\nÁlgebra topológica (Intersecciones, Buffers, Áreas).\n\n\nfiona / pyogrio\nGDAL/OGR\nLectura y escritura de formatos vectoriales.\n\n\nrasterio\nGDAL\nManejo de datos ráster y metadatos de imágenes.\n\n\ngeopandas\n(Integra los 3 motores)\nGestión integral de GeoDataFrames espaciales.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>I</span>  <span class='chapter-title'>Adicionales Sobre Python</span>"
    ]
  },
  {
    "objectID": "88-python.html#versiones-instaladas-del-software",
    "href": "88-python.html#versiones-instaladas-del-software",
    "title": "Apéndice I — Adicionales Sobre Python",
    "section": "I.2 Versiones instaladas del software",
    "text": "I.2 Versiones instaladas del software\nPara verificar las versiones inSstaladas, puede ejecutar pip3 list en la terminal. Las versiones instaladas deben coincidir con la siguiente tabla:\n\n\n\n\n\n\n\n\n\n\nSoftware\nTipo\nVersión\nComando (desde terminal)\nComando (desde Python)\n\n\n\n\nPython\nLenguaje\n3.12.3\npython3 --version\nimport sys; sys.version\n\n\npip\nGestor de paquetes\n24.0\npip3 --version\nimport pip; pip.__version__\n\n\nnumpy\nPaquete\n2.4.1\npip3 show numpy\nimport numpy; numpy.__version__\n\n\npandas\nPaquete\n2.3.3\npip3 show pandas\nimport pandas; pandas.__version__\n\n\ngeopandas\nPaquete\n1.1.2\npip3 show geopandas\nimport geopandas; geopandas.__version__\n\n\nshapely\nPaquete\n2.1.2\npip3 show shapely\nimport shapely; shapely.__version__\n\n\npyproj\nPaquete\n3.7.2\npip3 show pyproj\nimport pyproj; pyproj.__version__\n\n\nfiona\nPaquete\n1.10.1\npip3 show fiona\nimport fiona; fiona.__version__\n\n\nrasterio\nPaquete\n1.5.0\npip3 show rasterio\nimport rasterio; rasterio.__version__\n\n\n\n\n\n\n\nDorman, M. (2025). Spatial Data Programming with Python. Ben-Gurion University of the Negev. https://geobgu.xyz/py-2025/",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>I</span>  <span class='chapter-title'>Adicionales Sobre Python</span>"
    ]
  },
  {
    "objectID": "89-r.html",
    "href": "89-r.html",
    "title": "Apéndice J — Adicionales Sobre R",
    "section": "",
    "text": "J.1 Stack de R\nPara el análisis geoespacial en R (instalado dentro de los contenedores), utilizaremos un ecosistema robusto basado en el estándar Simple Features y motores de alto rendimiento para datos ráster (rejilla - cuadrículas).",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>J</span>  <span class='chapter-title'>Adicionales Sobre R</span>"
    ]
  },
  {
    "objectID": "89-r.html#stack-de-r",
    "href": "89-r.html#stack-de-r",
    "title": "Apéndice J — Adicionales Sobre R",
    "section": "",
    "text": "Tabla J.1: Paquetes principales del stack espacial en R\n\n\n\n\n\nPaquete\nFuncionalidad\nSitio web\n\n\n\n\nsf\nGeometrías vectoriales (Simple Features)\nhttps://r-spatial.github.io/sf/\n\n\nterra\nAnálisis de datos espaciales (Ráster/Vector)\nhttps://rspatial.github.io/terra/\n\n\nstars\nArreglos ordenados espacio-temporales (DataCubes)\nhttps://r-spatial.github.io/stars/\n\n\ntidyverse\nMetapaquete para ciencia de datos\nhttps://www.tidyverse.org/\n\n\ntidyterra\nMétodos de tidyverse para terra\nhttps://dieghernan.github.io/tidyterra/\n\n\n\n\n\n\n\nsf (Simple Features): Es el estándar moderno para el manejo de datos vectoriales. Representa las geometrías como una columna especial en un data frame, permitiendo aplicar toda la potencia de manipulación de tablas a objetos espaciales.\nterra: Motor de alta eficiencia que reemplaza al antiguo paquete raster. Está optimizado para el manejo de grandes volúmenes de datos mediante objetos SpatRaster y SpatVector, permitiendo operaciones de álgebra de mapas y análisis local de manera veloz.\nstars (Spatiotemporal Arrays): Especializada en el manejo de “cubos de datos” (rejillas con dimensiones de espacio, tiempo y múltiples atributos). Es la herramienta ideal para procesar series temporales de imágenes satelitales o modelos climáticos multidimensionales.\ntidyterra: Extiende la gramática de ggplot2 y tidyverse hacia los objetos de terra. Permite visualizar mapas ráster de forma elegante y realizar tuberías (pipes) de datos manteniendo la integridad espacial.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>J</span>  <span class='chapter-title'>Adicionales Sobre R</span>"
    ]
  },
  {
    "objectID": "89-r.html#versiones-instaladas-del-software",
    "href": "89-r.html#versiones-instaladas-del-software",
    "title": "Apéndice J — Adicionales Sobre R",
    "section": "J.2 Versiones instaladas del software",
    "text": "J.2 Versiones instaladas del software\nVersiones que deben quedar instaladas en el sistema R:\n\n\n\n\n\n\n\n\n\n\nSoftware\nTipo\nVersión\nComando (desde terminal)\nComando (desde R)\n\n\n\n\nR\nLenguaje\n4.5.2\nR --version\nR.version.string\n\n\nGEOS\nLibrería sistema\n3.12.1\ngeos-config --version\nsf::sf_extSoftVersion()[\"GEOS\"]\n\n\nGDAL\nLibrería sistema\n3.8.4\ngdalinfo --version\nsf::sf_extSoftVersion()[\"GDAL\"]\n\n\nPROJ\nLibrería sistema\n9.4.0\n(no aplica / no disponible)\nsf::sf_extSoftVersion()[\"PROJ\"]\n\n\nsf\nPaquete\n1.0.23\nR -q -e \"packageVersion('sf')\"\npackageVersion(\"sf\")\n\n\nterra\nPaquete\n1.8.86\nR -q -e \"packageVersion('terra')\"\npackageVersion(\"terra\")\n\n\nstars\nPaquete\n0.7.0\nR -q -e \"packageVersion('stars')\"\npackageVersion(\"stars\")",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>J</span>  <span class='chapter-title'>Adicionales Sobre R</span>"
    ]
  },
  {
    "objectID": "89-r.html#sec-httpgd-config",
    "href": "89-r.html#sec-httpgd-config",
    "title": "Apéndice J — Adicionales Sobre R",
    "section": "J.3 Visualización interactiva con httpgd",
    "text": "J.3 Visualización interactiva con httpgd\nDado que nuestro entorno Docker es “headless” (sin monitor propio), utilizamos httpgd como un servidor gráfico intermedio. Este paquete captura las señales de dibujo de R y las sirve a través de una URL que VSCode puede renderizar.\n\nInicio del servidor gráfico\nCada vez que inicie una nueva sesión de R, debe despertar al servidor manualmente:\n# Inicia el motor gráfico\nhttpgd::hgd()\n\n# Verifica el estado y el puerto asignado\nhttpgd::hgd_details()\n\n\nResolución de conflictos (el “fix” del puerto)\nEn nuestro contenedor, el puerto estándar para gráficos está mapeado al 8787. Si al ejecutar hgd_details() nota que el sistema asignó un puerto aleatorio o si el visor aparece en blanco, fuerce la conexión con la siguiente “receta”:\n# Forzar host y puerto para compatibilidad con Docker\nhttpgd::hgd(host = \"0.0.0.0\", port = 8787, token = FALSE)\n\n\nFormas de ver sus gráficos\nUna vez el servidor está corriendo, tiene dos caminos para visualizar sus mapas:\n\n\n\n\n\n\n\n\nMétodo\nComando / Acción\nVentaja\n\n\n\n\nVisor Interno\nCtrl + Shift + P -&gt; Open httpgd viewer\nMantiene todo dentro de una pestaña de VSCode.\n\n\nNavegador Externo\nhttpgd::hgd_browse()\nIdeal si trabaja con dos monitores para ver mapas en pantalla completa.\n\n\n\n\n\n\n\n\n\n¿Por qué token = FALSE?\n\n\n\nDentro del entorno seguro del contenedor, desactivamos el token para facilitar la conexión inmediata entre el servidor de R y el visor de VSCode sin que el firewall interno bloquee la petición por falta de credenciales.\n\n\n\n\nVerificación de salud\nSi después de iniciar el servidor intenta graficar algo (ej: plot(1:10)) y no ve nada, ejecute httpgd::hgd_details(). Asegúrese de que: 1. URL: Apunte a http://0.0.0.0:8787. 2. Status: Indique que está escuchando (listening).\n\n\nEl Entorno interactivo (REPL) y motores gráficos\nEn el desarrollo científico, el REPL (Read-Eval-Print Loop) es la consola interactiva que permite la “programación exploratoria”. Es el ciclo donde el sistema lee su instrucción, la evalúa mediante el motor correspondiente, imprime el resultado y queda en un bucle a la espera del siguiente comando.\nEn nuestro laboratorio políglota, la identidad visual del REPL es su brújula para saber en qué lenguaje está operando:\n\n\n\n\n\n\n\n\nLenguaje\n¿Cómo se ve el REPL?\nCaracterísticas en este curso\n\n\n\n\nR\n&gt;\nConsola estándar para procesos geoespaciales con sf o terra.\n\n\nJulia\njulia&gt;\nEntorno de alto rendimiento con modos de ayuda (?) y terminal (;).\n\n\nPython\n&gt;&gt;&gt;\nConsola básica; se recomienda el uso de IPython para interactividad.\n\n\n\nLa experiencia interactiva y el soporte gráfico dentro de VSCode dependen de la combinación entre el motor de ejecución y el dispositivo gráfico configurado en el contenedor:\n\n\n\n\n\n\n\n\n\n\nLenguaje\nAcceso / Contexto\nMotor de Ejecución\nDispositivo Gráfico\nSoporte Inline\n\n\n\n\nR\nNativo (Estático)\nR Extension\nVSCode Plots (Pane)\n✅\n\n\nR\nNativo (Interactivo)\nR Extension\nhttpgd\n✅\n\n\nJulia\nNativo (REPL)\nVSCodeServer\nVSCode Plots (Pane)\n✅\n\n\nJulia\nInterop (R-Bridge)\nJuliaConnectoR\nhttpgd (vía R)\n✅\n\n\nPython\nInterop (R-Bridge)\nreticulate\nR Device (httpgd)\n❌ / ⚠️\n\n\nPython\nNativo (Jupyter)\nJupyter kernel\nJupyter Viewer\n✅\n\n\n\n\n\nEl rol crítico de httpgd en R\nPara R, no basta con tener la extensión instalada. El paquete httpgd actúa como un servidor web interno que captura los gráficos generados en el contenedor y los “proyecta” en VSCode.\n\n¿Por qué lo usamos? Los dispositivos gráficos tradicionales (como X11 o windows()) no funcionan dentro de un contenedor Docker (headless). httpgd soluciona esto convirtiendo cada mapa en un elemento interactivo SVG/HTML renderizable.\nActivación: Siempre debe iniciar su sesión de R ejecutando httpgd::hgd() para abrir este canal de comunicación.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>J</span>  <span class='chapter-title'>Adicionales Sobre R</span>"
    ]
  },
  {
    "objectID": "89-r.html#sec-interoperabilidad",
    "href": "89-r.html#sec-interoperabilidad",
    "title": "Apéndice J — Adicionales Sobre R",
    "section": "J.4 Paquetes para comunicación con Julia y Python",
    "text": "J.4 Paquetes para comunicación con Julia y Python\nPara que este ecosistema funcione, R actúa como el “director de orquesta” utilizando un motor de ejecución y una serie de puentes que permiten la comunicación fluida de datos entre lenguajes.\n\n\n\n\n\n\n\n\n\nLenguaje / Función\nPaquete en R\nMotor / Propósito\nEstado\n\n\n\n\nRenderizado\nknitr\nMotor maestro que orquesta la ejecución de celdas en el documento\n✅\n\n\nJulia\nJuliaConnectoR\nComunicación funcional estable con el kernel de Julia\n✅\n\n\nPython\nreticulate\nInteroperabilidad de objetos y ejecución de Python\n✅\n\n\nLSP (Soporte)\nlanguageserver\nAutocompletado, IntelliSense y ayuda en tiempo real\n✅\n\n\n\n\nEl rol de knitr\nMientras que los paquetes actúan como puentes técnicos, knitr es el encargado de leer el archivo .qmd, enviar las instrucciones a los motores respectivos y capturar los resultados (tablas, mapas, gráficos) para integrarlos en el documento final. Sin knitr, la integración políglota de Quarto no sería posible.\n\n\nTransición técnica: De JuliaCall a JuliaConnectoR\nEn el diseño de este entorno, se tomó la decisión técnica de descartar el paquete JuliaCall en favor de JuliaConnectoR:\n\nEl Problema: JuliaCall presentaba inestabilidades al gestionar dependencias dinámicas compartidas (como libcurl o libstdc++) dentro del contenedor, causando cierres inesperados (crashes) de la sesión de R.\nLa Sustitución: Se seleccionó JuliaConnectoR por su arquitectura más limpia, que no interfiere con el entorno de Julia ya configurado en el sistema operativo.\nLa Solución: La integración se resolvió mediante una “inyección” de código en el archivo Rprofile.site, configurando automáticamente la ruta del ejecutable en $Sys.BINDIR$ y definiendo las funciones maestras j_eval() y j_plot().\n\n\n\n\n\n\n\n🧠 Regla de Oro del Curso\n\n\n\n\nJulia y R: Se operan de manera totalmente interactiva en VSCode (envío de líneas con Ctrl+Enter).\nPython vía reticulate: Se utiliza primordialmente para el renderizado (vía knitr) de informes finales. Para una programación interactiva pura en Python, se recomienda el uso de los Jupyter kernels.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>J</span>  <span class='chapter-title'>Adicionales Sobre R</span>"
    ]
  },
  {
    "objectID": "90-julia.html",
    "href": "90-julia.html",
    "title": "Apéndice K — Adicionales Sobre Julia",
    "section": "",
    "text": "K.1 Stack de Julia\nJulia ofrece un rendimiento de nivel C++ con sintaxis simplificada. A continuación las principales librerías instaladas en los contenedores para el geoprocesamiento.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>K</span>  <span class='chapter-title'>Adicionales Sobre Julia</span>"
    ]
  },
  {
    "objectID": "90-julia.html#stack-de-julia",
    "href": "90-julia.html#stack-de-julia",
    "title": "Apéndice K — Adicionales Sobre Julia",
    "section": "",
    "text": "Tabla K.1: Paquetes principales del stack en Julia\n\n\n\n\n\nPaquete\nFuncionalidad\nSitio web\n\n\n\n\nLibPQ.jl\nControlador PostgreSQL/PostGIS\nhttps://juliadatabases.org/LibPQ.jl/dev/\n\n\nArchGDAL.jl\nInterfaz de alto nivel para GDAL\nhttps://yeesian.com/ArchGDAL.jl/\n\n\nLibGEOS.jl\nInterfaz del motor geométrico (GEOS)\nhttps://github.com/JuliaGeo/LibGEOS.jl\n\n\nPlots.jl\nVisualización y generación de gráficos\nhttps://docs.juliaplots.org/\n\n\nDataFrames.jl\nManipulación de datos en memoria\nhttps://dataframes.juliadata.org/\n\n\n\n\n\n\n\nLibPQ.jl: Conector de bajo nivel para PostgreSQL. Es la herramienta que permitirá a los estudiantes realizar ingesta y consulta de datos desde el servidor PostGIS.\nArchGDAL.jl: Proporciona una abstracción de alto nivel para el motor GDAL. Es excelente para transformar formatos y manejar proyecciones.\nLibGEOS.jl: La interfaz directa al motor de geometrías (GEOS). Se utiliza para operaciones topológicas puras como validación de polígonos, intersecciones y cálculos de buffers.\nDataFrames.jl: El estándar para el manejo de datos tabulares en Julia, permitiendo integrar los resultados de las consultas espaciales en estructuras fáciles de analizar.",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>K</span>  <span class='chapter-title'>Adicionales Sobre Julia</span>"
    ]
  },
  {
    "objectID": "90-julia.html#versiones-instaladas-del-software",
    "href": "90-julia.html#versiones-instaladas-del-software",
    "title": "Apéndice K — Adicionales Sobre Julia",
    "section": "K.2 Versiones instaladas del software",
    "text": "K.2 Versiones instaladas del software\nVersiones de paquetes Julia en el sistema:\n\n\n\n\n\n\n\n\n\n\nSoftware\nTipo\nVersión\nComando (desde terminal)\nComando (desde Julia)\n\n\n\n\nJulia\nLenguaje\n1.10.4\njulia --version\nVERSION\n\n\nLibPQ\nPaquete\n1.18.0\njulia -e \"using LibPQ; println(pkgversion(LibPQ))\"\nusing LibPQ; pkgversion(LibPQ)\n\n\nArchGDAL\nPaquete\n0.10.11\njulia -e \"using ArchGDAL; println(pkgversion(ArchGDAL))\"\nusing ArchGDAL; pkgversion(ArchGDAL)\n\n\nLibGEOS\nPaquete\n0.9.7\njulia -e \"using LibGEOS; println(pkgversion(LibGEOS))\"\nusing LibGEOS; pkgversion(LibGEOS)\n\n\nPlots\nPaquete\n1.41.4\njulia -e \"using Plots; println(pkgversion(Plots))\"\nusing Plots; pkgversion(Plots)\n\n\nDataFrames\nPaquete\n1.8.1\njulia -e \"using DataFrames; println(pkgversion(DataFrames))\"\nusing DataFrames; pkgversion(DataFrames)",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>K</span>  <span class='chapter-title'>Adicionales Sobre Julia</span>"
    ]
  },
  {
    "objectID": "91-qgis.html",
    "href": "91-qgis.html",
    "title": "Apéndice L — Adicionales Sobre QGIS",
    "section": "",
    "text": "L.1 Instalación",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>L</span>  <span class='chapter-title'>Adicionales Sobre QGIS</span>"
    ]
  },
  {
    "objectID": "91-qgis.html#instalación",
    "href": "91-qgis.html#instalación",
    "title": "Apéndice L — Adicionales Sobre QGIS",
    "section": "",
    "text": "OSGeo4w\n\n\nQGIS con PIXI",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>L</span>  <span class='chapter-title'>Adicionales Sobre QGIS</span>"
    ]
  },
  {
    "objectID": "92-arcgispro.html",
    "href": "92-arcgispro.html",
    "title": "Apéndice M — Adicionales sobre ArcGIS Pro",
    "section": "",
    "text": "M.1 Instalación",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>M</span>  <span class='chapter-title'>Adicionales sobre ArcGIS Pro</span>"
    ]
  },
  {
    "objectID": "93-postgresql.html",
    "href": "93-postgresql.html",
    "title": "Apéndice N — Adicionales sobre ArcGIS Pro",
    "section": "",
    "text": "N.1 Instalación",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>N</span>  <span class='chapter-title'>Adicionales sobre ArcGIS Pro</span>"
    ]
  },
  {
    "objectID": "98-errata.html",
    "href": "98-errata.html",
    "title": "Apéndice O — Errata",
    "section": "",
    "text": "Esta es la errata",
    "crumbs": [
      "Apéndices",
      "<span class='chapter-number'>O</span>  <span class='chapter-title'>Errata</span>"
    ]
  },
  {
    "objectID": "99-referencias.html",
    "href": "99-referencias.html",
    "title": "Referencias Bibliográficas",
    "section": "",
    "text": "Bezanson, J., Edelman, A., Karpinski, S., & Shah, V. B. (2017).\nJulia: A fresh approach to numerical computing. SIAM Review,\n59(1), 65–98.\n\n\nDorman, M. (2025). Spatial data programming with python.\nBen-Gurion University of the Negev. https://geobgu.xyz/py-2025/\n\n\nInc., D. (2025). Docker desktop documentation. https://docs.docker.com\n\n\nLaw, M., & Collins, A. (2019). Getting to know ArcGIS PRO. (No\nTitle).\n\n\nLawhead, J. (2017). QGIS python programming cookbook. Packt\nPublishing Ltd.\n\n\nMicrosoft Corporation. (2026). Visual studio code. https://code.visualstudio.com/\n\n\nMitchell, T. (2015). An introduction to open source geospatial\ntools.\n\n\nNeteler, M., Bowman, M. H., Landa, M., & Metz, M. (2012). GRASS GIS:\nA multi-purpose open source GIS. Environmental Modelling &\nSoftware, 31, 124–130.\n\n\nPassy, P., & Théry, S. (2018). The use of SAGA GIS modules in QGIS.\nQGIS and Generic Tools, 1, 107–149.\n\n\nPebesma, E., & Bivand, R. (2023). Spatial data science: With\napplications in R. Chapman; Hall/CRC. https://doi.org/10.1201/9780429459016\n\n\nPebesma, E., & Bivand, R. (2025). Spatial data science: With\napplications in R and Python. https://r-spatial.org/python/\n\n\nPython Software Foundation. (2025). Python 3 documentation. https://docs.python.org/3/\n\n\nPython, W. (2021). Python. Python Releases for Windows,\n24. http://static.softwaresuggest.com.s3.amazonaws.com/ssguides/1604480172_Python_read%20(1).pdf\n\n\nR Core Team. (2025). R: A language and environment for statistical\ncomputing. R Foundation for Statistical Computing. https://www.R-project.org/\n\n\nRosas-Chavoya, M., Gallardo-Salazar, J. L., López-Serrano, P. M.,\nAlcántara-Concepción, P. C., & León-Miranda, A. K. (2022). QGIS a\nconstantly growing free and open-source geospatial software contributing\nto scientific development. Cuadernos de Investigación\nGeográfica, 48(1), 197–213.\n\n\nToms, S. (2015). ArcPy and ArcGIS–geospatial analysis with\npython. Packt Publishing Ltd.\n\n\nWijayaningrum, V. N., Lestari, V. A., et al. (2022). Jupyter lab\nplatform-based interactive learning. 2022 International Conference\non Electrical and Information Technology (IEIT), 295–301.\n\n\nWu, Q. (2023a). PyQGIS cookbook in markdown and jupyter notebook\nformats. In GitHub repository. https://github.com/opengeos/pyqgis-cookbook; GitHub.\n\n\nWu, Q. (2023b). QGIS notebook plugin: Integrate jupyter notebooks into\nQGIS. In GitHub repository [Computer software]. https://github.com/opengeos/qgis-notebook-plugin;\nGitHub.\n\n\nXie, Y. (2019). TinyTeX: A lightweight, cross-platform, and\neasy-to-maintain LaTeX distribution based on TeX live. TUGboat,\n40(1), 30–32.",
    "crumbs": [
      "Apéndices",
      "Referencias Bibliográficas"
    ]
  }
]