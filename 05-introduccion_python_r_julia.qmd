# Introducción a Python, R y Julia

## Introducción

Este capítulo presenta una **introducción práctica y comparativa** a los lenguajes **Python, R y Julia**, enfocada en el uso de **comandos básicos** y en la lectura e interpretación de resultados en consola. El objetivo no es profundizar en programación avanzada, sino ofrecer una **puerta de entrada común** para estudiantes que se inician en el uso de herramientas computacionales para geocomputación.


### Ejecución de código en cada lenguaje

- **Python** y **R** se ejecutan de forma nativa mediante *code chunks* estándar.
- **Julia**, en este curso, **no se ejecuta directamente**. Todo el código Julia se evalúa desde R utilizando funciones auxiliares:
  - `j_eval()` para ejecutar instrucciones generales
  - `j_plot()` para generar gráficos

Por esta razón, en el documento encontrarás dos tipos de bloques relacionados con Julia:
- Bloques con **código Julia puro**, que sirven como referencia y pueden copiarse y reutilizarse.
- Bloques en **R** que llaman a `j_eval()` o `j_plot()`, que son los que realmente ejecutan el código.

### Sobre los bloques de código

- **Todos los bloques de código tienen un `label`**, lo que permite su correcta identificación y reutilización.
- Algunos bloques están pensados **exclusivamente para HTML** y no se ejecutan. Su función es permitir que el estudiante **copie y pegue el código** directamente en su entorno de trabajo.
- Cuando un bloque no se ejecuta, esto se indica explícitamente en sus opciones.

### Alcance del capítulo

En este capítulo aprenderás a:
- Acceder a la ayuda y documentación básica en cada lenguaje
- Ejecutar comandos simples y entender su salida
- Reconocer tipos de objetos y estructuras básicas
- Comparar cómo Python, R y Julia resuelven tareas similares

Este contenido servirá como base para los capítulos posteriores, donde se utilizarán estos lenguajes para la creación de mapas, análisis de datos espaciales y visualización geográfica.


## Función j_eval y j_plot en R

Usada para ejecutar código **Julia** en **R**. `j_eval` ejecuta comandos que no tengan salidas gráficas, y `j_plot` es necesaria cuándo el código Julia produce salidas gráficas.

::: {.content-visible when-format="html"}
::: {.callout-tip collapse="true" icon="false"}
##### ▷ CÓDIGO PURO (Copiar y Pegar)
```{r}
#| label: setup_benchmark_codigo
#| eval: false
# Código en R
j_eval <- function(cmd) {
  .ensure_julia_ready()
  lineas <- strsplit(cmd, "\n")[[1]]
  buffer <- ""; en_bloque <- 0; en_comillas <- 0; resultado_final <- NULL

  for (l in lineas) {
    if (trimws(l) == "") next
    buffer <- paste0(buffer, l, "\n")
    
    # --- Tu lógica estable de detección ---
    en_comillas <- (en_comillas + lengths(regmatches(l, gregexpr('"', l, fixed = TRUE)))) %% 2 
    if (en_comillas == 0) {
      abrir <- grepl("\\b(do|function|for|if|begin|let|while)\\b", l) + 
               lengths(regmatches(l, gregexpr("(", l, fixed = TRUE))) + 
               lengths(regmatches(l, gregexpr("[", l, fixed = TRUE)))
      cerrar <- grepl("\\bend\\b", l) + 
                lengths(regmatches(l, gregexpr(")", l, fixed = TRUE))) + 
                lengths(regmatches(l, gregexpr("]", l, fixed = TRUE)))
      en_bloque <- en_bloque + abrir - cerrar
    }
    
    if (en_bloque <= 0 && en_comillas == 0) {
      res_raw <- JuliaConnectoR::juliaCall("_unal_core_executor", buffer, FALSE, "", 72, 800, 500, 12)
      
      # --- AJUSTE DE SALIDA: Forzar nueva línea ---
      res_l <- gsub("\033\\[[0-9;]*m", "", res_raw) # Limpiar ANSI
      
      # Separamos por líneas para procesar el prompt
      partes <- strsplit(res_l, "\n")[[1]]
      for (p in partes) {
        if (grepl("^julia> ", p)) {
          # Si el comando y el resultado están pegados (separados por 2+ espacios), los dividimos
          p_div <- gsub("^(julia> .*?)\\s{2,}(?=\\S)", "\\1\n", p, perl = TRUE)
          cat(p_div, "\n")
        } else {
          cat(p, "\n")
        }
      }
      # ---------------------------------------------
      
      lineas_res <- strsplit(res_raw, "\n")[[1]]
      lineas_res <- trimws(lineas_res[lineas_res != ""])
      temp_res <- tail(lineas_res[!grepl("^julia>", lineas_res)], 1)
      if (length(temp_res) > 0) resultado_final <- temp_res
      buffer <- ""; en_bloque <- 0; en_comillas <- 0
    }
  }
  if (is.null(resultado_final)) return(invisible(NULL))
  val_limpio <- gsub('"', '', resultado_final)
  num_val <- suppressWarnings(as.numeric(val_limpio))
  return(if (!is.na(num_val)) num_val else val_limpio)
}

j_plot <- function(cmd, n = "tmp_plot.png", dpi = 300, w = 800, h = NULL, ratio = 1.6, fontsize = 12) {
  .ensure_julia_ready()
  if (is.null(h)) h <- round(w / ratio)
  lineas <- strsplit(cmd, "\n")[[1]]
  buffer <- ""; en_bloque <- 0; en_comillas <- 0
  
  for (i in 1:length(lineas)) {
    l <- lineas[i]
    if (trimws(l) == "") next
    buffer <- paste0(buffer, l, "\n")
    en_comillas <- (en_comillas + lengths(regmatches(l, gregexpr('"', l, fixed = TRUE)))) %% 2 
    
    if (en_comillas == 0) {
      abrir <- grepl("\\b(do|function|for|if|begin|let|while)\\b", l) + 
               lengths(regmatches(l, gregexpr("(", l, fixed = TRUE))) + 
               lengths(regmatches(l, gregexpr("[", l, fixed = TRUE)))
      cerrar <- grepl("\\bend\\b", l) + 
                lengths(regmatches(l, gregexpr(")", l, fixed = TRUE))) + 
                lengths(regmatches(l, gregexpr("]", l, fixed = TRUE)))
      en_bloque <- en_bloque + abrir - cerrar
    }
    
    if (en_bloque <= 0 && en_comillas == 0) {
      es_ultimo <- (i == length(lineas))
      log_out <- JuliaConnectoR::juliaCall("_unal_core_executor", buffer, es_ultimo, n, dpi, as.integer(w), as.integer(h), as.integer(fontsize))
      
      # Mismo ajuste de salida para j_plot
      log_l <- gsub("\033\\[[0-9;]*m", "", log_out)
      partes_log <- strsplit(log_l, "\n")[[1]]
      for (p in partes_log) {
        if (grepl("^julia> ", p)) {
          cat(gsub("^(julia> .*?)\\s{2,}(?=\\S)", "\\1\n", p, perl = TRUE), "\n")
        } else {
          cat(p, "\n")
        }
      }
      buffer <- ""; en_bloque <- 0; en_comillas <- 0
    }
  }
  if (file.exists(n)) {
    img <- png::readPNG(n)
    grid::grid.newpage()
    grid::grid.raster(img)
  }
}
```
:::
:::


```{r}
#| label: setup_benchmark
#| code-fold: true
#| include: false
#| results: asis
j_eval <- function(cmd) {
  .ensure_julia_ready()
  lineas <- strsplit(cmd, "\n")[[1]]
  buffer <- ""; en_bloque <- 0; en_comillas <- 0; resultado_final <- NULL

  for (l in lineas) {
    if (trimws(l) == "") next
    buffer <- paste0(buffer, l, "\n")
    
    # --- Tu lógica estable de detección ---
    en_comillas <- (en_comillas + lengths(regmatches(l, gregexpr('"', l, fixed = TRUE)))) %% 2 
    if (en_comillas == 0) {
      abrir <- grepl("\\b(do|function|for|if|begin|let|while)\\b", l) + 
               lengths(regmatches(l, gregexpr("(", l, fixed = TRUE))) + 
               lengths(regmatches(l, gregexpr("[", l, fixed = TRUE)))
      cerrar <- grepl("\\bend\\b", l) + 
                lengths(regmatches(l, gregexpr(")", l, fixed = TRUE))) + 
                lengths(regmatches(l, gregexpr("]", l, fixed = TRUE)))
      en_bloque <- en_bloque + abrir - cerrar
    }
    
    if (en_bloque <= 0 && en_comillas == 0) {
      res_raw <- JuliaConnectoR::juliaCall("_unal_core_executor", buffer, FALSE, "", 72, 800, 500, 12)
      
      # --- AJUSTE DE SALIDA: Forzar nueva línea ---
      res_l <- gsub("\033\\[[0-9;]*m", "", res_raw) # Limpiar ANSI
      
      # Separamos por líneas para procesar el prompt
      partes <- strsplit(res_l, "\n")[[1]]
      for (p in partes) {
        if (grepl("^julia> ", p)) {
          # Si el comando y el resultado están pegados (separados por 2+ espacios), los dividimos
          p_div <- gsub("^(julia> .*?)\\s{2,}(?=\\S)", "\\1\n", p, perl = TRUE)
          cat(p_div, "\n")
        } else {
          cat(p, "\n")
        }
      }
      # ---------------------------------------------
      
      lineas_res <- strsplit(res_raw, "\n")[[1]]
      lineas_res <- trimws(lineas_res[lineas_res != ""])
      temp_res <- tail(lineas_res[!grepl("^julia>", lineas_res)], 1)
      if (length(temp_res) > 0) resultado_final <- temp_res
      buffer <- ""; en_bloque <- 0; en_comillas <- 0
    }
  }
  if (is.null(resultado_final)) return(invisible(NULL))
  val_limpio <- gsub('"', '', resultado_final)
  num_val <- suppressWarnings(as.numeric(val_limpio))
  return(if (!is.na(num_val)) num_val else val_limpio)
}

j_plot <- function(cmd, n = "tmp_plot.png", dpi = 300, w = 800, h = NULL, ratio = 1.6, fontsize = 12) {
  .ensure_julia_ready()
  if (is.null(h)) h <- round(w / ratio)
  lineas <- strsplit(cmd, "\n")[[1]]
  buffer <- ""; en_bloque <- 0; en_comillas <- 0
  
  for (i in 1:length(lineas)) {
    l <- lineas[i]
    if (trimws(l) == "") next
    buffer <- paste0(buffer, l, "\n")
    en_comillas <- (en_comillas + lengths(regmatches(l, gregexpr('"', l, fixed = TRUE)))) %% 2 
    
    if (en_comillas == 0) {
      abrir <- grepl("\\b(do|function|for|if|begin|let|while)\\b", l) + 
               lengths(regmatches(l, gregexpr("(", l, fixed = TRUE))) + 
               lengths(regmatches(l, gregexpr("[", l, fixed = TRUE)))
      cerrar <- grepl("\\bend\\b", l) + 
                lengths(regmatches(l, gregexpr(")", l, fixed = TRUE))) + 
                lengths(regmatches(l, gregexpr("]", l, fixed = TRUE)))
      en_bloque <- en_bloque + abrir - cerrar
    }
    
    if (en_bloque <= 0 && en_comillas == 0) {
      es_ultimo <- (i == length(lineas))
      log_out <- JuliaConnectoR::juliaCall("_unal_core_executor", buffer, es_ultimo, n, dpi, as.integer(w), as.integer(h), as.integer(fontsize))
      
      # Mismo ajuste de salida para j_plot
      log_l <- gsub("\033\\[[0-9;]*m", "", log_out)
      partes_log <- strsplit(log_l, "\n")[[1]]
      for (p in partes_log) {
        if (grepl("^julia> ", p)) {
          cat(gsub("^(julia> .*?)\\s{2,}(?=\\S)", "\\1\n", p, perl = TRUE), "\n")
        } else {
          cat(p, "\n")
        }
      }
      buffer <- ""; en_bloque <- 0; en_comillas <- 0
    }
  }
  if (file.exists(n)) {
    img <- png::readPNG(n)
    grid::grid.newpage()
    grid::grid.raster(img)
  }
}
```

### Flujo de ejecución de texto con j_eval {#sec-flujo-jeval}

Para entender por qué los resultados aparecen con colores y cómo se gestionan los bloques de código, observe el siguiente flujo de ejecución de la función `j_eval`:

```{mermaid}
%%| label: fig-flujo-jeval
%%| fig-cap: "Arquitectura de ejecución de la función puente j_eval."
sequenceDiagram
    participant R as Usuario (R Console)
    participant F as Función j_eval
    participant JC as JuliaConnectoR
    participant J as Motor Julia (Core)

    R->>F: Envía código (cmd)
    loop Por cada línea
        F->>F: Detecta bloques (if, for, do)
        Note over F: Acumula en buffer hasta cerrar bloque
    end
    F->>JC: Pasa bloque completo
    JC->>J: Ejecuta en entorno Julia
    J-->>JC: Devuelve texto (raw string)
    JC-->>F: Retorna resultado a R
    F->>R: Imprime con resaltado (```julia)
    F->>R: Retorna valor final (Numeric/String)
```



::: {.callout-note}
Como se ilustra en la @fig-flujo-jeval, la función no solo "pasa" el texto, sino que actúa como un supervisor que espera a que los bloques de programación estén completos antes de despertar al motor de Julia. Esto garantiza la estabilidad del sistema.
:::

### Flujo de generación gráfica con j_plot {#sec-flujo-jplot}

A diferencia de la ejecución de texto, `j_plot` requiere una coordinación adicional para gestionar archivos físicos. Observe el proceso:

```{mermaid}
%%| label: fig-flujo-jplot
%%| fig-cap: "Arquitectura de generación y renderizado de gráficos Julia-R."
sequenceDiagram
    participant R as R (j_plot)
    participant J as Motor Julia
    participant D as Disco (PNG)
    participant V as Visor (R Graphics)

    R->>J: Envía bloques de código
    Note over J: Procesa lógica espacial/gráfica
    J-->>R: Retorna logs/mensajes
    R->>R: Imprime logs con color
    
    rect rgb(240, 240, 240)
    Note right of J: En el último bloque:
    J->>D: Guarda imagen (tmp_plot.png)
    end
    
    D-->>R: Confirma existencia de archivo
    R->>D: Lee matriz de píxeles (readPNG)
    R->>V: Dibuja en pantalla (grid.raster)
    Note over V: ¡Gráfico visible en el libro!
```



::: {.callout-tip}
#### El rol del disco duro
Como muestra la @fig-flujo-jplot, el secreto de `j_plot` es que utiliza un archivo temporal como "puente" visual. Por eso, si usted tiene el archivo `tmp_plot.png` abierto en otro programa, j_plot podría fallar al intentar sobrescribirlo.
:::


### Interpretación de errores y consola {#sec-errores-consola}

Al trabajar con la interoperabilidad entre lenguajes (usando las funciones `j_eval` y `j_plot` definidas arriba, la consola de **VSCode** nos devolverá mensajes que debemos aprender a interpretar.

#### El error de conexión TCP
Si al usar Julia recibe un mensaje de error que menciona `TCP connection`, usualmente significa que el motor de Julia se ha cerrado o ha entrado en conflicto de memoria.
* **Solución**: Ejecute `.ensure_julia_ready()` en su consola de R para reiniciar el puente de comunicación.

#### Interpretación del Stacktrace en Julia
Cuando Julia detecta un error, genera un rastro de llamadas o *Stacktrace*. No intente leer cada línea; busque siempre la primera (que define el tipo de error) y la última línea de código escrita por usted.

```julia
# Ejemplo de error por índice fuera de rango
ERROR: BoundsError: attempt to access 5-element Vector{Int64} at index [6]
```

#### Resaltado de sintaxis en la salida
Gracias a la configuración de `results: asis` en los bloques de código, la salida de nuestras funciones aparecerá con el prompt `julia>` coloreado, facilitando la distinción entre lo que es un mensaje informativo y un resultado del cálculo.

## Ayuda y documentación

| Tarea | Descripción | Python | R | Julia |
|---|---|---|---|---|
| Ver ayuda general | Abre la documentación interactiva | `help()` | `help.start()` | `?` en REPL |
| Ayuda de función | Documentación de un comando | `help(sum)` | `?mean` | `?sum` |
| Ver ejemplos | Código de ejemplo de una función | **Docstrings** | `example("lapply")` | **Docstrings** |
| Vignettes / guías | Tutoriales extendidos | `obj.__doc__` | `browseVignettes()` | `?Modulo` |
| Demo | Ejecutar ejemplos | `libreria.ejemplos()`* | `demo()` | `include("test")`* |

**Nota sobre los Docstrings:** En Python y Julia, la documentación y los ejemplos de uso residen directamente dentro del código fuente en bloques llamados *Docstrings*. Al ejecutar los comandos de ayuda (`help()` o `@doc`), el intérprete extrae estos comentarios y los muestra en la terminal, permitiendo que el usuario vea ejemplos reales de implementación de inmediato sin necesidad de manuales externos.

**Nota sobre los Demos (\*):** A diferencia de R, Python y Julia no tienen un comando universal `demo()`. El asterisco indica que el acceso a ejemplos depende de la librería. En Python, se suele explorar la propiedad `__doc__` o módulos de `datasets`. En Julia, se acostumbra a inspeccionar la carpeta de instalación mediante `pathof(Modulo)` para encontrar archivos de prueba o ejemplos.

::: {.panel-tabset}

### Python
```{python}
#| label: ayuda_python
#| eval: false
# help() busca y muestra el "Docstring" de la función
help(sum)

# Ayuda sobre un módulo completo para ver sus funciones disponibles
import math
help(math)

# dir() lista todos los métodos y atributos (la "anatomía" del objeto)
import pandas as pd
dir(pd.DataFrame)

# pydoc renderiza la documentación técnica en la terminal
import pydoc
print(pydoc.render_doc("math")) 

# Ejemplo de "Demo" en Python (vía datasets de una librería SIG)
import geopandas as gpd
# Listamos los mapas de ejemplo que vienen con la librería
print(gpd.datasets.available)
```

### R
```{r}
#| label: ayuda_r
#| eval: false
# Inicia el servidor de ayuda local en formato HTML
help.start()

# Acceso rápido a la documentación de una función específica
?mean
help("plot")

# Ejecuta automáticamente el código de ejemplo del manual
example("lapply")

# --- Vignettes y Demos ---

# Abre el índice de tutoriales detallados (vignettes)
browseVignettes()

# Listar guías del paquete 'stars' (análisis de cubos de datos)
# Nota: presione "q" al final de la lista para liberar la consola
vignette(package = "stars")

# Visualizar una vignette específica por su nombre
vignette("stars1", package = "stars")

# Importante: requiere dispositivo gráfico (ej. httpgd::hgd())
# presione "q" al final de la lista para salir
demo()

# Demos específicos de librerías de Geomática
library(sf)
demo("nc", package = "sf")
demo("ggplot", package = "sf")
```

### Julia

```{julia}
#| label: ayuda_julia_codigo
#| eval: false
# Este comando (?) solo funciona dentro del REPL interactivo
# ?sum

# En Quarto usamos la macro @doc para acceder al Docstring
@doc sum
@doc println

# Julia usa docstrings con ejemplos y ayuda integrados, similar a Python
# Para encontrar "Demos", localizamos la carpeta del paquete en el disco
using DataFrames
println("Ubicación del código: ", pathof(DataFrames))
```

:::

## Instalación y carga de paquetes

| Tarea | Descripción | Python | R | Julia |
|---|---|---|---|---|
| Instalar paquete | Agregar librerías externas | `pip3 install ...` | `install.packages()` | `Pkg.add()` |
| Cargar paquete | Habilitar funciones del paquete | `import ...` | `library()` | `using ...` |

::: {.panel-tabset}

### Python
```{python}
#| label: instalacion_python
# #| eval: false

# En terminal usamos pip3 
# para asegurar la versión de Python 3.x
# pip3 install colorama

# Dentro de python usamos el prefijo "!"
# !pip3 install colorama

# Cargamos solo lo necesario para manejar colores en consola
from colorama import Fore, Style

print("Librería cargada en Python")

# Aparecerán caracteres especiales al inicio del texto
# porque el HTML no entiende la instrucción colorear en rojo
# Fore.RED aplica el color; Style.RESET_ALL evita que el color "manche" las siguientes líneas
print(Fore.RED + "Librería cargada en Python" + Style.RESET_ALL)
```

### R
```{r}
#| label: instalacion_r
# #| eval: false

# Este comando carga el paquete con require() o lo instala
# si no existe
if (!require("crayon", character.only = TRUE)) {
  install.packages("crayon", dependencies = TRUE, repos = "https://cran.rstudio.com/")
}

# Activamos el paquete para la sesión actual de R
library(crayon)

# cat() interpreta los códigos de escape ANSI que generan los colores
cat(red("Librería cargada en R"))
```

### Julia

::: {.content-visible when-format="html"}
::: {.callout-tip collapse="true" icon="false"}
#### ▷ CÓDIGO PURO (Copiar y Pegar)
```{julia}
#| label: instalacion_julia_codigo
#| eval: false
# Cargamos el gestor de paquetes de Julia
using Pkg
# Instalamos la librería Crayons
Pkg.add("Crayons")

# Cargamos la librería para habilitar sus funciones
using Crayons

println("Librería cargada en Julia")

# Aparecerán caracteres especiales al inicio del texto
# porque el HTML no entiende la instrucción colorear en rojo
# println con Crayon permite aplicar estilos directamente
println(Crayon(foreground=:red), "Librería cargada en Julia")
```
:::
:::

```{r}
#| label: instalacion_julia_ejecucion
#| results: asis
# #| eval: false
j_eval('
using Pkg
# Verificamos si "Crayons" ya está en el proyecto; si no, lo instalamos
if !haskey(Pkg.dependencies(), Base.UUID("a83e43d3-9d41-5979-9952-4e448995a975"))
    Pkg.add("Crayons")
end
using Crayons
println("Librería cargada en Julia")

# Aparecerán caracteres especiales al inicio del texto
# porque el HTML no entiende la instrucción colorear en rojo
println(Crayon(foreground=:red), "Librería cargada en Julia")
')
```
:::


## Objetos básicos y estructuras de datos

El manejo eficiente de vectores y matrices es el corazón del procesamiento ráster. A continuación, se presenta una comparativa de cómo se declaran y manipulan los objetos básicos.


| Estructura | Descripción | Python | R | Julia |
|:--- |:--- |:--- |:--- |:--- |
| **Vector** | Colección lineal ordenada | `v = np.array([1, 2, 3])` | `v <- c(1, 2, 3)` | `v = [1, 2, 3]` |
| **Matriz** | Arreglo bidimensional (Ráster) | `m = np.zeros((3,3))` o `np.array([[...]])` | `m <- matrix(0, 3, 3)` | `m = zeros(3, 3)` o `[... ; ...]` |
| **Diccionario** | Pares clave-valor (Metadatos) | `{key: val}` ej. `{"id": 1}` | `list(k=v)` ej. `list(id = 1)` | `Dict(k=>v)` ej. `Dict("id"=>1)` |
| **Data Frame** | Estructura tabular (Atributos) | `pd.DataFrame()` | `data.frame()` | `DataFrame(...)` |
| **Indexación** | Posición del primer elemento | Inicia en **0** | Inicia en **1** | Inicia en **1** |

: Comparativa de estructuras de datos {#tbl-comparativa-datos}

### Relación entre estructuras y componentes SIG {#sec-diagrama-estructuras}

Para entender por qué usamos diferentes estructuras de datos, es útil ver cómo se mapean con los componentes de un Sistema de Información Geográfica:

```{mermaid}
%%| label: fig-relacion-geo
%%| fig-cap: "Mapeo de estructuras de programación a componentes de datos espaciales."
%%{init: {'theme': 'base', 'themeVariables': { 'clusterBkg': '#f8f9fa', 'clusterBorder': '#dee2e6' }}}%%
graph TD
    subgraph E [Estructuras en R/Python/Julia]
        M[Matriz / Array]
        D[DataFrame / Tabla]
        K[Diccionario / Dict]
    end

    subgraph C [Componentes del Dato SIG]
        R(Ráster / Rejilla de Celdas)
        A(Atributos / Datos Alfanuméricos)
        T(Metadatos / Información de Cabecera)
    end

    M ==>|Representa| R
    D ==>|Almacena| A
    K ==>|Define| T

    R -.->|Se vincula a| A
    T -.->|Describe a| R
    
    %% Estilos de los nodos
    style M fill:#e1f5fe,stroke:#01579b,stroke-width:2px
    style D fill:#e8f5e9,stroke:#1b5e20,stroke-width:2px
    style K fill:#fff3e0,stroke:#e65100,stroke-width:2px
    style R fill:#ffffff,stroke:#4a148c
    style A fill:#ffffff,stroke:#4a148c
    style T fill:#ffffff,stroke:#4a148c
    
    %% ESTILO DE LOS CUADROS DE FONDO (Gris Claro)
    style E fill:#f2f2f2,stroke:#cccccc,stroke-dasharray: 5 5
    style C fill:#f2f2f2,stroke:#cccccc,stroke-dasharray: 5 5
```

::: {.callout-note}
Como se observa en la @fig-relacion-geo, la **Matriz** es la estructura reina para el análisis ráster, mientras que los **DataFrames** son los que nos permiten realizar consultas sobre las bases de datos de predios o coberturas.
:::

::: {.callout-warning}
### El peligro de la indexación espacial
Esta es la fuente más frecuente de errores. Mientras que en **Python** el primer píxel de una banda satelital es el `[0,0]`, en **R** y **Julia** es el `[1,1]`. Un error de este tipo desplazará todos sus resultados una celda, invalidando análisis de precisión o cambios de cobertura.
:::





**Nota sobre estructuras:** En Geomática, los vectores suelen representar coordenadas o valores de píxeles, mientras que los diccionarios son fundamentales para manejar atributos (como en formato JSON o GeoJSON). Las tablas (DataFrames) son el estándar para bases de datos alfanuméricas de predios, municipios o estaciones climáticas.

::: {.panel-tabset}

### Python
```{python}
#| label: objetos_python
# #| eval: false
# 1. Listas: colecciones mutables de elementos
# Ejemplo: Códigos DANE de departamentos (Antioquia, Cundinamarca, Valle)
codigos = [5, 25, 76]
type(codigos)

# 2. Diccionarios: Estructuras de clave-valor
# Ideal para representar metadatos de un departamento
metadatos = {
    "departamento": ["Antioquia", "Cundinamarca", "Valle"],
    "area_km2": [63612, 22623, 22140],
    "capital": ["Medellín", "Bogotá", "Cali"]
}
type(metadatos)

# 3. DataFrames: Para manejar tablas de atributos SIG
import pandas as pd
df_colombia = pd.DataFrame(metadatos)
type(df_colombia)

# Visualizamos el resumen técnico de la tabla
print(df_colombia.info())
```


### R
```{r}
#| label: objetos_r
# #| eval: false
# 1. Vectores: La unidad básica en R (todos los elementos del mismo tipo)
# Códigos DANE de departamentos
codigos <- c(5, 25, 76)
class(codigos)

# 2. Listas: Pueden contener objetos de diferentes tipos y tamaños
# En R, las listas con nombres funcionan como los diccionarios
metadatos <- list(
  departamento = c("Antioquia", "Cundinamarca", "Valle"),
  area_km2 = c(63612, 22623, 22140),
  capital = c("Medellín", "Bogotá", "Cali")
)
class(metadatos)

# 3. Data Frame: La estructura tabular nativa por excelencia
df_colombia <- data.frame(metadatos)
class(df_colombia)

# str() muestra la estructura interna del objeto (equivalente a info() en Python)
str(df_colombia)
```


### Julia

::: {.content-visible when-format="html"}
::: {.callout-tip collapse="true" icon="false"}
#### ▷ CÓDIGO PURO (Copiar y Pegar)
```{julia}
#| label: objetos_julia_codigo
#| eval: false
# 1. Vectores: Se definen con corchetes (similar a Python)
codigos = [5, 25, 76]
typeof(codigos)

# 2. Diccionarios: Se usa el operador => para asociar clave y valor
metadatos = Dict(
    "departamento" => ["Antioquia", "Cundinamarca", "Valle"],
    "area_km2" => [63612, 22623, 22140]
)
typeof(metadatos)

# 3. Tablas: En Julia Base se pueden usar vectores de Tuplas Nombradas,
# pero en Geomática siempre usaremos la librería DataFrames
using DataFrames
df_colombia = DataFrame(
    departamento = ["Antioquia", "Cundinamarca", "Valle"],
    area_km2 = [63612, 22623, 22140],
    capital = ["Medellín", "Bogotá", "Cali"]
)
typeof(df_colombia)

# describe() da un resumen estadístico de la tabla
println(describe(df_colombia))
```
:::
:::


```{r}
#| label: objetos_julia_ejecucion
#| results: asis
# #| eval: false
j_eval('
# 1. Vectores: Se definen con corchetes (similar a Python)
codigos = [5, 25, 76]

typeof(codigos)

# 2. Diccionarios: Se usa el operador => para asociar clave y valor
metadatos = Dict(
    "departamento" => ["Antioquia", "Cundinamarca", "Valle"],
    "area_km2" => [63612, 22623, 22140]
)

typeof(metadatos)

# 3. Tablas: En Julia Base se pueden usar vectores de Tuplas Nombradas,
# pero en Geomática siempre usaremos la librería DataFrames
using DataFrames
df_colombia = DataFrame(
    departamento = ["Antioquia", "Cundinamarca", "Valle"],
    area_km2 = [63612, 22623, 22140],
    capital = ["Medellín", "Bogotá", "Cali"]
)

typeof(df_colombia)

# describe() da un resumen estadístico de la tabla
println(describe(df_colombia))
')
```
:::

## 4. Comandos básicos y manipulación de tablas

| Tarea | Descripción | Python | R | Julia |
|---|---|---|---|---|
| Directorio | Ruta de trabajo actual | `os.getcwd()` | `getwd()` | `pwd()` |
| Tipo / clase | Tipo de estructura | `type()` | `class()` | `typeof()` |
| Estructura | Resumen técnico | `df.info()` | `str()` | `describe(df)` |
| Dimensiones | Filas y columnas | `df.shape` | `dim()` | `size()` |
| Primeras filas | Vista rápida inicial | `df.head(n)` | `head(df, n)` | `first(df, n)` |
| Frecuencias | Conteo de categorías | `value_counts()` | `table()` | `countmap()` |
| Unir filas | Concatenar vertical | `pd.concat(..., axis=0)` | `rbind()` | `vcat()` |
| Omitir NA | Limpiar datos faltantes | `dropna()` | `na.omit()` | `dropmissing()` |
| Ordenar | Organizar por columna | `sort_values()` | `order()` / `arrange()` | `sort()` |

::: {.panel-tabset}

### Python
```{python}
#| label: comandos_python
# #| eval: false
import os
import numpy as np
import pandas as pd

# 1. Gestión del entorno de trabajo
print(f"Ruta actual: {os.getcwd()}")

# 2. Creación de datos: Departamentos de Colombia (Población en millones, Área en km2)
data = {
    "depto": ["Antioquia", "Cundinamarca", "Valle", "Bolívar", "Atlántico"],
    "pob_2023": [6.8, 3.2, 4.6, 2.2, 2.8],
    "area_km2": [63612, 22623, 22140, 25978, 3388],
    "region": ["Andina", "Andina", "Pacífica", "Caribe", "Caribe"]
}
df = pd.DataFrame(data)

# 3. Inspección de la tabla
print(df.info())           # Resumen de tipos de datos y memoria
print(f"Forma: {df.shape}") # (filas, columnas)
print(df.head(3))          # Ver los primeros 3 registros

# 4. Análisis de frecuencias (¿Cuántos deptos por región?)
print(df["region"].value_counts())

# 5. Operaciones de unión
# Crear un nuevo registro para un depto faltante
nuevo_depto = pd.DataFrame({"depto":["Chocó"], "pob_2023":[0.5], "area_km2":[46530], "region":["Pacífica"]})
# Concatenar verticalmente (axis=0 es por filas)
df_extendido = pd.concat([df, nuevo_depto], axis=0, ignore_index=True)

# 6. Ordenamiento
# Ordenar por población de mayor a menor
df_sorted = df_extendido.sort_values(by="pob_2023", ascending=False)
print(df_sorted)

# 7. Localización por condición (¿Dónde la población es > 4M?)
indices = np.where(df_extendido["pob_2023"] > 4.0)
print(f"Índices detectados: {indices}")
```

### R
```{r}
#| label: comandos_r
# #| eval: false
# 1. Gestión del entorno
getwd()

# 2. Datos de ejemplo (Departamentos de Colombia)
df <- data.frame(
  depto = c("Antioquia", "Cundinamarca", "Valle", "Bolívar", "Atlántico"),
  pob_2023 = c(6.8, 3.2, 4.6, 2.2, 2.8),
  area_km2 = c(63612, 22623, 22140, 25978, 3388),
  region = c("Andina", "Andina", "Pacífica", "Caribe", "Caribe")
)

# 3. Inspección básica
str(df)          # Estructura del objeto
dim(df)          # Dimensiones (filas y columnas)
head(df, 3)      # Primeras 3 filas

# 4. Frecuencias (Equivalente a value_counts)
table(df$region)

# 5. Uniones verticales
# Creamos el registro adicional
nuevo <- data.frame(depto="Chocó", pob_2023=0.5, area_km2=46530, region="Pacífica")
# rbind une por filas (necesita que las columnas se llamen igual)
df_extendido <- rbind(df, nuevo)

# 6. Ordenamiento
# order() devuelve los índices; los usamos para reindexar el dataframe
df_sorted <- df_extendido[order(-df_extendido$pob_2023), ]
print(df_sorted)

# 7. Alternativa con dplyr (El estándar de "Tidyverse" para manipular tablas)
library(dplyr)

# --- Opción A: Paso a paso con variables intermedias ---
# Útil para depurar y entender qué sucede en cada etapa

# Paso 1: Ordenar la tabla de departamentos por población de forma descendente
df_ordenado <- arrange(df_extendido, desc(pob_2023))
print(df_ordenado)

# Paso 2: Filtrar los resultados para quedarnos solo con los mayores a 4M
df_final <- filter(df_ordenado, pob_2023 > 4.0)
print(df_final)


# --- Opción B: Uso de Operadores Pipe (Flujo continuo) ---
# El pipe permite "pasar" el resultado de una función a la siguiente sin crear variables nuevas.

# 1. Pipe de la librería dplyr (el clásico: %>%)
# Se lee como: "Toma df_extendido, ENTONCES ordena, ENTONCES filtra"
df_extendido %>% 
  arrange(desc(pob_2023)) %>% 
  filter(pob_2023 > 4.0)

# 2. Pipe nativo de R (disponible desde la versión 4.1: |>)
# Es más eficiente en memoria y no depende de cargar librerías extra
df_extendido |> 
  arrange(desc(pob_2023)) |> 
  filter(pob_2023 > 4.0)

```

### Julia

::: {.content-visible when-format="html"}
::: {.callout-tip collapse="true" icon="false"}
#### ▷ CÓDIGO PURO (Copiar y Pegar)
```{julia}
#| label: comandos_julia_codigo
#| eval: false
using DataFrames, Statistics

# 1. Directorio actual
pwd()

# 2. Definición de la tabla de departamentos
df = DataFrame(
    depto = ["Antioquia", "Cundinamarca", "Valle", "Bolívar", "Atlántico"],
    pob_2023 = [6.8, 3.2, 4.6, 2.2, 2.8],
    area_km2 = [63612, 22623, 22140, 25978, 3388],
    region = ["Andina", "Andina", "Pacífica", "Caribe", "Caribe"]
)

# 3. Inspección técnica
describe(df)     # Resumen estadístico y de tipos
nrow(df)         # Número de filas
first(df, 3)     # Primeros 3 registros

# 4. Uniones
nuevo = DataFrame(depto=["Chocó"], pob_2023=[0.5], area_km2=[46530], region=["Pacífica"])
# vcat es concatenación vertical
df_ext = vcat(df, nuevo)

# 5. Ordenamiento (rev=true para descendente)
df_sorted = sort(df_ext, :pob_2023, rev=true)
println(df_sorted)
```
:::
:::

```{r}
#| label: comandos_julia_ejecucion
#| results: asis
# #| eval: false
j_eval('
using DataFrames

# Recreamos la tabla en el entorno de Julia
df = DataFrame(
    depto = ["Antioquia", "Cundinamarca", "Valle", "Bolívar", "Atlántico"],
    pob_2023 = [6.8, 3.2, 4.6, 2.2, 2.8],
    area_km2 = [63612, 22623, 22140, 25978, 3388],
    region = ["Andina", "Andina", "Pacífica", "Caribe", "Caribe"]
)

# Ejecutamos inspección y unión
nuevo = DataFrame(depto=["Chocó"], pob_2023=[0.5], area_km2=[46530], region=["Pacífica"])
df_ext = vcat(df, nuevo)

# Ordenar por población y mostrar
println(sort(df_ext, :pob_2023, rev=true))
')
```
:::

### Operaciones numéricas y matemáticas básicas

En el análisis espacial, estas operaciones son la base para calcular distancias, transformar coordenadas o procesar índices de vegetación (NDVI). A continuación, comparamos la sintaxis para las funciones matemáticas más comunes.

| Tarea | Descripción | Python | R | Julia |
|---|---|---|---|---|
| División entera | Cociente sin decimales | `//` | `%/%` | `div()` |
| Módulo | Residuo de la división | `%` | `%%` | `%` |
| Raíz cuadrada | Cálculo de $x^{1/2}$ | `math.sqrt()` | `sqrt()` | `sqrt()` |
| Logaritmo | Logaritmo natural ($ln$) | `math.log()` | `log()` | `log()` |
| Constantes | Valores de $\pi$ y $e$ | `math.pi`, `math.e`| `pi`, `exp(1)` | `pi`, `exp(1)` |

::: {.panel-tabset}

### Python
```{python}
#| label: operaciones_python
# #| eval: false
import math

# 1. Aritmética entera (Útil para indexación de matrices)
print(f"División entera (5 // 2): {5 // 2}")
print(f"Residuo/Módulo (5 % 2): {5 % 2}")

# 2. Constantes matemáticas universales
print(f"Número e: {math.e}")
print(f"Número pi: {math.pi}")

# 3. Funciones matemáticas (Requieren el módulo math)
print(f"Raíz cuadrada de 2: {math.sqrt(2)}")
print(f"Logaritmo natural de 3: {math.log(3)}")
print(f"Logaritmo base 10 de 3: {math.log(3, 10)}")

# 4. Valor absoluto (Distancia sin dirección)
print(f"Absoluto de -3.4: {abs(-3.4)}")
```

### R
```{r}
#| label: operaciones_r
# #| eval: false

# 1. Aritmética entera
cat("División entera (5 %/% 2):", 5 %/% 2, "\n")
cat("Residuo/Módulo (5 %% 2):", 5 %% 2, "\n")

# 2. Constantes (pi es nativo, e se obtiene con exp)
cat("Número e (exp(1)):", exp(1), "\n")
cat("Número pi:", pi, "\n")

# 3. Funciones matemáticas (Nativas en Base R)
cat("Raíz cuadrada de 2:", sqrt(2), "\n")
cat("Logaritmo natural de 3:", log(3), "\n")
cat("Logaritmo base 10 de 3:", log(3, 10), "\n")

# 4. Valor absoluto
cat("Absoluto de -3.4:", abs(-3.4), "\n")
```

### Julia

::: {.content-visible when-format="html"}
::: {.callout-tip collapse="true" icon="false"}
#### ▷ CÓDIGO PURO (Copiar y Pegar)
```{julia}
#| label: operaciones_julia_codigo
#| eval: false
# 1. Aritmética entera
println("División entera: ", div(5, 2))
println("Residuo: ", 5 % 2)

# 2. Constantes y funciones (Nativas en Julia)
println("Número e: ", exp(1))
println("Número pi: ", pi)

# 3. Funciones matemáticas
println("Raíz cuadrada: ", sqrt(2))
println("Logaritmo natural: ", log(3))
println("Logaritmo base 10: ", log(10, 3)) # Nota: En Julia log(base, x)

# 4. Valor absoluto
println("Absoluto: ", abs(-3.4))
```
:::
:::

```{r}
#| label: operaciones_julia_ejecucion
#| results: asis
# #| eval: false
j_eval('
# Ejecución de operaciones matemáticas vía j_eval
println("División entera Julia: ", div(5, 2))
println("Residuo Julia: ", 5 % 2)
println("Raíz de 2: ", sqrt(2))
println("Log natural 3: ", log(3))
println("Log base 10: ", log(10, 3)) # Inversión de argumentos frente a R/Python
println("Absoluto: ", abs(-3.4))
println("Pi: ", pi)
')
```
:::

## 5. Lectura y escritura de datos

| Tarea | Descripción | Python | R | Julia |
|---|---|---|---|---|
| Leer CSV | Cargar tabla desde texto/archivo | `pd.read_csv()` | `read.csv()` | `CSV.read()` |
| Escribir CSV | Guardar tabla en disco | `df.to_csv()` | `write.csv()` | `CSV.write()` |

Para este ejercicio, utilizaremos una técnica de **simulación de archivos en memoria**. Esto es extremadamente útil en programación SIG para procesar datos que vienen de servicios web (APIs) antes de guardarlos físicamente.

::: {.panel-tabset}

### Python
```{python}
#| label: lectura_python
# #| eval: false
import pandas as pd
from io import StringIO

# Simulamos el contenido de un archivo CSV con municipios y altitudes (msnm)
csv_data = """municipio,altitud
Bogota,2625
Medellin,1495
Cali,1018
Quibdo,43
"""

# StringIO convierte un texto en un "objeto de archivo" que pandas puede leer
df = pd.read_csv(StringIO(csv_data))

# Mostramos el resultado cargado
print(df)

# Guardamos en el disco (index=False evita que se guarde la columna de índices)
df.to_csv("municipios_altitud.csv", index=False)
```

### R
```{r}
#| label: lectura_r
# #| eval: false
# Contenido simulado
csv_data <- "municipio,altitud\nBogota,2625\nMedellin,1495\nCali,1018\nQuibdo,43"

# textConnection crea un flujo de lectura a partir de la cadena de texto
con <- textConnection(csv_data)
df <- read.csv(con)

# Es buena práctica cerrar la conexión después de usarla
close(con)

# Visualizamos la tabla
print(df)

# Escribimos en el disco (row.names=FALSE para evitar la columna adicional de números)
write.csv(df, "municipios_altitud.csv", row.names = FALSE)
```

### Julia

::: {.content-visible when-format="html"}
::: {.callout-tip collapse="true" icon="false"}
#### ▷ CÓDIGO PURO (Copiar y Pegar)
```{julia}
#| label: lectura_julia_codigo
#| eval: false
using CSV
using DataFrames

# Contenido simulado
csv_data = "municipio,altitud\nBogota,2625\nMedellin,1495\nCali,1018\nQuibdo,43"

# IOBuffer permite a Julia tratar un String como un archivo abierto
df = CSV.read(IOBuffer(csv_data), DataFrame)

# Visualizamos
println(df)

# Guardar datos en el disco
CSV.write("municipios_altitud.csv", df)
```
:::
:::

```{r}
#| label: lectura_julia_ejecucion
#| results: asis
# #| eval: false
j_eval('
using CSV
using DataFrames

csv_data = "municipio,altitud\nBogota,2625\nMedellin,1495\nCali,1018\nQuibdo,43"

# Cargamos el string como DataFrame usando el buffer de memoria
df = CSV.read(IOBuffer(csv_data), DataFrame)

println("Tabla cargada en Julia:")
println(df)

# Escritura física
CSV.write("municipios_altitud.csv", df)
')
```
:::


## 6. Indexación y filtrado

En esta sección aprenderemos a extraer subconjuntos de datos. En Geomática, esto es vital para aislar, por ejemplo, municipios que superen una altitud crítica o departamentos que pertenecen a una región específica.

| Tarea | Descripción | Python | R | Julia |
|---|---|---|---|---|
| Seleccionar filas | Elegir registros por posición | `df.iloc[0:2]` | `df[1:2, ]` | `df[1:2, :]` |
| Filtrar por condición | Subset basado en reglas | `df[df["altitud"] > 1000]` | `df[df$altitud > 1000, ]` | `filter(row -> ...)` |

::: {.panel-tabset}

### Python
```{python}
#| label: indexacion_python
# #| eval: false
import pandas as pd

# Datos de municipios colombianos con su altitud (msnm)
df = pd.DataFrame({
    "municipio": ["Bogotá", "Medellín", "Cali", "Quibdó", "Barranquilla"],
    "altitud": [2625, 1495, 1018, 43, 18],
    "departamento": ["Cundinamarca", "Antioquia", "Valle", "Chocó", "Atlántico"]
})

# 1. Seleccionar filas por posición (índices 0 y 1)
# iloc permite acceso puramente posicional
primeros_dos = df.iloc[0:2]
print("Primeros dos municipios:\n", primeros_dos)

# 2. Filtrar por condición (Municipios de "Tierras Altas" > 1500 msnm)
tierras_altas = df[df["altitud"] > 1500]
print("\nMunicipios en tierras altas:\n", tierras_altas)

# 3. Filtrado con múltiples condiciones (Andinos y con altitud > 1000)
# Usamos & para 'y' lógico
andinos_altos = df[(df["altitud"] > 1000) & (df["departamento"] != "Chocó")]
```

### R
```{r}
#| label: indexacion_r
# #| eval: false
df <- data.frame(
  municipio = c("Bogotá", "Medellín", "Cali", "Quibdó", "Barranquilla"),
  altitud = c(2625, 1495, 1018, 43, 18),
  departamento = c("Cundinamarca", "Antioquia", "Valle", "Chocó", "Atlántico")
)

# 1. Seleccionar filas por posición (En R los índices inician en 1)
primeros_dos <- df[1:2, ]
print(primeros_dos)

# 2. Filtrar por condición lógica
tierras_altas <- df[df$altitud > 1500, ]
print(tierras_altas)

# 3. Filtrado usando subset() - más legible en Base R
andinos_altos <- subset(df, altitud > 1000 & departamento != "Chocó")
print(andinos_altos)
```

### Julia

::: {.content-visible when-format="html"}
::: {.callout-tip collapse="true" icon="false"}
#### ▷ CÓDIGO PURO (Copiar y Pegar)
```{julia}
#| label: indexacion_julia_codigo
#| eval: false
using DataFrames

df = DataFrame(
    municipio = ["Bogotá", "Medellín", "Cali", "Quibdó", "Barranquilla"],
    altitud = [2625, 1495, 1018, 43, 18],
    departamento = ["Cundinamarca", "Antioquia", "Valle", "Chocó", "Atlántico"]
)

# 1. Selección por posición (similar a R, inicia en 1)
primeros_dos = df[1:2, :]

# 2. Filtrado usando la función filter()
# El operador -> crea una función anónima para evaluar cada fila
tierras_altas = filter(row -> row.altitud > 1500, df)

# 3. Filtrado abreviado (Sintaxis de Julia 1.7+)
andinos_altos = df[(df.altitud .> 1000) .& (df.departamento .!= "Chocó"), :]
```
:::
:::

```{r}
#| label: indexacion_julia_ejecucion
#| results: asis
# #| eval: false
j_eval('
using DataFrames

df = DataFrame(
    municipio = ["Bogotá", "Medellín", "Cali", "Quibdó", "Barranquilla"],
    altitud = [2625, 1495, 1018, 43, 18],
    departamento = ["Cundinamarca", "Antioquia", "Valle", "Chocó", "Atlántico"]
)

# Ejecutamos un filtro y mostramos el resultado
println("Municipios con altitud > 1000 msnm:")
println(filter(row -> row.altitud > 1000, df))
')
```
:::

## 7. Estadística descriptiva básica

El análisis estadístico permite entender la distribución de variables geográficas, como la precipitación acumulada o la densidad de población.

| Tarea | Descripción | Python | R | Julia |
|---|---|---|---|---|
| Media | Promedio aritmético | `np.mean()` | `mean()` | `mean()` |
| Desviación | Medida de dispersión | `np.std()` | `sd()` | `std()` |
| Resumen | Estadísticos básicos | `df.describe()` | `summary()` | `describe()` |

::: {.panel-tabset}

### Python
```{python}
#| label: estadistica_python
# #| eval: false
import numpy as np
import pandas as pd

# Altitudes de una muestra de estaciones climáticas en los Andes colombianos
altitudes = np.array([2625, 1495, 1018, 2150, 1850])

# 1. Estadísticos individuales con Numpy
print(f"Altitud Media: {np.mean(altitudes)} msnm")
print(f"Desviación Estándar: {np.std(altitudes):.2f}")

# 2. Resumen completo con Pandas
df_alt = pd.DataFrame(altitudes, columns=["msnm"])
print("\nResumen Descriptivo:")
print(df_alt.describe())
```

### R
```{r}
#| label: estadistica_r
# #| eval: false
# Vector de altitudes msnm
altitudes <- c(2625, 1495, 1018, 2150, 1850)

# 1. Estadísticos descriptivos básicos
cat("Media:", mean(altitudes), "\n")
cat("Desviación Estándar:", sd(altitudes), "\n")

# 2. Resumen completo (Min, 1st Qu, Median, Mean, 3rd Qu, Max)
summary(altitudes)
```

### Julia

::: {.content-visible when-format="html"}
::: {.callout-tip collapse="true" icon="false"}
#### ▷ CÓDIGO PURO (Copiar y Pegar)
```{julia}
#| label: estadistica_julia_codigo
#| eval: false
using Statistics
using DataFrames

altitudes = [2625, 1495, 1018, 2150, 1850]

# 1. Las funciones de estadística requieren el paquete 'Statistics'
println("Media: ", mean(altitudes))
println("Desviación: ", std(altitudes))

# 2. Resumen descriptivo para DataFrames
df = DataFrame(msnm = altitudes)
println(describe(df))
```
:::
:::

```{r}
#| label: estadistica_julia_ejecucion
#| results: asis
# #| eval: false
j_eval('
using Statistics
using DataFrames

altitudes = [2625, 1495, 1018, 2150, 1850]

println("Media aritmética en Julia: ", mean(altitudes))
println("Desviación estándar: ", std(altitudes))

# Mostramos el resumen tabular
df = DataFrame(msnm = altitudes)
println(describe(df))
')
```
:::


## 8. Gráficos básicos

La visualización es el primer paso del análisis exploratorio de datos (EDA). En SIG, usamos barras para comparar atributos entre regiones y los histogramas para entender la distribución de variables como la elevación o la precipitación.

| Tarea | Descripción | Python | R | Julia |
|---|---|---|---|---|
| Barras | Comparar categorías | `plt.bar()` | `barplot()` | `bar()` |
| Histograma | Distribución de frecuencias | `plt.hist()` | `hist()` | `histogram()` |

::: {.panel-tabset}

### Python
```{python}
#| label: graficos_python
# #| eval: false
import matplotlib.pyplot as plt

# 1. Gráfico de Barras: Altitud de ciudades principales
ciudades = ["Bogotá", "Medellín", "Cali", "Quibdó"]
altitudes = [2625, 1495, 1018, 43]

plt.bar(ciudades, altitudes, color='skyblue', edgecolor='navy')
plt.xlabel("Ciudad")
plt.ylabel("Altitud (msnm)")
plt.title("Comparativa de Altitud - Municipios de Colombia")
plt.show()

# 2. Histograma: Distribución de una muestra de altitudes
# Simulamos 50 estaciones climáticas en diferentes pisos térmicos
import numpy as np
muestra_altitudes = [2625, 1495, 1018, 43, 18, 2527, 959, 467, 2150, 1850] * 5

plt.hist(muestra_altitudes, bins=5, color='orange', alpha=0.7)
plt.xlabel("Rango de Altitud (msnm)")
plt.ylabel("Frecuencia (N° Estaciones)")
plt.title("Distribución de Estaciones por Altitud")
plt.show()
```

### R
```{r}
#| label: graficos_r
# #| eval: false
# 1. Gráfico de Barras
ciudades <- c("Bogotá", "Medellín", "Cali", "Quibdó")
altitudes <- c(2625, 1495, 1018, 43)

# En R base, barplot es simple y potente
barplot(altitudes, 
        names.arg = ciudades, 
        col = "skyblue", 
        border = "navy",
        xlab = "Ciudad", 
        ylab = "Altitud (msnm)",
        main = "Altitud de Municipios")

# 2. Histograma
muestra_altitudes <- c(2625, 1495, 1018, 43, 18, 2527, 959, 467, 2150, 1850)
hist(muestra_altitudes, 
     breaks = 5, 
     col = "orange", 
     xlab = "Altitud (msnm)", 
     main = "Distribución de la Muestra")
```

### Julia

::: {.content-visible when-format="html"}
::: {.callout-tip collapse="true" icon="false"}
#### ▷ CÓDIGO PURO (Copiar y Pegar)
```{julia}
#| label: graficos_julia_codigo
#| eval: false
using Plots

# 1. Gráfico de Barras
ciudades = ["Bogotá", "Medellín", "Cali", "Quibdó"]
altitudes = [2625, 1495, 1018, 43]

# Plots.jl usa una sintaxis muy limpia para etiquetas
bar(ciudades, altitudes, 
    color=:skyblue, 
    xlabel="Ciudad", 
    ylabel="Altitud (msnm)", 
    title="Altitud de Municipios",
    legend=false)

# 2. Histograma
muestra_altitudes = [2625, 1495, 1018, 43, 18, 2527, 959, 467, 2150, 1850]
histogram(muestra_altitudes, 
          bins=5, 
          color=:orange, 
          title="Frecuencia de Altitudes")
```
:::
:::

```{r}
#| label: graficos_julia_ejecucion
#| results: asis
# #| eval: false
j_plot('
using Plots

# Datos de Colombia
ciudades = ["Bogotá", "Medellín", "Cali", "Quibdó"]
altitudes = [2625, 1495, 1018, 43]

# En j_plot, el gráfico se genera en el dispositivo configurado
p1 = bar(ciudades, altitudes, title="Altitud Municipios", legend=false)
display(p1)

muestra = [2625, 1495, 1018, 43, 18, 2527, 959, 467, 2150, 1850]
p2 = histogram(muestra, bins=5, title="Histograma Altitudes")
display(p2)
')
```
:::

## 9. Transformación de datos

En el análisis de datos espaciales, frecuentemente necesitamos derivar nuevas variables a partir de las existentes, como convertir unidades de medida (metros a pies) o categorizar valores (crear rangos climáticos).

| Tarea | Descripción | Python | R | Julia |
|---|---|---|---|---|
| Crear columna | Nueva variable calculada | `df["nueva"] = ...` | `df$nueva <- ...` | `df.nueva = ...` |

::: {.panel-tabset}

### Python
```{python}
#| label: transformacion_python
# #| eval: false
import pandas as pd

# Definimos un DataFrame con municipios y su altitud en metros (msnm)
df = pd.DataFrame({
    "municipio": ["Bogotá", "Medellín", "Cali"],
    "altitud_m": [2625, 1495, 1018]
})

# 1. Creación de una columna mediante una operación aritmética simple
# Convertimos metros a pies (aprox. 3.28 pies por metro)
df["altitud_ft"] = df["altitud_m"] * 3.28

# 2. Creación de una columna con lógica condicional (Clasificación climática)
# Usamos una función lambda para evaluar cada fila
df["clima"] = df["altitud_m"].apply(lambda x: "Frío" if x > 2000 else "Templado")

print(df)
```

### R
```{r}
#| label: transformacion_r
# #| eval: false
# Creamos el data frame base
df <- data.frame(
  municipio = c("Bogotá", "Medellín", "Cali"),
  altitud_m = c(2625, 1495, 1018)
)

# 1. Creación de columna usando el operador de asignación $
# La operación se aplica de forma vectorizada a toda la columna
df$altitud_ft <- df$altitud_m * 3.28

# 2. Creación de columna con lógica condicional usando ifelse()
df$clima <- ifelse(df$altitud_m > 2000, "Frío", "Templado")

print(df)
```

### Julia

::: {.content-visible when-format="html"}
::: {.callout-tip collapse="true" icon="false"}
#### ▷ CÓDIGO PURO (Copiar y Pegar)
```{julia}
#| label: transformacion_julia_codigo
#| eval: false
using DataFrames

# Definimos el DataFrame con datos de Colombia
df = DataFrame(
    municipio = ["Bogotá", "Medellín", "Cali"],
    altitud_m = [2625, 1495, 1018]
)

# 1. Creación de columna: El punto (.) indica que la operación es vectorizada (broadcast)
# Es fundamental en Julia para operar sobre todos los elementos de la columna
df.altitud_ft = df.altitud_m .* 3.28

# 2. Creación con lógica condicional usando una comprensión de lista
df.clima = [x > 2000 ? "Frío" : "Templado" for x in df.altitud_m]

println(df)
```
:::
:::

```{r}
#| label: transformacion_julia_ejecucion
#| results: asis
# #| eval: false
j_eval('
using DataFrames

# Recreamos el DataFrame en el entorno de Julia
df = DataFrame(
    municipio = ["Bogotá", "Medellín", "Cali"],
    altitud_m = [2625, 1495, 1018]
)

# Aplicamos las transformaciones
df.altitud_ft = df.altitud_m .* 3.28
df.clima = [x > 2000 ? "Frío" : "Templado" for x in df.altitud_m]

# Mostramos el resultado final
println(df)
')
```
:::


## 10. Resumen comparativo (cheat sheet)

Esta tabla sirve como guía de referencia rápida para transitar entre los tres lenguajes durante el desarrollo de proyectos de análisis espacial.

| Categoría | Tarea | Python | R | Julia |
|---|---|---|---|---|
| **Ecosistema** | Ayuda de función | `help(f)` | `?f` | `?f` |
| | Instalar paquete | `pip3 install x` | `install.packages("x")` | `Pkg.add("x")` |
| **Estructuras** | Vector / Lista | `[1, 2, 3]` | `c(1, 2, 3)` | `[1, 2, 3]` |
| | Diccionario / Mapa | `{"k": v}` | `list(k = v)` | `Dict(k => v)` |
| | Data Frame | `pd.DataFrame(d)` | `data.frame(d)` | `DataFrame(d)` |
| **I/O** | Leer CSV | `pd.read_csv("f.csv")` | `read.csv("f.csv")` | `CSV.read("f.csv", DF)` |
| **Manipulación**| Ver estructura | `df.info()` | `str(df)` | `describe(df)` |
| | Filtrar filas | `df[df.col > x]` | `df[df$col > x, ]` | `filter(r -> r.col > x, df)`|
| | Crear columna | `df["n"] = x * 2` | `df$n <- x * 2` | `df.n = x .* 2` |
| **Análisis** | Media | `np.mean(x)` | `mean(x)` | `mean(x)` |
| | Dimensiones | `df.shape` | `dim(df)` | `size(df)` |
| **Visualización**| Barras | `plt.bar(x, y)` | `barplot(y, names=x)`| `bar(x, y)` |




---

### Observaciones finales

Para evitar errores comunes en el procesamiento de datos geoespaciales, tenga siempre en cuenta estos tres pilares de la programación moderna:

#### 1. Índices de arreglos (posicionamiento)
La forma en que los lenguajes cuentan las posiciones es la causa principal de errores en la extracción de coordenadas o píxeles:

* **Python:** Utiliza indexación **base-0** (el primer elemento está en la posición `0`).
* **R:** Utiliza indexación **base-1** (el primer elemento está en la posición `1`).
* **Julia:** Al igual que R, utiliza indexación **base-1**.



#### 2. Vectorización y broadcasting (eficiencia)
La capacidad de operar sobre columnas completas sin usar bucles manuales (que son lentos) varía en su sintaxis y naturaleza:

* **Python:** La vectorización **no es nativa** de las listas base. Depende totalmente de librerías como `numpy` o `pandas`. Si intenta multiplicar una lista estándar por 2 (`[1, 2] * 2`), Python duplicará los elementos de la lista en lugar de realizar el cálculo matemático.
* **R:** La vectorización es **nativa y automática**. Casi todas las funciones de R están diseñadas para recibir un vector y devolver otro. Al hacer `vector * 2`, R entiende por defecto que debe multiplicarse cada elemento.
* **Julia:** Utiliza el concepto de **Broadcasting**. Es el más explícito: requiere añadir un **punto** antes del operador (`.*`, `./`, `.^`) o de la función. Este punto le indica al compilador de Julia que "esparza" la operación sobre todos los elementos del vector con una eficiencia comparable al lenguaje C.



#### 3. El flujo de datos: el **pipe** (`.`, `%>%`, `|>`)
El "Pipe" permite escribir código que se lee de izquierda a derecha (como una receta), evitando el anidamiento excesivo de paréntesis.

* **Python (`pandas`):** Utiliza el **encadenamiento de métodos** mediante el punto (`.`). Cada operación devuelve un nuevo objeto sobre el cual se aplica la siguiente: `df.filter(...).sort(...)`.
* **R (`dplyr` / Nativo):** El pipe clásico de *Tidyverse* (`%>%`) o el nativo (`|>`) pasa el objeto automáticamente como **primer argumento** de la siguiente función: `df %>% filter(...)`.
* **Julia (`|>` / `Chain.jl`):** El pipe nativo (`|>`) es un operador de tubería simple. Para flujos de datos complejos y legibles, la comunidad de Julia prefiere la macro `@chain` del paquete `Chain.jl`.

---

### Librerías de referencia (caja de herramientas)

Para que su entorno de trabajo esté completo, asegúrese de tener instaladas y cargadas estas librerías base:

1.  **Python:** `pandas` (tablas de atributos), `numpy` (álgebra de mapas), `matplotlib` (salidas gráficas).
2.  **R:** `base` y `dplyr` (manipulación), `graphics` (visualización rápida).
3.  **Julia:** `DataFrames` (tablas), `CSV` (lectura), `Statistics` y `Plots`.

> **Nota sobre el rendimiento:** Ninguno de los comandos vistos en este capítulo ejecuta procesamiento en paralelo (uso de múltiples núcleos). La vectorización y el pipe son herramientas de **eficiencia lógica y computacional en un solo núcleo**. El procesamiento multihilo se reservará para el análisis de grandes volúmenes de datos en capítulos posteriores.


