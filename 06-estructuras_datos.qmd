---
format:
  html: default
  pdf:
    keep-tex: true
    mermaid-format: png
    include-in-header:
      - text: \usepackage{pdflscape}
---

# Estructuras de datos {#sec-estructuras_datos}

## Funciones j_eval y j_plot en R

```{r}
#| label: j_eval_j_plot
#| code-fold: true
# #| include: false
source("./docs/j_eval_j_plot.r")
```

## Introducci√≥n


## Objetivos de aprendizaje

## Tuplas

Las **Tuplas** son estructuras de datos dise√±adas para almacenar una colecci√≥n de elementos. Su caracter√≠stica m√°s importante es la **inmutabilidad**: una vez creada una tupla, sus elementos no pueden ser alterados, a√±adidos ni eliminados. Esto las hace perfectas para almacenar pares de coordenadas est√°ticas `(Latitud, Longitud)` que no deben modificarse accidentalmente durante la ejecuci√≥n de un algoritmo espacial.

::: {.panel-tabset}

### Python

::: {.content-visible when-format="html"}
::: {.callout-tip collapse="true" icon="false"}
#### ‚ñ∑ C√ìDIGO PURO (Copiar y Pegar)
```{python}
#| label: python_tuplas_codigo
#| eval: false

# Creaci√≥n de una tupla est√°tica (Latitud, Longitud) de Bogot√°
punto_bogota = (4.6097, -74.0817)
print(f"Coordenadas de Bogot√°: {punto_bogota}")

# Acceso a los elementos de la tupla (Recordar: √çndice Base 0)
latitud = punto_bogota[0]
longitud = punto_bogota[1]
print(f"Latitud: {latitud}")
print(f"Longitud: {longitud}")

# Desempaquetado de tuplas (Tuple Unpacking) en variables separadas
lat, lon = punto_bogota
print(f"Bogot√° est√° ubicada a {lat}¬∞N, {lon}¬∞W")

# Almacenamiento de m√∫ltiples puntos geogr√°ficos como tuplas
medellin = (6.2442, -75.5812)
cali = (3.4516, -76.5320)
cartagena = (10.3910, -75.4794)

print(f"Medell√≠n: {medellin}")
print(f"Cali: {cali}")
print(f"Cartagena: {cartagena}")
```
:::
:::


```{python}
#| label: python_tuplas
# #| eval: false

# Creaci√≥n de una tupla est√°tica (Latitud, Longitud) de Bogot√°
punto_bogota = (4.6097, -74.0817)
print(f"Coordenadas de Bogot√°: {punto_bogota}")

# Acceso a los elementos de la tupla (Recordar: √çndice Base 0)
latitud = punto_bogota[0]
longitud = punto_bogota[1]
print(f"Latitud: {latitud}")
print(f"Longitud: {longitud}")

# Desempaquetado de tuplas (Tuple Unpacking) en variables separadas
lat, lon = punto_bogota
print(f"Bogot√° est√° ubicada a {lat}¬∞N, {lon}¬∞W")

# Almacenamiento de m√∫ltiples puntos geogr√°ficos como tuplas
medellin = (6.2442, -75.5812)
cali = (3.4516, -76.5320)
cartagena = (10.3910, -75.4794)

print(f"Medell√≠n: {medellin}")
print(f"Cali: {cali}")
print(f"Cartagena: {cartagena}")
```

### R

::: {.content-visible when-format="html"}
::: {.callout-tip collapse="true" icon="false"}
#### ‚ñ∑ C√ìDIGO PURO (Copiar y Pegar)
```{r}
#| label: r_tuplas_codigo
#| eval: false

# R no tiene "tuplas" nativas; usamos vectores 'c()' para coordenadas
punto_bogota <- c(4.6097, -74.0817)
cat("Coordenadas de Bogot√°:", punto_bogota, "\n")

# Acceso a los elementos (Recordar: √çndice Base 1)
latitud <- punto_bogota[1]
longitud <- punto_bogota[2]
cat("Latitud:", latitud, "\n")
cat("Longitud:", longitud, "\n")

# Asignaci√≥n de variables (R nativo no tiene desempaquetado autom√°tico)
lat <- punto_bogota[1]
lon <- punto_bogota[2]
cat(sprintf("Bogot√° est√° ubicada a %s¬∞N, %s¬∞W\n", lat, lon))

# Almacenamiento de m√∫ltiples puntos geogr√°ficos
medellin <- c(6.2442, -75.5812)
cali <- c(3.4516, -76.5320)
cartagena <- c(10.3910, -75.4794)

cat("Medell√≠n:", medellin, "\n")
cat("Cali:", cali, "\n")
cat("Cartagena:", cartagena, "\n")
```
:::
:::

```{r}
#| label: r_tuplas
# #| eval: false

# R no tiene "tuplas" nativas; usamos vectores 'c()' para coordenadas
punto_bogota <- c(4.6097, -74.0817)
cat("Coordenadas de Bogot√°:", punto_bogota, "\n")

# Acceso a los elementos (Recordar: √çndice Base 1)
latitud <- punto_bogota[1]
longitud <- punto_bogota[2]
cat("Latitud:", latitud, "\n")
cat("Longitud:", longitud, "\n")

# Asignaci√≥n de variables (R nativo no tiene desempaquetado autom√°tico)
lat <- punto_bogota[1]
lon <- punto_bogota[2]
cat(sprintf("Bogot√° est√° ubicada a %s¬∞N, %s¬∞W\n", lat, lon))

# Almacenamiento de m√∫ltiples puntos geogr√°ficos
medellin <- c(6.2442, -75.5812)
cali <- c(3.4516, -76.5320)
cartagena <- c(10.3910, -75.4794)

cat("Medell√≠n:", medellin, "\n")
cat("Cali:", cali, "\n")
cat("Cartagena:", cartagena, "\n")
```

### Julia

::: {.content-visible when-format="html"}
::: {.callout-tip collapse="true" icon="false"}
#### ‚ñ∑ C√ìDIGO PURO (Copiar y Pegar)
```{julia}
#| label: julia_tuplas_codigo
#| eval: false

# Creaci√≥n de una tupla est√°tica (Latitud, Longitud) de Bogot√°
punto_bogota = (4.6097, -74.0817)
println("Coordenadas de Bogot√°: ", punto_bogota)

# Acceso a los elementos de la tupla (Recordar: √çndice Base 1)
latitud = punto_bogota[1]
longitud = punto_bogota[2]
println("Latitud: ", latitud)
println("Longitud: ", longitud)

# Desempaquetado de tuplas (Tuple Unpacking)
lat, lon = punto_bogota
println("Bogot√° est√° ubicada a $lat¬∞N, $lon¬∞W")

# Almacenamiento de m√∫ltiples puntos geogr√°ficos como tuplas
medellin = (6.2442, -75.5812)
cali = (3.4516, -76.5320)
cartagena = (10.3910, -75.4794)

println("Medell√≠n: ", medellin)
println("Cali: ", cali)
println("Cartagena: ", cartagena)
```
:::
:::

```{r}
#| label: julia_tuplas
#| results: asis
#| code-fold: true
# #| eval: false
j_eval('
# Creaci√≥n de una tupla est√°tica (Latitud, Longitud) de Bogot√°
punto_bogota = (4.6097, -74.0817)
println("Coordenadas de Bogot√°: ", punto_bogota)

# Acceso a los elementos de la tupla (Recordar: √çndice Base 1)
latitud = punto_bogota[1]
longitud = punto_bogota[2]
println("Latitud: ", latitud)
println("Longitud: ", longitud)

# Desempaquetado de tuplas (Tuple Unpacking)
lat, lon = punto_bogota
println("Bogot√° est√° ubicada a $lat¬∞N, $lon¬∞W")

# Almacenamiento de m√∫ltiples puntos geogr√°ficos como tuplas
medellin = (6.2442, -75.5812)
cali = (3.4516, -76.5320)
cartagena = (10.3910, -75.4794)

println("Medell√≠n: ", medellin)
println("Cali: ", cali)
println("Cartagena: ", cartagena)
')
```

:::

| Caracter√≠stica | Python | R | Julia |
|:---|:---:|:---:|:---:|
| **Sintaxis de Creaci√≥n** | `t = (x, y)` | `v <- c(x, y)` (Vector) | `t = (x, y)` |
| **Inmutabilidad estricta**| S√≠ (genera error si se intenta alterar). | No aplica. Los vectores hacen una copia en memoria si se alteran. | S√≠ (genera error si se intenta alterar). |
| **Desempaquetado (*Unpacking*)** | `x, y = t` | Requiere extraer por √≠ndice manual `x <- v[1]; y <- v[2]`. | `x, y = t` |
| **Uso Principal en SIG** | Proteger pares de coordenadas est√°ticas de alteraciones en iteraciones. | Creaci√≥n r√°pida de puntos geom√©tricos. | Tipado estricto y seguro de coordenadas para m√°ximo rendimiento. |

: Comparaci√≥n t√©cnica de tuplas y equivalentes {#tbl-tuplas tbl-colwidths="[20,25,30,25]"}



---

**Nota t√©cnica:** Las tuplas no existen nativamente en R con el comportamiento de "desempaquetado" e "inmutabilidad estricta" que vemos en Python y Julia. En R, utilizamos **vectores** (`c()`) o **listas** (`list()`) para agrupar coordenadas. Es crucial entender que en Python y Julia, si intentas ejecutar `punto_bogota[0] = 5.0`, el programa colapsar√° inmediatamente para proteger los datos (porque una tupla es inmutable). En R, `punto_bogota[1] <- 5.0` s√≠ funcionar√°, reescribiendo la coordenada silenciosamente.


## Listas (y vectores)

A diferencia de las tuplas, las **Listas** (en Python y Julia) o los **Vectores** (en R) son secuencias **mutables** y din√°micas. Son la estructura de datos m√°s utilizada en geom√°tica para almacenar series temporales, perfiles de elevaci√≥n, atributos de una tabla o una secuencia ordenada de v√©rtices que conforman una ruta, ya que permiten agregar, eliminar o modificar datos sobre la marcha.

::: {.panel-tabset}

### Python

::: {.content-visible when-format="html"}
::: {.callout-tip collapse="true" icon="false"}
#### ‚ñ∑ C√ìDIGO PURO (Copiar y Pegar)
```{python}
#| label: python_listas_codigo
#| eval: false

# 1. CREACI√ìN DE LISTAS
# Una lista de tuplas de coordenadas representando una ruta de viaje
ruta = [
    (4.6097, -74.0817),  # Bogot√°
    (6.2442, -75.5812),  # Medell√≠n
    (3.4516, -76.5320),  # Cali
]
print("Ruta inicial:", ruta)

# Una lista de mediciones de elevaci√≥n (en metros)
elevaciones = [2600.5, 2650.2, 2710.8, 2800.3, 2950.7, 3100.1]
print("Perfil de elevaci√≥n:", elevaciones)

# Una lista de cadenas de texto (nombres de ciudades)
ciudades = ["Bogot√°", "Medell√≠n", "Cali"]
print("Ciudades a visitar:", ciudades)

# 2. AGREGAR ELEMENTOS (Mutabilidad)

# a. Agregar al final (.append)
# Agregamos Cartagena al final de nuestra ruta (pasa a ser la tercera parada, √≠ndice 2)
ruta.append((10.3910, -75.4794))
elevaciones.append(2.0)
print("Ruta con Cartagena al final:", ruta)

# b. Insertar en una posici√≥n espec√≠fica (.insert)
# Necesitamos agregar una parada (ej. Manizales) justo DESPU√âS de Medell√≠n.
# Como Medell√≠n es el √≠ndice 1, insertamos en el √≠ndice 2.
# Esto empuja a Cartagena hacia el √≠ndice 3
ruta.insert(2, (5.0689, -75.5174))
elevaciones.insert(2, 2160.0)

print("\nRuta final con parada intercalada:", ruta)
print("Elevaciones finales:", elevaciones)

# NOTA PEDAG√ìGICA:
# Usar .insert(2, valor) asegura que el nuevo elemento ocupe exactamente 
# la tercera posici√≥n de la lista (Base 0), respetando el orden de las paradas anteriores.

# 3. ACCEDER A ELEMENTOS (√çndices)
# Acceder a la primera ciudad de la ruta (√çndice 0)
primera_parada = ruta[0]
print(f"Primera parada: {primera_parada}")

# Acceder a la latitud de la segunda ciudad de la ruta 
# √çndice 1 (entra a Medell√≠n) y luego √çndice 0 (extrae la latitud)
# Nota: A diferencia de R, en Python NO se usan dobles corchetes [[ ]].
# Aqu√≠ simplemente encadenamos un corchete al lado del otro: [1][0]
sda_parada_lat = ruta[1][0]
print(f"Latitud segunda parada: {sda_parada_lat}")

# Alternativa Pythonica: Desempaquetado de tuplas
# Extraemos la tupla entera (ruta[1]) y la desempaquetamos 
# directamente en dos variables con nombres claros.
# En este caso decidimos no extraer la longitud
latitud, _ = ruta[1]

print(f"Latitud segunda parada: {latitud}")


# Acceder a la √∫ltima ciudad usando indexaci√≥n negativa
ultima_parada = ruta[-1]
print(f"√öltima parada: {ultima_parada}")

# 4. SLICING (Extraer porciones de la lista)
# Obtener las dos primeras paradas (√≠ndices 0 y 1, el 2 es exclusivo)
primeras_dos = ruta[:2]
print("Primeras dos paradas:", primeras_dos)

# Obtener una porci√≥n central de las elevaciones (√≠ndices 2, 3 y 4)
elevaciones_medias = elevaciones[2:5]
print("Elevaciones intermedias:", elevaciones_medias)

# 5. OPERACIONES √öTILES
# Contar el n√∫mero de v√©rtices (puntos de ruta)
num_vertices = len(ruta)
print(f"N√∫mero de v√©rtices: {num_vertices}")

# Encontrar la elevaci√≥n m√°xima
elev_maxima = max(elevaciones)
print(f"Elevaci√≥n m√°xima: {elev_maxima} metros")

# Calcular la elevaci√≥n promedio
elev_promedio = sum(elevaciones) / len(elevaciones)
print(f"Elevaci√≥n promedio: {elev_promedio:.1f} metros")
```
:::
:::


```{python}
#| label: python_listas
# #| eval: false

# 1. CREACI√ìN DE LISTAS
# Una lista de tuplas de coordenadas representando una ruta de viaje
ruta = [
    (4.6097, -74.0817),  # Bogot√°
    (6.2442, -75.5812),  # Medell√≠n
    (3.4516, -76.5320),  # Cali
]
print("Ruta inicial:", ruta)

# Una lista de mediciones de elevaci√≥n (en metros)
elevaciones = [2600.5, 2650.2, 2710.8, 2800.3, 2950.7, 3100.1]
print("Perfil de elevaci√≥n:", elevaciones)

# Una lista de cadenas de texto (nombres de ciudades)
ciudades = ["Bogot√°", "Medell√≠n", "Cali"]
print("Ciudades a visitar:", ciudades)

# 2. AGREGAR ELEMENTOS (Mutabilidad)

# a. Agregar al final (.append)
# Agregamos Cartagena al final de nuestra ruta (pasa a ser la tercera parada, √≠ndice 2)
ruta.append((10.3910, -75.4794))
elevaciones.append(2.0)
print("Ruta con Cartagena al final:", ruta)

# b. Insertar en una posici√≥n espec√≠fica (.insert)
# Necesitamos agregar una parada (ej. Manizales) justo DESPU√âS de Medell√≠n.
# Como Medell√≠n es el √≠ndice 1, insertamos en el √≠ndice 2.
# Esto empuja a Cartagena hacia el √≠ndice 3
ruta.insert(2, (5.0689, -75.5174))
elevaciones.insert(2, 2160.0)

print("\nRuta final con parada intercalada:", ruta)
print("Elevaciones finales:", elevaciones)

# NOTA PEDAG√ìGICA:
# Usar .insert(2, valor) asegura que el nuevo elemento ocupe exactamente 
# la tercera posici√≥n de la lista (Base 0), respetando el orden de las paradas anteriores.

# 3. ACCEDER A ELEMENTOS (√çndices)
# Acceder a la primera ciudad de la ruta (√çndice 0)
primera_parada = ruta[0]
print(f"Primera parada: {primera_parada}")

# Acceder a la latitud de la segunda ciudad de la ruta 
# √çndice 1 (entra a Medell√≠n) y luego √çndice 0 (extrae la latitud)
# Nota: A diferencia de R, en Python NO se usan dobles corchetes [[ ]].
# Aqu√≠ simplemente encadenamos un corchete al lado del otro: [1][0]
sda_parada_lat = ruta[1][0]
print(f"Latitud segunda parada: {sda_parada_lat}")

# Alternativa Pythonica: Desempaquetado de tuplas
# Extraemos la tupla entera (ruta[1]) y la desempaquetamos 
# directamente en dos variables con nombres claros.
# En este caso decidimos no extraer la longitud
latitud, _ = ruta[1]

print(f"Latitud segunda parada: {latitud}")

# Acceder a la √∫ltima ciudad usando indexaci√≥n negativa
ultima_parada = ruta[-1]
print(f"√öltima parada: {ultima_parada}")

# 4. SLICING (Extraer porciones de la lista)
# Obtener las dos primeras paradas (√≠ndices 0 y 1, el 2 es exclusivo)
primeras_dos = ruta[:2]
print("Primeras dos paradas:", primeras_dos)

# Obtener una porci√≥n central de las elevaciones (√≠ndices 2, 3 y 4)
elevaciones_medias = elevaciones[2:5]
print("Elevaciones intermedias:", elevaciones_medias)

# 5. OPERACIONES √öTILES
# Contar el n√∫mero de v√©rtices (puntos de ruta)
num_vertices = len(ruta)
print(f"N√∫mero de v√©rtices: {num_vertices}")

# Encontrar la elevaci√≥n m√°xima
elev_maxima = max(elevaciones)
print(f"Elevaci√≥n m√°xima: {elev_maxima} metros")

# Calcular la elevaci√≥n promedio
elev_promedio = sum(elevaciones) / len(elevaciones)
print(f"Elevaci√≥n promedio: {elev_promedio:.1f} metros")
```

### R

::: {.content-visible when-format="html"}
::: {.callout-tip collapse="true" icon="false"}
#### ‚ñ∑ C√ìDIGO PURO (Copiar y Pegar)
```{r}
#| label: r_listas_codigo
#| eval: false

# 1. CREACI√ìN DE LISTAS Y VECTORES
# En R, usamos 'list' para agrupar objetos complejos como vectores de coordenadas
ruta <- list(
    c(4.6097, -74.0817),  # Bogot√°
    c(6.2442, -75.5812),  # Medell√≠n
    c(3.4516, -76.5320)   # Cali
)
cat("Ruta inicial:\n"); print(ruta)

# Los datos homog√©neos (n√∫meros o textos solos) van en vectores at√≥micos 'c()'
elevaciones <- c(2600.5, 2650.2, 2710.8, 2800.3, 2950.7, 3100.1)
cat("Perfil de elevaci√≥n:", elevaciones, "\n")

ciudades <- c("Bogot√°", "Medell√≠n", "Cali")
cat("Ciudades a visitar:", ciudades, "\n")

# 2. AGREGAR ELEMENTOS (Mutabilidad)

# a. Agregar al final (append / c)
# Agregamos Cartagena al final de la lista de rutas
ruta <- append(ruta, list(c(10.3910, -75.4794)))
# Agregamos la elevaci√≥n al final del vector
elevaciones <- c(elevaciones, 2.0)

print("Ruta con Cartagena al final:")
print(ruta)

# b. Insertar en una posici√≥n espec√≠fica (after)
# Necesitamos agregar Manizales justo DESPU√âS de Medell√≠n.
# Como Medell√≠n es la posici√≥n 2, indicamos after = 2.
# Esto coloca a Manizales en la posici√≥n 3 y desplaza a Cartagena a la 4.
ruta <- append(ruta, list(c(5.0689, -75.5174)), after = 2)
elevaciones <- append(elevaciones, 2160.0, after = 2)

print("Ruta final con parada intercalada:")
print(ruta)

# NOTA PEDAG√ìGICA:
# En R, la funci√≥n append() es muy vers√°til. Si no usas 'after', agrega al final.
# Al usar after = 2, le indicamos que el nuevo "eslab√≥n" se enganche justo 
# despu√©s de la segunda posici√≥n, manteniendo la l√≥gica de nuestra ruta.

# 3. ACCEDER A ELEMENTOS (√çndice Base 1)

# LA REGLA DE ORO DE LAS LISTAS EN R:
# ruta[1]   -> Devuelve una LISTA (La "caja" cerrada). No podemos hacer c√°lculos num√©ricos con esto.
# ruta[[1]] -> Devuelve el VECTOR (El contenido de la caja). ¬°Esto es lo que necesitamos!
primera_parada <- ruta[[1]]
cat("Primera parada:", primera_parada, "\n")

# ACCEDER A LA LATITUD DE LA SEGUNDA CIUDAD DE LA RUTA (MEDELL√çN)
# --- ESTRATEGIA MATRIOSHKA EN R ---

# a. El camino largo (Entender las capas)
# ruta[2]         -> Crea una sub-lista (caja con el paquete adentro)
# ruta[2][[1]]    -> Abre la sub-lista para sacar el vector (el paquete)
# ruta[2][[1]][1] -> Toma el primer valor del paquete (la latitud)

sda_parada_lat_v1 <- ruta[2][[1]][1]
cat("Camino Largo - Latitud segunda parada:", sda_parada_lat_v1, "\n")

# b. El camino directo (La forma recomendada)
# ruta[[2]]       -> Abre directamente la caja 2 de la lista original
# ruta[[2]][1]    -> Toma el primer valor del vector extra√≠do

sda_parada_lat_v2 <- ruta[[2]][1]
cat("Camino Corto - Latitud segunda parada:", sda_parada_lat_v2, "\n")

# NOTA PEDAG√ìGICA: 
# ruta[2][[1]] es exactamente id√©ntico a ruta[[2]]. 
# Usar la primera opci√≥n es como abrir un sobre para sacar una carta 
# que est√° dentro de otro sobre. ¬°Doble trabajo innecesario!

# c. Alternativa: Paso a paso para evitar el laberinto de corchetes
# A diferencia de Python/Julia, R Base no tiene un "desempaquetado" de 
# m√∫ltiples variables en una sola l√≠nea. La forma m√°s limpia y "R-√≥nica" 
# de hacerlo sin confundirse es usar variables intermedias:

medellin_coords <- ruta[[2]]   # Paso 1: Extraemos el vector completo
latitud <- medellin_coords[1]  # Paso 2: Sacamos solo lo que nos interesa

cat("Paso a Paso  - Latitud segunda parada:", latitud, "\n")

# Acceder a la √∫ltima ciudad usando la longitud total
ultima_parada <- ruta[[length(ruta)]]
cat("√öltima parada:", ultima_parada, "\n")

# 4. SLICING (Extraer porciones)
# En R, el √≠ndice final S√ç se incluye en el rango
primeras_dos <- ruta[1:2] # Usa corchete simple para rebanar listas

# Para extraer las elevaciones equivalentes (3er, 4to y 5to elemento)
elevaciones_medias <- elevaciones[3:5]
cat("Elevaciones intermedias:", elevaciones_medias, "\n")

# 5. OPERACIONES √öTILES
num_vertices <- length(ruta)
cat("N√∫mero de v√©rtices:", num_vertices, "\n")

elev_maxima <- max(elevaciones)
cat("Elevaci√≥n m√°xima:", elev_maxima, "metros\n")

# R tiene una funci√≥n nativa para el promedio
elev_promedio <- mean(elevaciones)
cat(sprintf("Elevaci√≥n promedio: %.1f metros\n", elev_promedio))
```
:::
:::

```{r}
#| label: r_listas
# #| eval: false

# 1. CREACI√ìN DE LISTAS Y VECTORES
# En R, usamos 'list' para agrupar objetos complejos como vectores de coordenadas
ruta <- list(
    c(4.6097, -74.0817),  # Bogot√°
    c(6.2442, -75.5812),  # Medell√≠n
    c(3.4516, -76.5320)   # Cali
)
cat("Ruta inicial:\n"); print(ruta)

# Los datos homog√©neos (n√∫meros o textos solos) van en vectores at√≥micos 'c()'
elevaciones <- c(2600.5, 2650.2, 2710.8, 2800.3, 2950.7, 3100.1)
cat("Perfil de elevaci√≥n:", elevaciones, "\n")

ciudades <- c("Bogot√°", "Medell√≠n", "Cali")
cat("Ciudades a visitar:", ciudades, "\n")

# 2. AGREGAR ELEMENTOS (Mutabilidad)

# a. Agregar al final (append / c)
# Agregamos Cartagena al final de la lista de rutas
ruta <- append(ruta, list(c(10.3910, -75.4794)))
# Agregamos la elevaci√≥n al final del vector
elevaciones <- c(elevaciones, 2.0)

print("Ruta con Cartagena al final:")
print(ruta)

# b. Insertar en una posici√≥n espec√≠fica (after)
# Necesitamos agregar Manizales justo DESPU√âS de Medell√≠n.
# Como Medell√≠n es la posici√≥n 2, indicamos after = 2.
# Esto coloca a Manizales en la posici√≥n 3 y desplaza a Cartagena a la 4.
ruta <- append(ruta, list(c(5.0689, -75.5174)), after = 2)
elevaciones <- append(elevaciones, 2160.0, after = 2)

print("Ruta final con parada intercalada:")
print(ruta)

# NOTA PEDAG√ìGICA:
# En R, la funci√≥n append() es muy vers√°til. Si no usas 'after', agrega al final.
# Al usar after = 2, le indicamos que el nuevo "eslab√≥n" se enganche justo 
# despu√©s de la segunda posici√≥n, manteniendo la l√≥gica de nuestra ruta.

# 3. ACCEDER A ELEMENTOS (√çndice Base 1)

# LA REGLA DE ORO DE LAS LISTAS EN R:
# ruta[1]   -> Devuelve una LISTA (La "caja" cerrada). No podemos hacer c√°lculos num√©ricos con esto.
# ruta[[1]] -> Devuelve el VECTOR (El contenido de la caja). ¬°Esto es lo que necesitamos!
primera_parada <- ruta[[1]]
cat("Primera parada:", primera_parada, "\n")

# ACCEDER A LA LATITUD DE LA SEGUNDA CIUDAD DE LA RUTA (MEDELL√çN)
# --- ESTRATEGIA MATRIOSHKA EN R ---

# a. El camino largo (Entender las capas)
# ruta[2]         -> Crea una sub-lista (caja con el paquete adentro)
# ruta[2][[1]]    -> Abre la sub-lista para sacar el vector (el paquete)
# ruta[2][[1]][1] -> Toma el primer valor del paquete (la latitud)

sda_parada_lat_v1 <- ruta[2][[1]][1]
cat("Camino Largo - Latitud segunda parada:", sda_parada_lat_v1, "\n")

# b. El camino directo (La forma recomendada)
# ruta[[2]]       -> Abre directamente la caja 2 de la lista original
# ruta[[2]][1]    -> Toma el primer valor del vector extra√≠do

sda_parada_lat_v2 <- ruta[[2]][1]
cat("Camino Corto - Latitud segunda parada:", sda_parada_lat_v2, "\n")

# NOTA PEDAG√ìGICA: 
# ruta[2][[1]] es exactamente id√©ntico a ruta[[2]]. 
# Usar la primera opci√≥n es como abrir un sobre para sacar una carta 
# que est√° dentro de otro sobre. ¬°Doble trabajo innecesario!

# c. Alternativa: Paso a paso para evitar el laberinto de corchetes
# A diferencia de Python/Julia, R Base no tiene un "desempaquetado" de 
# m√∫ltiples variables en una sola l√≠nea. La forma m√°s limpia y "R-√≥nica" 
# de hacerlo sin confundirse es usar variables intermedias:

medellin_coords <- ruta[[2]]   # Paso 1: Extraemos el vector completo
latitud <- medellin_coords[1]  # Paso 2: Sacamos solo lo que nos interesa

cat("Paso a Paso  - Latitud segunda parada:", latitud, "\n")

# Acceder a la √∫ltima ciudad usando la longitud total
ultima_parada <- ruta[[length(ruta)]]
cat("√öltima parada:", ultima_parada, "\n")

# 4. SLICING (Extraer porciones)
# En R, el √≠ndice final S√ç se incluye en el rango
primeras_dos <- ruta[1:2] # Usa corchete simple para rebanar listas

# Para extraer las elevaciones equivalentes (3er, 4to y 5to elemento)
elevaciones_medias <- elevaciones[3:5]
cat("Elevaciones intermedias:", elevaciones_medias, "\n")

# 5. OPERACIONES √öTILES
num_vertices <- length(ruta)
cat("N√∫mero de v√©rtices:", num_vertices, "\n")

elev_maxima <- max(elevaciones)
cat("Elevaci√≥n m√°xima:", elev_maxima, "metros\n")

# R tiene una funci√≥n nativa para el promedio
elev_promedio <- mean(elevaciones)
cat(sprintf("Elevaci√≥n promedio: %.1f metros\n", elev_promedio))
```

### Julia

::: {.content-visible when-format="html"}
::: {.callout-tip collapse="true" icon="false"}
#### ‚ñ∑ C√ìDIGO PURO (Copiar y Pegar)
```{julia}
#| label: julia_listas_codigo
#| eval: false

# 1. CREACI√ìN DE ARREGLOS (Listas)
# Un Array de tuplas de coordenadas
ruta = [
    (4.6097, -74.0817),  # Bogot√°
    (6.2442, -75.5812),  # Medell√≠n
    (3.4516, -76.5320),  # Cali
]
println("Ruta inicial: ", ruta)

# Array de valores num√©ricos de coma flotante
elevaciones = [2600.5, 2650.2, 2710.8, 2800.3, 2950.7, 3100.1]
println("Perfil de elevaci√≥n: ", elevaciones)

# Array de cadenas de texto
ciudades = ["Bogot√°", "Medell√≠n", "Cali"]
println("Ciudades a visitar: ", ciudades)

# 2. AGREGAR ELEMENTOS (Mutabilidad directa con push! e insert!)

# a. Agregar al final (push!)
# Agregamos Cartagena al final de la ruta (pasa a ser la tercera parada)
push!(ruta, (10.3910, -75.4794))
push!(elevaciones, 2.0)

println("Ruta con Cartagena al final: ", ruta)

# b. Insertar en una posici√≥n espec√≠fica (insert!)
# Queremos a Manizales justo DESPU√âS de Medell√≠n. 
# Como Medell√≠n es la posici√≥n 2, insertamos en la posici√≥n 3.
# Esto desplaza a Cartagena a la posici√≥n 4.
insert!(ruta, 3, (5.0689, -75.5174))
insert!(elevaciones, 3, 2160.0)

println("\nRuta final con parada intercalada: ", ruta)
println("Elevaciones finales: ", elevaciones)

# NOTA PEDAG√ìGICA:
# El signo '!' en push! e insert! indica que estas funciones modifican 
# el objeto original (mutabilidad). Al ser Base 1, la posici√≥n 3 es 
# exactamente el lugar que sigue a Medell√≠n.

# 3. ACCEDER A ELEMENTOS (√çndice Base 1)
# Acceder a la primera ciudad de la ruta (√çndice 1)
primera_parada = ruta[1]
println("Primera parada: ", primera_parada)

# Acceder a la latitud de la segunda ciudad de la ruta (Medell√≠n)
# √çndice 2 (entra a Medell√≠n) y luego √çndice 1 (extrae la latitud)
# Nota: A diferencia de R, aqu√≠ no hay cajas fuertes [[ ]]. 
# Igual que en Python, simplemente encadenamos corchetes simples: [2][1]
sda_parada_lat = ruta[2][1]
println("Latitud segunda parada: ", sda_parada_lat)

# Alternativa elegante: Desempaquetado de tuplas (Destructuring)
# Julia hereda esta genialidad de lenguajes modernos. Extraemos la tupla 
# entera (ruta[2]) y la desempaquetamos directamente en variables.
# Usamos el guion bajo (_) para ignorar el dato que no necesitamos (longitud).
latitud, _ = ruta[2]

println("Latitud segunda parada (desempaquetado): ", latitud)
# Julia tiene la palabra clave 'end' para acceder al √∫ltimo elemento
ultima_parada = ruta[end]
println("√öltima parada: ", ultima_parada)

# 4. SLICING (Extraer porciones)
# El rango [1:2] incluye ambos l√≠mites
primeras_dos = ruta[1:2]
println("Primeras dos paradas: ", primeras_dos)

# Las posiciones equivalentes (3er, 4to y 5to elemento)
elevaciones_medias = elevaciones[3:5]
println("Elevaciones intermedias: ", elevaciones_medias)

# 5. OPERACIONES √öTILES
num_vertices = length(ruta)
println("N√∫mero de v√©rtices: ", num_vertices)

# En Julia se prefiere 'maximum' para colecciones completas
elev_maxima = maximum(elevaciones)
println("Elevaci√≥n m√°xima: ", elev_maxima, " metros")

# Promedio (sumatoria sobre longitud)
elev_promedio = sum(elevaciones) / length(elevaciones)
println("Elevaci√≥n promedio: ", round(elev_promedio, digits=1), " metros")
```
:::
:::

```{r}
#| label: julia_listas
#| results: asis
#| code-fold: true
# #| eval: false
j_eval('
# 1. CREACI√ìN DE ARREGLOS (Listas)
# Un Array de tuplas de coordenadas
ruta = [
    (4.6097, -74.0817),  # Bogot√°
    (6.2442, -75.5812),  # Medell√≠n
    (3.4516, -76.5320),  # Cali
]
println("Ruta inicial: ", ruta)

# Array de valores num√©ricos de coma flotante
elevaciones = [2600.5, 2650.2, 2710.8, 2800.3, 2950.7, 3100.1]
println("Perfil de elevaci√≥n: ", elevaciones)

# Array de cadenas de texto
ciudades = ["Bogot√°", "Medell√≠n", "Cali"]
println("Ciudades a visitar: ", ciudades)

# 2. AGREGAR ELEMENTOS (Mutabilidad directa con push! e insert!)

# a. Agregar al final (push!)
# Agregamos Cartagena al final de la ruta (pasa a ser la tercera parada)
push!(ruta, (10.3910, -75.4794))
push!(elevaciones, 2.0)

println("Ruta con Cartagena al final: ", ruta)

# b. Insertar en una posici√≥n espec√≠fica (insert!)
# Queremos a Manizales justo DESPU√âS de Medell√≠n. 
# Como Medell√≠n es la posici√≥n 2, insertamos en la posici√≥n 3.
# Esto desplaza a Cartagena a la posici√≥n 4.
insert!(ruta, 3, (5.0689, -75.5174))
insert!(elevaciones, 3, 2160.0)

println("\nRuta final con parada intercalada: ", ruta)
println("Elevaciones finales: ", elevaciones)

# NOTA PEDAG√ìGICA:
# El signo \'!\' en push! e insert! indica que estas funciones modifican 
# el objeto original (mutabilidad). Al ser Base 1, la posici√≥n 3 es 
# exactamente el lugar que sigue a Medell√≠n.

# 3. ACCEDER A ELEMENTOS (√çndice Base 1)
# Acceder a la primera ciudad de la ruta (√çndice 1)
primera_parada = ruta[1]
println("Primera parada: ", primera_parada)

# Acceder a la latitud de la segunda ciudad de la ruta (Medell√≠n)
# √çndice 2 (entra a Medell√≠n) y luego √çndice 1 (extrae la latitud)
# Nota: A diferencia de R, aqu√≠ no hay cajas fuertes [[ ]]. 
# Igual que en Python, simplemente encadenamos corchetes simples: [2][1]
sda_parada_lat = ruta[2][1]
println("Latitud segunda parada: ", sda_parada_lat)

# Alternativa elegante: Desempaquetado de tuplas (Destructuring)
# Julia hereda esta genialidad de lenguajes modernos. Extraemos la tupla 
# entera (ruta[2]) y la desempaquetamos directamente en variables.
# Usamos el guion bajo (_) para ignorar el dato que no necesitamos (longitud).
latitud, _ = ruta[2]

println("Latitud segunda parada (desempaquetado): ", latitud)

# Julia tiene la palabra clave "end" para acceder al √∫ltimo elemento
ultima_parada = ruta[end]
println("√öltima parada: ", ultima_parada)

# 4. SLICING (Extraer porciones)
# El rango [1:2] incluye ambos l√≠mites
primeras_dos = ruta[1:2]
println("Primeras dos paradas: ", primeras_dos)

# Las posiciones equivalentes (3er, 4to y 5to elemento)
elevaciones_medias = elevaciones[3:5]
println("Elevaciones intermedias: ", elevaciones_medias)

# 5. OPERACIONES √öTILES
num_vertices = length(ruta)
println("N√∫mero de v√©rtices: ", num_vertices)

# En Julia se prefiere "maximum" para colecciones completas
elev_maxima = maximum(elevaciones)
println("Elevaci√≥n m√°xima: ", elev_maxima, " metros")

# Promedio (sumatoria sobre longitud)
elev_promedio = sum(elevaciones) / length(elevaciones)
println("Elevaci√≥n promedio: ", round(elev_promedio, digits=1), " metros")
')
```

:::

### Diagrama Conceptual: La Met√°fora de la Caja y el Paquete

Para entender c√≥mo cada lenguaje navega por estas estructuras complejas, vamos a plantearnos un objetivo pr√°ctico: **extraer la latitud de la segunda parada de nuestra ruta (Medell√≠n)**.

En el siguiente diagrama observaremos el flujo completo, desde c√≥mo se declara la lista de coordenadas, hasta los comandos exactos que debemos introducir en la terminal para llegar al n√∫mero `6.2442`. 

La clave al leer el gr√°fico est√° en notar la diferencia de filosof√≠as: observe c√≥mo Python y Julia le entregan el dato listo para usar o desempaquetar, mientras que R le pone una trampa. Si usa corchetes simples (`[ ]`), R le entregar√° una "caja fuerte" cerrada que provocar√° un error matem√°tico si intenta operarla; para obtener el dato real, deber√° usar la llave doble (`[[ ]]`) que abre el paquete.



```{=latex}
\begin{landscape}
```

```{mermaid}
%%| label: fig-metafora-indices-obra-maestra-v2
%%| fig-cap: "El flujo completo: Desde la declaraci√≥n de la estructura hasta el desempaquetado de sus elementos."
%%| fig-width: 8
%%| fig-align: center
%%| out-width: "100%"
graph TD
    %% 1. ESTILOS DEFINITIVOS
    classDef caja fill:#fbeeb8,stroke:#e6b800,stroke-width:3px,stroke-dasharray: 5 5,color:#000;
    classDef abierto fill:#d4edda,stroke:#28a745,stroke-width:3px,color:#000;
    classDef terminal fill:#333,stroke:#666,color:#fff,font-family:monospace,font-size:13px;
    classDef var fill:#e2e3e5,stroke:#343a40,stroke-width:2px,color:#000;
    classDef err fill:#f1f4f9,stroke:#dc3545,stroke-width:2px,color:#dc3545;
    classDef tit fill:#fff,stroke:#333;
    
    %% Bajamos a 11px y mantenemos el monospace para las definiciones
    classDef codigo fill:#e8f4f8,stroke:#0dcaf0,stroke-width:2px,color:#000,font-family:monospace,font-size:11px;

    %% 2. T√çTULOS
    Python["&nbsp;&nbsp;&nbsp;üêç PYTHON [Base 0]&nbsp;&nbsp;&nbsp;"]:::tit
    Rlang["&nbsp;&nbsp;&nbsp;üîµ R [Base 1]&nbsp;&nbsp;&nbsp;"]:::tit
    Julia["&nbsp;&nbsp;&nbsp;üü£ JULIA [Base 1]&nbsp;&nbsp;&nbsp;"]:::tit

    %% 3. DEFINICI√ìN DE LA VARIABLE INICIAL (Padding masivo de 10 espacios)
    Py_Def["&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ruta = [(lat0, lon0), (6.2442, -75.5812), ...]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"]:::codigo
    R_Def["&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ruta <- list(c(lat1, lon1), c(6.2442, -75.5812), ...)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"]:::codigo
    Ju_Def["&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ruta = [(lat1, lon1), (6.2442, -75.5812), ...]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"]:::codigo

    Python --- Py_Def
    Rlang --- R_Def
    Julia --- Ju_Def

    %% --- FLUJO PYTHON ---
    Py_Def --- Py_Cmd["ruta[1]"]
    Py_Cmd --> Py_Out["&nbsp;Terminal: (6.2442, -75.5812)&nbsp;"]:::terminal
    
    Py_Out -->|"[0]"| Py_Lat["Lat: 6.2442"]:::var
    Py_Out -->|"lat, lon = ruta[1]"| Py_Unpack["Desempaquetado"]:::var

    %% --- FLUJO R ---
    R_Def --- R_CmdS["ruta[2]"]
    R_Def --- R_CmdE["ruta[[2]]"]
    
    R_CmdS --> R_OutS["&nbsp;Terminal: [[1]]<br/>&nbsp;[1] 6.2442 -75.5812&nbsp;"]:::terminal
    R_OutS --> R_Box["üì¶ CAJA CERRADA<br/>[Lista con vector]"]:::caja
    
    R_CmdE --> R_OutE["&nbsp;Terminal: [1] 6.2442 -75.5812&nbsp;"]:::terminal
    R_OutE -->|"Abre la caja"| R_Vec["üîì PAQUETE ABIERTO<br/>(Vector)"]:::abierto
    
    R_Box -->|"[[1]]"| R_Vec
    R_Box -.->|"Error Matem√°tico"| R_Fail{"‚ùå No operable"}:::err
    R_Vec -->|"[1]"| R_Lat["Lat: 6.2442"]:::var

    %% --- FLUJO JULIA ---
    Ju_Def --- Ju_Cmd["ruta[2]"]
    Ju_Cmd --> Ju_Out["&nbsp;Terminal: (6.2442, -75.5812)&nbsp;"]:::terminal
    
    Ju_Out -->|"[1]"| Ju_Lat["Lat: 6.2442"]:::var
    Ju_Out -->|"lat, _ = ruta[2]"| Ju_Unpack["Desempaquetado"]:::var
```

```{=latex}
\end{landscape}
```




### Resumen de Operaciones en Listas/Vectores

| Operaci√≥n | Python | R | Julia |
|:---|:---:|:---:|:---:|
| **Creaci√≥n** | `[x, y, z]` | `list(x, y, z)` o `c(x, y, z)` | `[x, y, z]` |
| **Extraer contenido (Listas)** | `[i]` | `[[i]]` | `[i]` |
| **Desempaquetado** | `a, b = lista` | *No nativo (Base)* | `a, b = lista` |
| **Agregar (final)** | `.append(x)` | `c(vector, x)` | `push!(array, x)` |
**Insertar (pos i)** | `.insert(i, val)` | `append(x, val, after=i)` | `insert!(x, i, val)` |
| **√öltimo Elemento** | `[-1]` | `[length(x)]` | `[end]` |
| **Rango (*Slicing*)** | `[2:5]` (Excluye el 5) | `[3:5]` (Incluye el 5) | `[3:5]` (Incluye el 5) |
| **Largo total** | `len(x)` | `length(x)` | `length(x)` |
| **M√°ximo** | `max(x)` | `max(x)` | `maximum(x)` |
| **Promedio** | `sum(x)/len(x)` | `mean(x)` | `sum(x)/length(x)` |

: Equivalencias para el manejo de secuencias ordenadas {#tbl-operaciones_listas tbl-colwidths="[25,25,25,25]"}

---

**Nota t√©cnica sobre Slicing (Rebanado):**
Extraer porciones de datos (*slicing*) es una de las mayores fuentes de error topol√≥gico y estad√≠stico al migrar c√≥digo.
* En **Python**, la sintaxis `[2:5]` extrae los elementos en los √≠ndices `2, 3 y 4` (omitiendo el final). Dado que Python inicia en 0, esto corresponde al 3er, 4to y 5to elemento real de los datos.
* En **R y Julia**, la sintaxis `[3:5]` extrae los elementos en los √≠ndices `3, 4 y 5` (incluyendo ambos extremos). Como inician en 1, esto corresponde directamente al 3er, 4to y 5to dato.

::: {.callout-note icon="false"}
### El dilema en R: ¬øVectores `c()` o Listas `list()`?

Existe un choque de terminolog√≠a fundamental al pasar de lenguajes como Python o Julia hacia R: **lo que Python y Julia llaman "Lista" (`[1, 2, 3]`), R lo llama "Vector At√≥mico" (`c(1, 2, 3)`). Y lo que R llama "Lista" (`list()`), en Python suele comportarse m√°s como una lista anidada o, si tiene nombres, como un Diccionario.**

Para evitar errores al manipular datos espaciales en R, es vital entender esta diferencia pr√°ctica:

1. **Vectores At√≥micos `c()`:** Exigen que **todos los elementos sean del mismo tipo** (todos n√∫meros o todos texto). Son estructuras planas (1D). Se usan para series de datos simples, como un perfil de elevaciones o una columna de nombres de municipios.
   * *Ejemplo:* `c(2600.5, 2650.2, 2710.8)`

2. **Listas `list()`:** Son contenedores flexibles. Permiten mezclar texto con n√∫meros, e incluso **pueden contener otros vectores u otras listas dentro de s√≠ mismas** (anidaci√≥n). Se usan para agrupar objetos complejos, como los pares de coordenadas `(x,y)` independientes que componen una ruta.
   * *Ejemplo:* `list( c(4.6, -74.0), c(6.2, -75.5) )`



**Regla de oro en R:** Usa `c()` para colecciones de datos homog√©neos. Usa `list()` cuando necesites agrupar geometr√≠as complejas, atributos mixtos o emular la estructura de un diccionario clave-valor.
:::

## Conjuntos (*sets*)

Los **Conjuntos** son estructuras de datos que almacenan colecciones de elementos **sin orden y sin duplicados**. Son la traducci√≥n computacional de la teor√≠a matem√°tica de conjuntos. En el an√°lisis espacial, son indispensables para obtener listas de valores √∫nicos (por ejemplo, extraer todos los c√≥digos de municipios de una gran base de datos sin repeticiones) y para realizar operaciones espaciales l√≥gicas como intersecciones, uniones o diferencias de atributos entre dos zonas geogr√°ficas.



[Image of set theory Venn diagram operations]


::: {.panel-tabset}

### Python

::: {.content-visible when-format="html"}
::: {.callout-tip collapse="true" icon="false"}
#### ‚ñ∑ C√ìDIGO PURO (Copiar y Pegar)
```{python}
#| label: python_conjuntos_codigo
#| eval: false

# 1. CREACI√ìN Y LIMPIEZA DE DUPLICADOS
# Crear un conjunto con llaves {}
regiones_visitadas = {"Andina", "Caribe", "Pac√≠fica"}
print("Regiones:", regiones_visitadas)

# Crear un conjunto desde una lista (elimina duplicados autom√°ticamente)
codigos_dptos = ["ANT", "BOG", "VAL", "ANT", "BOG"]
codigos_unicos = set(codigos_dptos)
print("C√≥digos √∫nicos:", codigos_unicos)

# 2. AGREGAR ELEMENTOS
# Agregar una regi√≥n nueva
regiones_visitadas.add("Orinoqu√≠a")
# Intentar agregar un duplicado (Python lo ignorar√° sin dar error)
regiones_visitadas.add("Caribe") 
print("Regiones actualizadas:", regiones_visitadas)

# 3. OPERACIONES DE CONJUNTOS (Venn)
# Especies observadas en dos pol√≠gonos diferentes
area_a = {"Roble", "Pino", "Frailej√≥n", "Aliso"}
area_b = {"Pino", "Frailej√≥n", "Palma de Cera", "Yagrumo"}

# Intersecci√≥n: Especies comunes en ambas √°reas
comunes = area_a.intersection(area_b)
print("Especies en ambas √°reas:", comunes)

# Diferencia: Especies exclusivas del √Årea A
solo_a = area_a - area_b
print("Especies exclusivas de A:", solo_a)

# Uni√≥n: Todas las especies registradas
todas_especies = area_a.union(area_b)
print("Todas las especies:", todas_especies)

# 4. MEMBRES√çA (Comprobar si existe)
if "Pino" in comunes:
    print("El Pino est√° en la zona de intersecci√≥n.")
```
:::
:::


```{python}
#| label: python_conjuntos
# #| eval: false

# 1. CREACI√ìN Y LIMPIEZA DE DUPLICADOS
# Crear un conjunto con llaves {}
regiones_visitadas = {"Andina", "Caribe", "Pac√≠fica"}
print("Regiones:", regiones_visitadas)

# Crear un conjunto desde una lista (elimina duplicados autom√°ticamente)
codigos_dptos = ["ANT", "BOG", "VAL", "ANT", "BOG"]
codigos_unicos = set(codigos_dptos)
print("C√≥digos √∫nicos:", codigos_unicos)

# 2. AGREGAR ELEMENTOS
# Agregar una regi√≥n nueva
regiones_visitadas.add("Orinoqu√≠a")
# Intentar agregar un duplicado (Python lo ignorar√° sin dar error)
regiones_visitadas.add("Caribe") 
print("Regiones actualizadas:", regiones_visitadas)

# 3. OPERACIONES DE CONJUNTOS (Venn)
# Especies observadas en dos pol√≠gonos diferentes
area_a = {"Roble", "Pino", "Frailej√≥n", "Aliso"}
area_b = {"Pino", "Frailej√≥n", "Palma de Cera", "Yagrumo"}

# Intersecci√≥n: Especies comunes en ambas √°reas
comunes = area_a.intersection(area_b)
print("Especies en ambas √°reas:", comunes)

# Diferencia: Especies exclusivas del √Årea A
solo_a = area_a - area_b
print("Especies exclusivas de A:", solo_a)

# Uni√≥n: Todas las especies registradas
todas_especies = area_a.union(area_b)
print("Todas las especies:", todas_especies)

# 4. MEMBRES√çA (Comprobar si existe)
if "Pino" in comunes:
    print("El Pino est√° en la zona de intersecci√≥n.")
```

### R

::: {.content-visible when-format="html"}
::: {.callout-tip collapse="true" icon="false"}
#### ‚ñ∑ C√ìDIGO PURO (Copiar y Pegar)
```{r}
#| label: r_conjuntos_codigo
#| eval: false

# 1. CREACI√ìN Y LIMPIEZA DE DUPLICADOS
# En R, usamos vectores at√≥micos normales y les aplicamos funciones l√≥gicas
regiones_visitadas <- c("Andina", "Caribe", "Pac√≠fica")

# Eliminar duplicados usando unique()
codigos_dptos <- c("ANT", "BOG", "VAL", "ANT", "BOG")
codigos_unicos <- unique(codigos_dptos)
cat("C√≥digos √∫nicos:", codigos_unicos, "\n")

# 2. AGREGAR ELEMENTOS
# Concatenamos y aplicamos unique() para mantener la l√≥gica de conjuntos
regiones_visitadas <- unique(c(regiones_visitadas, "Orinoqu√≠a", "Caribe"))
cat("Regiones actualizadas:", regiones_visitadas, "\n")

# 3. OPERACIONES DE CONJUNTOS (Venn)
area_a <- c("Roble", "Pino", "Frailej√≥n", "Aliso")
area_b <- c("Pino", "Frailej√≥n", "Palma de Cera", "Yagrumo")

# Intersecci√≥n: Especies comunes
comunes <- intersect(area_a, area_b)
cat("Especies en ambas √°reas:", comunes, "\n")

# Diferencia: Especies exclusivas de A
solo_a <- setdiff(area_a, area_b)
cat("Especies exclusivas de A:", solo_a, "\n")

# Uni√≥n: Todas las especies (elimina duplicados autom√°ticamente)
todas_especies <- union(area_a, area_b)
cat("Todas las especies:", todas_especies, "\n")

# 4. MEMBRES√çA (Comprobar si existe con %in%)
if ("Pino" %in% comunes) {
  cat("El Pino est√° en la zona de intersecci√≥n.\n")
}
```
:::
:::

```{r}
#| label: r_conjuntos
# #| eval: false

# 1. CREACI√ìN Y LIMPIEZA DE DUPLICADOS
# En R, usamos vectores at√≥micos normales y les aplicamos funciones l√≥gicas
regiones_visitadas <- c("Andina", "Caribe", "Pac√≠fica")

# Eliminar duplicados usando unique()
codigos_dptos <- c("ANT", "BOG", "VAL", "ANT", "BOG")
codigos_unicos <- unique(codigos_dptos)
cat("C√≥digos √∫nicos:", codigos_unicos, "\n")

# 2. AGREGAR ELEMENTOS
# Concatenamos y aplicamos unique() para mantener la l√≥gica de conjuntos
regiones_visitadas <- unique(c(regiones_visitadas, "Orinoqu√≠a", "Caribe"))
cat("Regiones actualizadas:", regiones_visitadas, "\n")

# 3. OPERACIONES DE CONJUNTOS (Venn)
area_a <- c("Roble", "Pino", "Frailej√≥n", "Aliso")
area_b <- c("Pino", "Frailej√≥n", "Palma de Cera", "Yagrumo")

# Intersecci√≥n: Especies comunes
comunes <- intersect(area_a, area_b)
cat("Especies en ambas √°reas:", comunes, "\n")

# Diferencia: Especies exclusivas de A
solo_a <- setdiff(area_a, area_b)
cat("Especies exclusivas de A:", solo_a, "\n")

# Uni√≥n: Todas las especies (elimina duplicados autom√°ticamente)
todas_especies <- union(area_a, area_b)
cat("Todas las especies:", todas_especies, "\n")

# 4. MEMBRES√çA (Comprobar si existe con %in%)
if ("Pino" %in% comunes) {
  cat("El Pino est√° en la zona de intersecci√≥n.\n")
}
```

### Julia

::: {.content-visible when-format="html"}
::: {.callout-tip collapse="true" icon="false"}
#### ‚ñ∑ C√ìDIGO PURO (Copiar y Pegar)
```{julia}
#| label: julia_conjuntos_codigo
#| eval: false

# 1. CREACI√ìN Y LIMPIEZA DE DUPLICADOS
# En Julia existe el tipo nativo Set
regiones_visitadas = Set(["Andina", "Caribe", "Pac√≠fica"])

# Crear un Set a partir de un Array elimina duplicados
codigos_dptos = ["ANT", "BOG", "VAL", "ANT", "BOG"]
codigos_unicos = Set(codigos_dptos)
println("C√≥digos √∫nicos: ", codigos_unicos)

# 2. AGREGAR ELEMENTOS
# Usamos push! para agregar elementos in-place
push!(regiones_visitadas, "Orinoqu√≠a")
push!(regiones_visitadas, "Caribe") # Se ignora el duplicado
println("Regiones actualizadas: ", regiones_visitadas)

# 3. OPERACIONES DE CONJUNTOS (Venn)
area_a = Set(["Roble", "Pino", "Frailej√≥n", "Aliso"])
area_b = Set(["Pino", "Frailej√≥n", "Palma de Cera", "Yagrumo"])

# Intersecci√≥n
comunes = intersect(area_a, area_b)
println("Especies en ambas √°reas: ", comunes)

# Diferencia
solo_a = setdiff(area_a, area_b)
println("Especies exclusivas de A: ", solo_a)

# Uni√≥n
todas_especies = union(area_a, area_b)
println("Todas las especies: ", todas_especies)

# 4. MEMBRES√çA (Operador in)
if in("Pino", comunes) # Tambi√©n se puede escribir: "Pino" in comunes
    println("El Pino est√° en la zona de intersecci√≥n.")
end
```
:::
:::

```{r}
#| label: julia_conjuntos
#| results: asis
#| code-fold: true
# #| eval: false
j_eval('
# 1. CREACI√ìN Y LIMPIEZA DE DUPLICADOS
# En Julia existe el tipo nativo Set
regiones_visitadas = Set(["Andina", "Caribe", "Pac√≠fica"])

# Crear un Set a partir de un Array elimina duplicados
codigos_dptos = ["ANT", "BOG", "VAL", "ANT", "BOG"]
codigos_unicos = Set(codigos_dptos)
println("C√≥digos √∫nicos: ", codigos_unicos)

# 2. AGREGAR ELEMENTOS
# Usamos push! para agregar elementos in-place
push!(regiones_visitadas, "Orinoqu√≠a")
push!(regiones_visitadas, "Caribe") # Se ignora el duplicado
println("Regiones actualizadas: ", regiones_visitadas)

# 3. OPERACIONES DE CONJUNTOS (Venn)
area_a = Set(["Roble", "Pino", "Frailej√≥n", "Aliso"])
area_b = Set(["Pino", "Frailej√≥n", "Palma de Cera", "Yagrumo"])

# Intersecci√≥n
comunes = intersect(area_a, area_b)
println("Especies en ambas √°reas: ", comunes)

# Diferencia
solo_a = setdiff(area_a, area_b)
println("Especies exclusivas de A: ", solo_a)

# Uni√≥n
todas_especies = union(area_a, area_b)
println("Todas las especies: ", todas_especies)

# 4. MEMBRES√çA (Operador in)
if in("Pino", comunes) # Tambi√©n se puede escribir: "Pino" in comunes
    println("El Pino est√° en la zona de intersecci√≥n.")
end
')
```

:::

### Resumen de Operaciones con Conjuntos

| Operaci√≥n | Python | R | Julia |
|:---|:---:|:---:|:---:|
| **Creaci√≥n B√°sica** | `{"A", "B"}` o `set()` | `c("A", "B")` (Vectores) | `Set(["A", "B"])` |
| **Eliminar Duplicados** | `set(lista)` | `unique(vector)` | `Set(array)` o `unique(array)` |
| **Agregar Elemento** | `set.add(x)` | `unique(c(v, x))` | `push!(set, x)` |
| **Intersecci√≥n (Com√∫n)** | `a.intersection(b)` o `a & b` | `intersect(a, b)` | `intersect(a, b)` |
| **Uni√≥n (Todos)** | `a.union(b)` o `a | b` | `union(a, b)` | `union(a, b)` |
| **Diferencia (Solo en A)** | `a - b` | `setdiff(a, b)` | `setdiff(a, b)` |
| **Pertenece a** | `x in set` | `x %in% v` | `in(x, set)` o `x in set` |

: Equivalencias para operaciones l√≥gicas de conjuntos {#tbl-operaciones_conjuntos tbl-colwidths="[20,25,30,25]"}

---

**Nota t√©cnicas:** 

* Tenga cuidado al crear conjuntos vac√≠os en **Python**. Si escribe `mis_datos = {}`, Python crear√° un *Diccionario* vac√≠o, no un conjunto. Para crear un conjunto vac√≠o obligatoriamente debe usar `mis_datos = set()`. Por otro lado, si inicializa con datos como `{"Andina", "Caribe"}`, Python s√≠ entender√° autom√°ticamente que es un conjunto.
* A diferencia de Python y Julia, que tienen una estructura de datos `Set` espec√≠fica (las cuales ignoran intr√≠nsecamente los duplicados), **R no posee un tipo de dato "Conjunto" nativo**. En R, trabajamos con vectores regulares y utilizamos funciones l√≥gicas (`union`, `intersect`, `setdiff`, `unique`) que simulan el comportamiento de los conjuntos matem√°ticos al evaluarlos.

## Diccionarios

Los **Diccionarios** son estructuras de datos que almacenan informaci√≥n mediante pares de **Clave-Valor** (*Key-Value*). A diferencia de las listas (donde accedes por la posici√≥n num√©rica), en un diccionario accedes a los datos a trav√©s de "etiquetas" √∫nicas (las claves). 

En el √°mbito de los Sistemas de Informaci√≥n Geogr√°fica, los diccionarios son, literalmente, la base t√©cnica de c√≥mo se estructuran los atributos de un vector. De hecho, el popular formato **GeoJSON** no es m√°s que un gran diccionario anidado.



::: {.panel-tabset}

### Python

::: {.content-visible when-format="html"}
::: {.callout-tip collapse="true" icon="false"}
#### ‚ñ∑ C√ìDIGO PURO (Copiar y Pegar)
```{python}
#| label: python_diccionarios_codigo
#| eval: false

# 1. CREACI√ìN DE DICCIONARIOS
# Diccionario almacenando atributos de una ciudad
info_bogota = {
    "nombre": "Bogot√°",
    "poblacion": 7181469,
    "coordenadas": (4.6097, -74.0817),
    "pais": "Colombia",
    "fundacion": 1538,
}
print("Informaci√≥n de Bogot√°:", info_bogota)

# 2. ACCESO A VALORES
# Acceder a informaci√≥n espec√≠fica usando la clave entre corchetes
nombre_ciudad = info_bogota["nombre"]
poblacion_ciudad = info_bogota["poblacion"]
print(f"Ciudad: {nombre_ciudad} | Poblaci√≥n: {poblacion_ciudad:,}")

# Acceso seguro con get() para evitar errores si la clave no existe
area = info_bogota.get("area_km2", "No especificada")
print(f"√Årea: {area}")

# 3. AGREGAR Y ACTUALIZAR VALORES
# Agregar nueva informaci√≥n al diccionario
info_bogota["area_km2"] = 1775
info_bogota["poblacion"] = 7900000  # Actualizar un valor existente
print("Info actualizada:", info_bogota)

# 4. TRABAJANDO CON COLECCIONES ANIDADAS (Estilo GeoJSON)
capitales_deptos = {
    "Antioquia": {
        "capital": "Medell√≠n",
        "coordenadas": (6.2442, -75.5812),
        "poblacion": 2533424
    },
    "Valle del Cauca": {
        "capital": "Cali",
        "coordenadas": (3.4516, -76.5320),
        "poblacion": 2227642
    }
}

# Acceder a informaci√≥n anidada
info_valle = capitales_deptos["Valle del Cauca"]
print(f"Capital del Valle: {info_valle['capital']}")

# 5. EXPLORACI√ìN DE DICCIONARIOS
print("Claves disponibles:", list(info_bogota.keys()))

# Comprobar si una clave existe
if "coordenadas" in info_bogota:
    print("La informaci√≥n de coordenadas est√° disponible.")

# 6. EJEMPLO PR√ÅCTICO: Metadatos de un Waypoint GPS
punto_gps = {
    "id": "PC001",
    "nombre": "Inicio Sendero Cocora",
    "latitud": 4.6395,
    "longitud": -75.4851,
    "elevacion": 2400,
    "tipo_cobertura": "Bosque de Palma",
    "facilidades": ["parqueadero", "gu√≠a", "restaurante"]
}

print(f"Punto: {punto_gps['nombre']} a {punto_gps['elevacion']} msnm")
print(f"Servicios: {', '.join(punto_gps['facilidades'])}")
```
:::
:::


```{python}
#| label: python_diccionarios
# #| eval: false

# 1. CREACI√ìN DE DICCIONARIOS
# Diccionario almacenando atributos de una ciudad
info_bogota = {
    "nombre": "Bogot√°",
    "poblacion": 7181469,
    "coordenadas": (4.6097, -74.0817),
    "pais": "Colombia",
    "fundacion": 1538,
}
print("Informaci√≥n de Bogot√°:", info_bogota)

# 2. ACCESO A VALORES
# Acceder a informaci√≥n espec√≠fica usando la clave entre corchetes
nombre_ciudad = info_bogota["nombre"]
poblacion_ciudad = info_bogota["poblacion"]
print(f"Ciudad: {nombre_ciudad} | Poblaci√≥n: {poblacion_ciudad:,}")

# Acceso seguro con get() para evitar errores si la clave no existe
area = info_bogota.get("area_km2", "No especificada")
print(f"√Årea: {area}")

# 3. AGREGAR Y ACTUALIZAR VALORES
# Agregar nueva informaci√≥n al diccionario
info_bogota["area_km2"] = 1775
info_bogota["poblacion"] = 7900000  # Actualizar un valor existente
print("Info actualizada:", info_bogota)

# 4. TRABAJANDO CON COLECCIONES ANIDADAS (Estilo GeoJSON)
capitales_deptos = {
    "Antioquia": {
        "capital": "Medell√≠n",
        "coordenadas": (6.2442, -75.5812),
        "poblacion": 2533424
    },
    "Valle del Cauca": {
        "capital": "Cali",
        "coordenadas": (3.4516, -76.5320),
        "poblacion": 2227642
    }
}

# Acceder a informaci√≥n anidada
info_valle = capitales_deptos["Valle del Cauca"]
print(f"Capital del Valle: {info_valle['capital']}")

# 5. EXPLORACI√ìN DE DICCIONARIOS
print("Claves disponibles:", list(info_bogota.keys()))

# Comprobar si una clave existe
if "coordenadas" in info_bogota:
    print("La informaci√≥n de coordenadas est√° disponible.")

# 6. EJEMPLO PR√ÅCTICO: Metadatos de un Waypoint GPS
punto_gps = {
    "id": "PC001",
    "nombre": "Inicio Sendero Cocora",
    "latitud": 4.6395,
    "longitud": -75.4851,
    "elevacion": 2400,
    "tipo_cobertura": "Bosque de Palma",
    "facilidades": ["parqueadero", "gu√≠a", "restaurante"]
}

print(f"Punto: {punto_gps['nombre']} a {punto_gps['elevacion']} msnm")
print(f"Servicios: {', '.join(punto_gps['facilidades'])}")
```

### R

::: {.content-visible when-format="html"}
::: {.callout-tip collapse="true" icon="false"}
#### ‚ñ∑ C√ìDIGO PURO (Copiar y Pegar)
```{r}
#| label: r_diccionarios_codigo
#| eval: false

# 1. CREACI√ìN DE DICCIONARIOS
# En R, usamos listas nombradas (named lists) para emular diccionarios
info_bogota <- list(
    nombre = "Bogot√°",
    poblacion = 7181469,
    coordenadas = c(4.6097, -74.0817),
    pais = "Colombia",
    fundacion = 1538
)
cat("Informaci√≥n de Bogot√°:\n"); print(info_bogota)

# 2. ACCESO A VALORES
# Accedemos mediante el s√≠mbolo del d√≥lar '$' o doble corchete '[[]]'
nombre_ciudad <- info_bogota$nombre
poblacion_ciudad <- info_bogota$poblacion
cat(sprintf("Ciudad: %s | Poblaci√≥n: %s\n", nombre_ciudad, format(poblacion_ciudad, big.mark=",")))

# En R, acceder a una clave inexistente devuelve NULL de forma nativa
area <- if(is.null(info_bogota$area_km2)) "No especificada" else info_bogota$area_km2
cat(sprintf("√Årea: %s\n", area))

# 3. AGREGAR Y ACTUALIZAR VALORES
info_bogota$area_km2 <- 1775
info_bogota$poblacion <- 7900000
cat("Info actualizada:\n"); print(info_bogota)

# 4. TRABAJANDO CON COLECCIONES ANIDADAS
capitales_deptos <- list(
    Antioquia = list(
        capital = "Medell√≠n",
        coordenadas = c(6.2442, -75.5812),
        poblacion = 2533424
    ),
    Valle_del_Cauca = list(
        capital = "Cali",
        coordenadas = c(3.4516, -76.5320),
        poblacion = 2227642
    )
)

info_valle <- capitales_deptos$Valle_del_Cauca
cat(sprintf("Capital del Valle: %s\n", info_valle$capital))

# 5. EXPLORACI√ìN DE DICCIONARIOS
cat("Claves disponibles:", names(info_bogota), "\n")

if ("coordenadas" %in% names(info_bogota)) {
    cat("La informaci√≥n de coordenadas est√° disponible.\n")
}

# 6. EJEMPLO PR√ÅCTICO: Metadatos de un Waypoint GPS
punto_gps <- list(
    id = "PC001",
    nombre = "Inicio Sendero Cocora",
    latitud = 4.6395,
    longitud = -75.4851,
    elevacion = 2400,
    tipo_cobertura = "Bosque de Palma",
    facilidades = c("parqueadero", "gu√≠a", "restaurante")
)

cat(sprintf("Punto: %s a %s msnm\n", punto_gps$nombre, punto_gps$elevacion))
cat(sprintf("Servicios: %s\n", paste(punto_gps$facilidades, collapse=", ")))
```
:::
:::

```{r}
#| label: r_diccionarios
# #| eval: false

# 1. CREACI√ìN DE DICCIONARIOS
# En R, usamos listas nombradas (named lists) para emular diccionarios
info_bogota <- list(
    nombre = "Bogot√°",
    poblacion = 7181469,
    coordenadas = c(4.6097, -74.0817),
    pais = "Colombia",
    fundacion = 1538
)
cat("Informaci√≥n de Bogot√°:\n"); print(info_bogota)

# 2. ACCESO A VALORES
# Accedemos mediante el s√≠mbolo del d√≥lar '$' o doble corchete '[[]]'
nombre_ciudad <- info_bogota$nombre
poblacion_ciudad <- info_bogota$poblacion
cat(sprintf("Ciudad: %s | Poblaci√≥n: %s\n", nombre_ciudad, format(poblacion_ciudad, big.mark=",")))

# En R, acceder a una clave inexistente devuelve NULL de forma nativa
area <- if(is.null(info_bogota$area_km2)) "No especificada" else info_bogota$area_km2
cat(sprintf("√Årea: %s\n", area))

# 3. AGREGAR Y ACTUALIZAR VALORES
info_bogota$area_km2 <- 1775
info_bogota$poblacion <- 7900000
cat("Info actualizada:\n"); print(info_bogota)

# 4. TRABAJANDO CON COLECCIONES ANIDADAS
capitales_deptos <- list(
    Antioquia = list(
        capital = "Medell√≠n",
        coordenadas = c(6.2442, -75.5812),
        poblacion = 2533424
    ),
    Valle_del_Cauca = list(
        capital = "Cali",
        coordenadas = c(3.4516, -76.5320),
        poblacion = 2227642
    )
)

info_valle <- capitales_deptos$Valle_del_Cauca
cat(sprintf("Capital del Valle: %s\n", info_valle$capital))

# 5. EXPLORACI√ìN DE DICCIONARIOS
cat("Claves disponibles:", names(info_bogota), "\n")

if ("coordenadas" %in% names(info_bogota)) {
    cat("La informaci√≥n de coordenadas est√° disponible.\n")
}

# 6. EJEMPLO PR√ÅCTICO: Metadatos de un Waypoint GPS
punto_gps <- list(
    id = "PC001",
    nombre = "Inicio Sendero Cocora",
    latitud = 4.6395,
    longitud = -75.4851,
    elevacion = 2400,
    tipo_cobertura = "Bosque de Palma",
    facilidades = c("parqueadero", "gu√≠a", "restaurante")
)

cat(sprintf("Punto: %s a %s msnm\n", punto_gps$nombre, punto_gps$elevacion))
cat(sprintf("Servicios: %s\n", paste(punto_gps$facilidades, collapse=", ")))
```

### Julia

::: {.content-visible when-format="html"}
::: {.callout-tip collapse="true" icon="false"}
#### ‚ñ∑ C√ìDIGO PURO (Copiar y Pegar)
```{julia}
#| label: julia_diccionarios_codigo
#| eval: false

# 1. CREACI√ìN DE DICCIONARIOS
# Julia usa Dict() con el operador =>
info_bogota = Dict(
    "nombre" => "Bogot√°",
    "poblacion" => 7181469,
    "coordenadas" => (4.6097, -74.0817),
    "pais" => "Colombia",
    "fundacion" => 1538
)
println("Informaci√≥n de Bogot√°: ", info_bogota)

# 2. ACCESO A VALORES
nombre_ciudad = info_bogota["nombre"]
poblacion_ciudad = info_bogota["poblacion"]
println("Ciudad: $nombre_ciudad | Poblaci√≥n: $poblacion_ciudad")

# Acceso seguro con get()
area = get(info_bogota, "area_km2", "No especificada")
println("√Årea: $area")

# 3. AGREGAR Y ACTUALIZAR VALORES
info_bogota["area_km2"] = 1775
info_bogota["poblacion"] = 7900000
println("Info actualizada: ", info_bogota)

# 4. TRABAJANDO CON COLECCIONES ANIDADAS
capitales_deptos = Dict(
    "Antioquia" => Dict(
        "capital" => "Medell√≠n",
        "coordenadas" => (6.2442, -75.5812),
        "poblacion" => 2533424
    ),
    "Valle del Cauca" => Dict(
        "capital" => "Cali",
        "coordenadas" => (3.4516, -76.5320),
        "poblacion" => 2227642
    )
)

info_valle = capitales_deptos["Valle del Cauca"]
println("Capital del Valle: ", info_valle["capital"])

# 5. EXPLORACI√ìN DE DICCIONARIOS
println("Claves disponibles: ", collect(keys(info_bogota)))

if haskey(info_bogota, "coordenadas")
    println("La informaci√≥n de coordenadas est√° disponible.")
end

# 6. EJEMPLO PR√ÅCTICO: Metadatos de un Waypoint GPS
punto_gps = Dict(
    "id" => "PC001",
    "nombre" => "Inicio Sendero Cocora",
    "latitud" => 4.6395,
    "longitud" => -75.4851,
    "elevacion" => 2400,
    "tipo_cobertura" => "Bosque de Palma",
    "facilidades" => ["parqueadero", "gu√≠a", "restaurante"]
)

println("Punto: ", punto_gps["nombre"], " a ", punto_gps["elevacion"], " msnm")
println("Servicios: ", join(punto_gps["facilidades"], ", "))
```
:::
:::

```{r}
#| label: julia_diccionarios
#| results: asis
#| code-fold: true
# #| eval: false
j_eval('
# 1. CREACI√ìN DE DICCIONARIOS
# Julia usa Dict() con el operador =>
info_bogota = Dict(
    "nombre" => "Bogot√°",
    "poblacion" => 7181469,
    "coordenadas" => (4.6097, -74.0817),
    "pais" => "Colombia",
    "fundacion" => 1538
)
println("Informaci√≥n de Bogot√°: ", info_bogota)

# 2. ACCESO A VALORES
nombre_ciudad = info_bogota["nombre"]
poblacion_ciudad = info_bogota["poblacion"]
println("Ciudad: $nombre_ciudad | Poblaci√≥n: $poblacion_ciudad")

# Acceso seguro con get()
area = get(info_bogota, "area_km2", "No especificada")
println("√Årea: $area")

# 3. AGREGAR Y ACTUALIZAR VALORES
info_bogota["area_km2"] = 1775
info_bogota["poblacion"] = 7900000
println("Info actualizada: ", info_bogota)

# 4. TRABAJANDO CON COLECCIONES ANIDADAS
capitales_deptos = Dict(
    "Antioquia" => Dict(
        "capital" => "Medell√≠n",
        "coordenadas" => (6.2442, -75.5812),
        "poblacion" => 2533424
    ),
    "Valle del Cauca" => Dict(
        "capital" => "Cali",
        "coordenadas" => (3.4516, -76.5320),
        "poblacion" => 2227642
    )
)

info_valle = capitales_deptos["Valle del Cauca"]
println("Capital del Valle: ", info_valle["capital"])

# 5. EXPLORACI√ìN DE DICCIONARIOS
println("Claves disponibles: ", collect(keys(info_bogota)))

if haskey(info_bogota, "coordenadas")
    println("La informaci√≥n de coordenadas est√° disponible.")
end

# 6. EJEMPLO PR√ÅCTICO: Metadatos de un Waypoint GPS
punto_gps = Dict(
    "id" => "PC001",
    "nombre" => "Inicio Sendero Cocora",
    "latitud" => 4.6395,
    "longitud" => -75.4851,
    "elevacion" => 2400,
    "tipo_cobertura" => "Bosque de Palma",
    "facilidades" => ["parqueadero", "gu√≠a", "restaurante"]
)

println("Punto: ", punto_gps["nombre"], " a ", punto_gps["elevacion"], " msnm")
println("Servicios: ", join(punto_gps["facilidades"], ", "))
')
```

:::

### Resumen de Diccionarios y Listas Nombradas

| Operaci√≥n | Python | R | Julia |
|:---|:---:|:---:|:---:|
| **Creaci√≥n** | `{"k": v}` | `list(k = v)` | `Dict("k" => v)` |
| **Acceso a valor** | `dict["k"]` | `lista$k` o `lista[["k"]]` | `dict["k"]` |
| **Acceso seguro (Fallback)** | `dict.get("k", "Null")` | `if(is.null(lista$k))` | `get(dict, "k", "Null")` |
| **Actualizar/A√±adir** | `dict["k"] = nuevo` | `lista$k <- nuevo` | `dict["k"] = nuevo` |
| **Verificar si existe** | `"k" in dict` | `"k" %in% names(lista)` | `haskey(dict, "k")` |
| **Obtener todas las claves** | `dict.keys()` | `names(lista)` | `keys(dict)` |

: Manejo de estructuras Clave-Valor {#tbl-operaciones_diccionarios tbl-colwidths="[20,25,30,25]"}

---

**Nota t√©cnica importante sobre errores de acceso:** Uno de los comportamientos que m√°s confunde a los analistas de datos ocurre cuando intentan acceder a una clave o atributo que **no existe** en la estructura.

* En **Python y Julia**, pedir una clave inexistente (como `info_bogota["clima"]`) har√° que el programa **colapse inmediatamente** (`KeyError`). Por eso, es mejor pr√°ctica usar la funci√≥n segura `.get()` cuando no estamos seguros de si el atributo existe.
* En **R**, la aproximaci√≥n es mucho m√°s laxa. Si pides `info_bogota$clima`, R no arrojar√° ning√∫n error, simplemente devolver√° `NULL` (vac√≠o). Esto puede ser peligroso porque el programa sigue ejecut√°ndose silenciosamente, pero los c√°lculos posteriores podr√≠an fallar o contaminarse con datos nulos.

## Gu√≠a de selecci√≥n de estructuras de datos

Saber elegir la estructura de datos correcta es la diferencia entre un script que procesa millones de coordenadas en segundos y uno que colapsa tu computadora. A continuaci√≥n, te presentamos una gu√≠a pr√°ctica para tomar esta decisi√≥n en tus proyectos de an√°lisis espacial.

### √Årbol de decisi√≥n r√°pido

Hazte las siguientes preguntas sobre los datos que necesitas almacenar:

1. **¬øLos datos tienen un orden secuencial que importa?**
   * *Ejemplo:* Los v√©rtices de un pol√≠gono o los puntos de una ruta GPS. El orden define la geometr√≠a.
   * **S√ç:** Pasa a la pregunta 2.
   * **NO:** Pasa a la pregunta 3.

2. **¬øNecesitar√°s agregar, borrar o intercalar datos despu√©s de crearlos?**
   * **S√ç (Mutables):** Usa una **Lista** (o Vector `c()` en R). *Ideal para acumular resultados al final de un proceso (`append`) o intercalar nuevas paradas en medio de una ruta (`insert`).*
   * **NO (Inmutables):** Usa una **Tupla** (en Python/Julia). *Ideal para fijar pares de coordenadas exactas (Lat, Lon) que nadie deba alterar por error.*

3. **¬øC√≥mo vas a buscar la informaci√≥n?**
   * **Por una etiqueta o nombre (Clave-Valor):** Usa un **Diccionario** (o `list()` nombrada en R). *Ideal para almacenar los atributos de un municipio (Nombre, √Årea, Poblaci√≥n) o crear metadatos tipo GeoJSON.*
   * **Solo me importan los valores √∫nicos y sin repeticiones:** Usa un **Conjunto** (`Set` o funciones l√≥gicas en R). *Ideal para limpiar bases de datos (ej. obtener los c√≥digos √∫nicos de departamentos desde una tabla nacional de 10,000 registros).*

---

### Casos de uso comunes en geom√°tica

| Escenario | Estructura Recomendada | ¬øPor qu√©? |
|:---|:---:|:---|
| Coordenada est√°tica `(X, Y)` | **Tupla** | Protege el dato. Si un algoritmo intenta mover la X sin mover la Y, el programa arroja error y salva la topolog√≠a. |
| Perfil de elevaci√≥n de una ruta | **Lista / Vector** | Mantiene el orden estricto de los datos y permite mutabilidad posicional. Permite usar funciones matem√°ticas r√°pidas (`max`, `mean`). |
| Tabla de atributos de un lote | **Diccionario** | Permite acceder a los datos intuitivamente por nombre (ej. `lote["propietario"]`) en lugar de recordar en qu√© columna num√©rica estaban. |
| Intersectar √°reas de influencia | **Conjunto (Set)** | Permite operaciones de Teor√≠a de Conjuntos nativas y ultrarr√°pidas (`union`, `intersect`) para saber, por ejemplo, qu√© fincas est√°n en zona de riesgo. |

: Escenarios pr√°cticos para la selecci√≥n de estructuras de datos {#tbl-seleccion_estructuras tbl-colwidths="[25,20,55]"}

::: {.callout-warning icon="false"}
### ‚ö†Ô∏è La Trampa de R (Recordatorio)
Si en tu an√°lisis decidiste usar una **Lista** en R (`list()`) para agrupar geometr√≠as complejas, nunca olvides la regla de oro de la extracci√≥n: usar un corchete simple `[i]` te devuelve una caja cerrada con la que no puedes hacer matem√°ticas. Para extraer el dato real y operar con √©l, **siempre debes abrir la caja con el doble corchete `[[i]]`**.
:::

::: {.callout-tip}
### Consejo de Rendimiento
Si est√°s procesando *Big Data* espacial (ej. nubes de puntos LiDAR con millones de registros), evita usar **Listas** si vas a realizar b√∫squedas frecuentes ("¬øExiste este punto en la lista?"). Buscar en una lista obliga al computador a revisar elemento por elemento. Por el contrario, buscar en un **Conjunto** o en las claves de un **Diccionario** es casi instant√°neo debido a c√≥mo se estructuran internamente en la memoria (Tablas Hash).
:::

## Resumen de aprendizajes (cheat sheet)

En este cap√≠tulo hemos explorado c√≥mo organizar, almacenar y manipular grupos de datos usando las cuatro estructuras fundamentales de la programaci√≥n. A continuaci√≥n, se presenta tu **Hoja de Referencia (Cheat Sheet)** para traducir estos conceptos entre Python, R y Julia.

### 1. Creaci√≥n y propiedades fundamentales

| Estructura | Python | R | Julia | Mutabilidad |
|:---|:---|:---|:---|:---:|
| **Tupla** (Pares fijos) | `t = (1, 2)` | *Usa vectores* `c(1, 2)` | `t = (1, 2)` | **Inmutable** (Py/Jl) |
| **Lista / Vector** (Secuencias) | `l = [1, 2, 3]` | `v <- c(1, 2, 3)` | `a = [1, 2, 3]` | **Mutable** |
| **Conjunto** (Valores √∫nicos) | `s = {"A", "B"}` | *Usa vectores* `c("A")` | `s = Set(["A", "B"])`| **Mutable** |
| **Diccionario** (Clave-Valor) | `d = {"x": 1}` | `d <- list(x = 1)` | `d = Dict("x" => 1)` | **Mutable** |

: Definici√≥n de estructuras de datos y mutabilidad {#tbl-cheat_creacion tbl-colwidths="[20,20,25,20,15]"}

### 2. Acceso, √≠ndices y extracci√≥n (*Slicing*)

| Operaci√≥n | Python (Base 0) | R (Base 1) | Julia (Base 1) |
|:---|:---|:---|:---|
| **Primer Elemento** | `lista[0]` | `vector[1]` o `lista[[1]]` | `array[1]` |
| **Desempaquetado** | `a, b = tupla` | *Paso a paso:* `a <- v[1]` | `a, b = tupla` |
| **√öltimo Elemento** | `lista[-1]` | `vector[length(vector)]` | `array[end]` |
| **Rango (*Slicing*)** | `lista[2:5]` *(Excluye el 5)* | `vector[3:5]` *(Incluye el 5)* | `array[3:5]` *(Incluye el 5)* |
| **Acceso a Diccionario** | `dict["clave"]` | `lista$clave` | `dict["clave"]` |
| **Acceso Seguro (Fallback)**| `dict.get("clave", 0)` | `if(is.null(l$c)) 0 else l$c`| `get(dict, "clave", 0)` |

: Reglas de indexaci√≥n y acceso a elementos {#tbl-cheat_acceso tbl-colwidths="[25,25,25,25]"}

### 3. Operaciones principales y modificaciones

| Objetivo / Acci√≥n | Python | R | Julia |
|:---|:---|:---|:---|
| **Tama√±o / Longitud** | `len(datos)` | `length(datos)` | `length(datos)` |
| **Agregar al final** | `lista.append(x)` | `v <- c(v, x)` | `push!(array, x)` |
| **Insertar en posici√≥n *i***| `lista.insert(i, x)` | `append(v, list(x), after=i)`| `insert!(array, i, x)` |
| **Eliminar Duplicados** | `set(lista)` | `unique(vector)` | `unique(array)` o `Set(array)`|
| **Valor M√°ximo** | `max(lista)` | `max(vector)` | `maximum(array)` |
| **Intersecci√≥n (Comunes)** | `set1 & set2` | `intersect(v1, v2)` | `intersect(s1, s2)` |
| **Comprobar si existe** | `x in lista` | `x %in% vector` | `x in array` |

: Funciones nativas para manipulaci√≥n de colecciones {#tbl-cheat_operaciones tbl-colwidths="[25,25,25,25]"}

---

::: {.callout-important}
### Conclusiones Cr√≠ticas del M√≥dulo

1. **La trampa del √çndice de Origen:** Nunca olvides que Python empieza a contar desde `0`, mientras que R y Julia empiezan desde `1`. Migrar un c√≥digo de an√°lisis de series de tiempo de R a Python sin ajustar los √≠ndices resultar√° en datos desplazados o errores de ejecuci√≥n (*IndexError*).
2. **La ilusi√≥n de las Listas en R:** En Python y Julia, los corchetes `[]` crean listas o arreglos din√°micos. En R, una verdadera colecci√≥n homog√©nea se crea con la funci√≥n concatenar `c()`. El comando `list()` en R equivale en comportamiento a un Diccionario o a una estructura anidada.
3. **Tuplas para Topolog√≠a:** Acost√∫mbrate a guardar las coordenadas geogr√°ficas siempre como Tuplas en Python y Julia. Su inmutabilidad evitar√° que un bucle mal programado altere silenciosamente la posici√≥n espacial de tus datos originales.
4. **El laberinto de los corchetes en R:** Cuando trabajes con listas complejas (`list()`) en R, recuerda la met√°fora de la caja fuerte. Un corchete simple `[i]` te devuelve una sub-lista (la caja cerrada), mientras que el doble corchete `[[i]]` te entrega el vector operable (el paquete abierto listo para usarse). ¬°Confundirlos es una causa muy com√∫n de errores matem√°ticos!
:::

## Ejercicios

Para poner en pr√°ctica los conceptos aprendidos sobre estructuras de datos, deber√°s resolver los siguientes dos ejercicios. Puedes elegir resolverlos en **Python, R o Julia** (o implementar la soluci√≥n en varios lenguajes si deseas retarte).

### Ejercicio 1: Rutas de monitoreo (tuplas y listas)



**Contexto:** Trabajas en un proyecto de conservaci√≥n en la Sierra Nevada de Santa Marta. Los guardabosques realizan recorridos diarios y te env√≠an las coordenadas de los puntos de avistamiento de fauna. Necesitas estructurar esta ruta temporal de forma segura, garantizando que las coordenadas individuales no se alteren, pero permitiendo que la ruta crezca a medida que reportan nuevos puntos.

**Instrucciones de c√≥digo:**

1. Define tres variables (`punto_1`, `punto_2`, `punto_3`) que almacenen las coordenadas (Latitud, Longitud) como **Tuplas** est√°ticas (o su equivalente m√°s seguro en tu lenguaje).
   * Punto 1: `11.1198, -74.0321`
   * Punto 2: `11.1250, -74.0280`
   * Punto 3: `11.1302, -74.0215`
2. Crea una colecci√≥n secuencial y mutable (**Lista** en Python/Julia o **Vector/Lista** en R) llamada `ruta_avistamiento` que contenga los tres puntos iniciales en orden.
3. Los guardabosques acaban de reportar un cuarto punto (`11.1355, -74.0150`). Utiliza el m√©todo nativo de tu lenguaje para **agregar** esta nueva coordenada al final de tu ruta.
4. Utilizando la indexaci√≥n din√°mica (indexaci√≥n negativa o comandos como `length/end`), extrae el **√∫ltimo punto** de la ruta y gu√°rdalo en una variable llamada `ultimo_reporte`.
5. Crea una nueva lista/vector paralela llamada `elevaciones` que contenga las alturas de los cuatro puntos: `[850.5, 920.0, 1050.2, 1180.8]`.
6. Calcula e imprime la elevaci√≥n m√°xima alcanzada en el recorrido y el n√∫mero total de puntos visitados (v√©rtices), utilizando las funciones nativas (ej. `max()`, `len()`, `length()`).

### Ejercicio 2: Metadatos y ecosistemas (diccionarios y conjuntos)

**Contexto:** Est√°s dise√±ando el esquema de base de datos para los Parques Nacionales Naturales (PNN). Necesitas estructurar los atributos de un parque usando un modelo de clave-valor (similar a GeoJSON) y depurar una lista de observaciones de campo que tiene datos duplicados.

**Instrucciones de c√≥digo:**

1. Crea un **Diccionario** (o Lista nombrada en R) llamado `pnn_tayrona` que contenga exactamente las siguientes claves y valores:
   * `"nombre"`: "PNN Tayrona"
   * `"area_hectareas"`: 15000
   * `"abierto_turismo"`: Verdadero (tipo Booleano)
   * `"ecosistemas"`: Una lista/vector con los textos `"Manglar"`, `"Bosque Seco"`, y `"Coral"`.
2. Emplea la funci√≥n o m√©todo de acceso seguro (ej. `.get()` en Python o condicionales en R/Julia) para intentar extraer la clave `"fecha_creacion"`. Como no existe, debe devolver el texto `"Dato no disponible"` sin que el programa colapse. Imprime el resultado.
3. Actualiza el diccionario a√±adiendo una nueva clave llamada `"departamento"` con el valor `"Magdalena"`.
4. Recibes un reporte de campo crudo con los ecosistemas observados hoy, el cual contiene duplicados:
   `observaciones_crudas = ["Manglar", "Coral", "Bosque Seco", "Manglar", "Coral", "Matorral"]`
   Convierte esta colecci√≥n en un **Conjunto** (*Set* o usando `unique()`) para eliminar los duplicados y gu√°rdalo en la variable `observaciones_unicas`.
5. Utiliza una **operaci√≥n l√≥gica de conjuntos** (intersecci√≥n) entre la lista oficial de ecosistemas del parque (guardada dentro de tu diccionario en el paso 1) y tus `observaciones_unicas`. Imprime el resultado para saber qu√© ecosistemas oficiales fueron efectivamente avistados hoy.

### Entregables y criterios de evaluaci√≥n

El objetivo de esta evaluaci√≥n no es solo que el c√≥digo funcione, sino que seas capaz de documentar y explicar tus decisiones t√©cnicas.

**1. Archivos de C√≥digo:**
Debes desarrollar los algoritmos en al menos uno de los siguientes formatos de archivo:
* Script tradicional (`.py`, `.R`, `.jl`)
* Notebook interactivo (`.ipynb`)
* Documento computacional (`.qmd` con *chunks* de c√≥digo)

**2. Documento Anal√≠tico (Quarto):**
Independientemente del formato de tu c√≥digo fuente, **debes redactar un documento en Quarto (`.qmd`) y renderizarlo tanto en HTML como en PDF**. En este documento debes incluir tus bloques de c√≥digo y responder argumentativamente a las siguientes preguntas:

* **Sobre el Ejercicio 1:** En t√©rminos de topolog√≠a espacial y seguridad del c√≥digo, ¬øcu√°l es la ventaja de guardar las coordenadas individuales `(X, Y)` como *Tuplas* inmutables, pero guardar la ruta completa como una *Lista* mutable? ¬øQu√© pasar√≠a si intentas modificar directamente la latitud del `punto_1` usando `punto_1[0] = 12.0000` en Python o Julia?
* **Sobre el Ejercicio 2:** En R, existe un debate constante entre usar `c()` o `list()`. Si estuvieras programando en R y necesitaras almacenar la lista de `"ecosistemas"` dentro de las propiedades del parque, ¬øqu√© comando usar√≠as para agrupar esos textos espec√≠ficos y por qu√©?
* **Pregunta General (Slicing):** Explica brevemente la diferencia cr√≠tica en el comportamiento de extracci√≥n de rangos (*slicing*) si ejecutas `ruta[1:3]` en **Python** comparado con ejecutar el mismo c√≥digo en **R o Julia**. ¬øCu√°ntos elementos te devuelve cada uno y por qu√©?

**3. Repositorio en GitHub:**
Sube tu carpeta del proyecto (que debe contener tus scripts, el archivo `.qmd` y los renders finales en HTML y PDF) a un repositorio p√∫blico en tu cuenta personal de **GitHub**.
* **Entrega:** Deber√°s enviar √∫nicamente el enlace (URL) a tu repositorio de GitHub para la calificaci√≥n.


