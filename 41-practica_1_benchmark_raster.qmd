# Evaluaci√≥n Comparativa de Procesamiento Geoespacial


## Introducci√≥n
* **Materia**: Programaci√≥n SIG: Python, R, Julia
* **Pr√°ctica 1**: Sentinel-2 (1GB) - R (`terra`) vs R (`stars`) vs Python (`rasterio`) vs Julia (`ArchGDAL + Raster.jl`)
* **Autores**: Alexys Rodr√≠guez-Avellaneda Ph.D. & herramientas IA

## Funci√≥n j_eval en R

::: {.content-visible when-format="html"}
::: {.callout-tip collapse="true" icon="false"}
##### ‚ñ∑ C√ìDIGO PURO (Copiar y Pegar)
```{r}
#| label: setup_benchmark_codigo
#| eval: false
# C√≥digo en R 
j_eval <- function(cmd) {
  .ensure_julia_ready()
  lineas <- strsplit(cmd, "\n")[[1]]
  buffer_bloque <- ""; en_bloque <- 0; resultado_final <- NULL

  for (l in lineas) {
    if (trimws(l) == "") next
    buffer_bloque <- paste0(buffer_bloque, l, "\n")
    abrir <- grepl("\\b(do|function|for|if|begin|let|while)\\b", l) & !grepl("\\bend\\b", l)
    cerrar <- grepl("\\bend\\b", l)
    en_bloque <- en_bloque + abrir - cerrar
    
    if (en_bloque <= 0) {
      res_raw <- JuliaConnectoR::juliaCall("_unal_core_executor", buffer_bloque, FALSE, "", 72, 800, 500, 12)
      cat(res_raw)
      lineas_res <- strsplit(res_raw, "\n")[[1]]
      lineas_res <- trimws(lineas_res[lineas_res != ""])
      # Capturamos solo si hay contenido real
      temp_res <- tail(lineas_res[!grepl("^julia>", lineas_res)], 1)
      if (length(temp_res) > 0) resultado_final <- temp_res
      buffer_bloque <- ""; en_bloque <- 0
    }
  }
  if (is.null(resultado_final)) return(NULL) # Evita el error de length zero
  val_limpio <- gsub('"', '', resultado_final)
  num_val <- suppressWarnings(as.numeric(val_limpio))
  return(if (!is.na(num_val)) num_val else val_limpio)
}
```
:::
:::


```{r}
#| label: setup_benchmark
#| code-fold: true
#| include: false
j_eval <- function(cmd) {
  .ensure_julia_ready()
  lineas <- strsplit(cmd, "\n")[[1]]
  buffer_bloque <- ""; en_bloque <- 0; resultado_final <- NULL

  for (l in lineas) {
    if (trimws(l) == "") next
    buffer_bloque <- paste0(buffer_bloque, l, "\n")
    abrir <- grepl("\\b(do|function|for|if|begin|let|while)\\b", l) & !grepl("\\bend\\b", l)
    cerrar <- grepl("\\bend\\b", l)
    en_bloque <- en_bloque + abrir - cerrar
    
    if (en_bloque <= 0) {
      res_raw <- JuliaConnectoR::juliaCall("_unal_core_executor", buffer_bloque, FALSE, "", 72, 800, 500, 12)
      cat(res_raw)
      lineas_res <- strsplit(res_raw, "\n")[[1]]
      lineas_res <- trimws(lineas_res[lineas_res != ""])
      # Capturamos solo si hay contenido real
      temp_res <- tail(lineas_res[!grepl("^julia>", lineas_res)], 1)
      if (length(temp_res) > 0) resultado_final <- temp_res
      buffer_bloque <- ""; en_bloque <- 0
    }
  }
  if (is.null(resultado_final)) return(NULL) # Evita el error de length zero
  val_limpio <- gsub('"', '', resultado_final)
  num_val <- suppressWarnings(as.numeric(val_limpio))
  return(if (!is.na(num_val)) num_val else val_limpio)
}
```

## Preparaci√≥n de los Datos: Sentinel-2A

En este ejercicio procesamos una escena de **Sentinel-2A** en formato `.zip`. En lugar de extraer el archivo (lo cual duplicar√≠a el espacio en disco a casi 2GB), usamos el driver **VSI (Virtual Systems Interface)** de GDAL.

### Anatom√≠a de la Imagen
La imagen Sentinel-2 se organiza por bandas. Para este benchmark usaremos la **Banda 4 (Red)**, fundamental para el c√°lculo de √≠ndices de vegetaci√≥n como el NDVI.

| Banda | Resoluci√≥n | Longitud de Onda | Uso |
|:---|:---|:---|:---|
| B02 (Blue) | 10m | 490 nm | Mapeo de aguas, suelos |
| B03 (Green) | 10m | 560 nm | Vigor de vegetaci√≥n |
| **B04 (Red)** | **10m** | **665 nm** | **Absorci√≥n de clorofila** |
| B08 (NIR) | 10m | 842 nm | Biomasa, salud foliar |


#### Descubrir la Ruta de la Imagen Sentinel-2

::: {.content-visible when-format="html"}
::: {.callout-tip collapse="true" icon="false"}
##### ‚ñ∑ C√ìDIGO PURO (Copiar y Pegar)

```{r}
#| eval: false
#| lst-cap: "Construcci√≥n de ruta virtual GDAL para Sentinel-2"
# C√≥digo en R

library(starsdata)
library(terra)
library(stars)
library(reticulate)

# 1. Localizaci√≥n del ZIP dentro del paquete starsdata
f <- "sentinel/S2A_MSIL1C_20180220T105051_N0206_R051_T32ULE_20180221T134037.zip"
granule <- system.file(file = f, package = "starsdata")
granule

# 2. Construcci√≥n de la ruta Virtual de GDAL (/vsizip/)
# Rompemos la cadena en varias l√≠neas para que LaTeX pueda procesarla
base_name <- strsplit(basename(granule), ".zip")[[1]]
base_name


# Esta ruta permite leer directamente el XML de metadatos dentro del ZIP sin descomprimir.
#s2_path <- paste0("SENTINEL2_L1C:/vsizip/", granule, "/", base_name, ".SAFE/MTD_MSIL1C.xml:10m:EPSG_32632")
s2_path <- paste0(
  "SENTINEL2_L1C:/vsizip/", 
  granule, 
  "/", 
  base_name, 
  ".SAFE/MTD_MSIL1C.xml:10m:EPSG_32632"
)
#s2_path

# Mostramos el resultado sin comillas ni √≠ndices [1] para el libro
cat("Ruta generada:", s2_path, fill = TRUE)

# Guardamos la ruta en un archivo compartido para que Python y Julia la lean
writeLines(s2_path, "s2_shared_path.txt")

```


:::
:::


```{r}
#| label: path_to_raster
#| code-fold: true

library(starsdata)
library(terra)
library(stars)
library(reticulate)

# 1. Localizaci√≥n del ZIP dentro del paquete starsdata
f <- "sentinel/S2A_MSIL1C_20180220T105051_N0206_R051_T32ULE_20180221T134037.zip"
granule <- system.file(file = f, package = "starsdata")
granule
base_name <- strsplit(basename(granule), ".zip")[[1]]
base_name

# 2. Construcci√≥n de la ruta Virtual de GDAL (/vsizip/)
# Esta ruta permite leer directamente el XML de metadatos dentro del ZIP sin descomprimir.
s2_path <- paste0("SENTINEL2_L1C:/vsizip/", granule, "/", base_name, ".SAFE/MTD_MSIL1C.xml:10m:EPSG_32632")
s2_path

# Guardamos la ruta en un archivo compartido para que Python y Julia la lean
writeLines(s2_path, "s2_shared_path.txt")

```


## Metodolog√≠a de la evaluaci√≥n comparativa (benchmarking)

Este experimento eval√∫a el rendimiento de cuatro motores geoespaciales ampliamente utilizados ‚Äî`terra` (**R**), `stars` (**R**), `rasterio` (**Python**) y `Rasters.jl` (**Julia**)‚Äî frente a una operaci√≥n num√©ricamente simple pero computacionalmente exigente sobre datos raster de gran tama√±o.

El flujo de trabajo consiste en:

1. Apertura del archivo raster Sentinel-2.
2. Selecci√≥n de una sola banda (B4).
3. Aplicaci√≥n de una operaci√≥n aritm√©tica escalar.
4. C√°lculo de la **media global** (*mean*), que fuerza la evaluaci√≥n completa del raster.

A diferencia de benchmarks centrados en *materializaci√≥n expl√≠cita*, este experimento utiliza la operaci√≥n `mean()` como **operaci√≥n com√∫n de evaluaci√≥n**, permitiendo que cada motor ejecute el c√°lculo conforme a su propio modelo interno de ejecuci√≥n (*lazy vs eager*).

---

### Dimensi√≥n del problema

Una banda Sentinel-2 a 10 m de resoluci√≥n contiene:


$$10.980 \times 10.980 = 120.560.400 \text{ p√≠xeles}$$


Asumiendo datos en punto flotante de 32 bits (4 bytes), el volumen te√≥rico m√≠nimo es:

$$120.560.400 \times 4 \approx 482{,}24 \text{ MB}$$


Este tama√±o excede ampliamente la cach√© de CPU, por lo que el experimento est√° dominado por **I/O, acceso a memoria y eficiencia de recorrido**, no por complejidad algor√≠tmica.

---

### Exclusiones deliberadas

- La **generaci√≥n de gr√°ficos (plotting)** se ejecuta fuera del bloque cronometrado.
- El tiempo de renderizado y escritura en disco no refleja la velocidad de procesamiento num√©rico.
- En **Julia**, se realiza una ejecuci√≥n previa (*warm-up*) para excluir el costo de compilaci√≥n *Just-In-Time (JIT)* del tiempo reportado.
- En **Python** y **R**, el c√≥digo num√©rico cr√≠tico se ejecuta en librer√≠as ya compiladas (GDAL, NumPy, C/C++), por lo que no existe un costo de compilaci√≥n comparable. Cualquier efecto de ‚Äúcalentamiento‚Äù en estos casos se limita a inicializaci√≥n de librer√≠as y cach√© de disco, y no altera de forma significativa los tiempos medidos.

---

### Etapas del proceso evaluado

| Etapa | Descripci√≥n t√©cnica | Implementaci√≥n por motor |
|---|---|---|
| **1. Apertura del dataset** | Lectura de metadatos y establecimiento de conexi√≥n al raster (sin carga completa a RAM) | **R / terra:** `rast()` <br> **R / stars:** `read_stars(proxy = TRUE)` <br> **Python / rasterio:** `rasterio.open()` <br> **Julia / ArchGDAL + Rasters.jl:** `ArchGDAL.read()` |
| **2. Selecci√≥n de banda B4** | Referencia a la banda espectral sin materializar todos los p√≠xeles | **R / terra:** `r[[1]]` <br> **R / stars:** `s[,,,1]` <br> **Python / rasterio:** `src.read(1)` <br> **Julia / Rasters.jl:** `Raster(ds)[Band(1)]` |
| **3. Operaci√≥n aritm√©tica escalar** | Multiplicaci√≥n de cada p√≠xel por un factor constante (1.5) | **R / terra:** `b4 * 1.5` <br> **R / stars:** `b4 * 1.5` <br> **Python / NumPy:** `b4 * 1.5` <br> **Julia / Rasters.jl:** ` r .* 1.5` |
| **4. Reducci√≥n global (mean)** | C√°lculo de la media global, forzando el recorrido completo del raster | **R / terra:** `global(res_terra, "mean", na.rm = TRUE)[1, 1]` *(streaming)* <br> **R / stars:** `mean(as.vector(res_mem[[1]]), na.rm = TRUE)` *(tras materializaci√≥n expl√≠cita)* <br> **Python / NumPy:** `res.mean()` *(array ya en RAM)* <br> **Julia / Rasters.jl:** `mean(res)` *(streaming lazy)* |

---

### Interpretaci√≥n clave del paso de reducci√≥n (`mean`)

El c√°lculo de la media es fundamental porque:

- Obliga a **recorrer todos los p√≠xeles** del raster.
- Garantiza que la operaci√≥n aritm√©tica fue realmente ejecutada.
- Permite forzar la evaluaci√≥n completa del flujo de c√°lculo sin introducir operaciones adicionales.

No obstante, **cada motor implementa este paso de forma distinta**: algunos realizan la reducci√≥n en *streaming* sin materializar el raster completo, mientras que otros requieren una materializaci√≥n expl√≠cita en memoria. Estas diferencias responden a decisiones de dise√±o propias de cada librer√≠a y constituyen una limitaci√≥n inevitable de la comparaci√≥n.

---

### Diferencias estructurales entre motores

Cada motor est√° optimizado para un tipo distinto de an√°lisis. `terra` y `rasterio` est√°n especialmente afinados para c√°lculos num√©ricos simples sobre grandes vol√∫menes de datos, mientras que `stars` y `Rasters.jl` priorizan flexibilidad y modelos de datos m√°s generales, lo cual puede afectar el rendimiento en operaciones simples como una media global.


| Motor | ¬øC√≥mo trabaja internamente? | ¬øQu√© implica en este benchmark? |
|---|---|---|
| **terra (R)** | Usa archivos raster ‚Äúpor referencia‚Äù y hace los c√°lculos en C++ | Recorre el raster una sola vez de forma muy eficiente |
| **stars (R)** | Maneja los datos como cubos multidimensionales con mucha informaci√≥n espacial | Es m√°s flexible, pero la media global es m√°s lenta por el manejo de metadatos |
| **rasterio (Python)** | Carga la banda completa en un arreglo NumPy | Los datos quedan contiguos en memoria y se procesan muy r√°pido |
| **Rasters.jl (Julia)** | Eval√∫a las operaciones paso a paso y por bloques | Es muy general, pero en este caso introduce m√°s sobrecarga |

---

### Limitaciones inevitables del benchmarking

Este benchmark **no mide qu√© lenguaje es ‚Äúm√°s r√°pido‚Äù**, sino c√≥mo funciona **todo el conjunto de herramientas** que usa cada uno (librer√≠as, forma de leer datos y manera de calcular).

En particular:

- **Python (rasterio)** es muy r√°pido porque lee la banda completa en memoria y usa arreglos NumPy optimizados.
- **terra (R)** est√° muy bien optimizado para hacer operaciones matem√°ticas sobre rasters usando c√≥digo en C++.
- **stars (R)** se enfoca en manejar bien la informaci√≥n espacial y los metadatos, lo que hace m√°s lenta una media global.
- **Julia (Rasters.jl)** est√° pensado para an√°lisis espaciales m√°s generales y flexibles, no para un √∫nico c√°lculo masivo como en NumPy.

Por eso, estos resultados deben interpretarse as√≠:

> *Miden el rendimiento para una tarea espec√≠fica (leer un raster y calcular una media),  
> No un ranking general de lenguajes de programaci√≥n.*

### Interpretaci√≥n del benchmark

Este benchmark representa un **caso extremo y muy simplificado**:

- Se utiliza **una sola banda raster**.
- Se aplica **una operaci√≥n matem√°tica trivial** (multiplicaci√≥n escalar).
- Se calcula **una √∫nica media global**.

Por lo tanto, **no eval√∫a**:

- An√°lisis con m√∫ltiples bandas.
- Operaciones espaciales complejas (vecindarios, m√°scaras, reproyecciones).
- Flujos de trabajo largos, iterativos o modelos estad√≠sticos.

El objetivo **no es declarar un ‚Äúlenguaje ganador‚Äù**, sino **entender los costos reales** de:
- leer los datos,
- manejar las abstracciones,
- y calcular una estad√≠stica global.

#### ¬øQu√© significa ‚Äúmanejar las abstracciones‚Äù?

Las abstracciones son capas de software que facilitan el trabajo del usuario.  
Estas capas se encargan de:

- Leer los datos de forma segura.
- Mantener la informaci√≥n espacial (coordenadas, resoluci√≥n, extensi√≥n).
- Coordinar las operaciones sin que el usuario controle cada paso.

Aunque hacen el c√≥digo m√°s claro y seguro, **introducen un costo adicional**, que se vuelve visible en operaciones simples y masivas, como una reducci√≥n global (`mean`).

#### Nivel de abstracci√≥n por motor

| Motor / librer√≠a | Nivel de abstracci√≥n | Forma de trabajar (idea intuitiva) |
|---|---|---|
| **Python / rasterio + NumPy** | Baja | ‚ÄúAqu√≠ tienes un arreglo de n√∫meros en memoria, hagamos cuentas r√°pido‚Äù |
| **R / terra** | Media | ‚ÄúYo manejo el raster y optimizo las operaciones por ti‚Äù |
| **R / stars** | Alta | ‚ÄúAdem√°s de los valores, manejo dimensiones, tiempo, atributos y geometr√≠a‚Äù |
| **Julia / Rasters.jl** | Flexible | ‚ÄúConstruyo un flujo de operaciones que se eval√∫a cuando es necesario‚Äù |

**Idea clave:**  
> A mayor nivel de abstracci√≥n, mayor comodidad y expresividad para el usuario,  
> pero tambi√©n mayor costo computacional en operaciones simples como una media global.


## An√°lisis de Rendimiento y Paralelismo

### Benchmark en Python vs. Julia

::: {.panel-tabset}

#### üêç Python (Rasterio)
`rasterio` es la navaja suiza de Python para rasters. Al combinarse con **NumPy**, utiliza instrucciones **SIMD** que paralelizan el c√°lculo a nivel de procesador (vectorizaci√≥n), aunque la lectura de GDAL sigue siendo monohilo.

::: {.content-visible when-format="html"}
::: {.callout-tip collapse="true" icon="false"}
##### ‚ñ∑ C√ìDIGO PURO (Copiar y Pegar)
```{python}
#| label: duracion_py_codigo
#| eval: false
# C√≥digo en Python
import rasterio
import numpy as np
import matplotlib.pyplot as plt
import time
import gc

# ------------------------------------------------
# 1. Leer ruta compartida
# ------------------------------------------------
with open("s2_shared_path.txt", "r") as f:
    s2_path = f.read().strip()

# ------------------------------------------------
# 2. WARM-UP (compila + cachea)
# ------------------------------------------------
with rasterio.open(s2_path) as src:
    _ = (src.read(1) * 1.5).mean()

gc.collect()

# ------------------------------------------------
# 3. BENCHMARK REAL
# ------------------------------------------------
t0 = time.perf_counter()

with rasterio.open(s2_path) as src:
    b4 = src.read(1)          # lectura banda 4
    res = b4 * 1.5            # operaci√≥n
    m_py = res.mean()         # FORZADO REAL

t_python = time.perf_counter() - t0

print(f"üêç Python: {t_python:.3f} seg | mean = {m_py:.6f}")

# ------------------------------------------------
# 4. Plot (FUERA DEL BENCHMARK)
# ------------------------------------------------
plt.imshow(res, cmap="terrain")
plt.title("Python: Banda 4 √ó 1.5")
plt.axis("off")
plt.show()

# ------------------------------------------------
# 5. Limpieza
# ------------------------------------------------
del b4, res
#gc.collect()
```
:::
:::

```{python}
#| label: duracion_py
#| code-fold: true

import rasterio
import numpy as np
import matplotlib.pyplot as plt
import time
import gc

# ------------------------------------------------
# 1. Leer ruta compartida
# ------------------------------------------------
with open("s2_shared_path.txt", "r") as f:
    s2_path = f.read().strip()

# ------------------------------------------------
# 2. WARM-UP (compila + cachea)
# ------------------------------------------------
with rasterio.open(s2_path) as src:
    _ = (src.read(1) * 1.5).mean()

gc.collect()

# ------------------------------------------------
# 3. BENCHMARK REAL
# ------------------------------------------------
t0 = time.perf_counter()

with rasterio.open(s2_path) as src:
    b4 = src.read(1)          # lectura banda 4
    res = b4 * 1.5            # operaci√≥n
    m_py = res.mean()         # FORZADO REAL

t_python = time.perf_counter() - t0

print(f"üêç Python: {t_python:.3f} seg | mean = {m_py:.6f}")

# ------------------------------------------------
# 4. Plot (FUERA DEL BENCHMARK)
# ------------------------------------------------
plt.imshow(res, cmap="terrain")
plt.title("Python: Banda 4 √ó 1.5")
plt.axis("off")
plt.show()

# ------------------------------------------------
# 5. Limpieza
# ------------------------------------------------
del b4, res
#gc.collect()
```

::: {.content-visible when-format="html"}
::: {.callout-tip collapse="true" icon="false"}
##### ‚ñ∑ C√ìDIGO PURO (Copiar y Pegar)
```{r}
#| label: captura_t_python_r_codigo
#| eval: false
# C√≥digo en R
# Aqu√≠ es donde creamos t_python para R de la variable t_python en Python. Lo necesitamos en R para la tabla final.
# Extraemos el valor desde el objeto 'py'
t_python <- py$t_python
#t_python <- 0

cat("üêç Tiempo capturado de Python:", round(t_python, 3), "seg.")
```
:::
:::

```{r}
#| label: captura_t_python
#| code-fold: true
# Aqu√≠ es donde creamos t_python para R de la variable t_python en Python. Lo necesitamos en R para la tabla final.
# Extraemos el valor desde el objeto 'py'
t_python <- py$t_python
#t_python <- 0

cat("üêç Tiempo capturado de Python:", round(t_python, 3), "seg.")
```


#### ‚ö° Julia (Rasters.jl)

Julia es el √∫nico de los cuatro motores evaluados que puede explotar **paralelismo multihilo** en esta operaci√≥n espec√≠fica, sin recurrir a librer√≠as externas adicionales, aprovechando los n√∫cleos asignados al contenedor. 


::: {.content-visible when-format="html"}
::: {.callout-tip collapse="true" icon="false"}
##### ‚ñ∑ C√ìDIGO PURO (Copiar y Pegar)
```{julia}
#| label: t_julia_codigo
#| eval: false
# C√≥digo en Julia
using Rasters, ArchGDAL, Statistics, Plots

# Evita restricciones artificiales de memoria
Rasters.checkmem!(false)

# ------------------------------------------------
# 1. Leer ruta compartida
# ------------------------------------------------
path = strip(read("s2_shared_path.txt", String))

# ------------------------------------------------
# 2. FUNCI√ìN DE BENCHMARK (proxy + mean)
# ------------------------------------------------
function process_band_mean(path)
    ArchGDAL.read(path) do ds
        r   = Raster(ds)[Band(1)]   # proxy, solo banda 4
        res = r .* 1.5              # operaci√≥n lazy
        return mean(res)            # FORZADO REAL (streaming)
    end
end

# ------------------------------------------------
# 3. WARM-UP (compilaci√≥n)
# ------------------------------------------------
process_band_mean(path)
GC.gc()

# ------------------------------------------------
# 4. BENCHMARK REAL
# ------------------------------------------------
t0 = time_ns()
m_julia = process_band_mean(path)
t1 = time_ns()

t_julia = (t1 - t0) / 1e9

println("üü£ Julia: ", round(t_julia, digits=3), " seg | mean = ", round(m_julia, digits=6))


# ------------------------------------------------
# 5. Plot (FUERA DEL BENCHMARK, proxy)
# ------------------------------------------------
ArchGDAL.read(path) do ds
    r   = Raster(ds)[Band(1)]
    res = r .* 1.5
    p = plot(res, colormap = :terrain,
         title = "Julia: Banda 4 √ó 1.5")
    savefig(p, "julia_plot.png")
end

# Debe ser la √∫ltima para que j_eval en R capture solo el n√∫mero
t_julia
```
:::
:::

```{r}
#| label: t_julia
#| out-width: "100%"
#| fig-align: "center"
#| fig-cap: "Procesamiento de alta resoluci√≥n en Julia"
#| code-fold: true

# 1. Desde R, llamamos a julia con j_eval (la funci√≥n al inicio de este archivo o en el Rprofile)
# Ejecutamos dos veces: 
#   la primera compila "costo de arranque" (JIT), 
#   la segunda mide el tiempo

t_julia <- j_eval('
using Rasters, ArchGDAL, Statistics, Plots

# Evita restricciones artificiales de memoria
Rasters.checkmem!(false)

# ------------------------------------------------
# 1. Leer ruta compartida
# ------------------------------------------------
path = strip(read("s2_shared_path.txt", String))

# ------------------------------------------------
# 2. FUNCI√ìN DE BENCHMARK (proxy + mean)
# ------------------------------------------------
function process_band_mean(path)
    ArchGDAL.read(path) do ds
        r   = Raster(ds)[Band(1)]   # proxy, solo banda 4
        res = r .* 1.5              # operaci√≥n lazy
        return mean(res)            # FORZADO REAL (streaming)
    end
end

# ------------------------------------------------
# 3. WARM-UP (compilaci√≥n)
# ------------------------------------------------
process_band_mean(path)
GC.gc()

# ------------------------------------------------
# 4. BENCHMARK REAL
# ------------------------------------------------
t0 = time_ns()
m_julia = process_band_mean(path)
t1 = time_ns()

t_julia = (t1 - t0) / 1e9

println("üü£ Julia: ", round(t_julia, digits=3), " seg | mean = ", round(m_julia, digits=6))


# ------------------------------------------------
# 5. Plot (FUERA DEL BENCHMARK, proxy)
# ------------------------------------------------
ArchGDAL.read(path) do ds
    r   = Raster(ds)[Band(1)]
    res = r .* 1.5
    p = plot(res, colormap = :terrain,
         title = "Julia: Banda 4 √ó 1.5")
    savefig(p, "julia_plot.png")
end

# Debe ser la √∫ltima para que j_eval en R capture solo el n√∫mero
t_julia
')

# 2. R muestra la imagen guardada por Julia en el HTML
knitr::include_graphics("julia_plot.png")

# 3. Impresi√≥n desde R
print(paste("‚ö° Tiempo capturado en R:", t_julia, " seg."))
```

:::

### Benchmark en R: Terra vs Stars


::: {.panel-tabset}

#### üèÅ R: terra
`terra` est√° desarrollado sobre C++. Su fortaleza es la velocidad de lectura y el manejo de memoria mediante punteros externos. 
**Paralelismo:** Para esta tarea (operaci√≥n escalar), `terra` trabaja de forma **secuencial** (monohilo), confiando en la optimizaci√≥n de sus bucles en C++.

::: {.content-visible when-format="html"}
::: {.callout-tip collapse="true" icon="false"}
##### ‚ñ∑ C√ìDIGO PURO (Copiar y Pegar)
```{r}
#| label: t_terra_codigo
#| eval: false
# C√≥digo en R
library(terra)
# ------------------------------------------------
# 0. Inicio del cron√≥metro
# ------------------------------------------------
t0 <- Sys.time()

# ------------------------------------------------
# 1. Abrir raster en modo proxy (NO RAM)
# ------------------------------------------------
r <- rast(s2_path)

# ------------------------------------------------
# 2. Seleccionar solo la banda 4 (sigue siendo proxy)
# ------------------------------------------------
b4 <- r[[1]]

# ------------------------------------------------
# 3. Operaci√≥n aritm√©tica (lazy)
# ------------------------------------------------
res_terra <- b4 * 1.5

# ------------------------------------------------
# 4. FORZADO REAL (streaming, sin materializar)
# ------------------------------------------------
m_terra <- global(res_terra, "mean", na.rm = TRUE)[1, 1]

# ------------------------------------------------
# 5. Tiempo total
# ------------------------------------------------
t_terra <- as.numeric(Sys.time() - t0)

cat("üü§ Terra:",
    round(t_terra, 3), "seg |",
    "mean =", round(m_terra, 6), "\n")

# ------------------------------------------------
# 6. Plot (FUERA DEL BENCHMARK, proxy)
# ------------------------------------------------
plot(res_terra, col = terrain.colors(100),
     main = "Terra: Banda 4 √ó 1.5")

# ------------------------------------------------
# 7. Limpieza
# ------------------------------------------------
rm(r, b4, res_terra)
gc()
```
:::
:::

```{r}
#| label: t_terra
#| code-fold: true

# library(terra)
# ------------------------------------------------
# 0. Inicio del cron√≥metro
# ------------------------------------------------
t0 <- Sys.time()

# ------------------------------------------------
# 1. Abrir raster en modo proxy (NO RAM)
# ------------------------------------------------
r <- rast(s2_path)

# ------------------------------------------------
# 2. Seleccionar solo la banda 4 (sigue siendo proxy)
# ------------------------------------------------
b4 <- r[[1]]

# ------------------------------------------------
# 3. Operaci√≥n aritm√©tica (lazy)
# ------------------------------------------------
res_terra <- b4 * 1.5

# ------------------------------------------------
# 4. FORZADO REAL (streaming, sin materializar)
# ------------------------------------------------
m_terra <- global(res_terra, "mean", na.rm = TRUE)[1, 1]

# ------------------------------------------------
# 5. Tiempo total
# ------------------------------------------------
t_terra <- as.numeric(Sys.time() - t0)

cat("üü§ Terra:",
    round(t_terra, 3), "seg |",
    "mean =", round(m_terra, 6), "\n")

# ------------------------------------------------
# 6. Plot (FUERA DEL BENCHMARK, proxy)
# ------------------------------------------------
plot(res_terra, col = terrain.colors(100),
     main = "Terra: Banda 4 √ó 1.5")

# ------------------------------------------------
# 7. Limpieza
# ------------------------------------------------
rm(r, b4, res_terra)
gc()
```

#### üåü R: stars

El paquete **`stars`** est√° especialmente dise√±ado para trabajar con **cubos de datos multidimensionales**, como m√∫ltiples bandas, series temporales y atributos espaciales complejos. Esta capacidad lo hace muy expresivo y adecuado para an√°lisis espaciales avanzados.

Sin embargo, cuando se utiliza `proxy = FALSE`, los datos se **materializan completamente en la memoria de R**. En rasters de gran tama√±o, esto puede introducir un mayor costo computacional asociado a:

- Lectura completa de los datos desde disco.
- Copia de grandes matrices a la memoria de R.
- Gesti√≥n de metadatos espaciales y dimensionales.

**Paralelismo**: En operaciones aritm√©ticas simples ‚Äîcomo una **multiplicaci√≥n escalar** seguida de una **media global**‚Äî **ni `stars` ni `terra` garantizan paralelismo expl√≠cito por defecto**. En estos casos, el procesamiento suele realizarse de forma:
- **Secuencial**, o  
- **Por bloques**, dependiendo de la configuraci√≥n interna del paquete y del backend utilizado (por ejemplo, GDAL).

::: {.content-visible when-format="html"}
::: {.callout-tip collapse="true" icon="false"}
##### ‚ñ∑ C√ìDIGO PURO (Copiar y Pegar)
```{r}
#| label: t_stars_codigo
#| eval: false
# C√≥digo en R
library(stars)

# ------------------------------------------------
# 0. Inicio del cron√≥metro
# ------------------------------------------------
t0 <- Sys.time()

# ------------------------------------------------
# 1. Leer raster como proxy (NO RAM)
# ------------------------------------------------
s <- read_stars(s2_path, proxy = TRUE)

# ------------------------------------------------
# 2. Seleccionar solo la banda 4 (proxy)
# ------------------------------------------------
b4 <- s[,,,1]

# ------------------------------------------------
# 3. Operaci√≥n aritm√©tica (lazy)
# ------------------------------------------------
res_stars <- b4 * 1.5

# ------------------------------------------------
# 4. FORZADO REAL (materializa la banda resultante)
# ------------------------------------------------
res_mem <- st_as_stars(res_stars)

# ------------------------------------------------
# 5. Media escalar (ya num√©rica)
# ------------------------------------------------
m_stars <- mean(as.vector(res_mem[[1]]), na.rm = TRUE)

# ------------------------------------------------
# 6. Tiempo total
# ------------------------------------------------
t_stars <- as.numeric(Sys.time() - t0)

cat("üåü Stars:",
    round(t_stars, 3), "seg |",
    "mean =", round(m_stars, 6), "\n")

# ------------------------------------------------
# 7. Plot (FUERA DEL BENCHMARK, proxy)
# ------------------------------------------------
plot(res_stars, col = terrain.colors(100),
     main = "Stars: Banda 4 √ó 1.5")

# ------------------------------------------------
# 8. Limpieza
# ------------------------------------------------
rm(s, b4, res_stars)
gc()
```
:::
:::

```{r}
#| label: t_stars
#| code-fold: true

# library(stars)

# ------------------------------------------------
# 0. Inicio del cron√≥metro
# ------------------------------------------------
t0 <- Sys.time()

# ------------------------------------------------
# 1. Leer raster como proxy (NO RAM)
# ------------------------------------------------
s <- read_stars(s2_path, proxy = TRUE)

# ------------------------------------------------
# 2. Seleccionar solo la banda 4 (proxy)
# ------------------------------------------------
b4 <- s[,,,1]

# ------------------------------------------------
# 3. Operaci√≥n aritm√©tica (lazy)
# ------------------------------------------------
res_stars <- b4 * 1.5

# ------------------------------------------------
# 4. FORZADO REAL (materializa la banda resultante)
# ------------------------------------------------
res_mem <- st_as_stars(res_stars)

# ------------------------------------------------
# 5. Media escalar (ya num√©rica)
# ------------------------------------------------
m_stars <- mean(as.vector(res_mem[[1]]), na.rm = TRUE)

# ------------------------------------------------
# 6. Tiempo total
# ------------------------------------------------
t_stars <- as.numeric(Sys.time() - t0)

cat("üåü Stars:",
    round(t_stars, 3), "seg |",
    "mean =", round(m_stars, 6), "\n")

# ------------------------------------------------
# 7. Plot (FUERA DEL BENCHMARK, proxy)
# ------------------------------------------------
plot(res_stars, col = terrain.colors(100),
     main = "Stars: Banda 4 √ó 1.5")

# ------------------------------------------------
# 8. Limpieza
# ------------------------------------------------
rm(s, b4, res_stars)
gc()
```

:::


## Resultados finales

A continuaci√≥n, se presenta la comparativa de rendimiento para procesar la Banda 4 (Red) de 10m desde el archivo comprimido original.

::: {.content-visible when-format="html"}
::: {.callout-tip collapse="true" icon="false"}
##### ‚ñ∑ C√ìDIGO PURO (Copiar y Pegar)
```{r}
#| label: tabla_resultados_codigo
#| eval: false
# C√≥digo en R
library(knitr)
library(kableExtra)

# Creamos el dataframe con los datos capturados
resultados <- data.frame(
  Motor = c("R: terra", "R: stars", "Python: rasterio", "Julia: Rasters.jl"),
  Lenguaje = c("R (C++)", "R", "Python (C++/NumPy)", "Julia (Nativo)"),
  Paralelismo = c("Monohilo", "Monohilo", "SIMD (Vectorizado)", "Multihilo (12 hilos)"),
  Tiempo_Seg = c(t_terra, t_stars, t_python, t_julia)
)
resultados
# C√°lculo de eficiencia: ¬øCu√°ntas veces es m√°s r√°pido que el m√°s lento?
max_t <- max(resultados$Tiempo_Seg, na.rm = TRUE)
resultados$X_mas_rapido <- round(max_t / resultados$Tiempo_Seg, 2)

# Formateo elegante para el HTML
kable(resultados, 
      digits = 3, 
      caption = "Duelo de Titanes: Procesamiento de 1GB Sentinel-2",
      col.names = c("Motor", "Lenguaje", "Paralelismo", "Tiempo (s)", "Eficiencia (X)")) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), 
                full_width = F) %>%
  row_spec(which.min(resultados$Tiempo_Seg), bold = T, color = "white", background = "#2c3e50")
```
:::
:::


```{r}
#| label: tabla_resultados
#| echo: false
#| message: false
#| warning: false
library(knitr)
library(kableExtra)

# Creamos el dataframe con los datos capturados
resultados <- data.frame(
  Motor = c("R: terra", "R: stars", "Python: rasterio", "Julia: Rasters.jl"),
  Lenguaje = c("R (C++)", "R", "Python (C++/NumPy)", "Julia (Nativo)"),
  Paralelismo = c("Monohilo", "Monohilo", "SIMD (Vectorizado)", "Multihilo (12 hilos)"),
  Tiempo_Seg = c(t_terra, t_stars, t_python, t_julia)
)
resultados
# C√°lculo de eficiencia: ¬øCu√°ntas veces es m√°s r√°pido que el m√°s lento?
max_t <- max(resultados$Tiempo_Seg, na.rm = TRUE)
resultados$X_mas_rapido <- round(max_t / resultados$Tiempo_Seg, 2)

# Formateo elegante para el HTML
kable(resultados, 
      digits = 3, 
      caption = "Duelo de Titanes: Procesamiento de 1GB Sentinel-2",
      col.names = c("Motor", "Lenguaje", "Paralelismo", "Tiempo (s)", "Eficiencia (X)")) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), 
                full_width = F) %>%
  row_spec(which.min(resultados$Tiempo_Seg), bold = T, color = "white", background = "#2c3e50")

```

Los tiempos no deben compararse fuera del contexto de este patr√≥n de acceso (lectura secuencial + reducci√≥n global).


> El benchmark favorece motores optimizados para **recorridos contiguos de memoria** y **reducciones monol√≠ticas**, en particular **NumPy (v√≠a rasterio en Python)** y **el motor C++ interno de `terra` en R**, los cuales pueden ejecutar la operaci√≥n aritm√©tica y el c√°lculo estad√≠stico en una √∫nica pasada sobre un bloque contiguo de datos en memoria. 

En contraste, motores basados en evaluaciones diferidas (*lazy evaluation*) y procesamiento por bloques con mayor carga de metadatos, como **`stars` en R** y **`Rasters.jl` en Julia**, incurren en mayor overhead de abstracci√≥n y llamadas intermedias, lo que afecta su desempe√±o relativo en este escenario espec√≠fico.

1. **Eficiencia de Memoria:** `terra` es el ganador aqu√≠, ya que su gesti√≥n de objetos fuera de la RAM de R le permite manejar archivos gigantes sin colapsar.
2. **Paralelismo Real:** Solo **Julia** aprovecha los hilos de ejecuci√≥n de la CPU para la operaci√≥n matem√°tica de forma nativa. Python usa optimizaci√≥n de hardware (SIMD) v√≠a NumPy, mientras que R se mantiene secuencial pero optimizado en sus librer√≠as de C++.
3. **GDAL VSI:** Todos los lenguajes demostraron que el driver `/vsizip/` es la forma m√°s eficiente de interactuar con datos Sentinel-2 sin el costo de descompresi√≥n.

### Julia: paralelismo y pipelines composables

El potencial de paralelismo multihilo no siempre se traduce en mejores tiempos en benchmarks simples como el presente. Esto se debe a que Julia, a trav√©s de `Rasters.jl`, utiliza un modelo basado en **pipelines composables**.

Un **pipeline composable** significa que las operaciones no se ejecutan inmediatamente. En su lugar, Julia construye un *flujo de operaciones* (lectura ‚Üí selecci√≥n de banda ‚Üí operaci√≥n aritm√©tica ‚Üí reducci√≥n) que se eval√∫a solo cuando se solicita un resultado final, como la media global.

Este enfoque tiene ventajas claras en an√°lisis complejos y encadenados, pero introduce un costo adicional de planificaci√≥n y abstracci√≥n que se vuelve visible en tareas muy simples y masivas, como una √∫nica multiplicaci√≥n seguida de una reducci√≥n global.

En otras palabras, Julia est√° optimizada para **flujos de trabajo complejos**, no para reducciones monol√≠ticas de una sola pasada al estilo NumPy.


| Herramienta / librer√≠a | ¬øPipeline composable? | Ejemplo t√≠pico |
|------------------------|-----------------------|----------------|
| **Julia (Rasters.jl)** | ‚úÖ S√≠ | `mean(r .* 1.5)` ‚Üí se eval√∫a al final |
| **R (dplyr + dbplyr)** | ‚úÖ S√≠* | Cadena de transformaciones luego `collect()` |
| **Python (xarray + Dask)** | ‚úÖ S√≠ | `result = data.mean()` luego `compute()` |
| **Apache Spark** | ‚úÖ S√≠ | Plan de ejecuci√≥n (DAG) antes de correr |
| **Python (rasterio + NumPy)** | ‚ùå No | Lee y calcula todo inmediatamente |
| **R (terra)** | ‚ö†Ô∏è Parcial | Optimiza en C++ pero no expone pipeline diferido |
| **R (stars)** | ‚ùå No | `proxy` limitado, sin DAG composable completo |

\* **Nota sobre R (dplyr + dbplyr):**  
No es una soluci√≥n espacial por s√≠ misma. El pipeline composable existe, pero requiere un **backend espacial** (por ejemplo: PostGIS, DuckDB + spatial, Spark, BigQuery GIS). Sin ese backend, no aplica directamente a raster/cubos geoespaciales.

**Nota sobre `stars`:**  
Aunque puede trabajar con `proxy = TRUE`, `stars` **no implementa un pipeline composable tipo tidyverse**, ni un DAG diferido completo. Las operaciones tienden a materializar datos relativamente pronto y no se integran con `dplyr/dbplyr` para optimizaci√≥n global del flujo.


## M√°s all√° del benchmarking: optimizaci√≥n y virtualizaci√≥n de datos geoespaciales

Este benchmark eval√∫a un caso simple y controlado, pero **los proyectos reales con grandes vol√∫menes de datos geoespaciales** rara vez dependen de un solo archivo raster le√≠do de forma local. Hoy en d√≠a existen m√∫ltiples estrategias para **optimizar el rendimiento**, muchas de las cuales se basan en **virtualizaci√≥n del acceso a datos** y **formatos eficientes**.

Algunas de las principales alternativas que deben considerarse en proyectos de gran escala son:

### Formatos optimizados para alto volumen

- **Cloud Optimized GeoTIFF (COG)**  
  Permite leer solo las partes necesarias del raster mediante acceso por bloques y overviews, sin descargar el archivo completo.

- **Zarr / GeoZarr**  
  Formato orientado a datos multidimensionales y computaci√≥n distribuida. Muy eficiente para acceso parcial, paralelismo y almacenamiento en la nube.

- **GeoParquet**  
  Formato columnar optimizado para datos vectoriales masivos. Ideal para an√°lisis a gran escala, consultas selectivas y procesamiento distribuido.

### Virtualizaci√≥n y acceso remoto

- **GDAL VFS (`/vsicurl/`, `/vsis3/`, `/vsiaz/`)**  
  Permite trabajar con datos remotos como si fueran archivos locales, leyendo solo los bloques necesarios.

- **STAC (SpatioTemporal Asset Catalog)**  
  Facilita la b√∫squeda y acceso estructurado a grandes cat√°logos de datos espaciales distribuidos.

### Paralelismo y ejecuci√≥n distribuida

- **Procesamiento por bloques y multihilo** (GDAL, terra, rasterio)
- **Frameworks distribuidos** como **Dask**, **Spark** o **Ray**, especialmente combinados con Zarr o Parquet.
- **Aceleraci√≥n en la nube** mediante almacenamiento objeto y c√≥mputo escalable.

### Mensaje clave

Este ejercicio muestra los **costos m√≠nimos inevitables** de leer, abstraer y reducir datos raster. Sin embargo, **la verdadera optimizaci√≥n en proyectos reales no suele venir de cambiar de lenguaje**, sino de:

- Elegir **formatos de datos adecuados**.
- Minimizar movimientos innecesarios de datos.
- Aprovechar **acceso parcial, paralelismo y virtualizaci√≥n**.
- Dise√±ar flujos de trabajo pensados desde el inicio para grandes vol√∫menes.

En resumen:  
> *Cuando los datos crecen, la arquitectura y el formato importan tanto o m√°s que el lenguaje.*

## üèÅ Desaf√≠o de laboratorio: primer d√≠a

Para cerrar esta sesi√≥n del **‚ÄúDuelo de Titanes‚Äù**, deber√°n resolver el siguiente desaf√≠o pr√°ctico.  
Pueden apoyarse en herramientas de IA para investigar, pero recuerden:

> **Buscamos precisi√≥n y evidencia**, no ‚Äúcarreta‚Äù.

Este laboratorio incluye ejecuci√≥n real de c√≥digo en **distintos entornos**.

---

### üõ†Ô∏è Instrucciones de entrega

1. Creen un nuevo repositorio en su **GitHub personal** llamado `taller1-sig`.
2. Todas las respuestas escritas deben estar en un archivo `respuestas.qmd`.
3. Rendericen `respuestas.qmd` a **HTML** y **PDF**.
4. Suban al repositorio:
   - `respuestas.qmd`
   - `respuestas.html`
   - `respuestas.pdf`
   - Los **notebooks** y **scripts** solicitados (ver abajo).

---

### ‚öôÔ∏è Parte A ‚Äî Ejecuci√≥n en JupyterLab (notebooks)

Ejecuten los **cuatro procesos del benchmark** desde **JupyterLab**, usando el kernel adecuado para cada lenguaje.

#### üìí Notebooks obligatorios

Creen los siguientes notebooks:

- `01_benchmark_terra.ipynb`  
- `02_benchmark_stars.ipynb`  
- `03_benchmark_rasterio.ipynb`  
- `04_benchmark_rasters_julia.ipynb`

Cada notebook debe:

- Leer el raster
- Aplicar la operaci√≥n matem√°tica (√ó 1.5)
- Calcular la **media global**
- Imprimir el **tiempo total de ejecuci√≥n**

üìå **Entrega**:
- Suban los **cuatro notebooks** al repositorio.
- En `respuestas.qmd`, incluyan:
  - El tiempo reportado por cada motor
  - Una breve observaci√≥n (1‚Äì2 l√≠neas) por notebook

---

### üñ•Ô∏è Parte B ‚Äî Ejecuci√≥n desde VSCode (terminal integrada)

Ahora repitan el benchmark **fuera de Jupyter**, usando la terminal integrada de **VSCode**.

#### üìÑ Scripts obligatorios

Creen los siguientes archivos:

- `benchmark_terra.R`
- `benchmark_stars.R`
- `benchmark_rasterio.py`
- `benchmark_rasters.jl`

Cada script debe:

- Leer el raster
- Ejecutar la operaci√≥n
- Calcular la media global
- Imprimir:
  - El tiempo total
  - El valor de la media

#### ‚ñ∂Ô∏è Ejecuci√≥n esperada

Desde la terminal de VSCode:

```bash
Rscript benchmark_terra.R
Rscript benchmark_stars.R
python3 benchmark_rasterio.py
julia benchmark_rasters.jl
```

üìå **Entrega**:
- Suban los **cuatro scripts** al repositorio.
- Reporten los tiempos obtenidos en `respuestas.qmd`.

---

### ü™ü Parte C ‚Äî Ejecuci√≥n desde el Termina de Windows (PowerShell)

Finalmente, ejecuten los procesos **sin usar VSCode ni Jupyter**, directamente desde **Windows Terminal (PowerShell)**, trabajando con Docker.

Pueden usar **una o ambas opciones**.

---

#### Opci√≥n 1Ô∏è‚É£ ‚Äî Entrando al int√©rprete

Ejemplos:

```powershell
docker exec -it contenedor_sig_unal R
docker exec -it contenedor_sig_unal python3
docker exec -it contenedor_sig_unal julia
```

Y luego ejecutar el script correspondiente dentro del int√©rprete.

---

#### Opci√≥n 2Ô∏è‚É£ ‚Äî Ejecuci√≥n directa

Ejemplos:

```powershell
docker exec contenedor_sig_unal Rscript benchmark_terra.R
docker exec contenedor_sig_unal Rscript benchmark_stars.R
docker exec contenedor_sig_unal python3 benchmark_rasterio.py
docker exec contenedor_sig_unal julia benchmark_rasters.jl
```

üìå **Entrega**:
- Indiquen en `respuestas.qmd`:
  - Qu√© opci√≥n usaron
  - Los tiempos obtenidos
  - Si notaron diferencias frente a JupyterLab o VSCode

---

### ‚ùì Preguntas de an√°lisis

#### 1. üìç Entorno de ejecuci√≥n  
¬øNotaron diferencias de tiempo entre:

- JupyterLab  
- VSCode (terminal integrada)  
- Windows Terminal (PowerShell)

Den **una raz√≥n t√©cnica posible** (overhead del kernel, entorno, proceso, etc.).

---

#### 2. üß± Abstracci√≥n en la pr√°ctica  
¬øEn qu√© motor creen que el **costo de las abstracciones** es m√°s visible?  
Relacionen su respuesta con los tiempos observados.

#### 3. üî• Julia y el costo de compilaci√≥n (Warm-up)  
¬øEl efecto del *warm-up* de Julia se not√≥ m√°s en alg√∫n entorno espec√≠fico?  
Expliquen brevemente por qu√©.

---

#### 4. üß† Elecci√≥n informada  
Despu√©s de ejecutar el benchmark en **tres entornos distintos**,  
¬øcambiar√≠an su elecci√≥n del ‚ÄúTit√°n‚Äù para una emergencia ambiental real?

Justifiquen en **m√°ximo 5 l√≠neas**.

---

> üí° **Nota para el √©xito**
>
> Este laboratorio no busca que memoricen comandos,  
> sino que entiendan que **el rendimiento depende del stack completo**:
> lenguaje, librer√≠as, entorno y forma de ejecuci√≥n.


## Limpieza de recursos

::: {.content-visible when-format="html"}
::: {.callout-tip collapse="true" icon="false"}
##### ‚ñ∑ C√ìDIGO PURO (Copiar y Pegar)
```{r}
#| label: liberar_recursos_codigo
#| eval: false
# C√≥digo en R
# Eliminar variables
#rm(res_terra, res_stars, r, s)

# Liberar memoria RAM
gc()

# Borrar archivo con la ruta
if(file.exists("s2_shared_path.txt")) file.remove("s2_shared_path.txt")
```
:::
:::



```{r}
#| label: liberar_recursos
#| include: false
#| code-fold: true

# Eliminar variables
#rm(res_terra, res_stars, r, s)

# Liberar memoria RAM
gc()

# Borrar archivo con la ruta
#if(file.exists("s2_shared_path.txt")) file.remove("s2_shared_path.txt")
```